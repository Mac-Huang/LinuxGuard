[
  {
    "sha": "266b5d02e14f3a0e07414e11f239397de0577a1d",
    "message": "smb: client: fix race condition in negotiate timeout by using more precise timing\n\nWhen the SMB server reboots and the client immediately accesses the mount\npoint, a race condition can occur that causes operations to fail with\n\"Host is down\" error.\n\nReproduction steps:\n  # Mount SMB share\n  mount -t cifs //192.168.245.109/TEST /mnt/ -o xxxx\n  ls /mnt\n\n  # Reboot server\n  ssh root@192.168.245.109 reboot\n  ssh root@192.168.245.109 /path/to/cifs_server_setup.sh\n  ssh root@192.168.245.109 systemctl stop firewalld\n\n  # Immediate access fails\n  ls /mnt\n  ls: cannot access '/mnt': Host is down\n\n  # But works if there is a delay\n\nThe issue is caused by a race condition between negotiate and reconnect.\nThe 20-second negotiate timeout mechanism can interfere with the normal\nrecovery process when both are triggered simultaneously.\n\n  ls                              cifsd\n---------------------------------------------------\n cifs_getattr\n cifs_revalidate_dentry\n cifs_get_inode_info\n cifs_get_fattr\n smb2_query_path_info\n smb2_compound_op\n SMB2_open_init\n smb2_reconnect\n cifs_negotiate_protocol\n  smb2_negotiate\n   cifs_send_recv\n    smb_send_rqst\n    wait_for_response\n                            cifs_demultiplex_thread\n                              cifs_read_from_socket\n                              cifs_readv_from_socket\n                                server_unresponsive\n                                cifs_reconnect\n                                  __cifs_reconnect\n                                  cifs_abort_connection\n                                    mid->mid_state = MID_RETRY_NEEDED\n                                    cifs_wake_up_task\n    cifs_sync_mid_result\n     // case MID_RETRY_NEEDED\n     rc = -EAGAIN;\n   // In smb2_negotiate()\n   rc = -EHOSTDOWN;\n\nThe server_unresponsive() timeout triggers cifs_reconnect(), which aborts\nongoing mid requests and causes the ls command to receive -EAGAIN, leading\nto -EHOSTDOWN.\n\nFix this by introducing a dedicated `neg_start` field to\nprecisely tracks when the negotiate process begins. The timeout check\nnow uses this accurate timestamp instead of `lstrp`, ensuring that:\n\n1. Timeout is only triggered after negotiate has actually run for 20s\n2. The mechanism doesn't interfere with concurrent recovery processes\n3. Uninitialized timestamps (value 0) don't trigger false timeouts\n\nFixes: 7ccc1465465d (\"smb: client: fix hang in wait_for_response() for negproto\")\nSigned-off-by: Wang Zhaolong <wangzhaolong@huaweicloud.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "author": "Wang Zhaolong",
    "date": "2025-07-03T18:41:49-05:00",
    "files_changed": [
      "fs/smb/client/cifsglob.h",
      "fs/smb/client/connect.c"
    ],
    "diff": "diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.h\nindex fdd95e5100cd..89160bc34d35 100644\n--- a/fs/smb/client/cifsglob.h\n+++ b/fs/smb/client/cifsglob.h\n@@ -777,6 +777,7 @@ struct TCP_Server_Info {\n \t__le32 session_key_id; /* retrieved from negotiate response and send in session setup request */\n \tstruct session_key session_key;\n \tunsigned long lstrp; /* when we got last response from this server */\n+\tunsigned long neg_start; /* when negotiate started (jiffies) */\n \tstruct cifs_secmech secmech; /* crypto sec mech functs, descriptors */\n #define\tCIFS_NEGFLAVOR_UNENCAP\t1\t/* wct == 17, but no ext_sec */\n #define\tCIFS_NEGFLAVOR_EXTENDED\t2\t/* wct == 17, ext_sec bit set */\ndiff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.c\nindex 484b677143fd..205f547ca49e 100644\n--- a/fs/smb/client/connect.c\n+++ b/fs/smb/client/connect.c\n@@ -679,12 +679,12 @@ server_unresponsive(struct TCP_Server_Info *server)\n \t/*\n \t * If we're in the process of mounting a share or reconnecting a session\n \t * and the server abruptly shut down (e.g. socket wasn't closed, packet\n-\t * had been ACK'ed but no SMB response), don't wait longer than 20s to\n-\t * negotiate protocol.\n+\t * had been ACK'ed but no SMB response), don't wait longer than 20s from\n+\t * when negotiate actually started.\n \t */\n \tspin_lock(&server->srv_lock);\n \tif (server->tcpStatus == CifsInNegotiate &&\n-\t    time_after(jiffies, server->lstrp + 20 * HZ)) {\n+\t    time_after(jiffies, server->neg_start + 20 * HZ)) {\n \t\tspin_unlock(&server->srv_lock);\n \t\tcifs_reconnect(server, false);\n \t\treturn true;\n@@ -4209,6 +4209,7 @@ cifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n \n \tserver->lstrp = jiffies;\n \tserver->tcpStatus = CifsInNegotiate;\n+\tserver->neg_start = jiffies;\n \tspin_unlock(&server->srv_lock);\n \n \trc = server->ops->negotiate(xid, ses, server);",
    "stats": {
      "insertions": 5,
      "deletions": 3,
      "files": 2
    }
  },
  {
    "sha": "ac2ad73e75596189603995cd4283949863fd7e55",
    "message": "Merge tag 'exynos-drm-fixes-for-v6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/daeinki/drm-exynos into drm-fixes\n\nFixups\n- Fixed raw pointer leakage and unsafe behavior in printk()\n  . Switch from %pK to %p for pointer formatting, as %p is now safer\n    and prevents issues like raw pointer leakage and acquiring sleeping\n    locks in atomic contexts.\n\n- Fixed kernel panic during boot\n  . A NULL pointer dereference issue occasionally occurred\n    when the vblank interrupt handler was called before\n    the DRM driver was fully initialized during boot.\n    So this patch fixes the issue by adding a check in the interrupt handler\n    to ensure the DRM driver is properly initialized.\n\n- Fixed a lockup issue on Samsung Peach-Pit/Pi Chromebooks\n  . The issue occurred after commit c9b1150a68d9 changed\n    the call order of CRTC enable/disable and bridge pre_enable/post_disable\n    methods, causing fimd_dp_clock_enable() to be called\n    before the FIMD device was activated. To fix this,\n    runtime PM guards were added to fimd_dp_clock_enable()\n    to ensure proper operation even when CRTC is not enabled.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n\nFrom: Inki Dae <inki.dae@samsung.com>\nLink: https://lore.kernel.org/r/20250629083554.28628-1-inki.dae@samsung.com",
    "author": "Dave Airlie",
    "date": "2025-07-04T09:38:01+10:00",
    "files_changed": [
      "drivers/gpu/drm/exynos/exynos7_drm_decon.c",
      "drivers/gpu/drm/exynos/exynos_drm_fimd.c",
      "drivers/gpu/drm/exynos/exynos_drm_gem.c",
      "drivers/gpu/drm/exynos/exynos_drm_ipp.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/exynos/exynos7_drm_decon.c b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\nindex f91daefa9d2b..805aa28c1723 100644\n--- a/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n+++ b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n@@ -636,6 +636,10 @@ static irqreturn_t decon_irq_handler(int irq, void *dev_id)\n \tif (!ctx->drm_dev)\n \t\tgoto out;\n \n+\t/* check if crtc and vblank have been initialized properly */\n+\tif (!drm_dev_has_vblank(ctx->drm_dev))\n+\t\tgoto out;\n+\n \tif (!ctx->i80_if) {\n \t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n \ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_fimd.c b/drivers/gpu/drm/exynos/exynos_drm_fimd.c\nindex c394cc702d7d..205c238cc73a 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_fimd.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_fimd.c\n@@ -187,6 +187,7 @@ struct fimd_context {\n \tu32\t\t\t\ti80ifcon;\n \tbool\t\t\t\ti80_if;\n \tbool\t\t\t\tsuspended;\n+\tbool\t\t\t\tdp_clk_enabled;\n \twait_queue_head_t\t\twait_vsync_queue;\n \tatomic_t\t\t\twait_vsync_event;\n \tatomic_t\t\t\twin_updated;\n@@ -1047,7 +1048,18 @@ static void fimd_dp_clock_enable(struct exynos_drm_clk *clk, bool enable)\n \tstruct fimd_context *ctx = container_of(clk, struct fimd_context,\n \t\t\t\t\t\tdp_clk);\n \tu32 val = enable ? DP_MIE_CLK_DP_ENABLE : DP_MIE_CLK_DISABLE;\n+\n+\tif (enable == ctx->dp_clk_enabled)\n+\t\treturn;\n+\n+\tif (enable)\n+\t\tpm_runtime_resume_and_get(ctx->dev);\n+\n+\tctx->dp_clk_enabled = enable;\n \twritel(val, ctx->regs + DP_MIE_CLKCON);\n+\n+\tif (!enable)\n+\t\tpm_runtime_put(ctx->dev);\n }\n \n static const struct exynos_drm_crtc_ops fimd_crtc_ops = {\ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_gem.c b/drivers/gpu/drm/exynos/exynos_drm_gem.c\nindex 4787fee4696f..d44401a695e2 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c\n@@ -174,7 +174,7 @@ static struct exynos_drm_gem *exynos_drm_gem_init(struct drm_device *dev,\n \t\treturn ERR_PTR(ret);\n \t}\n \n-\tDRM_DEV_DEBUG_KMS(dev->dev, \"created file object = %pK\\n\", obj->filp);\n+\tDRM_DEV_DEBUG_KMS(dev->dev, \"created file object = %p\\n\", obj->filp);\n \n \treturn exynos_gem;\n }\ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_ipp.c b/drivers/gpu/drm/exynos/exynos_drm_ipp.c\nindex ea9f66037600..03c8490af4f4 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_ipp.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_ipp.c\n@@ -271,7 +271,7 @@ static inline struct exynos_drm_ipp_task *\n \ttask->src.rect.h = task->dst.rect.h = UINT_MAX;\n \ttask->transform.rotation = DRM_MODE_ROTATE_0;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Allocated task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Allocated task %p\\n\", task);\n \n \treturn task;\n }\n@@ -339,7 +339,7 @@ static int exynos_drm_ipp_task_set(struct exynos_drm_ipp_task *task,\n \t}\n \n \tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t     \"Got task %pK configuration from userspace\\n\",\n+\t\t\t     \"Got task %p configuration from userspace\\n\",\n \t\t\t     task);\n \treturn 0;\n }\n@@ -394,7 +394,7 @@ static void exynos_drm_ipp_task_release_buf(struct exynos_drm_ipp_buffer *buf)\n static void exynos_drm_ipp_task_free(struct exynos_drm_ipp *ipp,\n \t\t\t\t struct exynos_drm_ipp_task *task)\n {\n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Freeing task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Freeing task %p\\n\", task);\n \n \texynos_drm_ipp_task_release_buf(&task->src);\n \texynos_drm_ipp_task_release_buf(&task->dst);\n@@ -559,7 +559,7 @@ static int exynos_drm_ipp_check_format(struct exynos_drm_ipp_task *task,\n \t\t\t\t\t    DRM_EXYNOS_IPP_FORMAT_DESTINATION);\n \tif (!fmt) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: %s format not supported\\n\",\n+\t\t\t\t     \"Task %p: %s format not supported\\n\",\n \t\t\t\t     task, buf == src ? \"src\" : \"dst\");\n \t\treturn -EINVAL;\n \t}\n@@ -609,7 +609,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \tbool rotate = (rotation != DRM_MODE_ROTATE_0);\n \tbool scale = false;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Checking task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Checking task %p\\n\", task);\n \n \tif (src->rect.w == UINT_MAX)\n \t\tsrc->rect.w = src->buf.width;\n@@ -625,7 +625,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \t    dst->rect.x + dst->rect.w > (dst->buf.width) ||\n \t    dst->rect.y + dst->rect.h > (dst->buf.height)) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: defined area is outside provided buffers\\n\",\n+\t\t\t\t     \"Task %p: defined area is outside provided buffers\\n\",\n \t\t\t\t     task);\n \t\treturn -EINVAL;\n \t}\n@@ -642,7 +642,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_SCALE) && scale) ||\n \t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_CONVERT) &&\n \t     src->buf.fourcc != dst->buf.fourcc)) {\n-\t\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: hw capabilities exceeded\\n\",\n+\t\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %p: hw capabilities exceeded\\n\",\n \t\t\t\t     task);\n \t\treturn -EINVAL;\n \t}\n@@ -655,7 +655,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \tif (ret)\n \t\treturn ret;\n \n-\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"Task %pK: all checks done.\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"Task %p: all checks done.\\n\",\n \t\t\t     task);\n \n \treturn ret;\n@@ -667,25 +667,25 @@ static int exynos_drm_ipp_task_setup_buffers(struct exynos_drm_ipp_task *task,\n \tstruct exynos_drm_ipp_buffer *src = &task->src, *dst = &task->dst;\n \tint ret = 0;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Setting buffer for task %pK\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Setting buffer for task %p\\n\",\n \t\t\t     task);\n \n \tret = exynos_drm_ipp_task_setup_buffer(src, filp);\n \tif (ret) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: src buffer setup failed\\n\",\n+\t\t\t\t     \"Task %p: src buffer setup failed\\n\",\n \t\t\t\t     task);\n \t\treturn ret;\n \t}\n \tret = exynos_drm_ipp_task_setup_buffer(dst, filp);\n \tif (ret) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: dst buffer setup failed\\n\",\n+\t\t\t\t     \"Task %p: dst buffer setup failed\\n\",\n \t\t\t\t     task);\n \t\treturn ret;\n \t}\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: buffers prepared.\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %p: buffers prepared.\\n\",\n \t\t\t     task);\n \n \treturn ret;\n@@ -764,7 +764,7 @@ void exynos_drm_ipp_task_done(struct exynos_drm_ipp_task *task, int ret)\n \tstruct exynos_drm_ipp *ipp = task->ipp;\n \tunsigned long flags;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"ipp: %d, task %pK done: %d\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"ipp: %d, task %p done: %d\\n\",\n \t\t\t     ipp->id, task, ret);\n \n \tspin_lock_irqsave(&ipp->lock, flags);\n@@ -807,7 +807,7 @@ static void exynos_drm_ipp_next_task(struct exynos_drm_ipp *ipp)\n \tspin_unlock_irqrestore(&ipp->lock, flags);\n \n \tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n-\t\t\t     \"ipp: %d, selected task %pK to run\\n\", ipp->id,\n+\t\t\t     \"ipp: %d, selected task %p to run\\n\", ipp->id,\n \t\t\t     task);\n \n \tret = ipp->funcs->commit(ipp, task);\n@@ -917,14 +917,14 @@ int exynos_drm_ipp_commit_ioctl(struct drm_device *dev, void *data,\n \t */\n \tif (arg->flags & DRM_EXYNOS_IPP_FLAG_NONBLOCK) {\n \t\tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n-\t\t\t\t     \"ipp: %d, nonblocking processing task %pK\\n\",\n+\t\t\t\t     \"ipp: %d, nonblocking processing task %p\\n\",\n \t\t\t\t     ipp->id, task);\n \n \t\ttask->flags |= DRM_EXYNOS_IPP_TASK_ASYNC;\n \t\texynos_drm_ipp_schedule_task(task->ipp, task);\n \t\tret = 0;\n \t} else {\n-\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, processing task %pK\\n\",\n+\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, processing task %p\\n\",\n \t\t\t\t     ipp->id, task);\n \t\texynos_drm_ipp_schedule_task(ipp, task);\n \t\tret = wait_event_interruptible(ipp->done_wq,",
    "stats": {
      "insertions": 33,
      "deletions": 17,
      "files": 4
    }
  },
  {
    "sha": "afd30ace71eecc3ba06815c9b554e801e85ab73a",
    "message": "Merge tag 'drm-intel-fixes-2025-07-03' of https://gitlab.freedesktop.org/drm/i915/kernel into drm-fixes\n\n- Make mei interrupt top half irq disabled to fix RT builds\n- Fix timeline left held on VMA alloc error\n- Fix NULL pointer deref in vlv_dphy_param_init()\n- Fix selftest mock_request() to avoid NULL deref\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\nFrom: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>\nLink: https://lore.kernel.org/r/aGYVPAA4KvsZqDFx@jlahtine-mobl",
    "author": "Dave Airlie",
    "date": "2025-07-04T09:26:57+10:00",
    "files_changed": [
      "drivers/gpu/drm/i915/display/vlv_dsi.c",
      "drivers/gpu/drm/i915/gt/intel_gsc.c",
      "drivers/gpu/drm/i915/gt/intel_ring_submission.c",
      "drivers/gpu/drm/i915/selftests/i915_request.c",
      "drivers/gpu/drm/i915/selftests/mock_request.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/i915/display/vlv_dsi.c b/drivers/gpu/drm/i915/display/vlv_dsi.c\nindex 21c1e10caf68..2007bb9d974d 100644\n--- a/drivers/gpu/drm/i915/display/vlv_dsi.c\n+++ b/drivers/gpu/drm/i915/display/vlv_dsi.c\n@@ -1589,8 +1589,8 @@ static void vlv_dsi_add_properties(struct intel_connector *connector)\n \n static void vlv_dphy_param_init(struct intel_dsi *intel_dsi)\n {\n+\tstruct intel_display *display = to_intel_display(&intel_dsi->base);\n \tstruct intel_connector *connector = intel_dsi->attached_connector;\n-\tstruct intel_display *display = to_intel_display(connector);\n \tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n \tu32 tlpx_ns, extra_byte_count, tlpx_ui;\n \tu32 ui_num, ui_den;\ndiff --git a/drivers/gpu/drm/i915/gt/intel_gsc.c b/drivers/gpu/drm/i915/gt/intel_gsc.c\nindex 1e925c75fb08..c43febc862dc 100644\n--- a/drivers/gpu/drm/i915/gt/intel_gsc.c\n+++ b/drivers/gpu/drm/i915/gt/intel_gsc.c\n@@ -284,7 +284,7 @@ static void gsc_irq_handler(struct intel_gt *gt, unsigned int intf_id)\n \tif (gt->gsc.intf[intf_id].irq < 0)\n \t\treturn;\n \n-\tret = generic_handle_irq(gt->gsc.intf[intf_id].irq);\n+\tret = generic_handle_irq_safe(gt->gsc.intf[intf_id].irq);\n \tif (ret)\n \t\tgt_err_ratelimited(gt, \"error handling GSC irq: %d\\n\", ret);\n }\ndiff --git a/drivers/gpu/drm/i915/gt/intel_ring_submission.c b/drivers/gpu/drm/i915/gt/intel_ring_submission.c\nindex a876a34455f1..2a6d79abf25b 100644\n--- a/drivers/gpu/drm/i915/gt/intel_ring_submission.c\n+++ b/drivers/gpu/drm/i915/gt/intel_ring_submission.c\n@@ -610,7 +610,6 @@ static int ring_context_alloc(struct intel_context *ce)\n \t/* One ringbuffer to rule them all */\n \tGEM_BUG_ON(!engine->legacy.ring);\n \tce->ring = engine->legacy.ring;\n-\tce->timeline = intel_timeline_get(engine->legacy.timeline);\n \n \tGEM_BUG_ON(ce->state);\n \tif (engine->context_size) {\n@@ -623,6 +622,8 @@ static int ring_context_alloc(struct intel_context *ce)\n \t\tce->state = vma;\n \t}\n \n+\tce->timeline = intel_timeline_get(engine->legacy.timeline);\n+\n \treturn 0;\n }\n \ndiff --git a/drivers/gpu/drm/i915/selftests/i915_request.c b/drivers/gpu/drm/i915/selftests/i915_request.c\nindex 88870844b5bd..2fb7a9e7efec 100644\n--- a/drivers/gpu/drm/i915/selftests/i915_request.c\n+++ b/drivers/gpu/drm/i915/selftests/i915_request.c\n@@ -73,8 +73,8 @@ static int igt_add_request(void *arg)\n \t/* Basic preliminary test to create a request and let it loose! */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, HZ / 10);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_add(request);\n \n@@ -91,8 +91,8 @@ static int igt_wait_request(void *arg)\n \t/* Submit a request, then wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_get(request);\n \n@@ -160,8 +160,8 @@ static int igt_fence_wait(void *arg)\n \t/* Submit a request, treat it as a fence and wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \tif (dma_fence_wait_timeout(&request->fence, false, T) != -ETIME) {\n \t\tpr_err(\"fence wait success before submit (expected timeout)!\\n\");\n@@ -219,8 +219,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \trequest = mock_request(ce, 2 * HZ);\n \tintel_context_put(ce);\n-\tif (!request) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(request)) {\n+\t\terr = PTR_ERR(request);\n \t\tgoto err_context_0;\n \t}\n \n@@ -237,8 +237,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \tvip = mock_request(ce, 0);\n \tintel_context_put(ce);\n-\tif (!vip) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(vip)) {\n+\t\terr = PTR_ERR(vip);\n \t\tgoto err_context_1;\n \t}\n \ndiff --git a/drivers/gpu/drm/i915/selftests/mock_request.c b/drivers/gpu/drm/i915/selftests/mock_request.c\nindex 09f747228dff..1b0cf073e964 100644\n--- a/drivers/gpu/drm/i915/selftests/mock_request.c\n+++ b/drivers/gpu/drm/i915/selftests/mock_request.c\n@@ -35,7 +35,7 @@ mock_request(struct intel_context *ce, unsigned long delay)\n \t/* NB the i915->requests slab cache is enlarged to fit mock_request */\n \trequest = intel_context_create_request(ce);\n \tif (IS_ERR(request))\n-\t\treturn NULL;\n+\t\treturn request;\n \n \trequest->mock.delay = delay;\n \treturn request;",
    "stats": {
      "insertions": 15,
      "deletions": 14,
      "files": 5
    }
  },
  {
    "sha": "b91e11ec5cd972dc39121496c3a0cf2ec2e9a393",
    "message": "Merge tag 'drm-misc-fixes-2025-07-03' of https://gitlab.freedesktop.org/drm/misc/kernel into drm-fixes\n\ndrm-misc-fixes for v6.16-rc5:\n- Replace simple panel lookup hack with proper fix.\n- nullpointer deref in vesadrm fix.\n- fix dma_resv_wait_timeout.\n- fix error handling in ttm_buffer_object_transfer.\n- bridge fixes.\n- Fix vmwgfx accidentally allocating encrypted memory.\n- Fix race in spsc_queue_push()\n- Add refcount on backing GEM objects during fb creation.\n- Fix v3d irq's being enabled during gpu reset.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\nFrom: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nLink: https://lore.kernel.org/r/a7461418-08dc-4b7c-b2fa-264155f66d5e@linux.intel.com",
    "author": "Dave Airlie",
    "date": "2025-07-04T09:06:57+10:00",
    "files_changed": [
      "drivers/dma-buf/dma-resv.c",
      "drivers/gpu/drm/bridge/aux-hpd-bridge.c",
      "drivers/gpu/drm/bridge/panel.c",
      "drivers/gpu/drm/drm_gem.c",
      "drivers/gpu/drm/drm_gem_framebuffer_helper.c",
      "drivers/gpu/drm/drm_internal.h",
      "drivers/gpu/drm/drm_mipi_dsi.c",
      "drivers/gpu/drm/panel/panel-simple.c",
      "drivers/gpu/drm/sysfb/vesadrm.c",
      "drivers/gpu/drm/ttm/ttm_bo_util.c",
      "drivers/gpu/drm/v3d/v3d_drv.h",
      "drivers/gpu/drm/v3d/v3d_gem.c",
      "drivers/gpu/drm/v3d/v3d_irq.c",
      "drivers/gpu/drm/vmwgfx/vmwgfx_drv.c",
      "include/drm/drm_mipi_dsi.h",
      "include/drm/spsc_queue.h"
    ],
    "diff": "diff --git a/drivers/dma-buf/dma-resv.c b/drivers/dma-buf/dma-resv.c\nindex b1ef4546346d..bea3e9858aca 100644\n--- a/drivers/dma-buf/dma-resv.c\n+++ b/drivers/dma-buf/dma-resv.c\n@@ -685,11 +685,13 @@ long dma_resv_wait_timeout(struct dma_resv *obj, enum dma_resv_usage usage,\n \tdma_resv_iter_begin(&cursor, obj, usage);\n \tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n \n-\t\tret = dma_fence_wait_timeout(fence, intr, ret);\n-\t\tif (ret <= 0) {\n-\t\t\tdma_resv_iter_end(&cursor);\n-\t\t\treturn ret;\n-\t\t}\n+\t\tret = dma_fence_wait_timeout(fence, intr, timeout);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\t/* Even for zero timeout the return value is 1 */\n+\t\tif (timeout)\n+\t\t\ttimeout = ret;\n \t}\n \tdma_resv_iter_end(&cursor);\n \ndiff --git a/drivers/gpu/drm/bridge/aux-hpd-bridge.c b/drivers/gpu/drm/bridge/aux-hpd-bridge.c\nindex b3f588b71a7d..af6f79793407 100644\n--- a/drivers/gpu/drm/bridge/aux-hpd-bridge.c\n+++ b/drivers/gpu/drm/bridge/aux-hpd-bridge.c\n@@ -64,10 +64,11 @@ struct auxiliary_device *devm_drm_dp_hpd_bridge_alloc(struct device *parent, str\n \tadev->id = ret;\n \tadev->name = \"dp_hpd_bridge\";\n \tadev->dev.parent = parent;\n-\tadev->dev.of_node = of_node_get(parent->of_node);\n \tadev->dev.release = drm_aux_hpd_bridge_release;\n \tadev->dev.platform_data = of_node_get(np);\n \n+\tdevice_set_of_node_from_dev(&adev->dev, parent);\n+\n \tret = auxiliary_device_init(adev);\n \tif (ret) {\n \t\tof_node_put(adev->dev.platform_data);\ndiff --git a/drivers/gpu/drm/bridge/panel.c b/drivers/gpu/drm/bridge/panel.c\nindex 79b009ab9396..29b0358a7b6d 100644\n--- a/drivers/gpu/drm/bridge/panel.c\n+++ b/drivers/gpu/drm/bridge/panel.c\n@@ -299,6 +299,7 @@ struct drm_bridge *drm_panel_bridge_add_typed(struct drm_panel *panel,\n \tpanel_bridge->bridge.of_node = panel->dev->of_node;\n \tpanel_bridge->bridge.ops = DRM_BRIDGE_OP_MODES;\n \tpanel_bridge->bridge.type = connector_type;\n+\tpanel_bridge->bridge.pre_enable_prev_first = panel->prepare_prev_first;\n \n \tdrm_bridge_add(&panel_bridge->bridge);\n \n@@ -413,8 +414,6 @@ struct drm_bridge *devm_drm_panel_bridge_add_typed(struct device *dev,\n \t\treturn bridge;\n \t}\n \n-\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n-\n \t*ptr = bridge;\n \tdevres_add(dev, ptr);\n \n@@ -456,8 +455,6 @@ struct drm_bridge *drmm_panel_bridge_add(struct drm_device *drm,\n \tif (ret)\n \t\treturn ERR_PTR(ret);\n \n-\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n-\n \treturn bridge;\n }\n EXPORT_SYMBOL(drmm_panel_bridge_add);\ndiff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c\nindex 1e659d2660f7..4bf0a76bb35e 100644\n--- a/drivers/gpu/drm/drm_gem.c\n+++ b/drivers/gpu/drm/drm_gem.c\n@@ -212,6 +212,35 @@ void drm_gem_private_object_fini(struct drm_gem_object *obj)\n }\n EXPORT_SYMBOL(drm_gem_private_object_fini);\n \n+static void drm_gem_object_handle_get(struct drm_gem_object *obj)\n+{\n+\tstruct drm_device *dev = obj->dev;\n+\n+\tdrm_WARN_ON(dev, !mutex_is_locked(&dev->object_name_lock));\n+\n+\tif (obj->handle_count++ == 0)\n+\t\tdrm_gem_object_get(obj);\n+}\n+\n+/**\n+ * drm_gem_object_handle_get_unlocked - acquire reference on user-space handles\n+ * @obj: GEM object\n+ *\n+ * Acquires a reference on the GEM buffer object's handle. Required\n+ * to keep the GEM object alive. Call drm_gem_object_handle_put_unlocked()\n+ * to release the reference.\n+ */\n+void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj)\n+{\n+\tstruct drm_device *dev = obj->dev;\n+\n+\tguard(mutex)(&dev->object_name_lock);\n+\n+\tdrm_WARN_ON(dev, !obj->handle_count); /* first ref taken in create-tail helper */\n+\tdrm_gem_object_handle_get(obj);\n+}\n+EXPORT_SYMBOL(drm_gem_object_handle_get_unlocked);\n+\n /**\n  * drm_gem_object_handle_free - release resources bound to userspace handles\n  * @obj: GEM object to clean up.\n@@ -242,8 +271,14 @@ static void drm_gem_object_exported_dma_buf_free(struct drm_gem_object *obj)\n \t}\n }\n \n-static void\n-drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n+/**\n+ * drm_gem_object_handle_put_unlocked - releases reference on user-space handles\n+ * @obj: GEM object\n+ *\n+ * Releases a reference on the GEM buffer object's handle. Possibly releases\n+ * the GEM buffer object and associated dma-buf objects.\n+ */\n+void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n {\n \tstruct drm_device *dev = obj->dev;\n \tbool final = false;\n@@ -268,6 +303,7 @@ drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n \tif (final)\n \t\tdrm_gem_object_put(obj);\n }\n+EXPORT_SYMBOL(drm_gem_object_handle_put_unlocked);\n \n /*\n  * Called at device or object close to release the file's\n@@ -389,8 +425,8 @@ drm_gem_handle_create_tail(struct drm_file *file_priv,\n \tint ret;\n \n \tWARN_ON(!mutex_is_locked(&dev->object_name_lock));\n-\tif (obj->handle_count++ == 0)\n-\t\tdrm_gem_object_get(obj);\n+\n+\tdrm_gem_object_handle_get(obj);\n \n \t/*\n \t * Get the user-visible handle using idr.  Preload and perform\ndiff --git a/drivers/gpu/drm/drm_gem_framebuffer_helper.c b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\nindex 6f72e7a0f427..14a87788695d 100644\n--- a/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n+++ b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n@@ -99,7 +99,7 @@ void drm_gem_fb_destroy(struct drm_framebuffer *fb)\n \tunsigned int i;\n \n \tfor (i = 0; i < fb->format->num_planes; i++)\n-\t\tdrm_gem_object_put(fb->obj[i]);\n+\t\tdrm_gem_object_handle_put_unlocked(fb->obj[i]);\n \n \tdrm_framebuffer_cleanup(fb);\n \tkfree(fb);\n@@ -182,8 +182,10 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\tif (!objs[i]) {\n \t\t\tdrm_dbg_kms(dev, \"Failed to lookup GEM object\\n\");\n \t\t\tret = -ENOENT;\n-\t\t\tgoto err_gem_object_put;\n+\t\t\tgoto err_gem_object_handle_put_unlocked;\n \t\t}\n+\t\tdrm_gem_object_handle_get_unlocked(objs[i]);\n+\t\tdrm_gem_object_put(objs[i]);\n \n \t\tmin_size = (height - 1) * mode_cmd->pitches[i]\n \t\t\t + drm_format_info_min_pitch(info, i, width)\n@@ -193,22 +195,22 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\t\tdrm_dbg_kms(dev,\n \t\t\t\t    \"GEM object size (%zu) smaller than minimum size (%u) for plane %d\\n\",\n \t\t\t\t    objs[i]->size, min_size, i);\n-\t\t\tdrm_gem_object_put(objs[i]);\n+\t\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n \t\t\tret = -EINVAL;\n-\t\t\tgoto err_gem_object_put;\n+\t\t\tgoto err_gem_object_handle_put_unlocked;\n \t\t}\n \t}\n \n \tret = drm_gem_fb_init(dev, fb, mode_cmd, objs, i, funcs);\n \tif (ret)\n-\t\tgoto err_gem_object_put;\n+\t\tgoto err_gem_object_handle_put_unlocked;\n \n \treturn 0;\n \n-err_gem_object_put:\n+err_gem_object_handle_put_unlocked:\n \twhile (i > 0) {\n \t\t--i;\n-\t\tdrm_gem_object_put(objs[i]);\n+\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n \t}\n \treturn ret;\n }\ndiff --git a/drivers/gpu/drm/drm_internal.h b/drivers/gpu/drm/drm_internal.h\nindex e44f28fd81d3..be77d61a16ce 100644\n--- a/drivers/gpu/drm/drm_internal.h\n+++ b/drivers/gpu/drm/drm_internal.h\n@@ -161,6 +161,8 @@ void drm_sysfs_lease_event(struct drm_device *dev);\n \n /* drm_gem.c */\n int drm_gem_init(struct drm_device *dev);\n+void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj);\n+void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj);\n int drm_gem_handle_create_tail(struct drm_file *file_priv,\n \t\t\t       struct drm_gem_object *obj,\n \t\t\t       u32 *handlep);\ndiff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c\nindex e5184a0c2465..21fd647f8ce1 100644\n--- a/drivers/gpu/drm/drm_mipi_dsi.c\n+++ b/drivers/gpu/drm/drm_mipi_dsi.c\n@@ -91,12 +91,13 @@ static const struct dev_pm_ops mipi_dsi_device_pm_ops = {\n \t.restore = pm_generic_restore,\n };\n \n-static const struct bus_type mipi_dsi_bus_type = {\n+const struct bus_type mipi_dsi_bus_type = {\n \t.name = \"mipi-dsi\",\n \t.match = mipi_dsi_device_match,\n \t.uevent = mipi_dsi_uevent,\n \t.pm = &mipi_dsi_device_pm_ops,\n };\n+EXPORT_SYMBOL_GPL(mipi_dsi_bus_type);\n \n /**\n  * of_find_mipi_dsi_device_by_node() - find the MIPI DSI device matching a\ndiff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c\nindex 0a3b26bb4d73..9f81fa960b46 100644\n--- a/drivers/gpu/drm/panel/panel-simple.c\n+++ b/drivers/gpu/drm/panel/panel-simple.c\n@@ -26,6 +26,7 @@\n #include <linux/i2c.h>\n #include <linux/media-bus-format.h>\n #include <linux/module.h>\n+#include <linux/of_device.h>\n #include <linux/of_platform.h>\n #include <linux/platform_device.h>\n #include <linux/pm_runtime.h>\n@@ -136,6 +137,14 @@ struct panel_desc {\n \tint connector_type;\n };\n \n+struct panel_desc_dsi {\n+\tstruct panel_desc desc;\n+\n+\tunsigned long flags;\n+\tenum mipi_dsi_pixel_format format;\n+\tunsigned int lanes;\n+};\n+\n struct panel_simple {\n \tstruct drm_panel base;\n \n@@ -430,10 +439,7 @@ static const struct drm_panel_funcs panel_simple_funcs = {\n \t.get_timings = panel_simple_get_timings,\n };\n \n-static struct panel_desc panel_dpi;\n-\n-static int panel_dpi_probe(struct device *dev,\n-\t\t\t   struct panel_simple *panel)\n+static struct panel_desc *panel_dpi_probe(struct device *dev)\n {\n \tstruct display_timing *timing;\n \tconst struct device_node *np;\n@@ -445,17 +451,17 @@ static int panel_dpi_probe(struct device *dev,\n \tnp = dev->of_node;\n \tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n \tif (!desc)\n-\t\treturn -ENOMEM;\n+\t\treturn ERR_PTR(-ENOMEM);\n \n \ttiming = devm_kzalloc(dev, sizeof(*timing), GFP_KERNEL);\n \tif (!timing)\n-\t\treturn -ENOMEM;\n+\t\treturn ERR_PTR(-ENOMEM);\n \n \tret = of_get_display_timing(np, \"panel-timing\", timing);\n \tif (ret < 0) {\n \t\tdev_err(dev, \"%pOF: no panel-timing node found for \\\"panel-dpi\\\" binding\\n\",\n \t\t\tnp);\n-\t\treturn ret;\n+\t\treturn ERR_PTR(ret);\n \t}\n \n \tdesc->timings = timing;\n@@ -473,9 +479,7 @@ static int panel_dpi_probe(struct device *dev,\n \t/* We do not know the connector for the DT node, so guess it */\n \tdesc->connector_type = DRM_MODE_CONNECTOR_DPI;\n \n-\tpanel->desc = desc;\n-\n-\treturn 0;\n+\treturn desc;\n }\n \n #define PANEL_SIMPLE_BOUNDS_CHECK(to_check, bounds, field) \\\n@@ -570,8 +574,44 @@ static int panel_simple_override_nondefault_lvds_datamapping(struct device *dev,\n \treturn 0;\n }\n \n-static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n+static const struct panel_desc *panel_simple_get_desc(struct device *dev)\n {\n+\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI) &&\n+\t    dev_is_mipi_dsi(dev)) {\n+\t\tconst struct panel_desc_dsi *dsi_desc;\n+\n+\t\tdsi_desc = of_device_get_match_data(dev);\n+\t\tif (!dsi_desc)\n+\t\t\treturn ERR_PTR(-ENODEV);\n+\n+\t\treturn &dsi_desc->desc;\n+\t}\n+\n+\tif (dev_is_platform(dev)) {\n+\t\tconst struct panel_desc *desc;\n+\n+\t\tdesc = of_device_get_match_data(dev);\n+\t\tif (!desc) {\n+\t\t\t/*\n+\t\t\t * panel-dpi probes without a descriptor and\n+\t\t\t * panel_dpi_probe() will initialize one for us\n+\t\t\t * based on the device tree.\n+\t\t\t */\n+\t\t\tif (of_device_is_compatible(dev->of_node, \"panel-dpi\"))\n+\t\t\t\treturn panel_dpi_probe(dev);\n+\t\t\telse\n+\t\t\t\treturn ERR_PTR(-ENODEV);\n+\t\t}\n+\n+\t\treturn desc;\n+\t}\n+\n+\treturn ERR_PTR(-ENODEV);\n+}\n+\n+static struct panel_simple *panel_simple_probe(struct device *dev)\n+{\n+\tconst struct panel_desc *desc;\n \tstruct panel_simple *panel;\n \tstruct display_timing dt;\n \tstruct device_node *ddc;\n@@ -579,27 +619,31 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \tu32 bus_flags;\n \tint err;\n \n+\tdesc = panel_simple_get_desc(dev);\n+\tif (IS_ERR(desc))\n+\t\treturn ERR_CAST(desc);\n+\n \tpanel = devm_drm_panel_alloc(dev, struct panel_simple, base,\n \t\t\t\t     &panel_simple_funcs, desc->connector_type);\n \tif (IS_ERR(panel))\n-\t\treturn PTR_ERR(panel);\n+\t\treturn ERR_CAST(panel);\n \n \tpanel->desc = desc;\n \n \tpanel->supply = devm_regulator_get(dev, \"power\");\n \tif (IS_ERR(panel->supply))\n-\t\treturn PTR_ERR(panel->supply);\n+\t\treturn ERR_CAST(panel->supply);\n \n \tpanel->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n \t\t\t\t\t\t     GPIOD_OUT_LOW);\n \tif (IS_ERR(panel->enable_gpio))\n-\t\treturn dev_err_probe(dev, PTR_ERR(panel->enable_gpio),\n-\t\t\t\t     \"failed to request GPIO\\n\");\n+\t\treturn dev_err_cast_probe(dev, panel->enable_gpio,\n+\t\t\t\t\t  \"failed to request GPIO\\n\");\n \n \terr = of_drm_get_panel_orientation(dev->of_node, &panel->orientation);\n \tif (err) {\n \t\tdev_err(dev, \"%pOF: failed to get orientation %d\\n\", dev->of_node, err);\n-\t\treturn err;\n+\t\treturn ERR_PTR(err);\n \t}\n \n \tddc = of_parse_phandle(dev->of_node, \"ddc-i2c-bus\", 0);\n@@ -608,19 +652,12 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \t\tof_node_put(ddc);\n \n \t\tif (!panel->ddc)\n-\t\t\treturn -EPROBE_DEFER;\n+\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n \t}\n \n-\tif (desc == &panel_dpi) {\n-\t\t/* Handle the generic panel-dpi binding */\n-\t\terr = panel_dpi_probe(dev, panel);\n-\t\tif (err)\n-\t\t\tgoto free_ddc;\n-\t\tdesc = panel->desc;\n-\t} else {\n-\t\tif (!of_get_display_timing(dev->of_node, \"panel-timing\", &dt))\n-\t\t\tpanel_simple_parse_panel_timing_node(dev, panel, &dt);\n-\t}\n+\tif (!of_device_is_compatible(dev->of_node, \"panel-dpi\") &&\n+\t    !of_get_display_timing(dev->of_node, \"panel-timing\", &dt))\n+\t\tpanel_simple_parse_panel_timing_node(dev, panel, &dt);\n \n \tif (desc->connector_type == DRM_MODE_CONNECTOR_LVDS) {\n \t\t/* Optional data-mapping property for overriding bus format */\n@@ -703,7 +740,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \n \tdrm_panel_add(&panel->base);\n \n-\treturn 0;\n+\treturn panel;\n \n disable_pm_runtime:\n \tpm_runtime_dont_use_autosuspend(dev);\n@@ -712,7 +749,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \tif (panel->ddc)\n \t\tput_device(&panel->ddc->dev);\n \n-\treturn err;\n+\treturn ERR_PTR(err);\n }\n \n static void panel_simple_shutdown(struct device *dev)\n@@ -5367,7 +5404,12 @@ static const struct of_device_id platform_of_match[] = {\n \t}, {\n \t\t/* Must be the last entry */\n \t\t.compatible = \"panel-dpi\",\n-\t\t.data = &panel_dpi,\n+\n+\t\t/*\n+\t\t * Explicitly NULL, the panel_desc structure will be\n+\t\t * allocated by panel_dpi_probe().\n+\t\t */\n+\t\t.data = NULL,\n \t}, {\n \t\t/* sentinel */\n \t}\n@@ -5376,13 +5418,13 @@ MODULE_DEVICE_TABLE(of, platform_of_match);\n \n static int panel_simple_platform_probe(struct platform_device *pdev)\n {\n-\tconst struct panel_desc *desc;\n+\tstruct panel_simple *panel;\n \n-\tdesc = of_device_get_match_data(&pdev->dev);\n-\tif (!desc)\n-\t\treturn -ENODEV;\n+\tpanel = panel_simple_probe(&pdev->dev);\n+\tif (IS_ERR(panel))\n+\t\treturn PTR_ERR(panel);\n \n-\treturn panel_simple_probe(&pdev->dev, desc);\n+\treturn 0;\n }\n \n static void panel_simple_platform_remove(struct platform_device *pdev)\n@@ -5412,14 +5454,6 @@ static struct platform_driver panel_simple_platform_driver = {\n \t.shutdown = panel_simple_platform_shutdown,\n };\n \n-struct panel_desc_dsi {\n-\tstruct panel_desc desc;\n-\n-\tunsigned long flags;\n-\tenum mipi_dsi_pixel_format format;\n-\tunsigned int lanes;\n-};\n-\n static const struct drm_display_mode auo_b080uan01_mode = {\n \t.clock = 154500,\n \t.hdisplay = 1200,\n@@ -5653,16 +5687,14 @@ MODULE_DEVICE_TABLE(of, dsi_of_match);\n static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)\n {\n \tconst struct panel_desc_dsi *desc;\n+\tstruct panel_simple *panel;\n \tint err;\n \n-\tdesc = of_device_get_match_data(&dsi->dev);\n-\tif (!desc)\n-\t\treturn -ENODEV;\n-\n-\terr = panel_simple_probe(&dsi->dev, &desc->desc);\n-\tif (err < 0)\n-\t\treturn err;\n+\tpanel = panel_simple_probe(&dsi->dev);\n+\tif (IS_ERR(panel))\n+\t\treturn PTR_ERR(panel);\n \n+\tdesc = container_of(panel->desc, struct panel_desc_dsi, desc);\n \tdsi->mode_flags = desc->flags;\n \tdsi->format = desc->format;\n \tdsi->lanes = desc->lanes;\ndiff --git a/drivers/gpu/drm/sysfb/vesadrm.c b/drivers/gpu/drm/sysfb/vesadrm.c\nindex 4d62c78e7d1e..f7532db3831f 100644\n--- a/drivers/gpu/drm/sysfb/vesadrm.c\n+++ b/drivers/gpu/drm/sysfb/vesadrm.c\n@@ -362,14 +362,19 @@ static struct vesadrm_device *vesadrm_device_create(struct drm_driver *drv,\n \n \tif (!__screen_info_vbe_mode_nonvga(si)) {\n \t\tvesa->cmap_write = vesadrm_vga_cmap_write;\n-#if defined(CONFIG_X86_32)\n \t} else {\n+#if defined(CONFIG_X86_32)\n \t\tphys_addr_t pmi_base = __screen_info_vesapm_info_base(si);\n-\t\tconst u16 *pmi_addr = phys_to_virt(pmi_base);\n \n-\t\tvesa->pmi.PrimaryPalette = (u8 *)pmi_addr + pmi_addr[2];\n-\t\tvesa->cmap_write = vesadrm_pmi_cmap_write;\n+\t\tif (pmi_base) {\n+\t\t\tconst u16 *pmi_addr = phys_to_virt(pmi_base);\n+\n+\t\t\tvesa->pmi.PrimaryPalette = (u8 *)pmi_addr + pmi_addr[2];\n+\t\t\tvesa->cmap_write = vesadrm_pmi_cmap_write;\n+\t\t} else\n #endif\n+\t\tif (format->is_color_indexed)\n+\t\t\tdrm_warn(dev, \"hardware palette is unchangeable, colors may be incorrect\\n\");\n \t}\n \n #ifdef CONFIG_X86\ndiff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c\nindex 15cab9bda17f..bd90404ea609 100644\n--- a/drivers/gpu/drm/ttm/ttm_bo_util.c\n+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c\n@@ -254,6 +254,13 @@ static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,\n \tret = dma_resv_trylock(&fbo->base.base._resv);\n \tWARN_ON(!ret);\n \n+\tret = dma_resv_reserve_fences(&fbo->base.base._resv, 1);\n+\tif (ret) {\n+\t\tdma_resv_unlock(&fbo->base.base._resv);\n+\t\tkfree(fbo);\n+\t\treturn ret;\n+\t}\n+\n \tif (fbo->base.resource) {\n \t\tttm_resource_set_bo(fbo->base.resource, &fbo->base);\n \t\tbo->resource = NULL;\n@@ -262,12 +269,6 @@ static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,\n \t\tfbo->base.bulk_move = NULL;\n \t}\n \n-\tret = dma_resv_reserve_fences(&fbo->base.base._resv, 1);\n-\tif (ret) {\n-\t\tkfree(fbo);\n-\t\treturn ret;\n-\t}\n-\n \tttm_bo_get(bo);\n \tfbo->bo = bo;\n \ndiff --git a/drivers/gpu/drm/v3d/v3d_drv.h b/drivers/gpu/drm/v3d/v3d_drv.h\nindex b51f0b648a08..411e47702f8a 100644\n--- a/drivers/gpu/drm/v3d/v3d_drv.h\n+++ b/drivers/gpu/drm/v3d/v3d_drv.h\n@@ -101,6 +101,12 @@ enum v3d_gen {\n \tV3D_GEN_71 = 71,\n };\n \n+enum v3d_irq {\n+\tV3D_CORE_IRQ,\n+\tV3D_HUB_IRQ,\n+\tV3D_MAX_IRQS,\n+};\n+\n struct v3d_dev {\n \tstruct drm_device drm;\n \n@@ -112,6 +118,8 @@ struct v3d_dev {\n \n \tbool single_irq_line;\n \n+\tint irq[V3D_MAX_IRQS];\n+\n \tstruct v3d_perfmon_info perfmon_info;\n \n \tvoid __iomem *hub_regs;\ndiff --git a/drivers/gpu/drm/v3d/v3d_gem.c b/drivers/gpu/drm/v3d/v3d_gem.c\nindex d7d16da78db3..37bf5eecdd2c 100644\n--- a/drivers/gpu/drm/v3d/v3d_gem.c\n+++ b/drivers/gpu/drm/v3d/v3d_gem.c\n@@ -134,6 +134,8 @@ v3d_reset(struct v3d_dev *v3d)\n \tif (false)\n \t\tv3d_idle_axi(v3d, 0);\n \n+\tv3d_irq_disable(v3d);\n+\n \tv3d_idle_gca(v3d);\n \tv3d_reset_sms(v3d);\n \tv3d_reset_v3d(v3d);\ndiff --git a/drivers/gpu/drm/v3d/v3d_irq.c b/drivers/gpu/drm/v3d/v3d_irq.c\nindex 2cca5d3a26a2..a515a301e480 100644\n--- a/drivers/gpu/drm/v3d/v3d_irq.c\n+++ b/drivers/gpu/drm/v3d/v3d_irq.c\n@@ -260,7 +260,7 @@ v3d_hub_irq(int irq, void *arg)\n int\n v3d_irq_init(struct v3d_dev *v3d)\n {\n-\tint irq1, ret, core;\n+\tint irq, ret, core;\n \n \tINIT_WORK(&v3d->overflow_mem_work, v3d_overflow_mem_work);\n \n@@ -271,17 +271,24 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));\n \tV3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS(v3d->ver));\n \n-\tirq1 = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n-\tif (irq1 == -EPROBE_DEFER)\n-\t\treturn irq1;\n-\tif (irq1 > 0) {\n-\t\tret = devm_request_irq(v3d->drm.dev, irq1,\n+\tirq = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n+\tif (irq == -EPROBE_DEFER)\n+\t\treturn irq;\n+\tif (irq > 0) {\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_core0\", v3d);\n \t\tif (ret)\n \t\t\tgoto fail;\n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_HUB_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_HUB_IRQ],\n \t\t\t\t       v3d_hub_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_hub\", v3d);\n \t\tif (ret)\n@@ -289,8 +296,12 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t} else {\n \t\tv3d->single_irq_line = true;\n \n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d\", v3d);\n \t\tif (ret)\n@@ -331,6 +342,12 @@ v3d_irq_disable(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~0);\n \tV3D_WRITE(V3D_HUB_INT_MSK_SET, ~0);\n \n+\t/* Finish any interrupt handler still in flight. */\n+\tfor (int i = 0; i < V3D_MAX_IRQS; i++) {\n+\t\tif (v3d->irq[i])\n+\t\t\tsynchronize_irq(v3d->irq[i]);\n+\t}\n+\n \t/* Clear any pending interrupts we might have left. */\n \tfor (core = 0; core < v3d->cores; core++)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));\ndiff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\nindex 0695a342b1ef..5205552b1970 100644\n--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\n+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\n@@ -749,7 +749,7 @@ static int vmw_setup_pci_resources(struct vmw_private *dev,\n \t\tdev->fifo_mem = devm_memremap(dev->drm.dev,\n \t\t\t\t\t      fifo_start,\n \t\t\t\t\t      fifo_size,\n-\t\t\t\t\t      MEMREMAP_WB);\n+\t\t\t\t\t      MEMREMAP_WB | MEMREMAP_DEC);\n \n \t\tif (IS_ERR(dev->fifo_mem)) {\n \t\t\tdrm_err(&dev->drm,\ndiff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h\nindex b37860f4a895..6d2c08e81101 100644\n--- a/include/drm/drm_mipi_dsi.h\n+++ b/include/drm/drm_mipi_dsi.h\n@@ -223,6 +223,9 @@ struct mipi_dsi_multi_context {\n \n #define to_mipi_dsi_device(__dev)\tcontainer_of_const(__dev, struct mipi_dsi_device, dev)\n \n+extern const struct bus_type mipi_dsi_bus_type;\n+#define dev_is_mipi_dsi(dev)\t((dev)->bus == &mipi_dsi_bus_type)\n+\n /**\n  * mipi_dsi_pixel_format_to_bpp - obtain the number of bits per pixel for any\n  *                                given pixel format defined by the MIPI DSI\ndiff --git a/include/drm/spsc_queue.h b/include/drm/spsc_queue.h\nindex 125f096c88cb..ee9df8cc67b7 100644\n--- a/include/drm/spsc_queue.h\n+++ b/include/drm/spsc_queue.h\n@@ -70,9 +70,11 @@ static inline bool spsc_queue_push(struct spsc_queue *queue, struct spsc_node *n\n \n \tpreempt_disable();\n \n+\tatomic_inc(&queue->job_count);\n+\tsmp_mb__after_atomic();\n+\n \ttail = (struct spsc_node **)atomic_long_xchg(&queue->tail, (long)&node->next);\n \tWRITE_ONCE(*tail, node);\n-\tatomic_inc(&queue->job_count);\n \n \t/*\n \t * In case of first element verify new node will be visible to the consumer",
    "stats": {
      "insertions": 205,
      "deletions": 94,
      "files": 16
    }
  },
  {
    "sha": "e79d0ba605d54dd47f3d8a487d00f264b896966c",
    "message": "nouveau/gsp: add a 50ms delay between fbsr and driver unload rpcs\n\nThis fixes a bunch of command hangs after runtime suspend/resume.\n\nThis fixes a regression caused by code movement in the commit below,\nthe commit seems to just change timings enough to cause this to happen\nnow, and adding the sleep seems to avoid it.\n\nI've spent some time trying to root cause it to no great avail,\nit seems like a bug on the firmware side, but it could be a bug\nin our rpc handling that I can't find.\n\nEither way, we should land the workaround to fix the problem,\nwhile we continue to work out the root cause.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\nCc: Ben Skeggs <bskeggs@nvidia.com>\nCc: Danilo Krummrich <dakr@kernel.org>\nFixes: c21b039715ce (\"drm/nouveau/gsp: add hals for fbsr.suspend/resume()\")\nSigned-off-by: Danilo Krummrich <dakr@kernel.org>\nLink: https://lore.kernel.org/r/20250702232707.175679-1-airlied@gmail.com",
    "author": "Dave Airlie",
    "date": "2025-07-04T00:22:12+02:00",
    "files_changed": [
      "drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\nindex baf42339f93e..23f80e167705 100644\n--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n@@ -1744,6 +1744,13 @@ r535_gsp_fini(struct nvkm_gsp *gsp, bool suspend)\n \t\t\tnvkm_gsp_sg_free(gsp->subdev.device, &gsp->sr.sgt);\n \t\t\treturn ret;\n \t\t}\n+\n+\t\t/*\n+\t\t * TODO: Debug the GSP firmware / RPC handling to find out why\n+\t\t * without this Turing (but none of the other architectures)\n+\t\t * ends up resetting all channels after resume.\n+\t\t */\n+\t\tmsleep(50);\n \t}\n \n \tret = r535_gsp_rpc_unloading_guest_driver(gsp, suspend);",
    "stats": {
      "insertions": 7,
      "deletions": 0,
      "files": 1
    }
  }
]
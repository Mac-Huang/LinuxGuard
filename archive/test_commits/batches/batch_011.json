[
  {
    "sha": "772b78c2abd85586bb90b23adff89f7303c704c7",
    "message": "Merge tag 'sched_urgent_for_v6.16_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip\n\nPull scheduler fixes from Borislav Petkov:\n\n - Fix the calculation of the deadline server task's runtime as this\n   mishap was preventing realtime tasks from running\n\n - Avoid a race condition during migrate-swapping two tasks\n\n - Fix the string reported for the \"none\" dynamic preemption option\n\n* tag 'sched_urgent_for_v6.16_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:\n  sched/deadline: Fix dl_server runtime calculation formula\n  sched/core: Fix migrate_swap() vs. hotplug\n  sched: Fix preemption string of preempt_dynamic_none",
    "author": "Linus Torvalds",
    "date": "2025-07-06T11:17:47-07:00",
    "files_changed": [
      "kernel/sched/core.c",
      "kernel/sched/deadline.c",
      "kernel/stop_machine.c"
    ],
    "diff": "diff --git a/kernel/sched/core.c b/kernel/sched/core.c\nindex 8988d38d46a3..ec68fc686bd7 100644\n--- a/kernel/sched/core.c\n+++ b/kernel/sched/core.c\n@@ -3943,6 +3943,11 @@ static inline bool ttwu_queue_cond(struct task_struct *p, int cpu)\n \tif (!scx_allow_ttwu_queue(p))\n \t\treturn false;\n \n+#ifdef CONFIG_SMP\n+\tif (p->sched_class == &stop_sched_class)\n+\t\treturn false;\n+#endif\n+\n \t/*\n \t * Do not complicate things with the async wake_list while the CPU is\n \t * in hotplug state.\n@@ -7663,7 +7668,7 @@ const char *preempt_model_str(void)\n \n \t\tif (IS_ENABLED(CONFIG_PREEMPT_DYNAMIC)) {\n \t\t\tseq_buf_printf(&s, \"(%s)%s\",\n-\t\t\t\t       preempt_dynamic_mode > 0 ?\n+\t\t\t\t       preempt_dynamic_mode >= 0 ?\n \t\t\t\t       preempt_modes[preempt_dynamic_mode] : \"undef\",\n \t\t\t\t       brace ? \"}\" : \"\");\n \t\t\treturn seq_buf_str(&s);\ndiff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c\nindex ad45a8fea245..89019a140826 100644\n--- a/kernel/sched/deadline.c\n+++ b/kernel/sched/deadline.c\n@@ -1504,7 +1504,9 @@ static void update_curr_dl_se(struct rq *rq, struct sched_dl_entity *dl_se, s64\n \tif (dl_entity_is_special(dl_se))\n \t\treturn;\n \n-\tscaled_delta_exec = dl_scaled_delta_exec(rq, dl_se, delta_exec);\n+\tscaled_delta_exec = delta_exec;\n+\tif (!dl_server(dl_se))\n+\t\tscaled_delta_exec = dl_scaled_delta_exec(rq, dl_se, delta_exec);\n \n \tdl_se->runtime -= scaled_delta_exec;\n \n@@ -1611,7 +1613,7 @@ static void update_curr_dl_se(struct rq *rq, struct sched_dl_entity *dl_se, s64\n  */\n void dl_server_update_idle_time(struct rq *rq, struct task_struct *p)\n {\n-\ts64 delta_exec, scaled_delta_exec;\n+\ts64 delta_exec;\n \n \tif (!rq->fair_server.dl_defer)\n \t\treturn;\n@@ -1624,9 +1626,7 @@ void dl_server_update_idle_time(struct rq *rq, struct task_struct *p)\n \tif (delta_exec < 0)\n \t\treturn;\n \n-\tscaled_delta_exec = dl_scaled_delta_exec(rq, &rq->fair_server, delta_exec);\n-\n-\trq->fair_server.runtime -= scaled_delta_exec;\n+\trq->fair_server.runtime -= delta_exec;\n \n \tif (rq->fair_server.runtime < 0) {\n \t\trq->fair_server.dl_defer_running = 0;\ndiff --git a/kernel/stop_machine.c b/kernel/stop_machine.c\nindex 5d2d0562115b..3fe6b0c99f3d 100644\n--- a/kernel/stop_machine.c\n+++ b/kernel/stop_machine.c\n@@ -82,18 +82,15 @@ static void cpu_stop_signal_done(struct cpu_stop_done *done)\n }\n \n static void __cpu_stop_queue_work(struct cpu_stopper *stopper,\n-\t\t\t\t\tstruct cpu_stop_work *work,\n-\t\t\t\t\tstruct wake_q_head *wakeq)\n+\t\t\t\t  struct cpu_stop_work *work)\n {\n \tlist_add_tail(&work->list, &stopper->works);\n-\twake_q_add(wakeq, stopper->thread);\n }\n \n /* queue @work to @stopper.  if offline, @work is completed immediately */\n static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n {\n \tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n-\tDEFINE_WAKE_Q(wakeq);\n \tunsigned long flags;\n \tbool enabled;\n \n@@ -101,12 +98,13 @@ static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n \traw_spin_lock_irqsave(&stopper->lock, flags);\n \tenabled = stopper->enabled;\n \tif (enabled)\n-\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n+\t\t__cpu_stop_queue_work(stopper, work);\n \telse if (work->done)\n \t\tcpu_stop_signal_done(work->done);\n \traw_spin_unlock_irqrestore(&stopper->lock, flags);\n \n-\twake_up_q(&wakeq);\n+\tif (enabled)\n+\t\twake_up_process(stopper->thread);\n \tpreempt_enable();\n \n \treturn enabled;\n@@ -264,7 +262,6 @@ static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n {\n \tstruct cpu_stopper *stopper1 = per_cpu_ptr(&cpu_stopper, cpu1);\n \tstruct cpu_stopper *stopper2 = per_cpu_ptr(&cpu_stopper, cpu2);\n-\tDEFINE_WAKE_Q(wakeq);\n \tint err;\n \n retry:\n@@ -300,8 +297,8 @@ static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n \t}\n \n \terr = 0;\n-\t__cpu_stop_queue_work(stopper1, work1, &wakeq);\n-\t__cpu_stop_queue_work(stopper2, work2, &wakeq);\n+\t__cpu_stop_queue_work(stopper1, work1);\n+\t__cpu_stop_queue_work(stopper2, work2);\n \n unlock:\n \traw_spin_unlock(&stopper2->lock);\n@@ -316,7 +313,10 @@ static int cpu_stop_queue_two_works(int cpu1, struct cpu_stop_work *work1,\n \t\tgoto retry;\n \t}\n \n-\twake_up_q(&wakeq);\n+\tif (!err) {\n+\t\twake_up_process(stopper1->thread);\n+\t\twake_up_process(stopper2->thread);\n+\t}\n \tpreempt_enable();\n \n \treturn err;",
    "stats": {
      "insertions": 21,
      "deletions": 16,
      "files": 3
    }
  },
  {
    "sha": "a1639ce5e590300af45bebedfbacf8fabc1777ed",
    "message": "Merge tag 'perf_urgent_for_v6.16_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip\n\nPull perf fixes from Borislav Petkov:\n\n - Revert uprobes to using CAP_SYS_ADMIN again as currently they can\n   destructively modify kernel code from an unprivileged process\n\n - Move a warning to where it belongs\n\n* tag 'perf_urgent_for_v6.16_rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:\n  perf: Revert to requiring CAP_SYS_ADMIN for uprobes\n  perf/core: Fix the WARN_ON_ONCE is out of lock protected region",
    "author": "Linus Torvalds",
    "date": "2025-07-06T10:49:27-07:00",
    "files_changed": [
      "kernel/events/core.c"
    ],
    "diff": "diff --git a/kernel/events/core.c b/kernel/events/core.c\nindex 7281230044d0..0db36b2b2448 100644\n--- a/kernel/events/core.c\n+++ b/kernel/events/core.c\n@@ -951,8 +951,6 @@ static void perf_cgroup_switch(struct task_struct *task)\n \tif (READ_ONCE(cpuctx->cgrp) == NULL)\n \t\treturn;\n \n-\tWARN_ON_ONCE(cpuctx->ctx.nr_cgroups == 0);\n-\n \tcgrp = perf_cgroup_from_task(task, NULL);\n \tif (READ_ONCE(cpuctx->cgrp) == cgrp)\n \t\treturn;\n@@ -964,6 +962,8 @@ static void perf_cgroup_switch(struct task_struct *task)\n \tif (READ_ONCE(cpuctx->cgrp) == NULL)\n \t\treturn;\n \n+\tWARN_ON_ONCE(cpuctx->ctx.nr_cgroups == 0);\n+\n \tperf_ctx_disable(&cpuctx->ctx, true);\n \n \tctx_sched_out(&cpuctx->ctx, NULL, EVENT_ALL|EVENT_CGROUP);\n@@ -11116,7 +11116,7 @@ static int perf_uprobe_event_init(struct perf_event *event)\n \tif (event->attr.type != perf_uprobe.type)\n \t\treturn -ENOENT;\n \n-\tif (!perfmon_capable())\n+\tif (!capable(CAP_SYS_ADMIN))\n \t\treturn -EACCES;\n \n \t/*",
    "stats": {
      "insertions": 3,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "1f988d0788f50d8464f957e793fab356e2937369",
    "message": "Merge tag 'hid-for-linus-2025070502' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid\n\nPull HID fixes from Jiri Kosina:\n\n - Memory corruption fixes in hid-appletb-kbd driver (Qasim Ijaz)\n\n - New device ID in hid-elecom driver (Leonard Dizon)\n\n - Fixed several HID debugfs contants (Vicki Pfau)\n\n* tag 'hid-for-linus-2025070502' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid:\n  HID: appletb-kbd: fix slab use-after-free bug in appletb_kbd_probe\n  HID: Fix debug name for BTN_GEAR_DOWN, BTN_GEAR_UP, BTN_WHEEL\n  HID: elecom: add support for ELECOM HUGE 019B variant\n  HID: appletb-kbd: fix memory corruption of input_handler_list",
    "author": "Linus Torvalds",
    "date": "2025-07-05T16:14:03-07:00",
    "files_changed": [
      "drivers/hid/hid-appletb-kbd.c",
      "drivers/hid/hid-debug.c",
      "drivers/hid/hid-elecom.c",
      "drivers/hid/hid-ids.h",
      "drivers/hid/hid-quirks.c"
    ],
    "diff": "diff --git a/drivers/hid/hid-appletb-kbd.c b/drivers/hid/hid-appletb-kbd.c\nindex 2e0caf52af13..b00687e67ce8 100644\n--- a/drivers/hid/hid-appletb-kbd.c\n+++ b/drivers/hid/hid-appletb-kbd.c\n@@ -430,16 +430,20 @@ static int appletb_kbd_probe(struct hid_device *hdev, const struct hid_device_id\n \tret = appletb_kbd_set_mode(kbd, appletb_tb_def_mode);\n \tif (ret) {\n \t\tdev_err_probe(dev, ret, \"Failed to set touchbar mode\\n\");\n-\t\tgoto close_hw;\n+\t\tgoto unregister_handler;\n \t}\n \n \thid_set_drvdata(hdev, kbd);\n \n \treturn 0;\n \n+unregister_handler:\n+\tinput_unregister_handler(&kbd->inp_handler);\n close_hw:\n-\tif (kbd->backlight_dev)\n+\tif (kbd->backlight_dev) {\n \t\tput_device(&kbd->backlight_dev->dev);\n+\t\ttimer_delete_sync(&kbd->inactivity_timer);\n+\t}\n \thid_hw_close(hdev);\n stop_hw:\n \thid_hw_stop(hdev);\n@@ -453,10 +457,10 @@ static void appletb_kbd_remove(struct hid_device *hdev)\n \tappletb_kbd_set_mode(kbd, APPLETB_KBD_MODE_OFF);\n \n \tinput_unregister_handler(&kbd->inp_handler);\n-\ttimer_delete_sync(&kbd->inactivity_timer);\n-\n-\tif (kbd->backlight_dev)\n+\tif (kbd->backlight_dev) {\n \t\tput_device(&kbd->backlight_dev->dev);\n+\t\ttimer_delete_sync(&kbd->inactivity_timer);\n+\t}\n \n \thid_hw_close(hdev);\n \thid_hw_stop(hdev);\ndiff --git a/drivers/hid/hid-debug.c b/drivers/hid/hid-debug.c\nindex 8433306148d5..c6b6b1029540 100644\n--- a/drivers/hid/hid-debug.c\n+++ b/drivers/hid/hid-debug.c\n@@ -3298,8 +3298,8 @@ static const char *keys[KEY_MAX + 1] = {\n \t[BTN_TOUCH] = \"Touch\",\t\t\t[BTN_STYLUS] = \"Stylus\",\n \t[BTN_STYLUS2] = \"Stylus2\",\t\t[BTN_TOOL_DOUBLETAP] = \"ToolDoubleTap\",\n \t[BTN_TOOL_TRIPLETAP] = \"ToolTripleTap\",\t[BTN_TOOL_QUADTAP] = \"ToolQuadrupleTap\",\n-\t[BTN_GEAR_DOWN] = \"WheelBtn\",\n-\t[BTN_GEAR_UP] = \"Gear up\",\t\t[KEY_OK] = \"Ok\",\n+\t[BTN_GEAR_DOWN] = \"BtnGearDown\",\t[BTN_GEAR_UP] = \"BtnGearUp\",\n+\t[BTN_WHEEL] = \"BtnWheel\",\t\t[KEY_OK] = \"Ok\",\n \t[KEY_SELECT] = \"Select\",\t\t[KEY_GOTO] = \"Goto\",\n \t[KEY_CLEAR] = \"Clear\",\t\t\t[KEY_POWER2] = \"Power2\",\n \t[KEY_OPTION] = \"Option\",\t\t[KEY_INFO] = \"Info\",\ndiff --git a/drivers/hid/hid-elecom.c b/drivers/hid/hid-elecom.c\nindex defcf91fdd14..0ad7d25d9864 100644\n--- a/drivers/hid/hid-elecom.c\n+++ b/drivers/hid/hid-elecom.c\n@@ -89,7 +89,8 @@ static const __u8 *elecom_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tbreak;\n \tcase USB_DEVICE_ID_ELECOM_M_DT1URBK:\n \tcase USB_DEVICE_ID_ELECOM_M_DT1DRBK:\n-\tcase USB_DEVICE_ID_ELECOM_M_HT1URBK:\n+\tcase USB_DEVICE_ID_ELECOM_M_HT1URBK_010C:\n+\tcase USB_DEVICE_ID_ELECOM_M_HT1URBK_019B:\n \tcase USB_DEVICE_ID_ELECOM_M_HT1DRBK_010D:\n \t\t/*\n \t\t * Report descriptor format:\n@@ -122,7 +123,8 @@ static const struct hid_device_id elecom_devices[] = {\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_XT4DRBK) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_DT1URBK) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_DT1DRBK) },\n-\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK_010C) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK_019B) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1DRBK_010D) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1DRBK_011C) },\n \t{ }\ndiff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h\nindex c6468568aea1..33cc5820f2be 100644\n--- a/drivers/hid/hid-ids.h\n+++ b/drivers/hid/hid-ids.h\n@@ -448,7 +448,8 @@\n #define USB_DEVICE_ID_ELECOM_M_XT4DRBK\t0x00fd\n #define USB_DEVICE_ID_ELECOM_M_DT1URBK\t0x00fe\n #define USB_DEVICE_ID_ELECOM_M_DT1DRBK\t0x00ff\n-#define USB_DEVICE_ID_ELECOM_M_HT1URBK\t0x010c\n+#define USB_DEVICE_ID_ELECOM_M_HT1URBK_010C\t0x010c\n+#define USB_DEVICE_ID_ELECOM_M_HT1URBK_019B\t0x019b\n #define USB_DEVICE_ID_ELECOM_M_HT1DRBK_010D\t0x010d\n #define USB_DEVICE_ID_ELECOM_M_HT1DRBK_011C\t0x011c\n \ndiff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c\nindex 31508da93ba2..9bf9ce8dc803 100644\n--- a/drivers/hid/hid-quirks.c\n+++ b/drivers/hid/hid-quirks.c\n@@ -410,7 +410,8 @@ static const struct hid_device_id hid_have_special_driver[] = {\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_XT4DRBK) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_DT1URBK) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_DT1DRBK) },\n-\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK_010C) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1URBK_019B) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1DRBK_010D) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_M_HT1DRBK_011C) },\n #endif",
    "stats": {
      "insertions": 19,
      "deletions": 11,
      "files": 5
    }
  },
  {
    "sha": "05df91921da664ebba2752a7e45b63e3dddb85de",
    "message": "Merge tag 'v6.16-rc4-smb3-client-fixes' of git://git.samba.org/sfrench/cifs-2.6\n\nPull smb client fixes from Steve French:\n\n - Two reconnect fixes including one for a reboot/reconnect race\n\n - Fix for incorrect file type that can be returned by SMB3.1.1 POSIX\n   extensions\n\n - tcon initialization fix\n\n - Fix for resolving Windows symlinks with absolute paths\n\n* tag 'v6.16-rc4-smb3-client-fixes' of git://git.samba.org/sfrench/cifs-2.6:\n  smb: client: fix native SMB symlink traversal\n  smb: client: fix race condition in negotiate timeout by using more precise timing\n  cifs: all initializations for tcon should happen in tcon_info_alloc\n  smb: client: fix warning when reconnecting channel\n  smb: client: fix readdir returning wrong type with POSIX extensions",
    "author": "Linus Torvalds",
    "date": "2025-07-05T13:05:28-07:00",
    "files_changed": [
      "fs/smb/client/cifsglob.h",
      "fs/smb/client/cifsproto.h",
      "fs/smb/client/connect.c",
      "fs/smb/client/fs_context.c",
      "fs/smb/client/misc.c",
      "fs/smb/client/readdir.c",
      "fs/smb/client/reparse.c",
      "fs/smb/client/smb2pdu.c"
    ],
    "diff": "diff --git a/fs/smb/client/cifsglob.h b/fs/smb/client/cifsglob.h\nindex 318a8405d475..89160bc34d35 100644\n--- a/fs/smb/client/cifsglob.h\n+++ b/fs/smb/client/cifsglob.h\n@@ -777,6 +777,7 @@ struct TCP_Server_Info {\n \t__le32 session_key_id; /* retrieved from negotiate response and send in session setup request */\n \tstruct session_key session_key;\n \tunsigned long lstrp; /* when we got last response from this server */\n+\tunsigned long neg_start; /* when negotiate started (jiffies) */\n \tstruct cifs_secmech secmech; /* crypto sec mech functs, descriptors */\n #define\tCIFS_NEGFLAVOR_UNENCAP\t1\t/* wct == 17, but no ext_sec */\n #define\tCIFS_NEGFLAVOR_EXTENDED\t2\t/* wct == 17, ext_sec bit set */\n@@ -1303,6 +1304,7 @@ struct cifs_tcon {\n \tbool use_persistent:1; /* use persistent instead of durable handles */\n \tbool no_lease:1;    /* Do not request leases on files or directories */\n \tbool use_witness:1; /* use witness protocol */\n+\tbool dummy:1; /* dummy tcon used for reconnecting channels */\n \t__le32 capabilities;\n \t__u32 share_flags;\n \t__u32 maximal_access;\ndiff --git a/fs/smb/client/cifsproto.h b/fs/smb/client/cifsproto.h\nindex 66093fa78aed..045227ed4efc 100644\n--- a/fs/smb/client/cifsproto.h\n+++ b/fs/smb/client/cifsproto.h\n@@ -136,6 +136,7 @@ extern int SendReceiveBlockingLock(const unsigned int xid,\n \t\t\tstruct smb_hdr *out_buf,\n \t\t\tint *bytes_returned);\n \n+void smb2_query_server_interfaces(struct work_struct *work);\n void\n cifs_signal_cifsd_for_reconnect(struct TCP_Server_Info *server,\n \t\t\t\t      bool all_channels);\ndiff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.c\nindex 685c65dcb8c4..205f547ca49e 100644\n--- a/fs/smb/client/connect.c\n+++ b/fs/smb/client/connect.c\n@@ -97,7 +97,7 @@ static int reconn_set_ipaddr_from_hostname(struct TCP_Server_Info *server)\n \treturn rc;\n }\n \n-static void smb2_query_server_interfaces(struct work_struct *work)\n+void smb2_query_server_interfaces(struct work_struct *work)\n {\n \tint rc;\n \tint xid;\n@@ -679,12 +679,12 @@ server_unresponsive(struct TCP_Server_Info *server)\n \t/*\n \t * If we're in the process of mounting a share or reconnecting a session\n \t * and the server abruptly shut down (e.g. socket wasn't closed, packet\n-\t * had been ACK'ed but no SMB response), don't wait longer than 20s to\n-\t * negotiate protocol.\n+\t * had been ACK'ed but no SMB response), don't wait longer than 20s from\n+\t * when negotiate actually started.\n \t */\n \tspin_lock(&server->srv_lock);\n \tif (server->tcpStatus == CifsInNegotiate &&\n-\t    time_after(jiffies, server->lstrp + 20 * HZ)) {\n+\t    time_after(jiffies, server->neg_start + 20 * HZ)) {\n \t\tspin_unlock(&server->srv_lock);\n \t\tcifs_reconnect(server, false);\n \t\treturn true;\n@@ -2880,20 +2880,14 @@ cifs_get_tcon(struct cifs_ses *ses, struct smb3_fs_context *ctx)\n \ttcon->max_cached_dirs = ctx->max_cached_dirs;\n \ttcon->nodelete = ctx->nodelete;\n \ttcon->local_lease = ctx->local_lease;\n-\tINIT_LIST_HEAD(&tcon->pending_opens);\n \ttcon->status = TID_GOOD;\n \n-\tINIT_DELAYED_WORK(&tcon->query_interfaces,\n-\t\t\t  smb2_query_server_interfaces);\n \tif (ses->server->dialect >= SMB30_PROT_ID &&\n \t    (ses->server->capabilities & SMB2_GLOBAL_CAP_MULTI_CHANNEL)) {\n \t\t/* schedule query interfaces poll */\n \t\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n \t\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n \t}\n-#ifdef CONFIG_CIFS_DFS_UPCALL\n-\tINIT_DELAYED_WORK(&tcon->dfs_cache_work, dfs_cache_refresh);\n-#endif\n \tspin_lock(&cifs_tcp_ses_lock);\n \tlist_add(&tcon->tcon_list, &ses->tcon_list);\n \tspin_unlock(&cifs_tcp_ses_lock);\n@@ -4215,6 +4209,7 @@ cifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n \n \tserver->lstrp = jiffies;\n \tserver->tcpStatus = CifsInNegotiate;\n+\tserver->neg_start = jiffies;\n \tspin_unlock(&server->srv_lock);\n \n \trc = server->ops->negotiate(xid, ses, server);\ndiff --git a/fs/smb/client/fs_context.c b/fs/smb/client/fs_context.c\nindex a634a34d4086..59ccc2229ab3 100644\n--- a/fs/smb/client/fs_context.c\n+++ b/fs/smb/client/fs_context.c\n@@ -1824,10 +1824,14 @@ static int smb3_fs_context_parse_param(struct fs_context *fc,\n \t\t\tcifs_errorf(fc, \"symlinkroot mount options must be absolute path\\n\");\n \t\t\tgoto cifs_parse_mount_err;\n \t\t}\n-\t\tkfree(ctx->symlinkroot);\n-\t\tctx->symlinkroot = kstrdup(param->string, GFP_KERNEL);\n-\t\tif (!ctx->symlinkroot)\n+\t\tif (strnlen(param->string, PATH_MAX) == PATH_MAX) {\n+\t\t\tcifs_errorf(fc, \"symlinkroot path too long (max path length: %u)\\n\",\n+\t\t\t\t    PATH_MAX - 1);\n \t\t\tgoto cifs_parse_mount_err;\n+\t\t}\n+\t\tkfree(ctx->symlinkroot);\n+\t\tctx->symlinkroot = param->string;\n+\t\tparam->string = NULL;\n \t\tbreak;\n \t}\n \t/* case Opt_ignore: - is ignored as expected ... */\n@@ -1837,13 +1841,6 @@ static int smb3_fs_context_parse_param(struct fs_context *fc,\n \t\tgoto cifs_parse_mount_err;\n \t}\n \n-\t/*\n-\t * By default resolve all native absolute symlinks relative to \"/mnt/\".\n-\t * Same default has drvfs driver running in WSL for resolving SMB shares.\n-\t */\n-\tif (!ctx->symlinkroot)\n-\t\tctx->symlinkroot = kstrdup(\"/mnt/\", GFP_KERNEL);\n-\n \treturn 0;\n \n  cifs_parse_mount_err:\ndiff --git a/fs/smb/client/misc.c b/fs/smb/client/misc.c\nindex e77017f47084..da23cc12a52c 100644\n--- a/fs/smb/client/misc.c\n+++ b/fs/smb/client/misc.c\n@@ -151,6 +151,12 @@ tcon_info_alloc(bool dir_leases_enabled, enum smb3_tcon_ref_trace trace)\n #ifdef CONFIG_CIFS_DFS_UPCALL\n \tINIT_LIST_HEAD(&ret_buf->dfs_ses_list);\n #endif\n+\tINIT_LIST_HEAD(&ret_buf->pending_opens);\n+\tINIT_DELAYED_WORK(&ret_buf->query_interfaces,\n+\t\t\t  smb2_query_server_interfaces);\n+#ifdef CONFIG_CIFS_DFS_UPCALL\n+\tINIT_DELAYED_WORK(&ret_buf->dfs_cache_work, dfs_cache_refresh);\n+#endif\n \n \treturn ret_buf;\n }\ndiff --git a/fs/smb/client/readdir.c b/fs/smb/client/readdir.c\nindex ba0193cf9033..4e5460206397 100644\n--- a/fs/smb/client/readdir.c\n+++ b/fs/smb/client/readdir.c\n@@ -264,7 +264,7 @@ cifs_posix_to_fattr(struct cifs_fattr *fattr, struct smb2_posix_info *info,\n \t/* The Mode field in the response can now include the file type as well */\n \tfattr->cf_mode = wire_mode_to_posix(le32_to_cpu(info->Mode),\n \t\t\t\t\t    fattr->cf_cifsattrs & ATTR_DIRECTORY);\n-\tfattr->cf_dtype = S_DT(le32_to_cpu(info->Mode));\n+\tfattr->cf_dtype = S_DT(fattr->cf_mode);\n \n \tswitch (fattr->cf_mode & S_IFMT) {\n \tcase S_IFLNK:\ndiff --git a/fs/smb/client/reparse.c b/fs/smb/client/reparse.c\nindex 1c40e42e4d89..5fa29a97ac15 100644\n--- a/fs/smb/client/reparse.c\n+++ b/fs/smb/client/reparse.c\n@@ -57,6 +57,7 @@ static int create_native_symlink(const unsigned int xid, struct inode *inode,\n \tstruct reparse_symlink_data_buffer *buf = NULL;\n \tstruct cifs_open_info_data data = {};\n \tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n+\tconst char *symroot = cifs_sb->ctx->symlinkroot;\n \tstruct inode *new;\n \tstruct kvec iov;\n \t__le16 *path = NULL;\n@@ -82,7 +83,8 @@ static int create_native_symlink(const unsigned int xid, struct inode *inode,\n \t\t.symlink_target = symlink_target,\n \t};\n \n-\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) && symname[0] == '/') {\n+\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) &&\n+\t    symroot && symname[0] == '/') {\n \t\t/*\n \t\t * This is a request to create an absolute symlink on the server\n \t\t * which does not support POSIX paths, and expects symlink in\n@@ -92,7 +94,7 @@ static int create_native_symlink(const unsigned int xid, struct inode *inode,\n \t\t * ensure compatibility of this symlink stored in absolute form\n \t\t * on the SMB server.\n \t\t */\n-\t\tif (!strstarts(symname, cifs_sb->ctx->symlinkroot)) {\n+\t\tif (!strstarts(symname, symroot)) {\n \t\t\t/*\n \t\t\t * If the absolute Linux symlink target path is not\n \t\t\t * inside \"symlinkroot\" location then there is no way\n@@ -101,12 +103,12 @@ static int create_native_symlink(const unsigned int xid, struct inode *inode,\n \t\t\tcifs_dbg(VFS,\n \t\t\t\t \"absolute symlink '%s' cannot be converted to NT format \"\n \t\t\t\t \"because it is outside of symlinkroot='%s'\\n\",\n-\t\t\t\t symname, cifs_sb->ctx->symlinkroot);\n+\t\t\t\t symname, symroot);\n \t\t\trc = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n-\t\tlen = strlen(cifs_sb->ctx->symlinkroot);\n-\t\tif (cifs_sb->ctx->symlinkroot[len-1] != '/')\n+\t\tlen = strlen(symroot);\n+\t\tif (symroot[len - 1] != '/')\n \t\t\tlen++;\n \t\tif (symname[len] >= 'a' && symname[len] <= 'z' &&\n \t\t    (symname[len+1] == '/' || symname[len+1] == '\\0')) {\n@@ -782,6 +784,7 @@ int smb2_parse_native_symlink(char **target, const char *buf, unsigned int len,\n \t\t\t      const char *full_path,\n \t\t\t      struct cifs_sb_info *cifs_sb)\n {\n+\tconst char *symroot = cifs_sb->ctx->symlinkroot;\n \tchar sep = CIFS_DIR_SEP(cifs_sb);\n \tchar *linux_target = NULL;\n \tchar *smb_target = NULL;\n@@ -815,7 +818,8 @@ int smb2_parse_native_symlink(char **target, const char *buf, unsigned int len,\n \t\tgoto out;\n \t}\n \n-\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) && !relative) {\n+\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) &&\n+\t    symroot && !relative) {\n \t\t/*\n \t\t * This is an absolute symlink from the server which does not\n \t\t * support POSIX paths, so the symlink is in NT-style path.\n@@ -907,15 +911,15 @@ int smb2_parse_native_symlink(char **target, const char *buf, unsigned int len,\n \t\t}\n \n \t\tabs_path_len = strlen(abs_path)+1;\n-\t\tsymlinkroot_len = strlen(cifs_sb->ctx->symlinkroot);\n-\t\tif (cifs_sb->ctx->symlinkroot[symlinkroot_len-1] == '/')\n+\t\tsymlinkroot_len = strlen(symroot);\n+\t\tif (symroot[symlinkroot_len - 1] == '/')\n \t\t\tsymlinkroot_len--;\n \t\tlinux_target = kmalloc(symlinkroot_len + 1 + abs_path_len, GFP_KERNEL);\n \t\tif (!linux_target) {\n \t\t\trc = -ENOMEM;\n \t\t\tgoto out;\n \t\t}\n-\t\tmemcpy(linux_target, cifs_sb->ctx->symlinkroot, symlinkroot_len);\n+\t\tmemcpy(linux_target, symroot, symlinkroot_len);\n \t\tlinux_target[symlinkroot_len] = '/';\n \t\tmemcpy(linux_target + symlinkroot_len + 1, abs_path, abs_path_len);\n \t} else if (smb_target[0] == sep && relative) {\ndiff --git a/fs/smb/client/smb2pdu.c b/fs/smb/client/smb2pdu.c\nindex 7f6186c2e60d..2df93a75e3b8 100644\n--- a/fs/smb/client/smb2pdu.c\n+++ b/fs/smb/client/smb2pdu.c\n@@ -424,9 +424,9 @@ smb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon,\n \t\tfree_xid(xid);\n \t\tses->flags &= ~CIFS_SES_FLAGS_PENDING_QUERY_INTERFACES;\n \n-\t\t/* regardless of rc value, setup polling */\n-\t\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n-\t\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n+\t\tif (!tcon->ipc && !tcon->dummy)\n+\t\t\tqueue_delayed_work(cifsiod_wq, &tcon->query_interfaces,\n+\t\t\t\t\t   (SMB_INTERFACE_POLL_INTERVAL * HZ));\n \n \t\tmutex_unlock(&ses->session_mutex);\n \n@@ -4229,10 +4229,8 @@ void smb2_reconnect_server(struct work_struct *work)\n \t\t}\n \t\tgoto done;\n \t}\n-\n \ttcon->status = TID_GOOD;\n-\ttcon->retry = false;\n-\ttcon->need_reconnect = false;\n+\ttcon->dummy = true;\n \n \t/* now reconnect sessions for necessary channels */\n \tlist_for_each_entry_safe(ses, ses2, &tmp_ses_list, rlist) {",
    "stats": {
      "insertions": 39,
      "deletions": 36,
      "files": 8
    }
  },
  {
    "sha": "fd860cd78146605eeeeee3ac264ca166cc9fa943",
    "message": "Merge tag 'i2c-for-6.16-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux\n\nPull i2c fixes from Wolfram Sang:\n\n - designware: initialise msg_write_idx during transfer\n\n - microchip: check return value from core xfer call\n\n - realtek: add 'reg' property constraint to the device tree\n\n* tag 'i2c-for-6.16-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux:\n  dt-bindings: i2c: realtek,rtl9301: Fix missing 'reg' constraint\n  i2c: microchip-core: re-fix fake detections w/ i2cdetect\n  i2c/designware: Fix an initialization issue",
    "author": "Linus Torvalds",
    "date": "2025-07-05T12:54:24-07:00",
    "files_changed": [
      "drivers/i2c/busses/i2c-designware-master.c",
      "drivers/i2c/busses/i2c-microchip-corei2c.c"
    ],
    "diff": "diff --git a/Documentation/devicetree/bindings/i2c/realtek,rtl9301-i2c.yaml b/Documentation/devicetree/bindings/i2c/realtek,rtl9301-i2c.yaml\nindex eddfd329c67b..69ac5db8b914 100644\n--- a/Documentation/devicetree/bindings/i2c/realtek,rtl9301-i2c.yaml\n+++ b/Documentation/devicetree/bindings/i2c/realtek,rtl9301-i2c.yaml\n@@ -26,7 +26,8 @@ properties:\n       - const: realtek,rtl9301-i2c\n \n   reg:\n-    description: Register offset and size this I2C controller.\n+    items:\n+      - description: Register offset and size this I2C controller.\n \n   \"#address-cells\":\n     const: 1\ndiff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c\nindex 9d7d9e47564a..cbd88ffa5610 100644\n--- a/drivers/i2c/busses/i2c-designware-master.c\n+++ b/drivers/i2c/busses/i2c-designware-master.c\n@@ -363,6 +363,7 @@ static int amd_i2c_dw_xfer_quirk(struct i2c_adapter *adap, struct i2c_msg *msgs,\n \n \tdev->msgs = msgs;\n \tdev->msgs_num = num_msgs;\n+\tdev->msg_write_idx = 0;\n \ti2c_dw_xfer_init(dev);\n \n \t/* Initiate messages read/write transaction */\ndiff --git a/drivers/i2c/busses/i2c-microchip-corei2c.c b/drivers/i2c/busses/i2c-microchip-corei2c.c\nindex f173bda1c98c..c8599733633e 100644\n--- a/drivers/i2c/busses/i2c-microchip-corei2c.c\n+++ b/drivers/i2c/busses/i2c-microchip-corei2c.c\n@@ -435,6 +435,7 @@ static int mchp_corei2c_smbus_xfer(struct i2c_adapter *adap, u16 addr, unsigned\n \tu8 tx_buf[I2C_SMBUS_BLOCK_MAX + 2];\n \tu8 rx_buf[I2C_SMBUS_BLOCK_MAX + 1];\n \tint num_msgs = 1;\n+\tint ret;\n \n \tmsgs[CORE_I2C_SMBUS_MSG_WR].addr = addr;\n \tmsgs[CORE_I2C_SMBUS_MSG_WR].flags = 0;\n@@ -505,7 +506,10 @@ static int mchp_corei2c_smbus_xfer(struct i2c_adapter *adap, u16 addr, unsigned\n \t\treturn -EOPNOTSUPP;\n \t}\n \n-\tmchp_corei2c_xfer(&idev->adapter, msgs, num_msgs);\n+\tret = mchp_corei2c_xfer(&idev->adapter, msgs, num_msgs);\n+\tif (ret < 0)\n+\t\treturn ret;\n+\n \tif (read_write == I2C_SMBUS_WRITE || size <= I2C_SMBUS_BYTE_DATA)\n \t\treturn 0;\n ",
    "stats": {
      "insertions": 8,
      "deletions": 2,
      "files": 3
    }
  }
]
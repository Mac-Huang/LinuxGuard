[
  {
    "sha": "c772cd726eea6fe8fb81d2aeeacb18cecff73a7b",
    "message": "wifi: mt76: Move RCU section in mt7996_mcu_set_fixed_field()\n\nSince mt76_mcu_skb_send_msg() routine can't be executed in atomic context,\nmove RCU section in mt7996_mcu_set_fixed_field() and execute\nmt76_mcu_skb_send_msg() in non-atomic context. This is a preliminary\npatch to fix a 'sleep while atomic' issue in mt7996_mac_sta_rc_work().\n\nFixes: 0762bdd30279 (\"wifi: mt76: mt7996: rework mt7996_mac_sta_rc_work to support MLO\")\nSigned-off-by: Lorenzo Bianconi <lorenzo@kernel.org>\nLink: https://patch.msgid.link/20250605-mt7996-sleep-while-atomic-v1-2-d46d15f9203c@kernel.org\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
    "author": "Lorenzo Bianconi",
    "date": "2025-07-07T17:42:20+02:00",
    "files_changed": [
      "drivers/net/wireless/mediatek/mt76/mt7996/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h"
    ],
    "diff": "diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\nindex 0dbd4662bc84..7444bd374b50 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n@@ -2405,11 +2405,10 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)\n \t\t\t       IEEE80211_RC_BW_CHANGED))\n \t\t\tmt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n \t\t\t\t\t\t link_sta, link, msta_link,\n-\t\t\t\t\t\t true);\n+\t\t\t\t\t\t link_id, true);\n \n \t\tif (changed & IEEE80211_RC_SMPS_CHANGED)\n-\t\t\tmt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t   msta_link, NULL,\n+\t\t\tmt7996_mcu_set_fixed_field(dev, msta, NULL, link_id,\n \t\t\t\t\t\t   RATE_PARAM_MMPS_UPDATE);\n \n \t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/main.c b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\nindex 78ae9f5cb176..a096b5bab001 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n@@ -1114,7 +1114,8 @@ mt7996_mac_sta_event(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \n \t\t\terr = mt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n \t\t\t\t\t\t       link_sta, link,\n-\t\t\t\t\t\t       msta_link, false);\n+\t\t\t\t\t\t       msta_link, link_id,\n+\t\t\t\t\t\t       false);\n \t\t\tif (err)\n \t\t\t\treturn err;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex f0adc0b4b8b6..33c61e795b73 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n@@ -1905,22 +1905,35 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t     MCU_WM_UNI_CMD(RA), true);\n }\n \n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field)\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field)\n {\n-\tstruct sta_phy_uni *phy = data;\n+\tstruct mt7996_vif *mvif = msta->vif;\n+\tstruct mt7996_sta_link *msta_link;\n \tstruct sta_rec_ra_fixed_uni *ra;\n+\tstruct sta_phy_uni *phy = data;\n+\tstruct mt76_vif_link *mlink;\n \tstruct sk_buff *skb;\n+\tint err = -ENODEV;\n \tstruct tlv *tlv;\n \n-\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n+\trcu_read_lock();\n+\n+\tmlink = rcu_dereference(mvif->mt76.link[link_id]);\n+\tif (!mlink)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, mlink,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\terr = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA_UPDATE, sizeof(*ra));\n \tra = (struct sta_rec_ra_fixed_uni *)tlv;\n@@ -1935,27 +1948,45 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n \t\tif (phy)\n \t\t\tra->phy = *phy;\n \t\tbreak;\n-\tcase RATE_PARAM_MMPS_UPDATE:\n+\tcase RATE_PARAM_MMPS_UPDATE: {\n+\t\tstruct ieee80211_sta *sta = wcid_to_sta(&msta_link->wcid);\n+\t\tstruct ieee80211_link_sta *link_sta;\n+\n+\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\t\tif (!link_sta) {\n+\t\t\tdev_kfree_skb(skb);\n+\t\t\tgoto error_unlock;\n+\t\t}\n+\n \t\tra->mmps_mode = mt7996_mcu_get_mmps_mode(link_sta->smps_mode);\n \t\tbreak;\n+\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tra->field = cpu_to_le32(field);\n \n+\trcu_read_unlock();\n+\n \treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn err;\n }\n \n static int\n mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \t\t\t       struct ieee80211_link_sta *link_sta,\n \t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link)\n+\t\t\t       struct mt7996_sta_link *msta_link,\n+\t\t\t       u8 link_id)\n {\n \tstruct cfg80211_chan_def *chandef = &link->phy->mt76->chandef;\n \tstruct cfg80211_bitrate_mask *mask = &link->bitrate_mask;\n \tenum nl80211_band band = chandef->chan->band;\n+\tstruct mt7996_sta *msta = msta_link->sta;\n \tstruct sta_phy_uni phy = {};\n \tint ret, nrates = 0;\n \n@@ -1996,8 +2027,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \n \t/* fixed single rate */\n \tif (nrates == 1) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_MCS);\n \t\tif (ret)\n \t\t\treturn ret;\n@@ -2018,8 +2048,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \t\telse\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);\n \n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_GI);\n \t\tif (ret)\n \t\t\treturn ret;\n@@ -2027,8 +2056,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \n \t/* fixed HE_LTF */\n \tif (mask->control[band].he_ltf != GENMASK(7, 0)) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_HE_LTF);\n \t\tif (ret)\n \t\t\treturn ret;\n@@ -2150,7 +2178,8 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t     struct ieee80211_bss_conf *link_conf,\n \t\t\t     struct ieee80211_link_sta *link_sta,\n \t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed)\n+\t\t\t     struct mt7996_sta_link *msta_link,\n+\t\t\t     u8 link_id, bool changed)\n {\n \tstruct sk_buff *skb;\n \tint ret;\n@@ -2178,7 +2207,8 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \tif (ret)\n \t\treturn ret;\n \n-\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, link_sta, link, msta_link);\n+\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, link_sta, link, msta_link,\n+\t\t\t\t\t      link_id);\n }\n \n static int\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\nindex 1ad6bc046f7c..a529c2bae7cb 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n@@ -625,18 +625,16 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t     struct ieee80211_bss_conf *link_conf,\n \t\t\t     struct ieee80211_link_sta *link_sta,\n \t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed);\n+\t\t\t     struct mt7996_sta_link *msta_link,\n+\t\t\t     u8 link_id, bool changed);\n int mt7996_set_channel(struct mt76_phy *mphy);\n int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);\n int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t      struct ieee80211_bss_conf *link_conf);\n int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t   void *data, u16 version);\n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field);\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field);\n int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);\n int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len);\n int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num);",
    "stats": {
      "insertions": 57,
      "deletions": 29,
      "files": 4
    }
  },
  {
    "sha": "d133036a0b23d3ef781d067ccdea6bbfb381e0cf",
    "message": "drm/nouveau/gsp: fix potential leak of memory used during acpi init\n\nIf any of the ACPI calls fail, memory allocated for the input buffer\nwould be leaked.  Fix failure paths to free allocated memory.\n\nAlso add checks to ensure the allocations succeeded in the first place.\n\nReported-by: Danilo Krummrich <dakr@kernel.org>\nFixes: 176fdcbddfd2 (\"drm/nouveau/gsp/r535: add support for booting GSP-RM\")\nSigned-off-by: Ben Skeggs <bskeggs@nvidia.com>\nSigned-off-by: Danilo Krummrich <dakr@kernel.org>\nLink: https://lore.kernel.org/r/20250617040036.2932-1-bskeggs@nvidia.com",
    "author": "Ben Skeggs",
    "date": "2025-07-07T16:32:44+02:00",
    "files_changed": [
      "drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\nindex 23f80e167705..588cb4ab85cb 100644\n--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n@@ -719,7 +719,6 @@ r535_gsp_acpi_caps(acpi_handle handle, CAPS_METHOD_DATA *caps)\n \tunion acpi_object argv4 = {\n \t\t.buffer.type    = ACPI_TYPE_BUFFER,\n \t\t.buffer.length  = 4,\n-\t\t.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL),\n \t}, *obj;\n \n \tcaps->status = 0xffff;\n@@ -727,17 +726,22 @@ r535_gsp_acpi_caps(acpi_handle handle, CAPS_METHOD_DATA *caps)\n \tif (!acpi_check_dsm(handle, &NVOP_DSM_GUID, NVOP_DSM_REV, BIT_ULL(0x1a)))\n \t\treturn;\n \n+\targv4.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL);\n+\tif (!argv4.buffer.pointer)\n+\t\treturn;\n+\n \tobj = acpi_evaluate_dsm(handle, &NVOP_DSM_GUID, NVOP_DSM_REV, 0x1a, &argv4);\n \tif (!obj)\n-\t\treturn;\n+\t\tgoto done;\n \n \tif (WARN_ON(obj->type != ACPI_TYPE_BUFFER) ||\n \t    WARN_ON(obj->buffer.length != 4))\n-\t\treturn;\n+\t\tgoto done;\n \n \tcaps->status = 0;\n \tcaps->optimusCaps = *(u32 *)obj->buffer.pointer;\n \n+done:\n \tACPI_FREE(obj);\n \n \tkfree(argv4.buffer.pointer);\n@@ -754,24 +758,28 @@ r535_gsp_acpi_jt(acpi_handle handle, JT_METHOD_DATA *jt)\n \tunion acpi_object argv4 = {\n \t\t.buffer.type    = ACPI_TYPE_BUFFER,\n \t\t.buffer.length  = sizeof(caps),\n-\t\t.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL),\n \t}, *obj;\n \n \tjt->status = 0xffff;\n \n+\targv4.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL);\n+\tif (!argv4.buffer.pointer)\n+\t\treturn;\n+\n \tobj = acpi_evaluate_dsm(handle, &JT_DSM_GUID, JT_DSM_REV, 0x1, &argv4);\n \tif (!obj)\n-\t\treturn;\n+\t\tgoto done;\n \n \tif (WARN_ON(obj->type != ACPI_TYPE_BUFFER) ||\n \t    WARN_ON(obj->buffer.length != 4))\n-\t\treturn;\n+\t\tgoto done;\n \n \tjt->status = 0;\n \tjt->jtCaps = *(u32 *)obj->buffer.pointer;\n \tjt->jtRevId = (jt->jtCaps & 0xfff00000) >> 20;\n \tjt->bSBIOSCaps = 0;\n \n+done:\n \tACPI_FREE(obj);\n \n \tkfree(argv4.buffer.pointer);",
    "stats": {
      "insertions": 14,
      "deletions": 6,
      "files": 1
    }
  },
  {
    "sha": "85e323bdbe28d4638aaefd8d9192763874efe9b0",
    "message": "ALSA: hda/tas2781: Fix calibration data parser issue\n\nWe will copy calibration data from position behind to front.\nWe have created a variable (tmp_val) point on top of calibration data\nbuffer, and tmp_val[1] is max of node number in original calibration\ndata structure, it will be overwritten after first data copy,\nso can't be used as max node number check in for loop.\nSo we create a new variable to save max of node number (tmp_val[1]),\nused to check if max node number was reached in for loop.\nAnd a point need to be increased to point at calibration data in node.\nData saved position also need to be increased one byte.\n\nFixes: 4fe238513407 (\"ALSA: hda/tas2781: Move and unified the calibrated-data getting function for SPI and I2C into the tas2781_hda lib\")\nSigned-off-by: Baojun Xu <baojun.xu@ti.com>\nLink: https://patch.msgid.link/20250707090513.1462-1-baojun.xu@ti.com\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "author": "Baojun Xu",
    "date": "2025-07-07T11:23:28+02:00",
    "files_changed": [
      "sound/pci/hda/tas2781_hda.c"
    ],
    "diff": "diff --git a/sound/pci/hda/tas2781_hda.c b/sound/pci/hda/tas2781_hda.c\nindex 5f1d4b3e9688..34217ce9f28e 100644\n--- a/sound/pci/hda/tas2781_hda.c\n+++ b/sound/pci/hda/tas2781_hda.c\n@@ -44,7 +44,7 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\tTASDEVICE_REG(0, 0x13, 0x70),\n \t\tTASDEVICE_REG(0, 0x18, 0x7c),\n \t};\n-\tunsigned int crc, oft;\n+\tunsigned int crc, oft, node_num;\n \tunsigned char *buf;\n \tint i, j, k, l;\n \n@@ -80,8 +80,9 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\t\tdev_err(p->dev, \"%s: CRC error\\n\", __func__);\n \t\t\treturn;\n \t\t}\n+\t\tnode_num = tmp_val[1];\n \n-\t\tfor (j = 0, k = 0; j < tmp_val[1]; j++) {\n+\t\tfor (j = 0, k = 0; j < node_num; j++) {\n \t\t\toft = j * 6 + 3;\n \t\t\tif (tmp_val[oft] == TASDEV_UEFI_CALI_REG_ADDR_FLG) {\n \t\t\t\tfor (i = 0; i < TASDEV_CALIB_N; i++) {\n@@ -99,8 +100,9 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\t\t\t}\n \n \t\t\t\tdata[l] = k;\n+\t\t\t\toft++;\n \t\t\t\tfor (i = 0; i < TASDEV_CALIB_N * 4; i++)\n-\t\t\t\t\tdata[l + i] = data[4 * oft + i];\n+\t\t\t\t\tdata[l + i + 1] = data[4 * oft + i];\n \t\t\t\tk++;\n \t\t\t}\n \t\t}",
    "stats": {
      "insertions": 5,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "737bb912ebbe4571195c56eba557c4d7315b26fb",
    "message": "wifi: prevent A-MSDU attacks in mesh networks\n\nThis patch is a mitigation to prevent the A-MSDU spoofing vulnerability\nfor mesh networks. The initial update to the IEEE 802.11 standard, in\nresponse to the FragAttacks, missed this case (CVE-2025-27558). It can\nbe considered a variant of CVE-2020-24588 but for mesh networks.\n\nThis patch tries to detect if a standard MSDU was turned into an A-MSDU\nby an adversary. This is done by parsing a received A-MSDU as a standard\nMSDU, calculating the length of the Mesh Control header, and seeing if\nthe 6 bytes after this header equal the start of an rfc1042 header. If\nequal, this is a strong indication of an ongoing attack attempt.\n\nThis defense was tested with mac80211_hwsim against a mesh network that\nuses an empty Mesh Address Extension field, i.e., when four addresses\nare used, and when using a 12-byte Mesh Address Extension field, i.e.,\nwhen six addresses are used. Functionality of normal MSDUs and A-MSDUs\nwas also tested, and confirmed working, when using both an empty and\n12-byte Mesh Address Extension field.\n\nIt was also tested with mac80211_hwsim that A-MSDU attacks in non-mesh\nnetworks keep being detected and prevented.\n\nNote that the vulnerability being patched, and the defense being\nimplemented, was also discussed in the following paper and in the\nfollowing IEEE 802.11 presentation:\n\nhttps://papers.mathyvanhoef.com/wisec2025.pdf\nhttps://mentor.ieee.org/802.11/dcn/25/11-25-0949-00-000m-a-msdu-mesh-spoof-protection.docx\n\nCc: stable@vger.kernel.org\nSigned-off-by: Mathy Vanhoef <Mathy.Vanhoef@kuleuven.be>\nLink: https://patch.msgid.link/20250616004635.224344-1-Mathy.Vanhoef@kuleuven.be\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "author": "Mathy Vanhoef",
    "date": "2025-07-07T10:54:13+02:00",
    "files_changed": [
      "net/wireless/util.c"
    ],
    "diff": "diff --git a/net/wireless/util.c b/net/wireless/util.c\nindex ed868c0f7ca8..1ad5a6bdfd75 100644\n--- a/net/wireless/util.c\n+++ b/net/wireless/util.c\n@@ -820,6 +820,52 @@ bool ieee80211_is_valid_amsdu(struct sk_buff *skb, u8 mesh_hdr)\n }\n EXPORT_SYMBOL(ieee80211_is_valid_amsdu);\n \n+\n+/*\n+ * Detects if an MSDU frame was maliciously converted into an A-MSDU\n+ * frame by an adversary. This is done by parsing the received frame\n+ * as if it were a regular MSDU, even though the A-MSDU flag is set.\n+ *\n+ * For non-mesh interfaces, detection involves checking whether the\n+ * payload, when interpreted as an MSDU, begins with a valid RFC1042\n+ * header. This is done by comparing the A-MSDU subheader's destination\n+ * address to the start of the RFC1042 header.\n+ *\n+ * For mesh interfaces, the MSDU includes a 6-byte Mesh Control field\n+ * and an optional variable-length Mesh Address Extension field before\n+ * the RFC1042 header. The position of the RFC1042 header must therefore\n+ * be calculated based on the mesh header length.\n+ *\n+ * Since this function intentionally parses an A-MSDU frame as an MSDU,\n+ * it only assumes that the A-MSDU subframe header is present, and\n+ * beyond this it performs its own bounds checks under the assumption\n+ * that the frame is instead parsed as a non-aggregated MSDU.\n+ */\n+static bool\n+is_amsdu_aggregation_attack(struct ethhdr *eth, struct sk_buff *skb,\n+\t\t\t    enum nl80211_iftype iftype)\n+{\n+\tint offset;\n+\n+\t/* Non-mesh case can be directly compared */\n+\tif (iftype != NL80211_IFTYPE_MESH_POINT)\n+\t\treturn ether_addr_equal(eth->h_dest, rfc1042_header);\n+\n+\toffset = __ieee80211_get_mesh_hdrlen(eth->h_dest[0]);\n+\tif (offset == 6) {\n+\t\t/* Mesh case with empty address extension field */\n+\t\treturn ether_addr_equal(eth->h_source, rfc1042_header);\n+\t} else if (offset + ETH_ALEN <= skb->len) {\n+\t\t/* Mesh case with non-empty address extension field */\n+\t\tu8 temp[ETH_ALEN];\n+\n+\t\tskb_copy_bits(skb, offset, temp, ETH_ALEN);\n+\t\treturn ether_addr_equal(temp, rfc1042_header);\n+\t}\n+\n+\treturn false;\n+}\n+\n void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n \t\t\t      const unsigned int extra_headroom,\n@@ -861,8 +907,10 @@ void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t/* the last MSDU has no padding */\n \t\tif (subframe_len > remaining)\n \t\t\tgoto purge;\n-\t\t/* mitigate A-MSDU aggregation injection attacks */\n-\t\tif (ether_addr_equal(hdr.eth.h_dest, rfc1042_header))\n+\t\t/* mitigate A-MSDU aggregation injection attacks, to be\n+\t\t * checked when processing first subframe (offset == 0).\n+\t\t */\n+\t\tif (offset == 0 && is_amsdu_aggregation_attack(&hdr.eth, skb, iftype))\n \t\t\tgoto purge;\n \n \t\toffset += sizeof(struct ethhdr);",
    "stats": {
      "insertions": 50,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "c5fd399a24c8e2865524361f7dc4d4a6899be4f4",
    "message": "wifi: mac80211: correctly identify S1G short beacon\n\nmac80211 identifies a short beacon by the presence of the next\nTBTT field, however the standard actually doesn't explicitly state that\nthe next TBTT can't be in a long beacon or even that it is required in\na short beacon - and as a result this validation does not work for all\nvendor implementations.\n\nThe standard explicitly states that an S1G long beacon shall contain\nthe S1G beacon compatibility element as the first element in a beacon\ntransmitted at a TBTT that is not a TSBTT (Target Short Beacon\nTransmission Time) as per IEEE80211-2024 11.1.3.10.1. This is validated\nby 9.3.4.3 Table 9-76 which states that the S1G beacon compatibility\nelement is only allowed in the full set and is not allowed in the\nminimum set of elements permitted for use within short beacons.\n\nCorrectly identify short beacons by the lack of an S1G beacon\ncompatibility element as the first element in an S1G beacon frame.\n\nFixes: 9eaffe5078ca (\"cfg80211: convert S1G beacon to scan results\")\nSigned-off-by: Simon Wadsworth <simon@morsemicro.com>\nSigned-off-by: Lachlan Hodges <lachlan.hodges@morsemicro.com>\nLink: https://patch.msgid.link/20250701075541.162619-1-lachlan.hodges@morsemicro.com\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "author": "Lachlan Hodges",
    "date": "2025-07-07T10:42:15+02:00",
    "files_changed": [
      "include/linux/ieee80211.h",
      "net/mac80211/mlme.c"
    ],
    "diff": "diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h\nindex 22f39e5e2ff1..996be3c2cff0 100644\n--- a/include/linux/ieee80211.h\n+++ b/include/linux/ieee80211.h\n@@ -662,18 +662,6 @@ static inline bool ieee80211_s1g_has_cssid(__le16 fc)\n \t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_CSSID));\n }\n \n-/**\n- * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n- * @fc: frame control bytes in little-endian byteorder\n- * Return: whether or not the frame is an S1G short beacon,\n- *\ti.e. it is an S1G beacon with 'next TBTT' flag set\n- */\n-static inline bool ieee80211_is_s1g_short_beacon(__le16 fc)\n-{\n-\treturn ieee80211_is_s1g_beacon(fc) &&\n-\t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_NEXT_TBTT));\n-}\n-\n /**\n  * ieee80211_is_atim - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ATIM\n  * @fc: frame control bytes in little-endian byteorder\n@@ -4901,6 +4889,39 @@ static inline bool ieee80211_is_ftm(struct sk_buff *skb)\n \treturn false;\n }\n \n+/**\n+ * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n+ * @fc: frame control bytes in little-endian byteorder\n+ * @variable: pointer to the beacon frame elements\n+ * @variable_len: length of the frame elements\n+ * Return: whether or not the frame is an S1G short beacon. As per\n+ *\tIEEE80211-2024 11.1.3.10.1, The S1G beacon compatibility element shall\n+ *\talways be present as the first element in beacon frames generated at a\n+ *\tTBTT (Target Beacon Transmission Time), so any frame not containing\n+ *\tthis element must have been generated at a TSBTT (Target Short Beacon\n+ *\tTransmission Time) that is not a TBTT. Additionally, short beacons are\n+ *\tprohibited from containing the S1G beacon compatibility element as per\n+ *\tIEEE80211-2024 9.3.4.3 Table 9-76, so if we have an S1G beacon with\n+ *\teither no elements or the first element is not the beacon compatibility\n+ *\telement, we have a short beacon.\n+ */\n+static inline bool ieee80211_is_s1g_short_beacon(__le16 fc, const u8 *variable,\n+\t\t\t\t\t\t size_t variable_len)\n+{\n+\tif (!ieee80211_is_s1g_beacon(fc))\n+\t\treturn false;\n+\n+\t/*\n+\t * If the frame does not contain at least 1 element (this is perfectly\n+\t * valid in a short beacon) and is an S1G beacon, we have a short\n+\t * beacon.\n+\t */\n+\tif (variable_len < 2)\n+\t\treturn true;\n+\n+\treturn variable[0] != WLAN_EID_S1G_BCN_COMPAT;\n+}\n+\n struct element {\n \tu8 id;\n \tu8 datalen;\ndiff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c\nindex 2d46d4af60d7..7ddb8e77b4c7 100644\n--- a/net/mac80211/mlme.c\n+++ b/net/mac80211/mlme.c\n@@ -7195,6 +7195,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \tstruct ieee80211_bss_conf *bss_conf = link->conf;\n \tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n \tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n+\tstruct ieee80211_ext *ext = NULL;\n \tsize_t baselen;\n \tstruct ieee802_11_elems *elems;\n \tstruct ieee80211_local *local = sdata->local;\n@@ -7220,7 +7221,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t/* Process beacon from the current BSS */\n \tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n \tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n-\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n+\t\text = (void *)mgmt;\n \t\tvariable = ext->u.s1g_beacon.variable +\n \t\t\t   ieee80211_s1g_optional_len(ext->frame_control);\n \t}\n@@ -7407,7 +7408,9 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t}\n \n \tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n-\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n+\t    (ext && ieee80211_is_s1g_short_beacon(ext->frame_control,\n+\t\t\t\t\t\t  parse_params.start,\n+\t\t\t\t\t\t  parse_params.len)))\n \t\tgoto free;\n \tlink->u.mgd.beacon_crc = ncrc;\n \tlink->u.mgd.beacon_crc_valid = true;",
    "stats": {
      "insertions": 38,
      "deletions": 14,
      "files": 2
    }
  }
]
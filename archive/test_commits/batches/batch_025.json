[
  {
    "sha": "7da6c155a67d42a0c1e4e22bd3f492fabcb14f2c",
    "message": "drm/i915/dsi: Fix NULL pointer deref in vlv_dphy_param_init()\n\nCommit 77ba0b856225 (\"drm/i915/dsi: convert vlv_dsi.[ch] to struct\nintel_display\") added a to_intel_display(connector) call to\nvlv_dphy_param_init() but when vlv_dphy_param_init() gets called\nthe connector object has not been initialized yet, so this leads\nto a NULL pointer deref:\n\n BUG: kernel NULL pointer dereference, address: 000000000000000c\n ...\n Hardware name: ASUSTeK COMPUTER INC. T100TA/T100TA, BIOS T100TA.314 08/13/2015\n RIP: 0010:vlv_dsi_init+0x4e6/0x1600 [i915]\n ...\n Call Trace:\n  <TASK>\n  ? intel_step_name+0x4be8/0x5c30 [i915]\n  intel_setup_outputs+0x2d6/0xbd0 [i915]\n  intel_display_driver_probe_nogem+0x13f/0x220 [i915]\n  i915_driver_probe+0x3d9/0xaf0 [i915]\n\nUse to_intel_display(&intel_dsi->base) instead to fix this.\n\nFixes: 77ba0b856225 (\"drm/i915/dsi: convert vlv_dsi.[ch] to struct intel_display\")\nSigned-off-by: Hans de Goede <hansg@kernel.org>\nReviewed-by: Jani Nikula <jani.nikula@intel.com>\nLink: https://lore.kernel.org/r/20250626143317.101706-1-hansg@kernel.org\nSigned-off-by: Jani Nikula <jani.nikula@intel.com>\n(cherry picked from commit 0dc6bfb50a5d0759e726cd36a3d3b7529fd2a627)\nSigned-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>",
    "author": "Hans de Goede",
    "date": "2025-06-30T08:12:36+03:00",
    "files_changed": [
      "drivers/gpu/drm/i915/display/vlv_dsi.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/i915/display/vlv_dsi.c b/drivers/gpu/drm/i915/display/vlv_dsi.c\nindex 21c1e10caf68..2007bb9d974d 100644\n--- a/drivers/gpu/drm/i915/display/vlv_dsi.c\n+++ b/drivers/gpu/drm/i915/display/vlv_dsi.c\n@@ -1589,8 +1589,8 @@ static void vlv_dsi_add_properties(struct intel_connector *connector)\n \n static void vlv_dphy_param_init(struct intel_dsi *intel_dsi)\n {\n+\tstruct intel_display *display = to_intel_display(&intel_dsi->base);\n \tstruct intel_connector *connector = intel_dsi->attached_connector;\n-\tstruct intel_display *display = to_intel_display(connector);\n \tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n \tu32 tlpx_ns, extra_byte_count, tlpx_ui;\n \tu32 ui_num, ui_den;",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "caa7c7a76b78ce41d347003f84975125383e6b59",
    "message": "drm/i915/selftests: Change mock_request() to return error pointers\n\nThere was an error pointer vs NULL bug in __igt_breadcrumbs_smoketest().\nThe __mock_request_alloc() function implements the\nsmoketest->request_alloc() function pointer.  It was supposed to return\nerror pointers, but it propogates the NULL return from mock_request()\nso in the event of a failure, it would lead to a NULL pointer\ndereference.\n\nTo fix this, change the mock_request() function to return error pointers\nand update all the callers to expect that.\n\nFixes: 52c0fdb25c7c (\"drm/i915: Replace global breadcrumbs with per-context interrupt tracking\")\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\nReviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>\nLink: https://lore.kernel.org/r/685c1417.050a0220.696f5.5c05@mx.google.com\nSigned-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>\n(cherry picked from commit 778fa8ad5f0f23397d045c7ebca048ce8def1c43)\nSigned-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>",
    "author": "Dan Carpenter",
    "date": "2025-06-30T08:12:33+03:00",
    "files_changed": [
      "drivers/gpu/drm/i915/selftests/i915_request.c",
      "drivers/gpu/drm/i915/selftests/mock_request.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/i915/selftests/i915_request.c b/drivers/gpu/drm/i915/selftests/i915_request.c\nindex 88870844b5bd..2fb7a9e7efec 100644\n--- a/drivers/gpu/drm/i915/selftests/i915_request.c\n+++ b/drivers/gpu/drm/i915/selftests/i915_request.c\n@@ -73,8 +73,8 @@ static int igt_add_request(void *arg)\n \t/* Basic preliminary test to create a request and let it loose! */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, HZ / 10);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_add(request);\n \n@@ -91,8 +91,8 @@ static int igt_wait_request(void *arg)\n \t/* Submit a request, then wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_get(request);\n \n@@ -160,8 +160,8 @@ static int igt_fence_wait(void *arg)\n \t/* Submit a request, treat it as a fence and wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \tif (dma_fence_wait_timeout(&request->fence, false, T) != -ETIME) {\n \t\tpr_err(\"fence wait success before submit (expected timeout)!\\n\");\n@@ -219,8 +219,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \trequest = mock_request(ce, 2 * HZ);\n \tintel_context_put(ce);\n-\tif (!request) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(request)) {\n+\t\terr = PTR_ERR(request);\n \t\tgoto err_context_0;\n \t}\n \n@@ -237,8 +237,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \tvip = mock_request(ce, 0);\n \tintel_context_put(ce);\n-\tif (!vip) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(vip)) {\n+\t\terr = PTR_ERR(vip);\n \t\tgoto err_context_1;\n \t}\n \ndiff --git a/drivers/gpu/drm/i915/selftests/mock_request.c b/drivers/gpu/drm/i915/selftests/mock_request.c\nindex 09f747228dff..1b0cf073e964 100644\n--- a/drivers/gpu/drm/i915/selftests/mock_request.c\n+++ b/drivers/gpu/drm/i915/selftests/mock_request.c\n@@ -35,7 +35,7 @@ mock_request(struct intel_context *ce, unsigned long delay)\n \t/* NB the i915->requests slab cache is enlarged to fit mock_request */\n \trequest = intel_context_create_request(ce);\n \tif (IS_ERR(request))\n-\t\treturn NULL;\n+\t\treturn request;\n \n \trequest->mock.delay = delay;\n \treturn request;",
    "stats": {
      "insertions": 11,
      "deletions": 11,
      "files": 2
    }
  },
  {
    "sha": "fa60c094c19b97e103d653f528f8d9c178b6a5f5",
    "message": "spi: spi-fsl-dspi: Clear completion counter before initiating transfer\n\nIn target mode, extra interrupts can be received between the end of a\ntransfer and halting the module if the host continues sending more data.\nIf the interrupt from this occurs after the reinit_completion() then the\ncompletion counter is left at a non-zero value. The next unrelated\ntransfer initiated by userspace will then complete immediately without\nwaiting for the interrupt or writing to the RX buffer.\n\nFix it by resetting the counter before the transfer so that lingering\nvalues are cleared. This is done after clearing the FIFOs and the\nstatus register but before the transfer is initiated, so no interrupts\nshould be received at this point resulting in other race conditions.\n\nFixes: 4f5ee75ea171 (\"spi: spi-fsl-dspi: Replace interruptible wait queue with a simple completion\")\nSigned-off-by: James Clark <james.clark@linaro.org>\nReviewed-by: Frank Li <Frank.Li@nxp.com>\nLink: https://patch.msgid.link/20250627-james-nxp-spi-dma-v4-1-178dba20c120@linaro.org\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "James Clark",
    "date": "2025-06-29T22:10:53+01:00",
    "files_changed": [
      "drivers/spi/spi-fsl-dspi.c"
    ],
    "diff": "diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c\nindex 863781ba6c16..0dcd49114095 100644\n--- a/drivers/spi/spi-fsl-dspi.c\n+++ b/drivers/spi/spi-fsl-dspi.c\n@@ -983,11 +983,20 @@ static int dspi_transfer_one_message(struct spi_controller *ctlr,\n \t\tif (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {\n \t\t\tstatus = dspi_dma_xfer(dspi);\n \t\t} else {\n+\t\t\t/*\n+\t\t\t * Reinitialize the completion before transferring data\n+\t\t\t * to avoid the case where it might remain in the done\n+\t\t\t * state due to a spurious interrupt from a previous\n+\t\t\t * transfer. This could falsely signal that the current\n+\t\t\t * transfer has completed.\n+\t\t\t */\n+\t\t\tif (dspi->irq)\n+\t\t\t\treinit_completion(&dspi->xfer_done);\n+\n \t\t\tdspi_fifo_write(dspi);\n \n \t\t\tif (dspi->irq) {\n \t\t\t\twait_for_completion(&dspi->xfer_done);\n-\t\t\t\treinit_completion(&dspi->xfer_done);\n \t\t\t} else {\n \t\t\t\tdo {\n \t\t\t\t\tstatus = dspi_poll(dspi);",
    "stats": {
      "insertions": 10,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "d85d0380292a7e618915069c3579ae23c7c80339",
    "message": "spi: spi-qpic-snand: reallocate BAM transactions\n\nUsing the mtd_nandbiterrs module for testing the driver occasionally\nresults in weird things like below.\n\n1. swiotlb mapping fails with the following message:\n\n  [   85.926216] qcom_snand 79b0000.spi: swiotlb buffer is full (sz: 4294967294 bytes), total 512 (slots), used 0 (slots)\n  [   85.932937] qcom_snand 79b0000.spi: failure in mapping desc\n  [   87.999314] qcom_snand 79b0000.spi: failure to write raw page\n  [   87.999352] mtd_nandbiterrs: error: write_oob failed (-110)\n\n  Rebooting the board after this causes a panic due to a NULL pointer\n  dereference.\n\n2. If the swiotlb mapping does not fail, rebooting the board may result\n   in a different panic due to a bad spinlock magic:\n\n  [  256.104459] BUG: spinlock bad magic on CPU#3, procd/2241\n  [  256.104488] Unable to handle kernel paging request at virtual address ffffffff0000049b\n  ...\n\nInvestigating the issue revealed that these symptoms are results of\nmemory corruption which is caused by out of bounds access within the\ndriver.\n\nThe driver uses a dynamically allocated structure for BAM transactions,\nwhich structure must have enough space for all possible variations of\ndifferent flash operations initiated by the driver. The required space\nheavily depends on the actual number of 'codewords' which is calculated\nfrom the pagesize of the actual NAND chip.\n\nAlthough the qcom_nandc_alloc() function allocates memory for the BAM\ntransactions during probe, but since the actual number of 'codewords'\nis not yet know the allocation is done for one 'codeword' only.\n\nBecause of this, whenever the driver does a flash operation, and the\nnumber of the required transactions exceeds the size of the allocated\narrays the driver accesses memory out of the allocated range.\n\nTo avoid this, change the code to free the initially allocated BAM\ntransactions memory, and allocate a new one once the actual number of\n'codewords' required for a given NAND chip is known.\n\nFixes: 7304d1909080 (\"spi: spi-qpic: add driver for QCOM SPI NAND flash Interface\")\nReviewed-by: Md Sadre Alam <quic_mdalam@quicinc.com>\nSigned-off-by: Gabor Juhos <j4g8y7@gmail.com>\nLink: https://patch.msgid.link/20250618-qpic-snand-avoid-mem-corruption-v3-1-319c71296cda@gmail.com\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "Gabor Juhos",
    "date": "2025-06-29T22:10:46+01:00",
    "files_changed": [
      "drivers/spi/spi-qpic-snand.c"
    ],
    "diff": "diff --git a/drivers/spi/spi-qpic-snand.c b/drivers/spi/spi-qpic-snand.c\nindex 77d9cc65477a..f2e1a27b410d 100644\n--- a/drivers/spi/spi-qpic-snand.c\n+++ b/drivers/spi/spi-qpic-snand.c\n@@ -315,6 +315,22 @@ static int qcom_spi_ecc_init_ctx_pipelined(struct nand_device *nand)\n \n \tmtd_set_ooblayout(mtd, &qcom_spi_ooblayout);\n \n+\t/*\n+\t * Free the temporary BAM transaction allocated initially by\n+\t * qcom_nandc_alloc(), and allocate a new one based on the\n+\t * updated max_cwperpage value.\n+\t */\n+\tqcom_free_bam_transaction(snandc);\n+\n+\tsnandc->max_cwperpage = cwperpage;\n+\n+\tsnandc->bam_txn = qcom_alloc_bam_transaction(snandc);\n+\tif (!snandc->bam_txn) {\n+\t\tdev_err(snandc->dev, \"failed to allocate BAM transaction\\n\");\n+\t\tret = -ENOMEM;\n+\t\tgoto err_free_ecc_cfg;\n+\t}\n+\n \tecc_cfg->cfg0 = FIELD_PREP(CW_PER_PAGE_MASK, (cwperpage - 1)) |\n \t\t\tFIELD_PREP(UD_SIZE_BYTES_MASK, ecc_cfg->cw_data) |\n \t\t\tFIELD_PREP(DISABLE_STATUS_AFTER_WRITE, 1) |",
    "stats": {
      "insertions": 16,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "eeca209124bb694650026216d3e59cae02d91686",
    "message": "regulator: tps65219: Fix devm_kmalloc size allocation\n\nIn probe(), two arrays of structs are allocated with the devm_kmalloc()\nfunction, but the memory size of the allocations were given as the arrays'\nlength (pmic->common_irq_size for the first call and pmic->dev_irq_size for\nthe second devm_kmalloc call). The memory size should have been the total\nmemory needed.\n\nThis led to a heap overflow when the struct array was used. The issue was\nfirst discovered with the PocketBeagle2 and BeaglePlay. The common and\ndevice-specific structs are now allocated one at a time within the loop.\n\nFixes: 38c9f98db20a (\"regulator: tps65219: Add support for TPS65215 Regulator IRQs\")\nReported-by: Dhruva Gole <d-gole@ti.com>\nCloses: https://lore.kernel.org/all/20250619153526.297398-1-d-gole@ti.com/\nTested-by: Robert Nelson <robertcnelson@gmail.com>\nAcked-by: Andrew Davis <afd@ti.com>\nSigned-off-by: Shree Ramamoorthy <s-ramamoorthy@ti.com>\nReviewed-by: Nishanth Menon <nm@ti.com>\nLink: https://patch.msgid.link/20250620154541.2713036-1-s-ramamoorthy@ti.com\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "Shree Ramamoorthy",
    "date": "2025-06-29T22:10:41+01:00",
    "files_changed": [
      "drivers/regulator/tps65219-regulator.c"
    ],
    "diff": "diff --git a/drivers/regulator/tps65219-regulator.c b/drivers/regulator/tps65219-regulator.c\nindex b16b300d7f45..5e67fdc88f49 100644\n--- a/drivers/regulator/tps65219-regulator.c\n+++ b/drivers/regulator/tps65219-regulator.c\n@@ -436,46 +436,46 @@ static int tps65219_regulator_probe(struct platform_device *pdev)\n \t\t\t\t\t     pmic->rdesc[i].name);\n \t}\n \n-\tirq_data = devm_kmalloc(tps->dev, pmic->common_irq_size, GFP_KERNEL);\n-\tif (!irq_data)\n-\t\treturn -ENOMEM;\n-\n \tfor (i = 0; i < pmic->common_irq_size; ++i) {\n \t\tirq_type = &pmic->common_irq_types[i];\n \t\tirq = platform_get_irq_byname(pdev, irq_type->irq_name);\n \t\tif (irq < 0)\n \t\t\treturn -EINVAL;\n \n-\t\tirq_data[i].dev = tps->dev;\n-\t\tirq_data[i].type = irq_type;\n+\t\tirq_data = devm_kmalloc(tps->dev, sizeof(*irq_data), GFP_KERNEL);\n+\t\tif (!irq_data)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tirq_data->dev = tps->dev;\n+\t\tirq_data->type = irq_type;\n \t\terror = devm_request_threaded_irq(tps->dev, irq, NULL,\n \t\t\t\t\t\t  tps65219_regulator_irq_handler,\n \t\t\t\t\t\t  IRQF_ONESHOT,\n \t\t\t\t\t\t  irq_type->irq_name,\n-\t\t\t\t\t\t  &irq_data[i]);\n+\t\t\t\t\t\t  irq_data);\n \t\tif (error)\n \t\t\treturn dev_err_probe(tps->dev, PTR_ERR(rdev),\n \t\t\t\t\t     \"Failed to request %s IRQ %d: %d\\n\",\n \t\t\t\t\t     irq_type->irq_name, irq, error);\n \t}\n \n-\tirq_data = devm_kmalloc(tps->dev, pmic->dev_irq_size, GFP_KERNEL);\n-\tif (!irq_data)\n-\t\treturn -ENOMEM;\n-\n \tfor (i = 0; i < pmic->dev_irq_size; ++i) {\n \t\tirq_type = &pmic->irq_types[i];\n \t\tirq = platform_get_irq_byname(pdev, irq_type->irq_name);\n \t\tif (irq < 0)\n \t\t\treturn -EINVAL;\n \n-\t\tirq_data[i].dev = tps->dev;\n-\t\tirq_data[i].type = irq_type;\n+\t\tirq_data = devm_kmalloc(tps->dev, sizeof(*irq_data), GFP_KERNEL);\n+\t\tif (!irq_data)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tirq_data->dev = tps->dev;\n+\t\tirq_data->type = irq_type;\n \t\terror = devm_request_threaded_irq(tps->dev, irq, NULL,\n \t\t\t\t\t\t  tps65219_regulator_irq_handler,\n \t\t\t\t\t\t  IRQF_ONESHOT,\n \t\t\t\t\t\t  irq_type->irq_name,\n-\t\t\t\t\t\t  &irq_data[i]);\n+\t\t\t\t\t\t  irq_data);\n \t\tif (error)\n \t\t\treturn dev_err_probe(tps->dev, PTR_ERR(rdev),\n \t\t\t\t\t     \"Failed to request %s IRQ %d: %d\\n\",",
    "stats": {
      "insertions": 14,
      "deletions": 14,
      "files": 1
    }
  }
]
[
  {
    "sha": "226862f50a7a88e4e4de9abbf36c64d19acd6fd0",
    "message": "drm/v3d: Disable interrupts before resetting the GPU\n\nCurrently, an interrupt can be triggered during a GPU reset, which can\nlead to GPU hangs and NULL pointer dereference in an interrupt context\nas shown in the following trace:\n\n [  314.035040] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000c0\n [  314.043822] Mem abort info:\n [  314.046606]   ESR = 0x0000000096000005\n [  314.050347]   EC = 0x25: DABT (current EL), IL = 32 bits\n [  314.055651]   SET = 0, FnV = 0\n [  314.058695]   EA = 0, S1PTW = 0\n [  314.061826]   FSC = 0x05: level 1 translation fault\n [  314.066694] Data abort info:\n [  314.069564]   ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000\n [  314.075039]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n [  314.080080]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n [  314.085382] user pgtable: 4k pages, 39-bit VAs, pgdp=0000000102728000\n [  314.091814] [00000000000000c0] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000\n [  314.100511] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP\n [  314.106770] Modules linked in: v3d i2c_brcmstb vc4 snd_soc_hdmi_codec gpu_sched drm_shmem_helper drm_display_helper cec drm_dma_helper drm_kms_helper drm drm_panel_orientation_quirks snd_soc_core snd_compress snd_pcm_dmaengine snd_pcm snd_timer snd backlight\n [  314.129654] CPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.25+rpt-rpi-v8 #1  Debian 1:6.12.25-1+rpt1\n [  314.139388] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT)\n [  314.145211] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n [  314.152165] pc : v3d_irq+0xec/0x2e0 [v3d]\n [  314.156187] lr : v3d_irq+0xe0/0x2e0 [v3d]\n [  314.160198] sp : ffffffc080003ea0\n [  314.163502] x29: ffffffc080003ea0 x28: ffffffec1f184980 x27: 021202b000000000\n [  314.170633] x26: ffffffec1f17f630 x25: ffffff8101372000 x24: ffffffec1f17d9f0\n [  314.177764] x23: 000000000000002a x22: 000000000000002a x21: ffffff8103252000\n [  314.184895] x20: 0000000000000001 x19: 00000000deadbeef x18: 0000000000000000\n [  314.192026] x17: ffffff94e51d2000 x16: ffffffec1dac3cb0 x15: c306000000000000\n [  314.199156] x14: 0000000000000000 x13: b2fc982e03cc5168 x12: 0000000000000001\n [  314.206286] x11: ffffff8103f8bcc0 x10: ffffffec1f196868 x9 : ffffffec1dac3874\n [  314.213416] x8 : 0000000000000000 x7 : 0000000000042a3a x6 : ffffff810017a180\n [  314.220547] x5 : ffffffec1ebad400 x4 : ffffffec1ebad320 x3 : 00000000000bebeb\n [  314.227677] x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000\n [  314.234807] Call trace:\n [  314.237243]  v3d_irq+0xec/0x2e0 [v3d]\n [  314.240906]  __handle_irq_event_percpu+0x58/0x218\n [  314.245609]  handle_irq_event+0x54/0xb8\n [  314.249439]  handle_fasteoi_irq+0xac/0x240\n [  314.253527]  handle_irq_desc+0x48/0x68\n [  314.257269]  generic_handle_domain_irq+0x24/0x38\n [  314.261879]  gic_handle_irq+0x48/0xd8\n [  314.265533]  call_on_irq_stack+0x24/0x58\n [  314.269448]  do_interrupt_handler+0x88/0x98\n [  314.273624]  el1_interrupt+0x34/0x68\n [  314.277193]  el1h_64_irq_handler+0x18/0x28\n [  314.281281]  el1h_64_irq+0x64/0x68\n [  314.284673]  default_idle_call+0x3c/0x168\n [  314.288675]  do_idle+0x1fc/0x230\n [  314.291895]  cpu_startup_entry+0x3c/0x50\n [  314.295810]  rest_init+0xe4/0xf0\n [  314.299030]  start_kernel+0x5e8/0x790\n [  314.302684]  __primary_switched+0x80/0x90\n [  314.306691] Code: 940029eb 360ffc13 f9442ea0 52800001 (f9406017)\n [  314.312775] ---[ end trace 0000000000000000 ]---\n [  314.317384] Kernel panic - not syncing: Oops: Fatal exception in interrupt\n [  314.324249] SMP: stopping secondary CPUs\n [  314.328167] Kernel Offset: 0x2b9da00000 from 0xffffffc080000000\n [  314.334076] PHYS_OFFSET: 0x0\n [  314.336946] CPU features: 0x08,00002013,c0200000,0200421b\n [  314.342337] Memory Limit: none\n [  314.345382] ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---\n\nBefore resetting the GPU, it's necessary to disable all interrupts and\ndeal with any interrupt handler still in-flight. Otherwise, the GPU might\nreset with jobs still running, or yet, an interrupt could be handled\nduring the reset.\n\nCc: stable@vger.kernel.org\nFixes: 57692c94dcbe (\"drm/v3d: Introduce a new DRM driver for Broadcom V3D V3.x+\")\nReviewed-by: Juan A. Suarez <jasuarez@igalia.com>\nReviewed-by: Iago Toral Quiroga <itoral@igalia.com>\nLink: https://lore.kernel.org/r/20250628224243.47599-1-mcanal@igalia.com\nSigned-off-by: Maíra Canal <mcanal@igalia.com>",
    "author": "Maíra Canal",
    "date": "2025-07-02T19:08:11-03:00",
    "files_changed": [
      "drivers/gpu/drm/v3d/v3d_drv.h",
      "drivers/gpu/drm/v3d/v3d_gem.c",
      "drivers/gpu/drm/v3d/v3d_irq.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/v3d/v3d_drv.h b/drivers/gpu/drm/v3d/v3d_drv.h\nindex b51f0b648a08..411e47702f8a 100644\n--- a/drivers/gpu/drm/v3d/v3d_drv.h\n+++ b/drivers/gpu/drm/v3d/v3d_drv.h\n@@ -101,6 +101,12 @@ enum v3d_gen {\n \tV3D_GEN_71 = 71,\n };\n \n+enum v3d_irq {\n+\tV3D_CORE_IRQ,\n+\tV3D_HUB_IRQ,\n+\tV3D_MAX_IRQS,\n+};\n+\n struct v3d_dev {\n \tstruct drm_device drm;\n \n@@ -112,6 +118,8 @@ struct v3d_dev {\n \n \tbool single_irq_line;\n \n+\tint irq[V3D_MAX_IRQS];\n+\n \tstruct v3d_perfmon_info perfmon_info;\n \n \tvoid __iomem *hub_regs;\ndiff --git a/drivers/gpu/drm/v3d/v3d_gem.c b/drivers/gpu/drm/v3d/v3d_gem.c\nindex d7d16da78db3..37bf5eecdd2c 100644\n--- a/drivers/gpu/drm/v3d/v3d_gem.c\n+++ b/drivers/gpu/drm/v3d/v3d_gem.c\n@@ -134,6 +134,8 @@ v3d_reset(struct v3d_dev *v3d)\n \tif (false)\n \t\tv3d_idle_axi(v3d, 0);\n \n+\tv3d_irq_disable(v3d);\n+\n \tv3d_idle_gca(v3d);\n \tv3d_reset_sms(v3d);\n \tv3d_reset_v3d(v3d);\ndiff --git a/drivers/gpu/drm/v3d/v3d_irq.c b/drivers/gpu/drm/v3d/v3d_irq.c\nindex 2cca5d3a26a2..a515a301e480 100644\n--- a/drivers/gpu/drm/v3d/v3d_irq.c\n+++ b/drivers/gpu/drm/v3d/v3d_irq.c\n@@ -260,7 +260,7 @@ v3d_hub_irq(int irq, void *arg)\n int\n v3d_irq_init(struct v3d_dev *v3d)\n {\n-\tint irq1, ret, core;\n+\tint irq, ret, core;\n \n \tINIT_WORK(&v3d->overflow_mem_work, v3d_overflow_mem_work);\n \n@@ -271,17 +271,24 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));\n \tV3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS(v3d->ver));\n \n-\tirq1 = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n-\tif (irq1 == -EPROBE_DEFER)\n-\t\treturn irq1;\n-\tif (irq1 > 0) {\n-\t\tret = devm_request_irq(v3d->drm.dev, irq1,\n+\tirq = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n+\tif (irq == -EPROBE_DEFER)\n+\t\treturn irq;\n+\tif (irq > 0) {\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_core0\", v3d);\n \t\tif (ret)\n \t\t\tgoto fail;\n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_HUB_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_HUB_IRQ],\n \t\t\t\t       v3d_hub_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_hub\", v3d);\n \t\tif (ret)\n@@ -289,8 +296,12 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t} else {\n \t\tv3d->single_irq_line = true;\n \n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d\", v3d);\n \t\tif (ret)\n@@ -331,6 +342,12 @@ v3d_irq_disable(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~0);\n \tV3D_WRITE(V3D_HUB_INT_MSK_SET, ~0);\n \n+\t/* Finish any interrupt handler still in flight. */\n+\tfor (int i = 0; i < V3D_MAX_IRQS; i++) {\n+\t\tif (v3d->irq[i])\n+\t\t\tsynchronize_irq(v3d->irq[i]);\n+\t}\n+\n \t/* Clear any pending interrupts we might have left. */\n \tfor (core = 0; core < v3d->cores; core++)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));",
    "stats": {
      "insertions": 37,
      "deletions": 10,
      "files": 3
    }
  },
  {
    "sha": "c2a2ff6b4db55647575260bf2227b0e09d46addb",
    "message": "net: ipv4: fix stat increase when udp early demux drops the packet\n\nudp_v4_early_demux now returns drop reasons as it either returns 0 or\nip_mc_validate_source, which returns itself a drop reason. However its\nuse was not converted in ip_rcv_finish_core and the drop reason is\nignored, leading to potentially skipping increasing LINUX_MIB_IPRPFILTER\nif the drop reason is SKB_DROP_REASON_IP_RPFILTER.\n\nThis is a fix and we're not converting udp_v4_early_demux to explicitly\nreturn a drop reason to ease backports; this can be done as a follow-up.\n\nFixes: d46f827016d8 (\"net: ip: make ip_mc_validate_source() return drop reason\")\nCc: Menglong Dong <menglong8.dong@gmail.com>\nReported-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: Antoine Tenart <atenart@kernel.org>\nReviewed-by: Sabrina Dubroca <sd@queasysnail.net>\nLink: https://patch.msgid.link/20250701074935.144134-1-atenart@kernel.org\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Antoine Tenart",
    "date": "2025-07-02T14:46:44-07:00",
    "files_changed": [
      "net/ipv4/ip_input.c"
    ],
    "diff": "diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c\nindex 30a5e9460d00..5a49eb99e5c4 100644\n--- a/net/ipv4/ip_input.c\n+++ b/net/ipv4/ip_input.c\n@@ -319,8 +319,8 @@ static int ip_rcv_finish_core(struct net *net,\n \t\t\t      const struct sk_buff *hint)\n {\n \tconst struct iphdr *iph = ip_hdr(skb);\n-\tint err, drop_reason;\n \tstruct rtable *rt;\n+\tint drop_reason;\n \n \tif (ip_can_use_hint(skb, iph, hint)) {\n \t\tdrop_reason = ip_route_use_hint(skb, iph->daddr, iph->saddr,\n@@ -345,9 +345,10 @@ static int ip_rcv_finish_core(struct net *net,\n \t\t\tbreak;\n \t\tcase IPPROTO_UDP:\n \t\t\tif (READ_ONCE(net->ipv4.sysctl_udp_early_demux)) {\n-\t\t\t\terr = udp_v4_early_demux(skb);\n-\t\t\t\tif (unlikely(err))\n+\t\t\t\tdrop_reason = udp_v4_early_demux(skb);\n+\t\t\t\tif (unlikely(drop_reason))\n \t\t\t\t\tgoto drop_error;\n+\t\t\t\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n \n \t\t\t\t/* must reload iph, skb->head might have changed */\n \t\t\t\tiph = ip_hdr(skb);",
    "stats": {
      "insertions": 4,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "103406b38c600fec1fe375a77b27d87e314aea09",
    "message": "net/sched: Always pass notifications when child class becomes empty\n\nCertain classful qdiscs may invoke their classes' dequeue handler on an\nenqueue operation. This may unexpectedly empty the child qdisc and thus\nmake an in-flight class passive via qlen_notify(). Most qdiscs do not\nexpect such behaviour at this point in time and may re-activate the\nclass eventually anyways which will lead to a use-after-free.\n\nThe referenced fix commit attempted to fix this behavior for the HFSC\ncase by moving the backlog accounting around, though this turned out to\nbe incomplete since the parent's parent may run into the issue too.\nThe following reproducer demonstrates this use-after-free:\n\n    tc qdisc add dev lo root handle 1: drr\n    tc filter add dev lo parent 1: basic classid 1:1\n    tc class add dev lo parent 1: classid 1:1 drr\n    tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1\n    tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0\n    tc qdisc add dev lo parent 2:1 handle 3: netem\n    tc qdisc add dev lo parent 3:1 handle 4: blackhole\n\n    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888\n    tc class delete dev lo classid 1:1\n    echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888\n\nSince backlog accounting issues leading to a use-after-frees on stale\nclass pointers is a recurring pattern at this point, this patch takes\na different approach. Instead of trying to fix the accounting, the patch\nensures that qdisc_tree_reduce_backlog always calls qlen_notify when\nthe child qdisc is empty. This solves the problem because deletion of\nqdiscs always involves a call to qdisc_reset() and / or\nqdisc_purge_queue() which ultimately resets its qlen to 0 thus causing\nthe following qdisc_tree_reduce_backlog() to report to the parent. Note\nthat this may call qlen_notify on passive classes multiple times. This\nis not a problem after the recent patch series that made all the\nclassful qdiscs qlen_notify() handlers idempotent.\n\nFixes: 3f981138109f (\"sch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()\")\nSigned-off-by: Lion Ackermann <nnamrec@gmail.com>\nReviewed-by: Jamal Hadi Salim <jhs@mojatatu.com>\nAcked-by: Cong Wang <xiyou.wangcong@gmail.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\nLink: https://patch.msgid.link/d912cbd7-193b-4269-9857-525bee8bbb6a@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Lion Ackermann",
    "date": "2025-07-02T14:42:17-07:00",
    "files_changed": [
      "net/sched/sch_api.c"
    ],
    "diff": "diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c\nindex c5e3673aadbe..d8a33486c511 100644\n--- a/net/sched/sch_api.c\n+++ b/net/sched/sch_api.c\n@@ -780,15 +780,12 @@ static u32 qdisc_alloc_handle(struct net_device *dev)\n \n void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)\n {\n-\tbool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;\n \tconst struct Qdisc_class_ops *cops;\n \tunsigned long cl;\n \tu32 parentid;\n \tbool notify;\n \tint drops;\n \n-\tif (n == 0 && len == 0)\n-\t\treturn;\n \tdrops = max_t(int, n, 0);\n \trcu_read_lock();\n \twhile ((parentid = sch->parent)) {\n@@ -797,17 +794,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)\n \n \t\tif (sch->flags & TCQ_F_NOPARENT)\n \t\t\tbreak;\n-\t\t/* Notify parent qdisc only if child qdisc becomes empty.\n-\t\t *\n-\t\t * If child was empty even before update then backlog\n-\t\t * counter is screwed and we skip notification because\n-\t\t * parent class is already passive.\n-\t\t *\n-\t\t * If the original child was offloaded then it is allowed\n-\t\t * to be seem as empty, so the parent is notified anyway.\n-\t\t */\n-\t\tnotify = !sch->q.qlen && !WARN_ON_ONCE(!n &&\n-\t\t\t\t\t\t       !qdisc_is_offloaded);\n+\t\t/* Notify parent qdisc only if child qdisc becomes empty. */\n+\t\tnotify = !sch->q.qlen;\n \t\t/* TODO: perform the search on a per txq basis */\n \t\tsch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));\n \t\tif (sch == NULL) {\n@@ -816,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)\n \t\t}\n \t\tcops = sch->ops->cl_ops;\n \t\tif (notify && cops->qlen_notify) {\n+\t\t\t/* Note that qlen_notify must be idempotent as it may get called\n+\t\t\t * multiple times.\n+\t\t\t */\n \t\t\tcl = cops->find(sch, parentid);\n \t\t\tcops->qlen_notify(sch, cl);\n \t\t}",
    "stats": {
      "insertions": 5,
      "deletions": 14,
      "files": 1
    }
  },
  {
    "sha": "b4911fb0b060899e4eebca0151eb56deb86921ec",
    "message": "Merge tag 'mmc-v6.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc\n\nPull MMC fixes from Ulf Hansson:\n \"MMC core:\n   - Apply BROKEN_SD_DISCARD quirk earlier during init\n   - Silence some confusing error messages for SD UHS-II cards\n\n  MMC host:\n   - mtk-sd:\n       - Prevent memory corruption from DMA map failure\n       - Fix a pagefault in dma_unmap_sg() for not prepared data\n   - sdhci: Revert \"Disable SD card clock before changing parameters\"\n   - sdhci-of-k1: Fix error code in probe()\n   - sdhci-uhs2: Silence some confusing error messages for SD UHS-II cards\"\n\n* tag 'mmc-v6.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc:\n  mtk-sd: reset host->mrq on prepare_data() error\n  Revert \"mmc: sdhci: Disable SD card clock before changing parameters\"\n  mmc: sdhci-uhs2: Adjust some error messages and register dump for SD UHS-II card\n  mmc: sdhci: Add a helper function for dump register in dynamic debug mode\n  mmc: core: Adjust some error messages for SD UHS-II cards\n  mtk-sd: Prevent memory corruption from DMA map failure\n  mtk-sd: Fix a pagefault in dma_unmap_sg() for not prepared data\n  mmc: sdhci-of-k1: Fix error code in probe()\n  mmc: core: sd: Apply BROKEN_SD_DISCARD quirk earlier",
    "author": "Linus Torvalds",
    "date": "2025-07-02T09:34:57-07:00",
    "files_changed": [
      "drivers/mmc/core/quirks.h",
      "drivers/mmc/core/sd_uhs2.c",
      "drivers/mmc/host/mtk-sd.c",
      "drivers/mmc/host/sdhci-of-k1.c",
      "drivers/mmc/host/sdhci-uhs2.c",
      "drivers/mmc/host/sdhci.c",
      "drivers/mmc/host/sdhci.h"
    ],
    "diff": "diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h\nindex 7f893bafaa60..c417ed34c057 100644\n--- a/drivers/mmc/core/quirks.h\n+++ b/drivers/mmc/core/quirks.h\n@@ -44,6 +44,12 @@ static const struct mmc_fixup __maybe_unused mmc_sd_fixups[] = {\n \t\t   0, -1ull, SDIO_ANY_ID, SDIO_ANY_ID, add_quirk_sd,\n \t\t   MMC_QUIRK_NO_UHS_DDR50_TUNING, EXT_CSD_REV_ANY),\n \n+\t/*\n+\t * Some SD cards reports discard support while they don't\n+\t */\n+\tMMC_FIXUP(CID_NAME_ANY, CID_MANFID_SANDISK_SD, 0x5344, add_quirk_sd,\n+\t\t  MMC_QUIRK_BROKEN_SD_DISCARD),\n+\n \tEND_FIXUP\n };\n \n@@ -147,12 +153,6 @@ static const struct mmc_fixup __maybe_unused mmc_blk_fixups[] = {\n \tMMC_FIXUP(\"M62704\", CID_MANFID_KINGSTON, 0x0100, add_quirk_mmc,\n \t\t  MMC_QUIRK_TRIM_BROKEN),\n \n-\t/*\n-\t * Some SD cards reports discard support while they don't\n-\t */\n-\tMMC_FIXUP(CID_NAME_ANY, CID_MANFID_SANDISK_SD, 0x5344, add_quirk_sd,\n-\t\t  MMC_QUIRK_BROKEN_SD_DISCARD),\n-\n \tEND_FIXUP\n };\n \ndiff --git a/drivers/mmc/core/sd_uhs2.c b/drivers/mmc/core/sd_uhs2.c\nindex 1c31d0dfa961..de17d1611290 100644\n--- a/drivers/mmc/core/sd_uhs2.c\n+++ b/drivers/mmc/core/sd_uhs2.c\n@@ -91,8 +91,8 @@ static int sd_uhs2_phy_init(struct mmc_host *host)\n \n \terr = host->ops->uhs2_control(host, UHS2_PHY_INIT);\n \tif (err) {\n-\t\tpr_err(\"%s: failed to initial phy for UHS-II!\\n\",\n-\t\t       mmc_hostname(host));\n+\t\tpr_debug(\"%s: failed to initial phy for UHS-II!\\n\",\n+\t\t\t mmc_hostname(host));\n \t}\n \n \treturn err;\ndiff --git a/drivers/mmc/host/mtk-sd.c b/drivers/mmc/host/mtk-sd.c\nindex 31eb90536bce..d7020e06dd55 100644\n--- a/drivers/mmc/host/mtk-sd.c\n+++ b/drivers/mmc/host/mtk-sd.c\n@@ -846,12 +846,18 @@ static inline void msdc_dma_setup(struct msdc_host *host, struct msdc_dma *dma,\n static void msdc_prepare_data(struct msdc_host *host, struct mmc_data *data)\n {\n \tif (!(data->host_cookie & MSDC_PREPARE_FLAG)) {\n-\t\tdata->host_cookie |= MSDC_PREPARE_FLAG;\n \t\tdata->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,\n \t\t\t\t\t    mmc_get_dma_dir(data));\n+\t\tif (data->sg_count)\n+\t\t\tdata->host_cookie |= MSDC_PREPARE_FLAG;\n \t}\n }\n \n+static bool msdc_data_prepared(struct mmc_data *data)\n+{\n+\treturn data->host_cookie & MSDC_PREPARE_FLAG;\n+}\n+\n static void msdc_unprepare_data(struct msdc_host *host, struct mmc_data *data)\n {\n \tif (data->host_cookie & MSDC_ASYNC_FLAG)\n@@ -1483,8 +1489,19 @@ static void msdc_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)\n \tWARN_ON(!host->hsq_en && host->mrq);\n \thost->mrq = mrq;\n \n-\tif (mrq->data)\n+\tif (mrq->data) {\n \t\tmsdc_prepare_data(host, mrq->data);\n+\t\tif (!msdc_data_prepared(mrq->data)) {\n+\t\t\thost->mrq = NULL;\n+\t\t\t/*\n+\t\t\t * Failed to prepare DMA area, fail fast before\n+\t\t\t * starting any commands.\n+\t\t\t */\n+\t\t\tmrq->cmd->error = -ENOSPC;\n+\t\t\tmmc_request_done(mmc_from_priv(host), mrq);\n+\t\t\treturn;\n+\t\t}\n+\t}\n \n \t/* if SBC is required, we have HW option and SW option.\n \t * if HW option is enabled, and SBC does not have \"special\" flags,\ndiff --git a/drivers/mmc/host/sdhci-of-k1.c b/drivers/mmc/host/sdhci-of-k1.c\nindex 6880d3e9ab62..2e5da7c5834c 100644\n--- a/drivers/mmc/host/sdhci-of-k1.c\n+++ b/drivers/mmc/host/sdhci-of-k1.c\n@@ -276,7 +276,8 @@ static int spacemit_sdhci_probe(struct platform_device *pdev)\n \n \thost->mmc->caps |= MMC_CAP_NEED_RSP_BUSY;\n \n-\tif (spacemit_sdhci_get_clocks(dev, pltfm_host))\n+\tret = spacemit_sdhci_get_clocks(dev, pltfm_host);\n+\tif (ret)\n \t\tgoto err_pltfm;\n \n \tret = sdhci_add_host(host);\ndiff --git a/drivers/mmc/host/sdhci-uhs2.c b/drivers/mmc/host/sdhci-uhs2.c\nindex c53b64d50c0d..0efeb9d0c376 100644\n--- a/drivers/mmc/host/sdhci-uhs2.c\n+++ b/drivers/mmc/host/sdhci-uhs2.c\n@@ -99,8 +99,8 @@ void sdhci_uhs2_reset(struct sdhci_host *host, u16 mask)\n \t/* hw clears the bit when it's done */\n \tif (read_poll_timeout_atomic(sdhci_readw, val, !(val & mask), 10,\n \t\t\t\t     UHS2_RESET_TIMEOUT_100MS, true, host, SDHCI_UHS2_SW_RESET)) {\n-\t\tpr_warn(\"%s: %s: Reset 0x%x never completed. %s: clean reset bit.\\n\", __func__,\n-\t\t\tmmc_hostname(host->mmc), (int)mask, mmc_hostname(host->mmc));\n+\t\tpr_debug(\"%s: %s: Reset 0x%x never completed. %s: clean reset bit.\\n\", __func__,\n+\t\t\t mmc_hostname(host->mmc), (int)mask, mmc_hostname(host->mmc));\n \t\tsdhci_writeb(host, 0, SDHCI_UHS2_SW_RESET);\n \t\treturn;\n \t}\n@@ -335,8 +335,8 @@ static int sdhci_uhs2_interface_detect(struct sdhci_host *host)\n \tif (read_poll_timeout(sdhci_readl, val, (val & SDHCI_UHS2_IF_DETECT),\n \t\t\t      100, UHS2_INTERFACE_DETECT_TIMEOUT_100MS, true,\n \t\t\t      host, SDHCI_PRESENT_STATE)) {\n-\t\tpr_warn(\"%s: not detect UHS2 interface in 100ms.\\n\", mmc_hostname(host->mmc));\n-\t\tsdhci_dumpregs(host);\n+\t\tpr_debug(\"%s: not detect UHS2 interface in 100ms.\\n\", mmc_hostname(host->mmc));\n+\t\tsdhci_dbg_dumpregs(host, \"UHS2 interface detect timeout in 100ms\");\n \t\treturn -EIO;\n \t}\n \n@@ -345,8 +345,8 @@ static int sdhci_uhs2_interface_detect(struct sdhci_host *host)\n \n \tif (read_poll_timeout(sdhci_readl, val, (val & SDHCI_UHS2_LANE_SYNC),\n \t\t\t      100, UHS2_LANE_SYNC_TIMEOUT_150MS, true, host, SDHCI_PRESENT_STATE)) {\n-\t\tpr_warn(\"%s: UHS2 Lane sync fail in 150ms.\\n\", mmc_hostname(host->mmc));\n-\t\tsdhci_dumpregs(host);\n+\t\tpr_debug(\"%s: UHS2 Lane sync fail in 150ms.\\n\", mmc_hostname(host->mmc));\n+\t\tsdhci_dbg_dumpregs(host, \"UHS2 Lane sync fail in 150ms\");\n \t\treturn -EIO;\n \t}\n \n@@ -417,12 +417,12 @@ static int sdhci_uhs2_do_detect_init(struct mmc_host *mmc)\n \t\thost->ops->uhs2_pre_detect_init(host);\n \n \tif (sdhci_uhs2_interface_detect(host)) {\n-\t\tpr_warn(\"%s: cannot detect UHS2 interface.\\n\", mmc_hostname(host->mmc));\n+\t\tpr_debug(\"%s: cannot detect UHS2 interface.\\n\", mmc_hostname(host->mmc));\n \t\treturn -EIO;\n \t}\n \n \tif (sdhci_uhs2_init(host)) {\n-\t\tpr_warn(\"%s: UHS2 init fail.\\n\", mmc_hostname(host->mmc));\n+\t\tpr_debug(\"%s: UHS2 init fail.\\n\", mmc_hostname(host->mmc));\n \t\treturn -EIO;\n \t}\n \n@@ -504,8 +504,8 @@ static int sdhci_uhs2_check_dormant(struct sdhci_host *host)\n \tif (read_poll_timeout(sdhci_readl, val, (val & SDHCI_UHS2_IN_DORMANT_STATE),\n \t\t\t      100, UHS2_CHECK_DORMANT_TIMEOUT_100MS, true, host,\n \t\t\t      SDHCI_PRESENT_STATE)) {\n-\t\tpr_warn(\"%s: UHS2 IN_DORMANT fail in 100ms.\\n\", mmc_hostname(host->mmc));\n-\t\tsdhci_dumpregs(host);\n+\t\tpr_debug(\"%s: UHS2 IN_DORMANT fail in 100ms.\\n\", mmc_hostname(host->mmc));\n+\t\tsdhci_dbg_dumpregs(host, \"UHS2 IN_DORMANT fail in 100ms\");\n \t\treturn -EIO;\n \t}\n \treturn 0;\ndiff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c\nindex f008167d1863..e116f2db34d5 100644\n--- a/drivers/mmc/host/sdhci.c\n+++ b/drivers/mmc/host/sdhci.c\n@@ -2065,15 +2065,10 @@ void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)\n \n \thost->mmc->actual_clock = 0;\n \n-\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n-\tif (clk & SDHCI_CLOCK_CARD_EN)\n-\t\tsdhci_writew(host, clk & ~SDHCI_CLOCK_CARD_EN,\n-\t\t\tSDHCI_CLOCK_CONTROL);\n+\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n \n-\tif (clock == 0) {\n-\t\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n+\tif (clock == 0)\n \t\treturn;\n-\t}\n \n \tclk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);\n \tsdhci_enable_clk(host, clk);\ndiff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h\nindex f9d65dd0f2b2..70ada1857a4c 100644\n--- a/drivers/mmc/host/sdhci.h\n+++ b/drivers/mmc/host/sdhci.h\n@@ -900,4 +900,20 @@ void sdhci_switch_external_dma(struct sdhci_host *host, bool en);\n void sdhci_set_data_timeout_irq(struct sdhci_host *host, bool enable);\n void __sdhci_set_timeout(struct sdhci_host *host, struct mmc_command *cmd);\n \n+#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n+\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n+#define SDHCI_DBG_ANYWAY 0\n+#elif defined(DEBUG)\n+#define SDHCI_DBG_ANYWAY 1\n+#else\n+#define SDHCI_DBG_ANYWAY 0\n+#endif\n+\n+#define sdhci_dbg_dumpregs(host, fmt)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);\t\t\t\\\n+\tif (DYNAMIC_DEBUG_BRANCH(descriptor) ||\tSDHCI_DBG_ANYWAY)\t\\\n+\t\tsdhci_dumpregs(host);\t\t\t\t\t\\\n+} while (0)\n+\n #endif /* __SDHCI_HW_H */",
    "stats": {
      "insertions": 57,
      "deletions": 28,
      "files": 7
    }
  },
  {
    "sha": "ba6a2f25d3d0c813bc5f70c4437002ecc90b85d5",
    "message": "Merge tag 's390-6.16-4' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux\n\nPull s390 fixes from Alexander Gordeev:\n\n - Fix PCI error recovery and bring it in line with AER/EEH\n\n* tag 's390-6.16-4' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux:\n  s390/pci: Allow automatic recovery with minimal driver support\n  s390/pci: Do not try re-enabling load/store if device is disabled\n  s390/pci: Fix stale function handles in error handling",
    "author": "Linus Torvalds",
    "date": "2025-07-02T09:27:57-07:00",
    "files_changed": [
      "arch/s390/pci/pci_event.c"
    ],
    "diff": "diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c\nindex 2fbee3887d13..d930416d4c90 100644\n--- a/arch/s390/pci/pci_event.c\n+++ b/arch/s390/pci/pci_event.c\n@@ -54,6 +54,7 @@ static inline bool ers_result_indicates_abort(pci_ers_result_t ers_res)\n \tcase PCI_ERS_RESULT_CAN_RECOVER:\n \tcase PCI_ERS_RESULT_RECOVERED:\n \tcase PCI_ERS_RESULT_NEED_RESET:\n+\tcase PCI_ERS_RESULT_NONE:\n \t\treturn false;\n \tdefault:\n \t\treturn true;\n@@ -78,10 +79,6 @@ static bool is_driver_supported(struct pci_driver *driver)\n \t\treturn false;\n \tif (!driver->err_handler->error_detected)\n \t\treturn false;\n-\tif (!driver->err_handler->slot_reset)\n-\t\treturn false;\n-\tif (!driver->err_handler->resume)\n-\t\treturn false;\n \treturn true;\n }\n \n@@ -106,6 +103,10 @@ static pci_ers_result_t zpci_event_do_error_state_clear(struct pci_dev *pdev,\n \tstruct zpci_dev *zdev = to_zpci(pdev);\n \tint rc;\n \n+\t/* The underlying device may have been disabled by the event */\n+\tif (!zdev_enabled(zdev))\n+\t\treturn PCI_ERS_RESULT_NEED_RESET;\n+\n \tpr_info(\"%s: Unblocking device access for examination\\n\", pci_name(pdev));\n \trc = zpci_reset_load_store_blocked(zdev);\n \tif (rc) {\n@@ -114,16 +115,18 @@ static pci_ers_result_t zpci_event_do_error_state_clear(struct pci_dev *pdev,\n \t\treturn PCI_ERS_RESULT_NEED_RESET;\n \t}\n \n-\tif (driver->err_handler->mmio_enabled) {\n+\tif (driver->err_handler->mmio_enabled)\n \t\ters_res = driver->err_handler->mmio_enabled(pdev);\n-\t\tif (ers_result_indicates_abort(ers_res)) {\n-\t\t\tpr_info(\"%s: Automatic recovery failed after MMIO re-enable\\n\",\n-\t\t\t\tpci_name(pdev));\n-\t\t\treturn ers_res;\n-\t\t} else if (ers_res == PCI_ERS_RESULT_NEED_RESET) {\n-\t\t\tpr_debug(\"%s: Driver needs reset to recover\\n\", pci_name(pdev));\n-\t\t\treturn ers_res;\n-\t\t}\n+\telse\n+\t\ters_res = PCI_ERS_RESULT_NONE;\n+\n+\tif (ers_result_indicates_abort(ers_res)) {\n+\t\tpr_info(\"%s: Automatic recovery failed after MMIO re-enable\\n\",\n+\t\t\tpci_name(pdev));\n+\t\treturn ers_res;\n+\t} else if (ers_res == PCI_ERS_RESULT_NEED_RESET) {\n+\t\tpr_debug(\"%s: Driver needs reset to recover\\n\", pci_name(pdev));\n+\t\treturn ers_res;\n \t}\n \n \tpr_debug(\"%s: Unblocking DMA\\n\", pci_name(pdev));\n@@ -150,7 +153,12 @@ static pci_ers_result_t zpci_event_do_reset(struct pci_dev *pdev,\n \t\treturn ers_res;\n \t}\n \tpdev->error_state = pci_channel_io_normal;\n-\ters_res = driver->err_handler->slot_reset(pdev);\n+\n+\tif (driver->err_handler->slot_reset)\n+\t\ters_res = driver->err_handler->slot_reset(pdev);\n+\telse\n+\t\ters_res = PCI_ERS_RESULT_NONE;\n+\n \tif (ers_result_indicates_abort(ers_res)) {\n \t\tpr_info(\"%s: Automatic recovery failed after slot reset\\n\", pci_name(pdev));\n \t\treturn ers_res;\n@@ -214,7 +222,7 @@ static pci_ers_result_t zpci_event_attempt_error_recovery(struct pci_dev *pdev)\n \t\tgoto out_unlock;\n \t}\n \n-\tif (ers_res == PCI_ERS_RESULT_CAN_RECOVER) {\n+\tif (ers_res != PCI_ERS_RESULT_NEED_RESET) {\n \t\ters_res = zpci_event_do_error_state_clear(pdev, driver);\n \t\tif (ers_result_indicates_abort(ers_res)) {\n \t\t\tstatus_str = \"failed (abort on MMIO enable)\";\n@@ -225,6 +233,16 @@ static pci_ers_result_t zpci_event_attempt_error_recovery(struct pci_dev *pdev)\n \tif (ers_res == PCI_ERS_RESULT_NEED_RESET)\n \t\ters_res = zpci_event_do_reset(pdev, driver);\n \n+\t/*\n+\t * ers_res can be PCI_ERS_RESULT_NONE either because the driver\n+\t * decided to return it, indicating that it abstains from voting\n+\t * on how to recover, or because it didn't implement the callback.\n+\t * Both cases assume, that if there is nothing else causing a\n+\t * disconnect, we recovered successfully.\n+\t */\n+\tif (ers_res == PCI_ERS_RESULT_NONE)\n+\t\ters_res = PCI_ERS_RESULT_RECOVERED;\n+\n \tif (ers_res != PCI_ERS_RESULT_RECOVERED) {\n \t\tpr_err(\"%s: Automatic recovery failed; operator intervention is required\\n\",\n \t\t       pci_name(pdev));\n@@ -273,6 +291,8 @@ static void __zpci_event_error(struct zpci_ccdf_err *ccdf)\n \tstruct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);\n \tstruct pci_dev *pdev = NULL;\n \tpci_ers_result_t ers_res;\n+\tu32 fh = 0;\n+\tint rc;\n \n \tzpci_dbg(3, \"err fid:%x, fh:%x, pec:%x\\n\",\n \t\t ccdf->fid, ccdf->fh, ccdf->pec);\n@@ -281,6 +301,15 @@ static void __zpci_event_error(struct zpci_ccdf_err *ccdf)\n \n \tif (zdev) {\n \t\tmutex_lock(&zdev->state_lock);\n+\t\trc = clp_refresh_fh(zdev->fid, &fh);\n+\t\tif (rc)\n+\t\t\tgoto no_pdev;\n+\t\tif (!fh || ccdf->fh != fh) {\n+\t\t\t/* Ignore events with stale handles */\n+\t\t\tzpci_dbg(3, \"err fid:%x, fh:%x (stale %x)\\n\",\n+\t\t\t\t ccdf->fid, fh, ccdf->fh);\n+\t\t\tgoto no_pdev;\n+\t\t}\n \t\tzpci_update_fh(zdev, ccdf->fh);\n \t\tif (zdev->zbus->bus)\n \t\t\tpdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);",
    "stats": {
      "insertions": 44,
      "deletions": 15,
      "files": 1
    }
  }
]
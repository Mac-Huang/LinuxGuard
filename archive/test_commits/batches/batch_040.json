[
  {
    "sha": "ff21a6ec0f27c126db0a86d96751bd6e5d1d9874",
    "message": "ASoC: rt721-sdca: fix boost gain calculation error\n\nFix the boost gain calculation error in rt721_sdca_set_gain_get.\nThis patch is specific for \"FU33 Boost Volume\".\n\nSigned-off-by: Jack Yu <jack.yu@realtek.com>\nLink: https://patch.msgid.link/1b18fcde41c64d6fa85451d523c0434a@realtek.com\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "Jack Yu",
    "date": "2025-06-24T13:55:18+01:00",
    "files_changed": [
      "sound/soc/codecs/rt721-sdca.c"
    ],
    "diff": "diff --git a/sound/soc/codecs/rt721-sdca.c b/sound/soc/codecs/rt721-sdca.c\nindex 1c9f32e405cf..ba080957e933 100644\n--- a/sound/soc/codecs/rt721-sdca.c\n+++ b/sound/soc/codecs/rt721-sdca.c\n@@ -430,6 +430,7 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \tunsigned int read_l, read_r, ctl_l = 0, ctl_r = 0;\n \tunsigned int adc_vol_flag = 0;\n \tconst unsigned int interval_offset = 0xc0;\n+\tconst unsigned int tendA = 0x200;\n \tconst unsigned int tendB = 0xa00;\n \n \tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\") ||\n@@ -439,9 +440,16 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \tregmap_read(rt721->mbq_regmap, mc->reg, &read_l);\n \tregmap_read(rt721->mbq_regmap, mc->rreg, &read_r);\n \n-\tif (mc->shift == 8) /* boost gain */\n+\tif (mc->shift == 8) {\n+\t\t/* boost gain */\n \t\tctl_l = read_l / tendB;\n-\telse {\n+\t} else if (mc->shift == 1) {\n+\t\t/* FU33 boost gain */\n+\t\tif (read_l == 0x8000 || read_l == 0xfe00)\n+\t\t\tctl_l = 0;\n+\t\telse\n+\t\t\tctl_l = read_l / tendA + 1;\n+\t} else {\n \t\tif (adc_vol_flag)\n \t\t\tctl_l = mc->max - (((0x1e00 - read_l) & 0xffff) / interval_offset);\n \t\telse\n@@ -449,9 +457,16 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \t}\n \n \tif (read_l != read_r) {\n-\t\tif (mc->shift == 8) /* boost gain */\n+\t\tif (mc->shift == 8) {\n+\t\t\t/* boost gain */\n \t\t\tctl_r = read_r / tendB;\n-\t\telse { /* ADC/DAC gain */\n+\t\t} else if (mc->shift == 1) {\n+\t\t\t/* FU33 boost gain */\n+\t\t\tif (read_r == 0x8000 || read_r == 0xfe00)\n+\t\t\t\tctl_r = 0;\n+\t\t\telse\n+\t\t\t\tctl_r = read_r / tendA + 1;\n+\t\t} else { /* ADC/DAC gain */\n \t\t\tif (adc_vol_flag)\n \t\t\t\tctl_r = mc->max - (((0x1e00 - read_r) & 0xffff) / interval_offset);\n \t\t\telse",
    "stats": {
      "insertions": 19,
      "deletions": 4,
      "files": 1
    }
  },
  {
    "sha": "1fd26729e013d0c829eb0675d5b6ad77ff497ab3",
    "message": "Merge tag 'for-net-2025-06-23' of git://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth\n\nLuiz Augusto von Dentz says:\n\n====================\nbluetooth pull request for net:\n\n - L2CAP: Fix L2CAP MTU negotiation\n - hci_core: Fix use-after-free in vhci_flush()\n - btintel_pcie: Fix potential race condition in firmware download\n - hci_qca: fix unable to load the BT driver\n\n* tag 'for-net-2025-06-23' of git://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth:\n  Bluetooth: hci_core: Fix use-after-free in vhci_flush()\n  driver: bluetooth: hci_qca:fix unable to load the BT driver\n  Bluetooth: L2CAP: Fix L2CAP MTU negotiation\n  Bluetooth: btintel_pcie: Fix potential race condition in firmware download\n====================\n\nLink: https://patch.msgid.link/20250623165405.227619-1-luiz.dentz@gmail.com\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
    "author": "Paolo Abeni",
    "date": "2025-06-24T12:40:54+02:00",
    "files_changed": [
      "drivers/bluetooth/btintel_pcie.c",
      "drivers/bluetooth/hci_qca.c",
      "include/net/bluetooth/hci_core.h",
      "net/bluetooth/hci_core.c",
      "net/bluetooth/l2cap_core.c"
    ],
    "diff": "diff --git a/drivers/bluetooth/btintel_pcie.c b/drivers/bluetooth/btintel_pcie.c\nindex 563165c5efae..e1c688dd2d45 100644\n--- a/drivers/bluetooth/btintel_pcie.c\n+++ b/drivers/bluetooth/btintel_pcie.c\n@@ -2033,6 +2033,28 @@ static void btintel_pcie_release_hdev(struct btintel_pcie_data *data)\n \tdata->hdev = NULL;\n }\n \n+static void btintel_pcie_disable_interrupts(struct btintel_pcie_data *data)\n+{\n+\tspin_lock(&data->irq_lock);\n+\tbtintel_pcie_wr_reg32(data, BTINTEL_PCIE_CSR_MSIX_FH_INT_MASK, data->fh_init_mask);\n+\tbtintel_pcie_wr_reg32(data, BTINTEL_PCIE_CSR_MSIX_HW_INT_MASK, data->hw_init_mask);\n+\tspin_unlock(&data->irq_lock);\n+}\n+\n+static void btintel_pcie_enable_interrupts(struct btintel_pcie_data *data)\n+{\n+\tspin_lock(&data->irq_lock);\n+\tbtintel_pcie_wr_reg32(data, BTINTEL_PCIE_CSR_MSIX_FH_INT_MASK, ~data->fh_init_mask);\n+\tbtintel_pcie_wr_reg32(data, BTINTEL_PCIE_CSR_MSIX_HW_INT_MASK, ~data->hw_init_mask);\n+\tspin_unlock(&data->irq_lock);\n+}\n+\n+static void btintel_pcie_synchronize_irqs(struct btintel_pcie_data *data)\n+{\n+\tfor (int i = 0; i < data->alloc_vecs; i++)\n+\t\tsynchronize_irq(data->msix_entries[i].vector);\n+}\n+\n static int btintel_pcie_setup_internal(struct hci_dev *hdev)\n {\n \tstruct btintel_pcie_data *data = hci_get_drvdata(hdev);\n@@ -2152,6 +2174,8 @@ static int btintel_pcie_setup(struct hci_dev *hdev)\n \t\tbt_dev_err(hdev, \"Firmware download retry count: %d\",\n \t\t\t   fw_dl_retry);\n \t\tbtintel_pcie_dump_debug_registers(hdev);\n+\t\tbtintel_pcie_disable_interrupts(data);\n+\t\tbtintel_pcie_synchronize_irqs(data);\n \t\terr = btintel_pcie_reset_bt(data);\n \t\tif (err) {\n \t\t\tbt_dev_err(hdev, \"Failed to do shr reset: %d\", err);\n@@ -2159,6 +2183,7 @@ static int btintel_pcie_setup(struct hci_dev *hdev)\n \t\t}\n \t\tusleep_range(10000, 12000);\n \t\tbtintel_pcie_reset_ia(data);\n+\t\tbtintel_pcie_enable_interrupts(data);\n \t\tbtintel_pcie_config_msix(data);\n \t\terr = btintel_pcie_enable_bt(data);\n \t\tif (err) {\n@@ -2291,6 +2316,12 @@ static void btintel_pcie_remove(struct pci_dev *pdev)\n \n \tdata = pci_get_drvdata(pdev);\n \n+\tbtintel_pcie_disable_interrupts(data);\n+\n+\tbtintel_pcie_synchronize_irqs(data);\n+\n+\tflush_work(&data->rx_work);\n+\n \tbtintel_pcie_reset_bt(data);\n \tfor (int i = 0; i < data->alloc_vecs; i++) {\n \t\tstruct msix_entry *msix_entry;\n@@ -2303,8 +2334,6 @@ static void btintel_pcie_remove(struct pci_dev *pdev)\n \n \tbtintel_pcie_release_hdev(data);\n \n-\tflush_work(&data->rx_work);\n-\n \tdestroy_workqueue(data->workqueue);\n \n \tbtintel_pcie_free(data);\ndiff --git a/drivers/bluetooth/hci_qca.c b/drivers/bluetooth/hci_qca.c\nindex 5fe5879881f5..3ec0be496820 100644\n--- a/drivers/bluetooth/hci_qca.c\n+++ b/drivers/bluetooth/hci_qca.c\n@@ -2392,10 +2392,17 @@ static int qca_serdev_probe(struct serdev_device *serdev)\n \t\t\t */\n \t\t\tqcadev->bt_power->pwrseq = devm_pwrseq_get(&serdev->dev,\n \t\t\t\t\t\t\t\t   \"bluetooth\");\n-\t\t\tif (IS_ERR(qcadev->bt_power->pwrseq))\n-\t\t\t\treturn PTR_ERR(qcadev->bt_power->pwrseq);\n \n-\t\t\tbreak;\n+\t\t\t/*\n+\t\t\t * Some modules have BT_EN enabled via a hardware pull-up,\n+\t\t\t * meaning it is not defined in the DTS and is not controlled\n+\t\t\t * through the power sequence. In such cases, fall through\n+\t\t\t * to follow the legacy flow.\n+\t\t\t */\n+\t\t\tif (IS_ERR(qcadev->bt_power->pwrseq))\n+\t\t\t\tqcadev->bt_power->pwrseq = NULL;\n+\t\t\telse\n+\t\t\t\tbreak;\n \t\t}\n \t\tfallthrough;\n \tcase QCA_WCN3950:\ndiff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h\nindex a760f05fa3fb..9fc8f544e20e 100644\n--- a/include/net/bluetooth/hci_core.h\n+++ b/include/net/bluetooth/hci_core.h\n@@ -29,6 +29,7 @@\n #include <linux/idr.h>\n #include <linux/leds.h>\n #include <linux/rculist.h>\n+#include <linux/srcu.h>\n \n #include <net/bluetooth/hci.h>\n #include <net/bluetooth/hci_drv.h>\n@@ -347,6 +348,7 @@ struct adv_monitor {\n \n struct hci_dev {\n \tstruct list_head list;\n+\tstruct srcu_struct srcu;\n \tstruct mutex\tlock;\n \n \tstruct ida\tunset_handle_ida;\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\nindex 07a8b4281a39..14d7221b8ac0 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n@@ -64,7 +64,7 @@ static DEFINE_IDA(hci_index_ida);\n \n /* Get HCI device by index.\n  * Device is held on return. */\n-struct hci_dev *hci_dev_get(int index)\n+static struct hci_dev *__hci_dev_get(int index, int *srcu_index)\n {\n \tstruct hci_dev *hdev = NULL, *d;\n \n@@ -77,6 +77,8 @@ struct hci_dev *hci_dev_get(int index)\n \tlist_for_each_entry(d, &hci_dev_list, list) {\n \t\tif (d->id == index) {\n \t\t\thdev = hci_dev_hold(d);\n+\t\t\tif (srcu_index)\n+\t\t\t\t*srcu_index = srcu_read_lock(&d->srcu);\n \t\t\tbreak;\n \t\t}\n \t}\n@@ -84,6 +86,22 @@ struct hci_dev *hci_dev_get(int index)\n \treturn hdev;\n }\n \n+struct hci_dev *hci_dev_get(int index)\n+{\n+\treturn __hci_dev_get(index, NULL);\n+}\n+\n+static struct hci_dev *hci_dev_get_srcu(int index, int *srcu_index)\n+{\n+\treturn __hci_dev_get(index, srcu_index);\n+}\n+\n+static void hci_dev_put_srcu(struct hci_dev *hdev, int srcu_index)\n+{\n+\tsrcu_read_unlock(&hdev->srcu, srcu_index);\n+\thci_dev_put(hdev);\n+}\n+\n /* ---- Inquiry support ---- */\n \n bool hci_discovery_active(struct hci_dev *hdev)\n@@ -568,9 +586,9 @@ static int hci_dev_do_reset(struct hci_dev *hdev)\n int hci_dev_reset(__u16 dev)\n {\n \tstruct hci_dev *hdev;\n-\tint err;\n+\tint err, srcu_index;\n \n-\thdev = hci_dev_get(dev);\n+\thdev = hci_dev_get_srcu(dev, &srcu_index);\n \tif (!hdev)\n \t\treturn -ENODEV;\n \n@@ -592,7 +610,7 @@ int hci_dev_reset(__u16 dev)\n \terr = hci_dev_do_reset(hdev);\n \n done:\n-\thci_dev_put(hdev);\n+\thci_dev_put_srcu(hdev, srcu_index);\n \treturn err;\n }\n \n@@ -2433,6 +2451,11 @@ struct hci_dev *hci_alloc_dev_priv(int sizeof_priv)\n \tif (!hdev)\n \t\treturn NULL;\n \n+\tif (init_srcu_struct(&hdev->srcu)) {\n+\t\tkfree(hdev);\n+\t\treturn NULL;\n+\t}\n+\n \thdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);\n \thdev->esco_type = (ESCO_HV1);\n \thdev->link_mode = (HCI_LM_ACCEPT);\n@@ -2678,6 +2701,9 @@ void hci_unregister_dev(struct hci_dev *hdev)\n \tlist_del(&hdev->list);\n \twrite_unlock(&hci_dev_list_lock);\n \n+\tsynchronize_srcu(&hdev->srcu);\n+\tcleanup_srcu_struct(&hdev->srcu);\n+\n \tdisable_work_sync(&hdev->rx_work);\n \tdisable_work_sync(&hdev->cmd_work);\n \tdisable_work_sync(&hdev->tx_work);\ndiff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c\nindex a5bde5db58ef..40daa38276f3 100644\n--- a/net/bluetooth/l2cap_core.c\n+++ b/net/bluetooth/l2cap_core.c\n@@ -3415,7 +3415,7 @@ static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data\n \tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n \tstruct l2cap_conf_efs efs;\n \tu8 remote_efs = 0;\n-\tu16 mtu = L2CAP_DEFAULT_MTU;\n+\tu16 mtu = 0;\n \tu16 result = L2CAP_CONF_SUCCESS;\n \tu16 size;\n \n@@ -3520,6 +3520,13 @@ static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data\n \t\t/* Configure output options and let the other side know\n \t\t * which ones we don't like. */\n \n+\t\t/* If MTU is not provided in configure request, use the most recently\n+\t\t * explicitly or implicitly accepted value for the other direction,\n+\t\t * or the default value.\n+\t\t */\n+\t\tif (mtu == 0)\n+\t\t\tmtu = chan->imtu ? chan->imtu : L2CAP_DEFAULT_MTU;\n+\n \t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n \t\t\tresult = L2CAP_CONF_UNACCEPT;\n \t\telse {",
    "stats": {
      "insertions": 81,
      "deletions": 10,
      "files": 5
    }
  },
  {
    "sha": "b272f42547d85356b035e46273ddaf2aa4e161b8",
    "message": "ALSA: qc_audio_offload: Fix missing error code in prepare_qmi_response()\n\nWhen snd_soc_usb_find_priv_data() fails, return failure instead of\nsuccess. While we are at it also use direct returns at first few error\npaths where there is no additional cleanup needed.\n\nReported-by: Dan Carpenter <dan.carpenter@linaro.org>\nCloses: https://lore.kernel.org/all/Z_40qL4JnyjR4j0O@stanley.mountain/\nFixes: 326bbc348298 (\"ALSA: usb-audio: qcom: Introduce QC USB SND offloading support\")\nSigned-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>\nLink: https://patch.msgid.link/20250623142639.2938056-1-harshit.m.mogalapalli@oracle.com\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "author": "Harshit Mogalapalli",
    "date": "2025-06-24T10:11:02+02:00",
    "files_changed": [
      "sound/usb/qcom/qc_audio_offload.c"
    ],
    "diff": "diff --git a/sound/usb/qcom/qc_audio_offload.c b/sound/usb/qcom/qc_audio_offload.c\nindex 5bc27c82e0af..797afd4561bd 100644\n--- a/sound/usb/qcom/qc_audio_offload.c\n+++ b/sound/usb/qcom/qc_audio_offload.c\n@@ -1360,20 +1360,21 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \n \tif (!uadev[card_num].ctrl_intf) {\n \t\tdev_err(&subs->dev->dev, \"audio ctrl intf info not cached\\n\");\n-\t\tret = -ENODEV;\n-\t\tgoto err;\n+\t\treturn -ENODEV;\n \t}\n \n \tret = uaudio_populate_uac_desc(subs, resp);\n \tif (ret < 0)\n-\t\tgoto err;\n+\t\treturn ret;\n \n \tresp->slot_id = subs->dev->slot_id;\n \tresp->slot_id_valid = 1;\n \n \tdata = snd_soc_usb_find_priv_data(uaudio_qdev->auxdev->dev.parent);\n-\tif (!data)\n-\t\tgoto err;\n+\tif (!data) {\n+\t\tdev_err(&subs->dev->dev, \"No private data found\\n\");\n+\t\treturn -ENODEV;\n+\t}\n \n \tuaudio_qdev->data = data;\n \n@@ -1382,7 +1383,7 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \t\t\t\t    &resp->xhci_mem_info.tr_data,\n \t\t\t\t    &resp->std_as_data_ep_desc);\n \tif (ret < 0)\n-\t\tgoto err;\n+\t\treturn ret;\n \n \tresp->std_as_data_ep_desc_valid = 1;\n \n@@ -1500,7 +1501,6 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \txhci_sideband_remove_endpoint(uadev[card_num].sb,\n \t\t\tusb_pipe_endpoint(subs->dev, subs->data_endpoint->pipe));\n \n-err:\n \treturn ret;\n }\n ",
    "stats": {
      "insertions": 7,
      "deletions": 7,
      "files": 1
    }
  },
  {
    "sha": "32ca245464e1479bfea8592b9db227fdc1641705",
    "message": "af_unix: Don't leave consecutive consumed OOB skbs.\n\nJann Horn reported a use-after-free in unix_stream_read_generic().\n\nThe following sequences reproduce the issue:\n\n  $ python3\n  from socket import *\n  s1, s2 = socketpair(AF_UNIX, SOCK_STREAM)\n  s1.send(b'x', MSG_OOB)\n  s2.recv(1, MSG_OOB)     # leave a consumed OOB skb\n  s1.send(b'y', MSG_OOB)\n  s2.recv(1, MSG_OOB)     # leave a consumed OOB skb\n  s1.send(b'z', MSG_OOB)\n  s2.recv(1)              # recv 'z' illegally\n  s2.recv(1, MSG_OOB)     # access 'z' skb (use-after-free)\n\nEven though a user reads OOB data, the skb holding the data stays on\nthe recv queue to mark the OOB boundary and break the next recv().\n\nAfter the last send() in the scenario above, the sk2's recv queue has\n2 leading consumed OOB skbs and 1 real OOB skb.\n\nThen, the following happens during the next recv() without MSG_OOB\n\n  1. unix_stream_read_generic() peeks the first consumed OOB skb\n  2. manage_oob() returns the next consumed OOB skb\n  3. unix_stream_read_generic() fetches the next not-yet-consumed OOB skb\n  4. unix_stream_read_generic() reads and frees the OOB skb\n\n, and the last recv(MSG_OOB) triggers KASAN splat.\n\nThe 3. above occurs because of the SO_PEEK_OFF code, which does not\nexpect unix_skb_len(skb) to be 0, but this is true for such consumed\nOOB skbs.\n\n  while (skip >= unix_skb_len(skb)) {\n    skip -= unix_skb_len(skb);\n    skb = skb_peek_next(skb, &sk->sk_receive_queue);\n    ...\n  }\n\nIn addition to this use-after-free, there is another issue that\nioctl(SIOCATMARK) does not function properly with consecutive consumed\nOOB skbs.\n\nSo, nothing good comes out of such a situation.\n\nInstead of complicating manage_oob(), ioctl() handling, and the next\nECONNRESET fix by introducing a loop for consecutive consumed OOB skbs,\nlet's not leave such consecutive OOB unnecessarily.\n\nNow, while receiving an OOB skb in unix_stream_recv_urg(), if its\nprevious skb is a consumed OOB skb, it is freed.\n\n[0]:\nBUG: KASAN: slab-use-after-free in unix_stream_read_actor (net/unix/af_unix.c:3027)\nRead of size 4 at addr ffff888106ef2904 by task python3/315\n\nCPU: 2 UID: 0 PID: 315 Comm: python3 Not tainted 6.16.0-rc1-00407-gec315832f6f9 #8 PREEMPT(voluntary)\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-4.fc42 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl (lib/dump_stack.c:122)\n print_report (mm/kasan/report.c:409 mm/kasan/report.c:521)\n kasan_report (mm/kasan/report.c:636)\n unix_stream_read_actor (net/unix/af_unix.c:3027)\n unix_stream_read_generic (net/unix/af_unix.c:2708 net/unix/af_unix.c:2847)\n unix_stream_recvmsg (net/unix/af_unix.c:3048)\n sock_recvmsg (net/socket.c:1063 (discriminator 20) net/socket.c:1085 (discriminator 20))\n __sys_recvfrom (net/socket.c:2278)\n __x64_sys_recvfrom (net/socket.c:2291 (discriminator 1) net/socket.c:2287 (discriminator 1) net/socket.c:2287 (discriminator 1))\n do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1))\n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\nRIP: 0033:0x7f8911fcea06\nCode: 5d e8 41 8b 93 08 03 00 00 59 5e 48 83 f8 fc 75 19 83 e2 39 83 fa 08 75 11 e8 26 ff ff ff 66 0f 1f 44 00 00 48 8b 45 10 0f 05 <48> 8b 5d f8 c9 c3 0f 1f 40 00 f3 0f 1e fa 55 48 89 e5 48 83 ec 08\nRSP: 002b:00007fffdb0dccb0 EFLAGS: 00000202 ORIG_RAX: 000000000000002d\nRAX: ffffffffffffffda RBX: 00007fffdb0dcdc8 RCX: 00007f8911fcea06\nRDX: 0000000000000001 RSI: 00007f8911a5e060 RDI: 0000000000000006\nRBP: 00007fffdb0dccd0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007f89119a7d20\nR13: ffffffffc4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nAllocated by task 315:\n kasan_save_stack (mm/kasan/common.c:48)\n kasan_save_track (mm/kasan/common.c:60 (discriminator 1) mm/kasan/common.c:69 (discriminator 1))\n __kasan_slab_alloc (mm/kasan/common.c:348)\n kmem_cache_alloc_node_noprof (./include/linux/kasan.h:250 mm/slub.c:4148 mm/slub.c:4197 mm/slub.c:4249)\n __alloc_skb (net/core/skbuff.c:660 (discriminator 4))\n alloc_skb_with_frags (./include/linux/skbuff.h:1336 net/core/skbuff.c:6668)\n sock_alloc_send_pskb (net/core/sock.c:2993)\n unix_stream_sendmsg (./include/net/sock.h:1847 net/unix/af_unix.c:2256 net/unix/af_unix.c:2418)\n __sys_sendto (net/socket.c:712 (discriminator 20) net/socket.c:727 (discriminator 20) net/socket.c:2226 (discriminator 20))\n __x64_sys_sendto (net/socket.c:2233 (discriminator 1) net/socket.c:2229 (discriminator 1) net/socket.c:2229 (discriminator 1))\n do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1))\n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\n\nFreed by task 315:\n kasan_save_stack (mm/kasan/common.c:48)\n kasan_save_track (mm/kasan/common.c:60 (discriminator 1) mm/kasan/common.c:69 (discriminator 1))\n kasan_save_free_info (mm/kasan/generic.c:579 (discriminator 1))\n __kasan_slab_free (mm/kasan/common.c:271)\n kmem_cache_free (mm/slub.c:4643 (discriminator 3) mm/slub.c:4745 (discriminator 3))\n unix_stream_read_generic (net/unix/af_unix.c:3010)\n unix_stream_recvmsg (net/unix/af_unix.c:3048)\n sock_recvmsg (net/socket.c:1063 (discriminator 20) net/socket.c:1085 (discriminator 20))\n __sys_recvfrom (net/socket.c:2278)\n __x64_sys_recvfrom (net/socket.c:2291 (discriminator 1) net/socket.c:2287 (discriminator 1) net/socket.c:2287 (discriminator 1))\n do_syscall_64 (arch/x86/entry/syscall_64.c:63 (discriminator 1) arch/x86/entry/syscall_64.c:94 (discriminator 1))\n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\n\nThe buggy address belongs to the object at ffff888106ef28c0\n which belongs to the cache skbuff_head_cache of size 224\nThe buggy address is located 68 bytes inside of\n freed 224-byte region [ffff888106ef28c0, ffff888106ef29a0)\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0xffff888106ef3cc0 pfn:0x106ef2\nhead: order:1 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0\nflags: 0x200000000000040(head|node=0|zone=2)\npage_type: f5(slab)\nraw: 0200000000000040 ffff8881001d28c0 ffffea000422fe00 0000000000000004\nraw: ffff888106ef3cc0 0000000080190010 00000000f5000000 0000000000000000\nhead: 0200000000000040 ffff8881001d28c0 ffffea000422fe00 0000000000000004\nhead: ffff888106ef3cc0 0000000080190010 00000000f5000000 0000000000000000\nhead: 0200000000000001 ffffea00041bbc81 00000000ffffffff 00000000ffffffff\nhead: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888106ef2800: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc\n ffff888106ef2880: fc fc fc fc fc fc fc fc fa fb fb fb fb fb fb fb\n>ffff888106ef2900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                   ^\n ffff888106ef2980: fb fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888106ef2a00: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nFixes: 314001f0bf92 (\"af_unix: Add OOB support\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Kuniyuki Iwashima <kuniyu@google.com>\nReviewed-by: Jann Horn <jannh@google.com>\nLink: https://patch.msgid.link/20250619041457.1132791-2-kuni1840@gmail.com\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
    "author": "Kuniyuki Iwashima",
    "date": "2025-06-24T10:10:06+02:00",
    "files_changed": [
      "net/unix/af_unix.c"
    ],
    "diff": "diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c\nindex 22e170fb5dda..5392aa53cbc8 100644\n--- a/net/unix/af_unix.c\n+++ b/net/unix/af_unix.c\n@@ -2680,11 +2680,11 @@ struct unix_stream_read_state {\n #if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n static int unix_stream_recv_urg(struct unix_stream_read_state *state)\n {\n+\tstruct sk_buff *oob_skb, *read_skb = NULL;\n \tstruct socket *sock = state->socket;\n \tstruct sock *sk = sock->sk;\n \tstruct unix_sock *u = unix_sk(sk);\n \tint chunk = 1;\n-\tstruct sk_buff *oob_skb;\n \n \tmutex_lock(&u->iolock);\n \tunix_state_lock(sk);\n@@ -2699,9 +2699,16 @@ static int unix_stream_recv_urg(struct unix_stream_read_state *state)\n \n \toob_skb = u->oob_skb;\n \n-\tif (!(state->flags & MSG_PEEK))\n+\tif (!(state->flags & MSG_PEEK)) {\n \t\tWRITE_ONCE(u->oob_skb, NULL);\n \n+\t\tif (oob_skb->prev != (struct sk_buff *)&sk->sk_receive_queue &&\n+\t\t    !unix_skb_len(oob_skb->prev)) {\n+\t\t\tread_skb = oob_skb->prev;\n+\t\t\t__skb_unlink(read_skb, &sk->sk_receive_queue);\n+\t\t}\n+\t}\n+\n \tspin_unlock(&sk->sk_receive_queue.lock);\n \tunix_state_unlock(sk);\n \n@@ -2712,6 +2719,8 @@ static int unix_stream_recv_urg(struct unix_stream_read_state *state)\n \n \tmutex_unlock(&u->iolock);\n \n+\tconsume_skb(read_skb);\n+\n \tif (chunk < 0)\n \t\treturn -EFAULT;\n ",
    "stats": {
      "insertions": 11,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "7a3750ff0f2e8fee338a9c168f429f6c37f0e820",
    "message": "wifi: mac80211: fix beacon interval calculation overflow\n\nAs we are converting from TU to usecs, a beacon interval of\n100*1024 usecs will lead to integer wrapping. To fix change\nto use a u32.\n\nFixes: 057d5f4ba1e4 (\"mac80211: sync dtim_count to TSF\")\nSigned-off-by: Lachlan Hodges <lachlan.hodges@morsemicro.com>\nLink: https://patch.msgid.link/20250621123209.511796-1-lachlan.hodges@morsemicro.com\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "author": "Lachlan Hodges",
    "date": "2025-06-24T09:04:55+02:00",
    "files_changed": [
      "net/mac80211/util.c"
    ],
    "diff": "diff --git a/net/mac80211/util.c b/net/mac80211/util.c\nindex 27d414efa3fd..a125995ed252 100644\n--- a/net/mac80211/util.c\n+++ b/net/mac80211/util.c\n@@ -3884,7 +3884,7 @@ void ieee80211_recalc_dtim(struct ieee80211_local *local,\n {\n \tu64 tsf = drv_get_tsf(local, sdata);\n \tu64 dtim_count = 0;\n-\tu16 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;\n+\tu32 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;\n \tu8 dtim_period = sdata->vif.bss_conf.dtim_period;\n \tstruct ps_data *ps;\n \tu8 bcns_from_dtim;",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  }
]
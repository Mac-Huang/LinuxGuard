[
  {
    "sha": "14dd95647ea533c7d7c528b9bb7e163e433b47b9",
    "message": "bcachefs: btree read retry fixes\n\nFix btree node read retries after validate errors:\n\n__btree_err() is the wrong place to flag a topology error: that is done\nby btree_lost_data().\n\nAdditionally, some calls to bch2_bkey_pick_read_device() were not\nupdated in the 6.16 rework for improved log messages; we were failing to\nsignal that we still had a retry.\n\nCc: Nikita Ofitserov <himikof@gmail.com>\nCc: Alan Huang <mmpgouride@gmail.com>\nReported-and-tested-by: Edoardo Codeglia <bcachefs@404.blue>\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>",
    "author": "Kent Overstreet",
    "date": "2025-07-05T12:42:41-04:00",
    "files_changed": [
      "fs/bcachefs/btree_io.c",
      "fs/bcachefs/errcode.h",
      "fs/bcachefs/error.c"
    ],
    "diff": "diff --git a/fs/bcachefs/btree_io.c b/fs/bcachefs/btree_io.c\nindex e874a4357f64..a4cc72986e36 100644\n--- a/fs/bcachefs/btree_io.c\n+++ b/fs/bcachefs/btree_io.c\n@@ -568,9 +568,9 @@ static int __btree_err(int ret,\n \t\tbch2_mark_btree_validate_failure(failed, ca->dev_idx);\n \n \t\tstruct extent_ptr_decoded pick;\n-\t\thave_retry = !bch2_bkey_pick_read_device(c,\n+\t\thave_retry = bch2_bkey_pick_read_device(c,\n \t\t\t\t\tbkey_i_to_s_c(&b->key),\n-\t\t\t\t\tfailed, &pick, -1);\n+\t\t\t\t\tfailed, &pick, -1) == 1;\n \t}\n \n \tif (!have_retry && ret == -BCH_ERR_btree_node_read_err_want_retry)\n@@ -615,7 +615,6 @@ static int __btree_err(int ret,\n \t\t\tgoto out;\n \t\tcase -BCH_ERR_btree_node_read_err_bad_node:\n \t\t\tprt_str(&out, \", \");\n-\t\t\tret = __bch2_topology_error(c, &out);\n \t\t\tbreak;\n \t\t}\n \n@@ -644,7 +643,6 @@ static int __btree_err(int ret,\n \t\tgoto out;\n \tcase -BCH_ERR_btree_node_read_err_bad_node:\n \t\tprt_str(&out, \", \");\n-\t\tret = __bch2_topology_error(c, &out);\n \t\tbreak;\n \t}\n print:\n@@ -1408,7 +1406,7 @@ static void btree_node_read_work(struct work_struct *work)\n \t\tret = bch2_bkey_pick_read_device(c,\n \t\t\t\t\tbkey_i_to_s_c(&b->key),\n \t\t\t\t\t&failed, &rb->pick, -1);\n-\t\tif (ret) {\n+\t\tif (ret <= 0) {\n \t\t\tset_btree_node_read_error(b);\n \t\t\tbreak;\n \t\t}\ndiff --git a/fs/bcachefs/errcode.h b/fs/bcachefs/errcode.h\nindex 86a842f1e88e..acc3b7b67704 100644\n--- a/fs/bcachefs/errcode.h\n+++ b/fs/bcachefs/errcode.h\n@@ -282,7 +282,6 @@\n \tx(EIO,\t\t\t\tsb_not_downgraded)\t\t\t\\\n \tx(EIO,\t\t\t\tbtree_node_write_all_failed)\t\t\\\n \tx(EIO,\t\t\t\tbtree_node_read_error)\t\t\t\\\n-\tx(EIO,\t\t\t\tbtree_node_read_validate_error)\t\t\\\n \tx(EIO,\t\t\t\tbtree_need_topology_repair)\t\t\\\n \tx(EIO,\t\t\t\tbucket_ref_update)\t\t\t\\\n \tx(EIO,\t\t\t\ttrigger_alloc)\t\t\t\t\\\ndiff --git a/fs/bcachefs/error.c b/fs/bcachefs/error.c\nindex b2a6c041e165..ea37f5af1800 100644\n--- a/fs/bcachefs/error.c\n+++ b/fs/bcachefs/error.c\n@@ -103,7 +103,7 @@ int __bch2_topology_error(struct bch_fs *c, struct printbuf *out)\n \t\treturn bch_err_throw(c, btree_need_topology_repair);\n \t} else {\n \t\treturn bch2_run_explicit_recovery_pass(c, out, BCH_RECOVERY_PASS_check_topology, 0) ?:\n-\t\t\tbch_err_throw(c, btree_node_read_validate_error);\n+\t\t\tbch_err_throw(c, btree_need_topology_repair);\n \t}\n }\n ",
    "stats": {
      "insertions": 4,
      "deletions": 7,
      "files": 3
    }
  },
  {
    "sha": "454706f1f8698eecc6cc00493c6dffbccdbbd416",
    "message": "Merge tag 'md-6.16-20250705' of gitolite.kernel.org:pub/scm/linux/kernel/git/mdraid/linux into block-6.16\n\nPull MD fixes from Yu:\n\n\" - fix uaf due to stack memory used for bio mempool, from Jinchao\n  - fix raid10/raid1 nowait IO error path, from Nigel and Qixing\n  - fix kernel crash from reading bitmap sysfs entry, by HÃ¥kon\"\n\n* tag 'md-6.16-20250705' of gitolite.kernel.org:pub/scm/linux/kernel/git/mdraid/linux:\n  md/md-bitmap: fix GPF in bitmap_get_stats()\n  md/raid1,raid10: strip REQ_NOWAIT from member bios\n  raid10: cleanup memleak at raid10_make_request\n  md/raid1: Fix stack memory use after return in raid1_reshape",
    "author": "Jens Axboe",
    "date": "2025-07-05T06:32:59-06:00",
    "files_changed": [
      "drivers/md/md-bitmap.c",
      "drivers/md/raid1.c",
      "drivers/md/raid10.c"
    ],
    "diff": "diff --git a/drivers/md/md-bitmap.c b/drivers/md/md-bitmap.c\nindex bd694910b01b..7f524a26cebc 100644\n--- a/drivers/md/md-bitmap.c\n+++ b/drivers/md/md-bitmap.c\n@@ -2366,8 +2366,7 @@ static int bitmap_get_stats(void *data, struct md_bitmap_stats *stats)\n \n \tif (!bitmap)\n \t\treturn -ENOENT;\n-\tif (!bitmap->mddev->bitmap_info.external &&\n-\t    !bitmap->storage.sb_page)\n+\tif (!bitmap->storage.sb_page)\n \t\treturn -EINVAL;\n \tsb = kmap_local_page(bitmap->storage.sb_page);\n \tstats->sync_size = le64_to_cpu(sb->sync_size);\ndiff --git a/drivers/md/raid1.c b/drivers/md/raid1.c\nindex 19c5a0ce5a40..64b8176907a9 100644\n--- a/drivers/md/raid1.c\n+++ b/drivers/md/raid1.c\n@@ -1399,7 +1399,7 @@ static void raid1_read_request(struct mddev *mddev, struct bio *bio,\n \t}\n \tread_bio = bio_alloc_clone(mirror->rdev->bdev, bio, gfp,\n \t\t\t\t   &mddev->bio_set);\n-\n+\tread_bio->bi_opf &= ~REQ_NOWAIT;\n \tr1_bio->bios[rdisk] = read_bio;\n \n \tread_bio->bi_iter.bi_sector = r1_bio->sector +\n@@ -1649,6 +1649,7 @@ static void raid1_write_request(struct mddev *mddev, struct bio *bio,\n \t\t\t\twait_for_serialization(rdev, r1_bio);\n \t\t}\n \n+\t\tmbio->bi_opf &= ~REQ_NOWAIT;\n \t\tr1_bio->bios[i] = mbio;\n \n \t\tmbio->bi_iter.bi_sector\t= (r1_bio->sector + rdev->data_offset);\n@@ -3428,6 +3429,7 @@ static int raid1_reshape(struct mddev *mddev)\n \t/* ok, everything is stopped */\n \toldpool = conf->r1bio_pool;\n \tconf->r1bio_pool = newpool;\n+\tinit_waitqueue_head(&conf->r1bio_pool.wait);\n \n \tfor (d = d2 = 0; d < conf->raid_disks; d++) {\n \t\tstruct md_rdev *rdev = conf->mirrors[d].rdev;\ndiff --git a/drivers/md/raid10.c b/drivers/md/raid10.c\nindex b74780af4c22..c9bd2005bfd0 100644\n--- a/drivers/md/raid10.c\n+++ b/drivers/md/raid10.c\n@@ -1182,8 +1182,11 @@ static void raid10_read_request(struct mddev *mddev, struct bio *bio,\n \t\t}\n \t}\n \n-\tif (!regular_request_wait(mddev, conf, bio, r10_bio->sectors))\n+\tif (!regular_request_wait(mddev, conf, bio, r10_bio->sectors)) {\n+\t\traid_end_bio_io(r10_bio);\n \t\treturn;\n+\t}\n+\n \trdev = read_balance(conf, r10_bio, &max_sectors);\n \tif (!rdev) {\n \t\tif (err_rdev) {\n@@ -1221,6 +1224,7 @@ static void raid10_read_request(struct mddev *mddev, struct bio *bio,\n \t\tr10_bio->master_bio = bio;\n \t}\n \tread_bio = bio_alloc_clone(rdev->bdev, bio, gfp, &mddev->bio_set);\n+\tread_bio->bi_opf &= ~REQ_NOWAIT;\n \n \tr10_bio->devs[slot].bio = read_bio;\n \tr10_bio->devs[slot].rdev = rdev;\n@@ -1256,6 +1260,7 @@ static void raid10_write_one_disk(struct mddev *mddev, struct r10bio *r10_bio,\n \t\t\t     conf->mirrors[devnum].rdev;\n \n \tmbio = bio_alloc_clone(rdev->bdev, bio, GFP_NOIO, &mddev->bio_set);\n+\tmbio->bi_opf &= ~REQ_NOWAIT;\n \tif (replacement)\n \t\tr10_bio->devs[n_copy].repl_bio = mbio;\n \telse\n@@ -1370,8 +1375,11 @@ static void raid10_write_request(struct mddev *mddev, struct bio *bio,\n \t}\n \n \tsectors = r10_bio->sectors;\n-\tif (!regular_request_wait(mddev, conf, bio, sectors))\n+\tif (!regular_request_wait(mddev, conf, bio, sectors)) {\n+\t\traid_end_bio_io(r10_bio);\n \t\treturn;\n+\t}\n+\n \tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n \t    (mddev->reshape_backwards\n \t     ? (bio->bi_iter.bi_sector < conf->reshape_safe &&",
    "stats": {
      "insertions": 14,
      "deletions": 5,
      "files": 3
    }
  },
  {
    "sha": "ddb9680a7226d6081b42869d2875715a17ecb51d",
    "message": "bcachefs: Fix bch2_io_failures_to_text()\n\nThis wasn't updated when we added tracking for btree validate errors.\n\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>",
    "author": "Kent Overstreet",
    "date": "2025-07-04T15:47:13-04:00",
    "files_changed": [
      "fs/bcachefs/extents.c"
    ],
    "diff": "diff --git a/fs/bcachefs/extents.c b/fs/bcachefs/extents.c\nindex 036e4ad95987..83cbd77dcb9c 100644\n--- a/fs/bcachefs/extents.c\n+++ b/fs/bcachefs/extents.c\n@@ -50,19 +50,17 @@ void bch2_io_failures_to_text(struct printbuf *out,\n \t\t\t      struct bch_io_failures *failed)\n {\n \tstatic const char * const error_types[] = {\n-\t\t\"io\", \"checksum\", \"ec reconstruct\", NULL\n+\t\t\"btree validate\", \"io\", \"checksum\", \"ec reconstruct\", NULL\n \t};\n \n \tfor (struct bch_dev_io_failures *f = failed->devs;\n \t     f < failed->devs + failed->nr;\n \t     f++) {\n \t\tunsigned errflags =\n-\t\t\t((!!f->failed_io)\t<< 0) |\n-\t\t\t((!!f->failed_csum_nr)\t<< 1) |\n-\t\t\t((!!f->failed_ec)\t<< 2);\n-\n-\t\tif (!errflags)\n-\t\t\tcontinue;\n+\t\t\t((!!f->failed_btree_validate)\t<< 0) |\n+\t\t\t((!!f->failed_io)\t\t<< 1) |\n+\t\t\t((!!f->failed_csum_nr)\t\t<< 2) |\n+\t\t\t((!!f->failed_ec)\t\t<< 3);\n \n \t\tbch2_printbuf_make_room(out, 1024);\n \t\tout->atomic++;\n@@ -77,7 +75,9 @@ void bch2_io_failures_to_text(struct printbuf *out,\n \n \t\tprt_char(out, ' ');\n \n-\t\tif (is_power_of_2(errflags)) {\n+\t\tif (!errflags) {\n+\t\t\tprt_str(out, \"no error - confused\");\n+\t\t} else if (is_power_of_2(errflags)) {\n \t\t\tprt_bitflags(out, error_types, errflags);\n \t\t\tprt_str(out, \" error\");\n \t\t} else {",
    "stats": {
      "insertions": 8,
      "deletions": 8,
      "files": 1
    }
  },
  {
    "sha": "63d6e9311999a3dd125ad3e0560a769e047fd7b1",
    "message": "bcachefs: bch2_fpunch_snapshot()\n\nAdd a new version of fpunch for operating on a snapshot ID, not a\nsubvolume - and use it for \"extent past end of inode\" repair.\n\nPreviously, repair would try to delete everything at once, but deleting\ntoo many extents at once can overflow the btree_trans bump allocator, as\nwell as causing other problems - the new helper properly uses\nbch2_extent_trim_atomic().\n\nReported-and-tested-by: Edoardo Codeglia <bcachefs@404.blue>\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>",
    "author": "Kent Overstreet",
    "date": "2025-07-04T15:45:22-04:00",
    "files_changed": [
      "fs/bcachefs/fsck.c",
      "fs/bcachefs/io_misc.c",
      "fs/bcachefs/io_misc.h"
    ],
    "diff": "diff --git a/fs/bcachefs/fsck.c b/fs/bcachefs/fsck.c\nindex dbf161e4311a..856eb2b41896 100644\n--- a/fs/bcachefs/fsck.c\n+++ b/fs/bcachefs/fsck.c\n@@ -12,6 +12,7 @@\n #include \"fs.h\"\n #include \"fsck.h\"\n #include \"inode.h\"\n+#include \"io_misc.h\"\n #include \"keylist.h\"\n #include \"namei.h\"\n #include \"recovery_passes.h\"\n@@ -1919,33 +1920,11 @@ static int check_extent(struct btree_trans *trans, struct btree_iter *iter,\n \t\t\t\t\t\"extent type past end of inode %llu:%u, i_size %llu\\n%s\",\n \t\t\t\t\ti->inode.bi_inum, i->inode.bi_snapshot, i->inode.bi_size,\n \t\t\t\t\t(bch2_bkey_val_to_text(&buf, c, k), buf.buf))) {\n-\t\t\t\tstruct bkey_i *whiteout = bch2_trans_kmalloc(trans, sizeof(*whiteout));\n-\t\t\t\tret = PTR_ERR_OR_ZERO(whiteout);\n-\t\t\t\tif (ret)\n-\t\t\t\t\tgoto err;\n-\n-\t\t\t\tbkey_init(&whiteout->k);\n-\t\t\t\twhiteout->k.p = SPOS(k.k->p.inode,\n-\t\t\t\t\t\t     last_block,\n-\t\t\t\t\t\t     i->inode.bi_snapshot);\n-\t\t\t\tbch2_key_resize(&whiteout->k,\n-\t\t\t\t\t\tmin(KEY_SIZE_MAX & (~0 << c->block_bits),\n-\t\t\t\t\t\t    U64_MAX - whiteout->k.p.offset));\n-\n-\n-\t\t\t\t/*\n-\t\t\t\t * Need a normal (not BTREE_ITER_all_snapshots)\n-\t\t\t\t * iterator, if we're deleting in a different\n-\t\t\t\t * snapshot and need to emit a whiteout\n-\t\t\t\t */\n-\t\t\t\tstruct btree_iter iter2;\n-\t\t\t\tbch2_trans_iter_init(trans, &iter2, BTREE_ID_extents,\n-\t\t\t\t\t\t     bkey_start_pos(&whiteout->k),\n-\t\t\t\t\t\t     BTREE_ITER_intent);\n-\t\t\t\tret =   bch2_btree_iter_traverse(trans, &iter2) ?:\n-\t\t\t\t\tbch2_trans_update(trans, &iter2, whiteout,\n-\t\t\t\t\t\tBTREE_UPDATE_internal_snapshot_node);\n-\t\t\t\tbch2_trans_iter_exit(trans, &iter2);\n+\t\t\t\tret = bch2_fpunch_snapshot(trans,\n+\t\t\t\t\t\t\t   SPOS(i->inode.bi_inum,\n+\t\t\t\t\t\t\t\tlast_block,\n+\t\t\t\t\t\t\t\ti->inode.bi_snapshot),\n+\t\t\t\t\t\t\t   POS(i->inode.bi_inum, U64_MAX));\n \t\t\t\tif (ret)\n \t\t\t\t\tgoto err;\n \ndiff --git a/fs/bcachefs/io_misc.c b/fs/bcachefs/io_misc.c\nindex bf72b1d2e2cb..07023667a475 100644\n--- a/fs/bcachefs/io_misc.c\n+++ b/fs/bcachefs/io_misc.c\n@@ -135,6 +135,33 @@ int bch2_extent_fallocate(struct btree_trans *trans,\n \treturn ret;\n }\n \n+/* For fsck */\n+int bch2_fpunch_snapshot(struct btree_trans *trans, struct bpos start, struct bpos end)\n+{\n+\tu32 restart_count = trans->restart_count;\n+\tstruct bch_fs *c = trans->c;\n+\tstruct disk_reservation disk_res = bch2_disk_reservation_init(c, 0);\n+\tunsigned max_sectors\t= KEY_SIZE_MAX & (~0 << c->block_bits);\n+\tstruct bkey_i delete;\n+\n+\tint ret = for_each_btree_key_max_commit(trans, iter, BTREE_ID_extents,\n+\t\t\tstart, end, 0, k,\n+\t\t\t&disk_res, NULL, BCH_TRANS_COMMIT_no_enospc, ({\n+\t\tbkey_init(&delete.k);\n+\t\tdelete.k.p = iter.pos;\n+\n+\t\t/* create the biggest key we can */\n+\t\tbch2_key_resize(&delete.k, max_sectors);\n+\t\tbch2_cut_back(end, &delete);\n+\n+\t\tbch2_extent_trim_atomic(trans, &iter, &delete) ?:\n+\t\tbch2_trans_update(trans, &iter, &delete, 0);\n+\t}));\n+\n+\tbch2_disk_reservation_put(c, &disk_res);\n+\treturn ret ?: trans_was_restarted(trans, restart_count);\n+}\n+\n /*\n  * Returns -BCH_ERR_transacton_restart if we had to drop locks:\n  */\ndiff --git a/fs/bcachefs/io_misc.h b/fs/bcachefs/io_misc.h\nindex 9cb44a7c43c1..b93e4d4b3c0c 100644\n--- a/fs/bcachefs/io_misc.h\n+++ b/fs/bcachefs/io_misc.h\n@@ -5,6 +5,8 @@\n int bch2_extent_fallocate(struct btree_trans *, subvol_inum, struct btree_iter *,\n \t\t\t  u64, struct bch_io_opts, s64 *,\n \t\t\t  struct write_point_specifier);\n+\n+int bch2_fpunch_snapshot(struct btree_trans *, struct bpos, struct bpos);\n int bch2_fpunch_at(struct btree_trans *, struct btree_iter *,\n \t\t   subvol_inum, u64, s64 *);\n int bch2_fpunch(struct bch_fs *c, subvol_inum, u64, u64, s64 *);",
    "stats": {
      "insertions": 35,
      "deletions": 27,
      "files": 3
    }
  },
  {
    "sha": "b1bf2ef6259e6aedc3f952ebd9bc056605563b74",
    "message": "Merge tag 'soc-fixes-6.16' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc\n\nPull SoC fixes from Arnd Bergmann:\n \"A couple of fixes for firmware drivers have come up, addressing kernel\n  side bugs in op-tee and ff-a code, as well as compatibility issues\n  with exynos-acpm and ff-a protocols.\n\n  The only devicetree fixes are for the Apple platform, addressing\n  issues with conformance to the bindings for the wlan, spi and mipi\n  nodes\"\n\n* tag 'soc-fixes-6.16' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc:\n  arm64: dts: apple: Move touchbar mipi {address,size}-cells from dtsi to dts\n  arm64: dts: apple: Drop {address,size}-cells from SPI NOR\n  arm64: dts: apple: t8103: Fix PCIe BCM4377 nodename\n  optee: ffa: fix sleep in atomic context\n  firmware: exynos-acpm: fix timeouts on xfers handling\n  arm64: defconfig: update renamed PHY_SNPS_EUSB2\n  firmware: arm_ffa: Fix the missing entry in struct ffa_indirect_msg_hdr\n  firmware: arm_ffa: Replace mutex with rwlock to avoid sleep in atomic context\n  firmware: arm_ffa: Move memory allocation outside the mutex locking\n  firmware: arm_ffa: Fix memory leak by freeing notifier callback node",
    "author": "Linus Torvalds",
    "date": "2025-07-04T12:05:36-07:00",
    "files_changed": [
      "drivers/firmware/arm_ffa/driver.c",
      "drivers/firmware/samsung/exynos-acpm.c",
      "drivers/tee/optee/ffa_abi.c",
      "drivers/tee/optee/optee_private.h",
      "include/linux/arm_ffa.h"
    ],
    "diff": "diff --git a/arch/arm64/boot/dts/apple/spi1-nvram.dtsi b/arch/arm64/boot/dts/apple/spi1-nvram.dtsi\nindex 3df2fd3993b5..9740fbf200f0 100644\n--- a/arch/arm64/boot/dts/apple/spi1-nvram.dtsi\n+++ b/arch/arm64/boot/dts/apple/spi1-nvram.dtsi\n@@ -20,8 +20,6 @@ flash@0 {\n \t\tcompatible = \"jedec,spi-nor\";\n \t\treg = <0x0>;\n \t\tspi-max-frequency = <25000000>;\n-\t\t#address-cells = <1>;\n-\t\t#size-cells = <1>;\n \n \t\tpartitions {\n \t\t\tcompatible = \"fixed-partitions\";\ndiff --git a/arch/arm64/boot/dts/apple/t8103-j293.dts b/arch/arm64/boot/dts/apple/t8103-j293.dts\nindex e2d9439397f7..5b3c42e9f0e6 100644\n--- a/arch/arm64/boot/dts/apple/t8103-j293.dts\n+++ b/arch/arm64/boot/dts/apple/t8103-j293.dts\n@@ -100,6 +100,8 @@ dfr_mipi_out_panel: endpoint@0 {\n \n &displaydfr_mipi {\n \tstatus = \"okay\";\n+\t#address-cells = <1>;\n+\t#size-cells = <0>;\n \n \tdfr_panel: panel@0 {\n \t\tcompatible = \"apple,j293-summit\", \"apple,summit\";\ndiff --git a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi\nindex 8e82231acab5..0c8206156bfe 100644\n--- a/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi\n+++ b/arch/arm64/boot/dts/apple/t8103-jxxx.dtsi\n@@ -71,7 +71,7 @@ hpm1: usb-pd@3f {\n  */\n &port00 {\n \tbus-range = <1 1>;\n-\twifi0: network@0,0 {\n+\twifi0: wifi@0,0 {\n \t\tcompatible = \"pci14e4,4425\";\n \t\treg = <0x10000 0x0 0x0 0x0 0x0>;\n \t\t/* To be filled by the loader */\ndiff --git a/arch/arm64/boot/dts/apple/t8103.dtsi b/arch/arm64/boot/dts/apple/t8103.dtsi\nindex 20faf0c0d809..3a204845b85b 100644\n--- a/arch/arm64/boot/dts/apple/t8103.dtsi\n+++ b/arch/arm64/boot/dts/apple/t8103.dtsi\n@@ -405,8 +405,6 @@ displaydfr_mipi: dsi@228600000 {\n \t\t\tcompatible = \"apple,t8103-display-pipe-mipi\", \"apple,h7-display-pipe-mipi\";\n \t\t\treg = <0x2 0x28600000 0x0 0x100000>;\n \t\t\tpower-domains = <&ps_mipi_dsi>;\n-\t\t\t#address-cells = <1>;\n-\t\t\t#size-cells = <0>;\n \t\t\tstatus = \"disabled\";\n \n \t\t\tports {\ndiff --git a/arch/arm64/boot/dts/apple/t8112-j493.dts b/arch/arm64/boot/dts/apple/t8112-j493.dts\nindex be86d34c6696..fb8ad7d4c65a 100644\n--- a/arch/arm64/boot/dts/apple/t8112-j493.dts\n+++ b/arch/arm64/boot/dts/apple/t8112-j493.dts\n@@ -63,6 +63,8 @@ dfr_mipi_out_panel: endpoint@0 {\n \n &displaydfr_mipi {\n \tstatus = \"okay\";\n+\t#address-cells = <1>;\n+\t#size-cells = <0>;\n \n \tdfr_panel: panel@0 {\n \t\tcompatible = \"apple,j493-summit\", \"apple,summit\";\ndiff --git a/arch/arm64/boot/dts/apple/t8112.dtsi b/arch/arm64/boot/dts/apple/t8112.dtsi\nindex e95711d8337f..f68354194355 100644\n--- a/arch/arm64/boot/dts/apple/t8112.dtsi\n+++ b/arch/arm64/boot/dts/apple/t8112.dtsi\n@@ -420,8 +420,6 @@ displaydfr_mipi: dsi@228600000 {\n \t\t\tcompatible = \"apple,t8112-display-pipe-mipi\", \"apple,h7-display-pipe-mipi\";\n \t\t\treg = <0x2 0x28600000 0x0 0x100000>;\n \t\t\tpower-domains = <&ps_mipi_dsi>;\n-\t\t\t#address-cells = <1>;\n-\t\t\t#size-cells = <0>;\n \t\t\tstatus = \"disabled\";\n \n \t\t\tports {\ndiff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig\nindex 897fc686e6a9..7e04a2905ce4 100644\n--- a/arch/arm64/configs/defconfig\n+++ b/arch/arm64/configs/defconfig\n@@ -1573,6 +1573,7 @@ CONFIG_RESET_QCOM_AOSS=y\n CONFIG_RESET_QCOM_PDC=m\n CONFIG_RESET_RZG2L_USBPHY_CTRL=y\n CONFIG_RESET_TI_SCI=y\n+CONFIG_PHY_SNPS_EUSB2=m\n CONFIG_PHY_XGENE=y\n CONFIG_PHY_CAN_TRANSCEIVER=m\n CONFIG_PHY_NXP_PTN3222=m\n@@ -1597,7 +1598,6 @@ CONFIG_PHY_QCOM_EDP=m\n CONFIG_PHY_QCOM_PCIE2=m\n CONFIG_PHY_QCOM_QMP=m\n CONFIG_PHY_QCOM_QUSB2=m\n-CONFIG_PHY_QCOM_SNPS_EUSB2=m\n CONFIG_PHY_QCOM_EUSB2_REPEATER=m\n CONFIG_PHY_QCOM_M31_USB=m\n CONFIG_PHY_QCOM_USB_HS=m\ndiff --git a/drivers/firmware/arm_ffa/driver.c b/drivers/firmware/arm_ffa/driver.c\nindex fe55613a8ea9..37eb2e6c2f9f 100644\n--- a/drivers/firmware/arm_ffa/driver.c\n+++ b/drivers/firmware/arm_ffa/driver.c\n@@ -110,7 +110,7 @@ struct ffa_drv_info {\n \tstruct work_struct sched_recv_irq_work;\n \tstruct xarray partition_info;\n \tDECLARE_HASHTABLE(notifier_hash, ilog2(FFA_MAX_NOTIFICATIONS));\n-\tstruct mutex notify_lock; /* lock to protect notifier hashtable  */\n+\trwlock_t notify_lock; /* lock to protect notifier hashtable  */\n };\n \n static struct ffa_drv_info *drv_info;\n@@ -1250,13 +1250,12 @@ notifier_hnode_get_by_type(u16 notify_id, enum notify_type type)\n \treturn NULL;\n }\n \n-static int\n-update_notifier_cb(struct ffa_device *dev, int notify_id, void *cb,\n-\t\t   void *cb_data, bool is_registration, bool is_framework)\n+static int update_notifier_cb(struct ffa_device *dev, int notify_id,\n+\t\t\t      struct notifier_cb_info *cb, bool is_framework)\n {\n \tstruct notifier_cb_info *cb_info = NULL;\n \tenum notify_type type = ffa_notify_type_get(dev->vm_id);\n-\tbool cb_found;\n+\tbool cb_found, is_registration = !!cb;\n \n \tif (is_framework)\n \t\tcb_info = notifier_hnode_get_by_vmid_uuid(notify_id, dev->vm_id,\n@@ -1270,20 +1269,10 @@ update_notifier_cb(struct ffa_device *dev, int notify_id, void *cb,\n \t\treturn -EINVAL;\n \n \tif (is_registration) {\n-\t\tcb_info = kzalloc(sizeof(*cb_info), GFP_KERNEL);\n-\t\tif (!cb_info)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tcb_info->dev = dev;\n-\t\tcb_info->cb_data = cb_data;\n-\t\tif (is_framework)\n-\t\t\tcb_info->fwk_cb = cb;\n-\t\telse\n-\t\t\tcb_info->cb = cb;\n-\n-\t\thash_add(drv_info->notifier_hash, &cb_info->hnode, notify_id);\n+\t\thash_add(drv_info->notifier_hash, &cb->hnode, notify_id);\n \t} else {\n \t\thash_del(&cb_info->hnode);\n+\t\tkfree(cb_info);\n \t}\n \n \treturn 0;\n@@ -1300,20 +1289,19 @@ static int __ffa_notify_relinquish(struct ffa_device *dev, int notify_id,\n \tif (notify_id >= FFA_MAX_NOTIFICATIONS)\n \t\treturn -EINVAL;\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\twrite_lock(&drv_info->notify_lock);\n \n-\trc = update_notifier_cb(dev, notify_id, NULL, NULL, false,\n-\t\t\t\tis_framework);\n+\trc = update_notifier_cb(dev, notify_id, NULL, is_framework);\n \tif (rc) {\n \t\tpr_err(\"Could not unregister notification callback\\n\");\n-\t\tmutex_unlock(&drv_info->notify_lock);\n+\t\twrite_unlock(&drv_info->notify_lock);\n \t\treturn rc;\n \t}\n \n \tif (!is_framework)\n \t\trc = ffa_notification_unbind(dev->vm_id, BIT(notify_id));\n \n-\tmutex_unlock(&drv_info->notify_lock);\n+\twrite_unlock(&drv_info->notify_lock);\n \n \treturn rc;\n }\n@@ -1334,6 +1322,7 @@ static int __ffa_notify_request(struct ffa_device *dev, bool is_per_vcpu,\n {\n \tint rc;\n \tu32 flags = 0;\n+\tstruct notifier_cb_info *cb_info = NULL;\n \n \tif (ffa_notifications_disabled())\n \t\treturn -EOPNOTSUPP;\n@@ -1341,28 +1330,40 @@ static int __ffa_notify_request(struct ffa_device *dev, bool is_per_vcpu,\n \tif (notify_id >= FFA_MAX_NOTIFICATIONS)\n \t\treturn -EINVAL;\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\tcb_info = kzalloc(sizeof(*cb_info), GFP_KERNEL);\n+\tif (!cb_info)\n+\t\treturn -ENOMEM;\n+\n+\tcb_info->dev = dev;\n+\tcb_info->cb_data = cb_data;\n+\tif (is_framework)\n+\t\tcb_info->fwk_cb = cb;\n+\telse\n+\t\tcb_info->cb = cb;\n+\n+\twrite_lock(&drv_info->notify_lock);\n \n \tif (!is_framework) {\n \t\tif (is_per_vcpu)\n \t\t\tflags = PER_VCPU_NOTIFICATION_FLAG;\n \n \t\trc = ffa_notification_bind(dev->vm_id, BIT(notify_id), flags);\n-\t\tif (rc) {\n-\t\t\tmutex_unlock(&drv_info->notify_lock);\n-\t\t\treturn rc;\n-\t\t}\n+\t\tif (rc)\n+\t\t\tgoto out_unlock_free;\n \t}\n \n-\trc = update_notifier_cb(dev, notify_id, cb, cb_data, true,\n-\t\t\t\tis_framework);\n+\trc = update_notifier_cb(dev, notify_id, cb_info, is_framework);\n \tif (rc) {\n \t\tpr_err(\"Failed to register callback for %d - %d\\n\",\n \t\t       notify_id, rc);\n \t\tif (!is_framework)\n \t\t\tffa_notification_unbind(dev->vm_id, BIT(notify_id));\n \t}\n-\tmutex_unlock(&drv_info->notify_lock);\n+\n+out_unlock_free:\n+\twrite_unlock(&drv_info->notify_lock);\n+\tif (rc)\n+\t\tkfree(cb_info);\n \n \treturn rc;\n }\n@@ -1406,9 +1407,9 @@ static void handle_notif_callbacks(u64 bitmap, enum notify_type type)\n \t\tif (!(bitmap & 1))\n \t\t\tcontinue;\n \n-\t\tmutex_lock(&drv_info->notify_lock);\n+\t\tread_lock(&drv_info->notify_lock);\n \t\tcb_info = notifier_hnode_get_by_type(notify_id, type);\n-\t\tmutex_unlock(&drv_info->notify_lock);\n+\t\tread_unlock(&drv_info->notify_lock);\n \n \t\tif (cb_info && cb_info->cb)\n \t\t\tcb_info->cb(notify_id, cb_info->cb_data);\n@@ -1446,9 +1447,9 @@ static void handle_fwk_notif_callbacks(u32 bitmap)\n \n \tffa_rx_release();\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\tread_lock(&drv_info->notify_lock);\n \tcb_info = notifier_hnode_get_by_vmid_uuid(notify_id, target, &uuid);\n-\tmutex_unlock(&drv_info->notify_lock);\n+\tread_unlock(&drv_info->notify_lock);\n \n \tif (cb_info && cb_info->fwk_cb)\n \t\tcb_info->fwk_cb(notify_id, cb_info->cb_data, buf);\n@@ -1973,7 +1974,7 @@ static void ffa_notifications_setup(void)\n \t\tgoto cleanup;\n \n \thash_init(drv_info->notifier_hash);\n-\tmutex_init(&drv_info->notify_lock);\n+\trwlock_init(&drv_info->notify_lock);\n \n \tdrv_info->notif_enabled = true;\n \treturn;\ndiff --git a/drivers/firmware/samsung/exynos-acpm.c b/drivers/firmware/samsung/exynos-acpm.c\nindex e02f14f4bd7c..3a69fe3234c7 100644\n--- a/drivers/firmware/samsung/exynos-acpm.c\n+++ b/drivers/firmware/samsung/exynos-acpm.c\n@@ -430,6 +430,9 @@ int acpm_do_xfer(const struct acpm_handle *handle, const struct acpm_xfer *xfer)\n \t\treturn -EOPNOTSUPP;\n \t}\n \n+\tmsg.chan_id = xfer->acpm_chan_id;\n+\tmsg.chan_type = EXYNOS_MBOX_CHAN_TYPE_DOORBELL;\n+\n \tscoped_guard(mutex, &achan->tx_lock) {\n \t\ttx_front = readl(achan->tx.front);\n \t\tidx = (tx_front + 1) % achan->qlen;\n@@ -446,25 +449,15 @@ int acpm_do_xfer(const struct acpm_handle *handle, const struct acpm_xfer *xfer)\n \n \t\t/* Advance TX front. */\n \t\twritel(idx, achan->tx.front);\n-\t}\n \n-\tmsg.chan_id = xfer->acpm_chan_id;\n-\tmsg.chan_type = EXYNOS_MBOX_CHAN_TYPE_DOORBELL;\n-\tret = mbox_send_message(achan->chan, (void *)&msg);\n-\tif (ret < 0)\n-\t\treturn ret;\n-\n-\tret = acpm_wait_for_message_response(achan, xfer);\n+\t\tret = mbox_send_message(achan->chan, (void *)&msg);\n+\t\tif (ret < 0)\n+\t\t\treturn ret;\n \n-\t/*\n-\t * NOTE: we might prefer not to need the mailbox ticker to manage the\n-\t * transfer queueing since the protocol layer queues things by itself.\n-\t * Unfortunately, we have to kick the mailbox framework after we have\n-\t * received our message.\n-\t */\n-\tmbox_client_txdone(achan->chan, ret);\n+\t\tmbox_client_txdone(achan->chan, 0);\n+\t}\n \n-\treturn ret;\n+\treturn acpm_wait_for_message_response(achan, xfer);\n }\n \n /**\ndiff --git a/drivers/tee/optee/ffa_abi.c b/drivers/tee/optee/ffa_abi.c\nindex f3af5666bb11..f9ef7d94cebd 100644\n--- a/drivers/tee/optee/ffa_abi.c\n+++ b/drivers/tee/optee/ffa_abi.c\n@@ -728,12 +728,21 @@ static bool optee_ffa_exchange_caps(struct ffa_device *ffa_dev,\n \treturn true;\n }\n \n+static void notif_work_fn(struct work_struct *work)\n+{\n+\tstruct optee_ffa *optee_ffa = container_of(work, struct optee_ffa,\n+\t\t\t\t\t\t   notif_work);\n+\tstruct optee *optee = container_of(optee_ffa, struct optee, ffa);\n+\n+\toptee_do_bottom_half(optee->ctx);\n+}\n+\n static void notif_callback(int notify_id, void *cb_data)\n {\n \tstruct optee *optee = cb_data;\n \n \tif (notify_id == optee->ffa.bottom_half_value)\n-\t\toptee_do_bottom_half(optee->ctx);\n+\t\tqueue_work(optee->ffa.notif_wq, &optee->ffa.notif_work);\n \telse\n \t\toptee_notif_send(optee, notify_id);\n }\n@@ -817,9 +826,11 @@ static void optee_ffa_remove(struct ffa_device *ffa_dev)\n \tstruct optee *optee = ffa_dev_get_drvdata(ffa_dev);\n \tu32 bottom_half_id = optee->ffa.bottom_half_value;\n \n-\tif (bottom_half_id != U32_MAX)\n+\tif (bottom_half_id != U32_MAX) {\n \t\tffa_dev->ops->notifier_ops->notify_relinquish(ffa_dev,\n \t\t\t\t\t\t\t      bottom_half_id);\n+\t\tdestroy_workqueue(optee->ffa.notif_wq);\n+\t}\n \toptee_remove_common(optee);\n \n \tmutex_destroy(&optee->ffa.mutex);\n@@ -835,6 +846,13 @@ static int optee_ffa_async_notif_init(struct ffa_device *ffa_dev,\n \tu32 notif_id = 0;\n \tint rc;\n \n+\tINIT_WORK(&optee->ffa.notif_work, notif_work_fn);\n+\toptee->ffa.notif_wq = create_workqueue(\"optee_notification\");\n+\tif (!optee->ffa.notif_wq) {\n+\t\trc = -EINVAL;\n+\t\tgoto err;\n+\t}\n+\n \twhile (true) {\n \t\trc = ffa_dev->ops->notifier_ops->notify_request(ffa_dev,\n \t\t\t\t\t\t\t\tis_per_vcpu,\n@@ -851,19 +869,24 @@ static int optee_ffa_async_notif_init(struct ffa_device *ffa_dev,\n \t\t * notifications in that case.\n \t\t */\n \t\tif (rc != -EACCES)\n-\t\t\treturn rc;\n+\t\t\tgoto err_wq;\n \t\tnotif_id++;\n \t\tif (notif_id >= OPTEE_FFA_MAX_ASYNC_NOTIF_VALUE)\n-\t\t\treturn rc;\n+\t\t\tgoto err_wq;\n \t}\n \toptee->ffa.bottom_half_value = notif_id;\n \n \trc = enable_async_notif(optee);\n-\tif (rc < 0) {\n-\t\tffa_dev->ops->notifier_ops->notify_relinquish(ffa_dev,\n-\t\t\t\t\t\t\t      notif_id);\n-\t\toptee->ffa.bottom_half_value = U32_MAX;\n-\t}\n+\tif (rc < 0)\n+\t\tgoto err_rel;\n+\n+\treturn 0;\n+err_rel:\n+\tffa_dev->ops->notifier_ops->notify_relinquish(ffa_dev, notif_id);\n+err_wq:\n+\tdestroy_workqueue(optee->ffa.notif_wq);\n+err:\n+\toptee->ffa.bottom_half_value = U32_MAX;\n \n \treturn rc;\n }\ndiff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h\nindex dc0f355ef72a..9526087f0e68 100644\n--- a/drivers/tee/optee/optee_private.h\n+++ b/drivers/tee/optee/optee_private.h\n@@ -165,6 +165,8 @@ struct optee_ffa {\n \t/* Serializes access to @global_ids */\n \tstruct mutex mutex;\n \tstruct rhashtable global_ids;\n+\tstruct workqueue_struct *notif_wq;\n+\tstruct work_struct notif_work;\n };\n \n struct optee;\ndiff --git a/include/linux/arm_ffa.h b/include/linux/arm_ffa.h\nindex 5bded24dc24f..e1634897e159 100644\n--- a/include/linux/arm_ffa.h\n+++ b/include/linux/arm_ffa.h\n@@ -283,6 +283,7 @@ struct ffa_indirect_msg_hdr {\n \tu32 offset;\n \tu32 send_recv_id;\n \tu32 size;\n+\tu32 res1;\n \tuuid_t uuid;\n };\n ",
    "stats": {
      "insertions": 86,
      "deletions": 68,
      "files": 12
    }
  }
]
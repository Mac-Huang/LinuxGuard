[
  {
    "sha": "3ef07434c7dbfba302df477bb6c70e082965f232",
    "message": "net: airoha: Fix an error handling path in airoha_probe()\n\nIf an error occurs after a successful airoha_hw_init() call,\nairoha_ppe_deinit() needs to be called as already done in the remove\nfunction.\n\nFixes: 00a7678310fe (\"net: airoha: Introduce flowtable offload support\")\nSigned-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>\nReviewed-by: Simon Horman <horms@kernel.org>\nAcked-by: Lorenzo Bianconi <lorenzo@kernel.org>\nLink: https://patch.msgid.link/1c940851b4fa3c3ed2a142910c821493a136f121.1746715755.git.christophe.jaillet@wanadoo.fr\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Christophe JAILLET",
    "date": "2025-07-08T08:59:24-07:00",
    "files_changed": [
      "drivers/net/ethernet/airoha/airoha_eth.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/airoha/airoha_eth.c b/drivers/net/ethernet/airoha/airoha_eth.c\nindex 06dea3a13e77..9057180051df 100644\n--- a/drivers/net/ethernet/airoha/airoha_eth.c\n+++ b/drivers/net/ethernet/airoha/airoha_eth.c\n@@ -2984,6 +2984,7 @@ static int airoha_probe(struct platform_device *pdev)\n error_napi_stop:\n \tfor (i = 0; i < ARRAY_SIZE(eth->qdma); i++)\n \t\tairoha_qdma_stop_napi(&eth->qdma[i]);\n+\tairoha_ppe_deinit(eth);\n error_hw_cleanup:\n \tfor (i = 0; i < ARRAY_SIZE(eth->qdma); i++)\n \t\tairoha_hw_cleanup(&eth->qdma[i]);",
    "stats": {
      "insertions": 1,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "d006330be3f782ff3fb7c3ed51e617e01f29a465",
    "message": "Merge tag 'sound-6.16-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound\n\nPull sound fixes from Takashi Iwai:\n \"Here are device-specific small fixes, including HD-audio, USB-audio\n  and ASoC Intel quirks, as well as ASoC fsl, Cirrus codec and the\n  legacy AD driver fixes.\n\n  All look safe and easy\"\n\n* tag 'sound-6.16-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:\n  ALSA: hda/realtek: Enable headset Mic on Positivo K116J\n  ALSA: hda/tas2781: Fix calibration data parser issue\n  ALSA: ad1816a: Fix potential NULL pointer deref in snd_card_ad1816a_pnp()\n  ASoC: cs35l56: probe() should fail if the device ID is not recognized\n  ALSA: hda/realtek: Add quirk for ASUS ExpertBook B9403CVAR\n  ASoC: Intel: sof_sdw: Add quirks for Lenovo P1 and P16\n  ALSA: usb-audio: Improve filtering of sample rates on Focusrite devices\n  ASoC: Intel: soc-acpi: arl: Correct order of cs42l43 matches\n  MAINTAINERS: update Qualcomm audio codec drivers list\n  ASoC: fsl_sai: Force a software reset when starting in consumer mode\n  ASoC: Intel: SND_SOC_INTEL_SOF_BOARD_HELPERS select SND_SOC_ACPI_INTEL_MATCH\n  ASoC: fsl_asrc: use internal measured ratio for non-ideal ratio mode\n  ALSA: hda/realtek - Add mute LED support for HP Victus 15-fb2xxx\n  ALSA: hda: Add missing NVIDIA HDA codec IDs",
    "author": "Linus Torvalds",
    "date": "2025-07-08T08:55:18-07:00",
    "files_changed": [
      "sound/isa/ad1816a/ad1816a.c",
      "sound/pci/hda/patch_hdmi.c",
      "sound/pci/hda/patch_realtek.c",
      "sound/pci/hda/tas2781_hda.c",
      "sound/soc/codecs/cs35l56-shared.c",
      "sound/soc/fsl/fsl_asrc.c",
      "sound/soc/fsl/fsl_sai.c",
      "sound/soc/intel/boards/sof_sdw.c",
      "sound/soc/intel/common/soc-acpi-intel-arl-match.c",
      "sound/usb/format.c"
    ],
    "diff": "diff --git a/MAINTAINERS b/MAINTAINERS\nindex fad6cb025a19..1ff244fe3e1a 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -20155,21 +20155,15 @@ S:\tSupported\n F:\tDocumentation/devicetree/bindings/soc/qcom/qcom,apr*\n F:\tDocumentation/devicetree/bindings/sound/qcom,*\n F:\tdrivers/soc/qcom/apr.c\n-F:\tinclude/dt-bindings/sound/qcom,wcd9335.h\n-F:\tinclude/dt-bindings/sound/qcom,wcd934x.h\n-F:\tsound/soc/codecs/lpass-rx-macro.*\n-F:\tsound/soc/codecs/lpass-tx-macro.*\n-F:\tsound/soc/codecs/lpass-va-macro.c\n-F:\tsound/soc/codecs/lpass-wsa-macro.*\n+F:\tdrivers/soundwire/qcom.c\n+F:\tinclude/dt-bindings/sound/qcom,wcd93*\n+F:\tsound/soc/codecs/lpass-*.*\n F:\tsound/soc/codecs/msm8916-wcd-analog.c\n F:\tsound/soc/codecs/msm8916-wcd-digital.c\n F:\tsound/soc/codecs/wcd-clsh-v2.*\n F:\tsound/soc/codecs/wcd-mbhc-v2.*\n-F:\tsound/soc/codecs/wcd9335.*\n-F:\tsound/soc/codecs/wcd934x.c\n-F:\tsound/soc/codecs/wsa881x.c\n-F:\tsound/soc/codecs/wsa883x.c\n-F:\tsound/soc/codecs/wsa884x.c\n+F:\tsound/soc/codecs/wcd93*.*\n+F:\tsound/soc/codecs/wsa88*.*\n F:\tsound/soc/qcom/\n \n QCOM EMBEDDED USB DEBUGGER (EUD)\ndiff --git a/sound/isa/ad1816a/ad1816a.c b/sound/isa/ad1816a/ad1816a.c\nindex 99006dc4777e..5c9e2d41d900 100644\n--- a/sound/isa/ad1816a/ad1816a.c\n+++ b/sound/isa/ad1816a/ad1816a.c\n@@ -98,7 +98,7 @@ static int snd_card_ad1816a_pnp(int dev, struct pnp_card_link *card,\n \tpdev = pnp_request_card_device(card, id->devs[1].id, NULL);\n \tif (pdev == NULL) {\n \t\tmpu_port[dev] = -1;\n-\t\tdev_warn(&pdev->dev, \"MPU401 device busy, skipping.\\n\");\n+\t\tpr_warn(\"MPU401 device busy, skipping.\\n\");\n \t\treturn 0;\n \t}\n \ndiff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c\nindex 08308231b4ed..9a7793eb16e9 100644\n--- a/sound/pci/hda/patch_hdmi.c\n+++ b/sound/pci/hda/patch_hdmi.c\n@@ -4551,7 +4551,9 @@ HDA_CODEC_ENTRY(0x10de002e, \"Tegra186 HDMI/DP1\", patch_tegra_hdmi),\n HDA_CODEC_ENTRY(0x10de002f, \"Tegra194 HDMI/DP2\", patch_tegra_hdmi),\n HDA_CODEC_ENTRY(0x10de0030, \"Tegra194 HDMI/DP3\", patch_tegra_hdmi),\n HDA_CODEC_ENTRY(0x10de0031, \"Tegra234 HDMI/DP\", patch_tegra234_hdmi),\n+HDA_CODEC_ENTRY(0x10de0033, \"SoC 33 HDMI/DP\",\tpatch_tegra234_hdmi),\n HDA_CODEC_ENTRY(0x10de0034, \"Tegra264 HDMI/DP\",\tpatch_tegra234_hdmi),\n+HDA_CODEC_ENTRY(0x10de0035, \"SoC 35 HDMI/DP\",\tpatch_tegra234_hdmi),\n HDA_CODEC_ENTRY(0x10de0040, \"GPU 40 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de0041, \"GPU 41 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de0042, \"GPU 42 HDMI/DP\",\tpatch_nvhdmi),\n@@ -4590,15 +4592,32 @@ HDA_CODEC_ENTRY(0x10de0097, \"GPU 97 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de0098, \"GPU 98 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de0099, \"GPU 99 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de009a, \"GPU 9a HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de009b, \"GPU 9b HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de009c, \"GPU 9c HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de009d, \"GPU 9d HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de009e, \"GPU 9e HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de009f, \"GPU 9f HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a0, \"GPU a0 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00a1, \"GPU a1 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a3, \"GPU a3 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a4, \"GPU a4 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a5, \"GPU a5 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a6, \"GPU a6 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de00a7, \"GPU a7 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00a8, \"GPU a8 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00a9, \"GPU a9 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00aa, \"GPU aa HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00ab, \"GPU ab HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00ad, \"GPU ad HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00ae, \"GPU ae HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00af, \"GPU af HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00b0, \"GPU b0 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00b1, \"GPU b1 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00c0, \"GPU c0 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00c1, \"GPU c1 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00c3, \"GPU c3 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00c4, \"GPU c4 HDMI/DP\",\tpatch_nvhdmi),\n+HDA_CODEC_ENTRY(0x10de00c5, \"GPU c5 HDMI/DP\",\tpatch_nvhdmi),\n HDA_CODEC_ENTRY(0x10de8001, \"MCP73 HDMI\",\tpatch_nvhdmi_2ch),\n HDA_CODEC_ENTRY(0x10de8067, \"MCP67/68 HDMI\",\tpatch_nvhdmi_2ch),\n HDA_CODEC_ENTRY(0x67663d82, \"Arise 82 HDMI/DP\",\tpatch_gf_hdmi),\ndiff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c\nindex 5d6d01ecfee2..060db37eab83 100644\n--- a/sound/pci/hda/patch_realtek.c\n+++ b/sound/pci/hda/patch_realtek.c\n@@ -10881,6 +10881,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8ce0, \"HP SnowWhite\", ALC287_FIXUP_CS35L41_I2C_2_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8cf5, \"HP ZBook Studio 16\", ALC245_FIXUP_CS35L41_SPI_4_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8d01, \"HP ZBook Power 14 G12\", ALC285_FIXUP_HP_GPIO_LED),\n+\tSND_PCI_QUIRK(0x103c, 0x8d07, \"HP Victus 15-fb2xxx (MB 8D07)\", ALC245_FIXUP_HP_MUTE_LED_COEFBIT),\n \tSND_PCI_QUIRK(0x103c, 0x8d18, \"HP EliteStudio 8 AIO\", ALC274_FIXUP_HP_AIO_BIND_DACS),\n \tSND_PCI_QUIRK(0x103c, 0x8d84, \"HP EliteBook X G1i\", ALC285_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8d85, \"HP EliteBook 14 G12\", ALC285_FIXUP_HP_GPIO_LED),\n@@ -11040,6 +11041,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1043, 0x1e63, \"ASUS H7606W\", ALC285_FIXUP_ASUS_GU605_SPI_SPEAKER2_TO_DAC1),\n \tSND_PCI_QUIRK(0x1043, 0x1e83, \"ASUS GA605W\", ALC285_FIXUP_ASUS_GU605_SPI_SPEAKER2_TO_DAC1),\n \tSND_PCI_QUIRK(0x1043, 0x1e8e, \"ASUS Zephyrus G15\", ALC289_FIXUP_ASUS_GA401),\n+\tSND_PCI_QUIRK(0x1043, 0x1e93, \"ASUS ExpertBook B9403CVAR\", ALC294_FIXUP_ASUS_HPE),\n \tSND_PCI_QUIRK(0x1043, 0x1eb3, \"ASUS Ally RCLA72\", ALC287_FIXUP_TAS2781_I2C),\n \tSND_PCI_QUIRK(0x1043, 0x1ed3, \"ASUS HN7306W\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x1043, 0x1ee2, \"ASUS UM6702RA/RC\", ALC287_FIXUP_CS35L41_I2C_2),\n@@ -11424,6 +11426,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x2782, 0x0228, \"Infinix ZERO BOOK 13\", ALC269VB_FIXUP_INFINIX_ZERO_BOOK_13),\n \tSND_PCI_QUIRK(0x2782, 0x0232, \"CHUWI CoreBook XPro\", ALC269VB_FIXUP_CHUWI_COREBOOK_XPRO),\n \tSND_PCI_QUIRK(0x2782, 0x1407, \"Positivo P15X\", ALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC),\n+\tSND_PCI_QUIRK(0x2782, 0x1409, \"Positivo K116J\", ALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC),\n \tSND_PCI_QUIRK(0x2782, 0x1701, \"Infinix Y4 Max\", ALC269VC_FIXUP_INFINIX_Y4_MAX),\n \tSND_PCI_QUIRK(0x2782, 0x1705, \"MEDION E15433\", ALC269VC_FIXUP_INFINIX_Y4_MAX),\n \tSND_PCI_QUIRK(0x2782, 0x1707, \"Vaio VJFE-ADL\", ALC298_FIXUP_SPK_VOLUME),\ndiff --git a/sound/pci/hda/tas2781_hda.c b/sound/pci/hda/tas2781_hda.c\nindex 5f1d4b3e9688..34217ce9f28e 100644\n--- a/sound/pci/hda/tas2781_hda.c\n+++ b/sound/pci/hda/tas2781_hda.c\n@@ -44,7 +44,7 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\tTASDEVICE_REG(0, 0x13, 0x70),\n \t\tTASDEVICE_REG(0, 0x18, 0x7c),\n \t};\n-\tunsigned int crc, oft;\n+\tunsigned int crc, oft, node_num;\n \tunsigned char *buf;\n \tint i, j, k, l;\n \n@@ -80,8 +80,9 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\t\tdev_err(p->dev, \"%s: CRC error\\n\", __func__);\n \t\t\treturn;\n \t\t}\n+\t\tnode_num = tmp_val[1];\n \n-\t\tfor (j = 0, k = 0; j < tmp_val[1]; j++) {\n+\t\tfor (j = 0, k = 0; j < node_num; j++) {\n \t\t\toft = j * 6 + 3;\n \t\t\tif (tmp_val[oft] == TASDEV_UEFI_CALI_REG_ADDR_FLG) {\n \t\t\t\tfor (i = 0; i < TASDEV_CALIB_N; i++) {\n@@ -99,8 +100,9 @@ static void tas2781_apply_calib(struct tasdevice_priv *p)\n \t\t\t\t}\n \n \t\t\t\tdata[l] = k;\n+\t\t\t\toft++;\n \t\t\t\tfor (i = 0; i < TASDEV_CALIB_N * 4; i++)\n-\t\t\t\t\tdata[l + i] = data[4 * oft + i];\n+\t\t\t\t\tdata[l + i + 1] = data[4 * oft + i];\n \t\t\t\tk++;\n \t\t\t}\n \t\t}\ndiff --git a/sound/soc/codecs/cs35l56-shared.c b/sound/soc/codecs/cs35l56-shared.c\nindex d0831d609584..ba653f6ccfae 100644\n--- a/sound/soc/codecs/cs35l56-shared.c\n+++ b/sound/soc/codecs/cs35l56-shared.c\n@@ -980,7 +980,7 @@ int cs35l56_hw_init(struct cs35l56_base *cs35l56_base)\n \t\tbreak;\n \tdefault:\n \t\tdev_err(cs35l56_base->dev, \"Unknown device %x\\n\", devid);\n-\t\treturn ret;\n+\t\treturn -ENODEV;\n \t}\n \n \tcs35l56_base->type = devid & 0xFF;\ndiff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c\nindex 677529916dc0..745532ccbdba 100644\n--- a/sound/soc/fsl/fsl_asrc.c\n+++ b/sound/soc/fsl/fsl_asrc.c\n@@ -517,7 +517,8 @@ static int fsl_asrc_config_pair(struct fsl_asrc_pair *pair, bool use_ideal_rate)\n \tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n \t\t\t   ASRCTR_ATSi_MASK(index), ASRCTR_ATS(index));\n \tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n-\t\t\t   ASRCTR_USRi_MASK(index), 0);\n+\t\t\t   ASRCTR_IDRi_MASK(index) | ASRCTR_USRi_MASK(index),\n+\t\t\t   ASRCTR_USR(index));\n \n \t/* Set the input and output clock sources */\n \tregmap_update_bits(asrc->regmap, REG_ASRCSR,\ndiff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c\nindex af1a168d35e3..50af6b725670 100644\n--- a/sound/soc/fsl/fsl_sai.c\n+++ b/sound/soc/fsl/fsl_sai.c\n@@ -803,13 +803,15 @@ static void fsl_sai_config_disable(struct fsl_sai *sai, int dir)\n \t * anymore. Add software reset to fix this issue.\n \t * This is a hardware bug, and will be fix in the\n \t * next sai version.\n+\t *\n+\t * In consumer mode, this can happen even after a\n+\t * single open/close, especially if both tx and rx\n+\t * are running concurrently.\n \t */\n-\tif (!sai->is_consumer_mode[tx]) {\n-\t\t/* Software Reset */\n-\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), FSL_SAI_CSR_SR);\n-\t\t/* Clear SR bit to finish the reset */\n-\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), 0);\n-\t}\n+\t/* Software Reset */\n+\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), FSL_SAI_CSR_SR);\n+\t/* Clear SR bit to finish the reset */\n+\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), 0);\n }\n \n static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,\ndiff --git a/sound/soc/intel/boards/Kconfig b/sound/soc/intel/boards/Kconfig\nindex 2df7afa2f469..128b6876af83 100644\n--- a/sound/soc/intel/boards/Kconfig\n+++ b/sound/soc/intel/boards/Kconfig\n@@ -42,6 +42,7 @@ config SND_SOC_INTEL_SOF_NUVOTON_COMMON\n \ttristate\n \n config SND_SOC_INTEL_SOF_BOARD_HELPERS\n+\tselect SND_SOC_ACPI_INTEL_MATCH\n \ttristate\n \n if SND_SOC_INTEL_CATPT\ndiff --git a/sound/soc/intel/boards/sof_sdw.c b/sound/soc/intel/boards/sof_sdw.c\nindex 81a914bd7ec2..504887505e68 100644\n--- a/sound/soc/intel/boards/sof_sdw.c\n+++ b/sound/soc/intel/boards/sof_sdw.c\n@@ -783,6 +783,9 @@ static const struct dmi_system_id sof_sdw_quirk_table[] = {\n static const struct snd_pci_quirk sof_sdw_ssid_quirk_table[] = {\n \tSND_PCI_QUIRK(0x1043, 0x1e13, \"ASUS Zenbook S14\", SOC_SDW_CODEC_MIC),\n \tSND_PCI_QUIRK(0x1043, 0x1f43, \"ASUS Zenbook S16\", SOC_SDW_CODEC_MIC),\n+\tSND_PCI_QUIRK(0x17aa, 0x2347, \"Lenovo P16\", SOC_SDW_CODEC_MIC),\n+\tSND_PCI_QUIRK(0x17aa, 0x2348, \"Lenovo P16\", SOC_SDW_CODEC_MIC),\n+\tSND_PCI_QUIRK(0x17aa, 0x2349, \"Lenovo P1\", SOC_SDW_CODEC_MIC),\n \t{}\n };\n \ndiff --git a/sound/soc/intel/common/soc-acpi-intel-arl-match.c b/sound/soc/intel/common/soc-acpi-intel-arl-match.c\nindex 73e581e93755..1ad704ca2c5f 100644\n--- a/sound/soc/intel/common/soc-acpi-intel-arl-match.c\n+++ b/sound/soc/intel/common/soc-acpi-intel-arl-match.c\n@@ -468,17 +468,17 @@ struct snd_soc_acpi_mach snd_soc_acpi_intel_arl_sdw_machines[] = {\n \t\t.get_function_tplg_files = sof_sdw_get_tplg_files,\n \t},\n \t{\n-\t\t.link_mask = BIT(2),\n-\t\t.links = arl_cs42l43_l2,\n+\t\t.link_mask = BIT(2) | BIT(3),\n+\t\t.links = arl_cs42l43_l2_cs35l56_l3,\n \t\t.drv_name = \"sof_sdw\",\n-\t\t.sof_tplg_filename = \"sof-arl-cs42l43-l2.tplg\",\n+\t\t.sof_tplg_filename = \"sof-arl-cs42l43-l2-cs35l56-l3.tplg\",\n \t\t.get_function_tplg_files = sof_sdw_get_tplg_files,\n \t},\n \t{\n-\t\t.link_mask = BIT(2) | BIT(3),\n-\t\t.links = arl_cs42l43_l2_cs35l56_l3,\n+\t\t.link_mask = BIT(2),\n+\t\t.links = arl_cs42l43_l2,\n \t\t.drv_name = \"sof_sdw\",\n-\t\t.sof_tplg_filename = \"sof-arl-cs42l43-l2-cs35l56-l3.tplg\",\n+\t\t.sof_tplg_filename = \"sof-arl-cs42l43-l2.tplg\",\n \t\t.get_function_tplg_files = sof_sdw_get_tplg_files,\n \t},\n \t{\ndiff --git a/sound/usb/format.c b/sound/usb/format.c\nindex 8cd54f7bf33a..0ee532acbb60 100644\n--- a/sound/usb/format.c\n+++ b/sound/usb/format.c\n@@ -310,16 +310,14 @@ static bool focusrite_valid_sample_rate(struct snd_usb_audio *chip,\n \t\t\t\t\tstruct audioformat *fp,\n \t\t\t\t\tunsigned int rate)\n {\n-\tstruct usb_interface *iface;\n \tstruct usb_host_interface *alts;\n \tunsigned char *fmt;\n \tunsigned int max_rate;\n \n-\tiface = usb_ifnum_to_if(chip->dev, fp->iface);\n-\tif (!iface)\n+\talts = snd_usb_get_host_interface(chip, fp->iface, fp->altsetting);\n+\tif (!alts)\n \t\treturn true;\n \n-\talts = &iface->altsetting[fp->altset_idx];\n \tfmt = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n \t\t\t\t      NULL, UAC_FORMAT_TYPE);\n \tif (!fmt)\n@@ -328,20 +326,20 @@ static bool focusrite_valid_sample_rate(struct snd_usb_audio *chip,\n \tif (fmt[0] == 10) { /* bLength */\n \t\tmax_rate = combine_quad(&fmt[6]);\n \n-\t\t/* Validate max rate */\n-\t\tif (max_rate != 48000 &&\n-\t\t    max_rate != 96000 &&\n-\t\t    max_rate != 192000 &&\n-\t\t    max_rate != 384000) {\n-\n+\t\tswitch (max_rate) {\n+\t\tcase 48000:\n+\t\t\treturn (rate == 44100 || rate == 48000);\n+\t\tcase 96000:\n+\t\t\treturn (rate == 88200 || rate == 96000);\n+\t\tcase 192000:\n+\t\t\treturn (rate == 176400 || rate == 192000);\n+\t\tdefault:\n \t\t\tusb_audio_info(chip,\n \t\t\t\t\"%u:%d : unexpected max rate: %u\\n\",\n \t\t\t\tfp->iface, fp->altsetting, max_rate);\n \n \t\t\treturn true;\n \t\t}\n-\n-\t\treturn rate <= max_rate;\n \t}\n \n \treturn true;",
    "stats": {
      "insertions": 64,
      "deletions": 41,
      "files": 12
    }
  },
  {
    "sha": "95a234f6affbf51f06338383537ab80d637bb785",
    "message": "net: ethernet: rtsn: Fix a null pointer dereference in rtsn_probe()\n\nAdd check for the return value of rcar_gen4_ptp_alloc()\nto prevent potential null pointer dereference.\n\nFixes: b0d3969d2b4d (\"net: ethernet: rtsn: Add support for Renesas Ethernet-TSN\")\nCc: stable@vger.kernel.org\nSigned-off-by: Haoxiang Li <haoxiang_li2024@163.com>\nReviewed-by: Niklas SÃ¶derlund <niklas.soderlund+renesas@ragnatech.se>\nLink: https://patch.msgid.link/20250703100109.2541018-1-haoxiang_li2024@163.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Haoxiang Li",
    "date": "2025-07-08T08:34:05-07:00",
    "files_changed": [
      "drivers/net/ethernet/renesas/rtsn.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/renesas/rtsn.c b/drivers/net/ethernet/renesas/rtsn.c\nindex 6b3f7fca8d15..05c4b6c8c9c3 100644\n--- a/drivers/net/ethernet/renesas/rtsn.c\n+++ b/drivers/net/ethernet/renesas/rtsn.c\n@@ -1259,7 +1259,12 @@ static int rtsn_probe(struct platform_device *pdev)\n \tpriv = netdev_priv(ndev);\n \tpriv->pdev = pdev;\n \tpriv->ndev = ndev;\n+\n \tpriv->ptp_priv = rcar_gen4_ptp_alloc(pdev);\n+\tif (!priv->ptp_priv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto error_free;\n+\t}\n \n \tspin_lock_init(&priv->lock);\n \tplatform_set_drvdata(pdev, priv);",
    "stats": {
      "insertions": 5,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "d3a5f2871adc0c61c61869f37f3e697d97f03d8c",
    "message": "tcp: Correct signedness in skb remaining space calculation\n\nSyzkaller reported a bug [1] where sk->sk_forward_alloc can overflow.\n\nWhen we send data, if an skb exists at the tail of the write queue, the\nkernel will attempt to append the new data to that skb. However, the code\nthat checks for available space in the skb is flawed:\n'''\ncopy = size_goal - skb->len\n'''\n\nThe types of the variables involved are:\n'''\ncopy: ssize_t (s64 on 64-bit systems)\nsize_goal: int\nskb->len: unsigned int\n'''\n\nDue to C's type promotion rules, the signed size_goal is converted to an\nunsigned int to match skb->len before the subtraction. The result is an\nunsigned int.\n\nWhen this unsigned int result is then assigned to the s64 copy variable,\nit is zero-extended, preserving its non-negative value. Consequently, copy\nis always >= 0.\n\nAssume we are sending 2GB of data and size_goal has been adjusted to a\nvalue smaller than skb->len. The subtraction will result in copy holding a\nvery large positive integer. In the subsequent logic, this large value is\nused to update sk->sk_forward_alloc, which can easily cause it to overflow.\n\nThe syzkaller reproducer uses TCP_REPAIR to reliably create this\ncondition. However, this can also occur in real-world scenarios. The\ntcp_bound_to_half_wnd() function can also reduce size_goal to a small\nvalue. This would cause the subsequent tcp_wmem_schedule() to set\nsk->sk_forward_alloc to a value close to INT_MAX. Further memory\nallocation requests would then cause sk_forward_alloc to wrap around and\nbecome negative.\n\n[1]: https://syzkaller.appspot.com/bug?extid=de6565462ab540f50e47\n\nReported-by: syzbot+de6565462ab540f50e47@syzkaller.appspotmail.com\nFixes: 270a1c3de47e (\"tcp: Support MSG_SPLICE_PAGES\")\nSigned-off-by: Jiayuan Chen <jiayuan.chen@linux.dev>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nReviewed-by: David Howells <dhowells@redhat.com>\nLink: https://patch.msgid.link/20250707054112.101081-1-jiayuan.chen@linux.dev\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jiayuan Chen",
    "date": "2025-07-08T07:56:26-07:00",
    "files_changed": [
      "net/ipv4/tcp.c"
    ],
    "diff": "diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c\nindex f64f8276a73c..461a9ab540af 100644\n--- a/net/ipv4/tcp.c\n+++ b/net/ipv4/tcp.c\n@@ -1176,7 +1176,7 @@ int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)\n \t\tgoto do_error;\n \n \twhile (msg_data_left(msg)) {\n-\t\tssize_t copy = 0;\n+\t\tint copy = 0;\n \n \t\tskb = tcp_write_queue_tail(sk);\n \t\tif (skb)",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "5383fc057a0ea18e8eb9a0472ea853c24b59ee5e",
    "message": "Merge tag 'kvm-x86-fixes-6.16-rcN' of https://github.com/kvm-x86/linux into HEAD\n\nKVM x86 fixes for 6.16-rcN\n\n- Reject SEV{-ES} intra-host migration if one or more vCPUs are actively\n  being created so as not to create a non-SEV{-ES} vCPU in an SEV{-ES} VM.\n\n- Use a pre-allocated, per-vCPU buffer for handling de-sparsified vCPU masks\n  when emulating Hyper-V hypercalls to fix a \"stack frame too large\" issue.\n\n- Allow out-of-range/invalid Xen event channel ports when configuring IRQ\n  routing to avoid dictating a specific ioctl() ordering to userspace.\n\n- Conditionally reschedule when setting memory attributes to avoid soft\n  lockups when userspace converts huge swaths of memory to/from private.\n\n- Add back MWAIT as a required feature for the MONITOR/MWAIT selftest.\n\n- Add a missing field in struct sev_data_snp_launch_start that resulted in\n  the guest-visible workarounds field being filled at the wrong offset.\n\n- Skip non-canonical address when processing Hyper-V PV TLB flushes to avoid\n  VM-Fail on INVVPID.\n\n- Advertise supported TDX TDVMCALLs to userspace.",
    "author": "Paolo Bonzini",
    "date": "2025-07-08T10:49:19-04:00",
    "files_changed": [
      "arch/x86/include/asm/kvm_host.h",
      "arch/x86/include/asm/shared/tdx.h",
      "arch/x86/include/uapi/asm/kvm.h",
      "arch/x86/kvm/hyperv.c",
      "arch/x86/kvm/svm/sev.c",
      "arch/x86/kvm/vmx/tdx.c",
      "arch/x86/kvm/xen.c",
      "include/linux/psp-sev.h",
      "include/uapi/linux/kvm.h",
      "tools/testing/selftests/kvm/x86/monitor_mwait_test.c",
      "virt/kvm/kvm_main.c"
    ],
    "diff": "diff --git a/Documentation/virt/kvm/api.rst b/Documentation/virt/kvm/api.rst\nindex 9abf93ee5f65..43ed57e048a8 100644\n--- a/Documentation/virt/kvm/api.rst\n+++ b/Documentation/virt/kvm/api.rst\n@@ -7196,6 +7196,10 @@ The valid value for 'flags' is:\n \t\t\t\t\tu64 leaf;\n \t\t\t\t\tu64 r11, r12, r13, r14;\n \t\t\t\t} get_tdvmcall_info;\n+\t\t\t\tstruct {\n+\t\t\t\t\tu64 ret;\n+\t\t\t\t\tu64 vector;\n+\t\t\t\t} setup_event_notify;\n \t\t\t};\n \t\t} tdx;\n \n@@ -7210,21 +7214,24 @@ number from register R11.  The remaining field of the union provide the\n inputs and outputs of the TDVMCALL.  Currently the following values of\n ``nr`` are defined:\n \n-* ``TDVMCALL_GET_QUOTE``: the guest has requested to generate a TD-Quote\n-signed by a service hosting TD-Quoting Enclave operating on the host.\n-Parameters and return value are in the ``get_quote`` field of the union.\n-The ``gpa`` field and ``size`` specify the guest physical address\n-(without the shared bit set) and the size of a shared-memory buffer, in\n-which the TDX guest passes a TD Report.  The ``ret`` field represents\n-the return value of the GetQuote request.  When the request has been\n-queued successfully, the TDX guest can poll the status field in the\n-shared-memory area to check whether the Quote generation is completed or\n-not. When completed, the generated Quote is returned via the same buffer.\n-\n-* ``TDVMCALL_GET_TD_VM_CALL_INFO``: the guest has requested the support\n-status of TDVMCALLs.  The output values for the given leaf should be\n-placed in fields from ``r11`` to ``r14`` of the ``get_tdvmcall_info``\n-field of the union.\n+ * ``TDVMCALL_GET_QUOTE``: the guest has requested to generate a TD-Quote\n+   signed by a service hosting TD-Quoting Enclave operating on the host.\n+   Parameters and return value are in the ``get_quote`` field of the union.\n+   The ``gpa`` field and ``size`` specify the guest physical address\n+   (without the shared bit set) and the size of a shared-memory buffer, in\n+   which the TDX guest passes a TD Report.  The ``ret`` field represents\n+   the return value of the GetQuote request.  When the request has been\n+   queued successfully, the TDX guest can poll the status field in the\n+   shared-memory area to check whether the Quote generation is completed or\n+   not. When completed, the generated Quote is returned via the same buffer.\n+\n+ * ``TDVMCALL_GET_TD_VM_CALL_INFO``: the guest has requested the support\n+   status of TDVMCALLs.  The output values for the given leaf should be\n+   placed in fields from ``r11`` to ``r14`` of the ``get_tdvmcall_info``\n+   field of the union.\n+\n+* ``TDVMCALL_SETUP_EVENT_NOTIFY_INTERRUPT``: the guest has requested to\n+set up a notification interrupt for vector ``vector``.\n \n KVM may add support for more values in the future that may cause a userspace\n exit, even without calls to ``KVM_ENABLE_CAP`` or similar.  In this case,\ndiff --git a/Documentation/virt/kvm/x86/intel-tdx.rst b/Documentation/virt/kvm/x86/intel-tdx.rst\nindex 76bdd95334d6..5efac62c92c7 100644\n--- a/Documentation/virt/kvm/x86/intel-tdx.rst\n+++ b/Documentation/virt/kvm/x86/intel-tdx.rst\n@@ -79,7 +79,20 @@ to be configured to the TDX guest.\n   struct kvm_tdx_capabilities {\n         __u64 supported_attrs;\n         __u64 supported_xfam;\n-        __u64 reserved[254];\n+\n+        /* TDG.VP.VMCALL hypercalls executed in kernel and forwarded to\n+         * userspace, respectively\n+         */\n+        __u64 kernel_tdvmcallinfo_1_r11;\n+        __u64 user_tdvmcallinfo_1_r11;\n+\n+        /* TDG.VP.VMCALL instruction executions subfunctions executed in kernel\n+         * and forwarded to userspace, respectively\n+         */\n+        __u64 kernel_tdvmcallinfo_1_r12;\n+        __u64 user_tdvmcallinfo_1_r12;\n+\n+        __u64 reserved[250];\n \n         /* Configurable CPUID bits for userspace */\n         struct kvm_cpuid2 cpuid;\ndiff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h\nindex b4a391929cdb..ee43615d96d8 100644\n--- a/arch/x86/include/asm/kvm_host.h\n+++ b/arch/x86/include/asm/kvm_host.h\n@@ -700,8 +700,13 @@ struct kvm_vcpu_hv {\n \n \tstruct kvm_vcpu_hv_tlb_flush_fifo tlb_flush_fifo[HV_NR_TLB_FLUSH_FIFOS];\n \n-\t/* Preallocated buffer for handling hypercalls passing sparse vCPU set */\n+\t/*\n+\t * Preallocated buffers for handling hypercalls that pass sparse vCPU\n+\t * sets (for high vCPU counts, they're too large to comfortably fit on\n+\t * the stack).\n+\t */\n \tu64 sparse_banks[HV_MAX_SPARSE_VCPU_BANKS];\n+\tDECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);\n \n \tstruct hv_vp_assist_page vp_assist_page;\n \ndiff --git a/arch/x86/include/asm/shared/tdx.h b/arch/x86/include/asm/shared/tdx.h\nindex d8525e6ef50a..8bc074c8d7c6 100644\n--- a/arch/x86/include/asm/shared/tdx.h\n+++ b/arch/x86/include/asm/shared/tdx.h\n@@ -72,6 +72,7 @@\n #define TDVMCALL_MAP_GPA\t\t0x10001\n #define TDVMCALL_GET_QUOTE\t\t0x10002\n #define TDVMCALL_REPORT_FATAL_ERROR\t0x10003\n+#define TDVMCALL_SETUP_EVENT_NOTIFY_INTERRUPT 0x10004ULL\n \n /*\n  * TDG.VP.VMCALL Status Codes (returned in R10)\ndiff --git a/arch/x86/include/uapi/asm/kvm.h b/arch/x86/include/uapi/asm/kvm.h\nindex 6f3499507c5e..0f15d683817d 100644\n--- a/arch/x86/include/uapi/asm/kvm.h\n+++ b/arch/x86/include/uapi/asm/kvm.h\n@@ -965,7 +965,13 @@ struct kvm_tdx_cmd {\n struct kvm_tdx_capabilities {\n \t__u64 supported_attrs;\n \t__u64 supported_xfam;\n-\t__u64 reserved[254];\n+\n+\t__u64 kernel_tdvmcallinfo_1_r11;\n+\t__u64 user_tdvmcallinfo_1_r11;\n+\t__u64 kernel_tdvmcallinfo_1_r12;\n+\t__u64 user_tdvmcallinfo_1_r12;\n+\n+\t__u64 reserved[250];\n \n \t/* Configurable CPUID bits for userspace */\n \tstruct kvm_cpuid2 cpuid;\ndiff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c\nindex 24f0318c50d7..ee27064dd72f 100644\n--- a/arch/x86/kvm/hyperv.c\n+++ b/arch/x86/kvm/hyperv.c\n@@ -1979,6 +1979,9 @@ int kvm_hv_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n \t\tif (entries[i] == KVM_HV_TLB_FLUSHALL_ENTRY)\n \t\t\tgoto out_flush_all;\n \n+\t\tif (is_noncanonical_invlpg_address(entries[i], vcpu))\n+\t\t\tcontinue;\n+\n \t\t/*\n \t\t * Lower 12 bits of 'address' encode the number of additional\n \t\t * pages to flush.\n@@ -2001,11 +2004,11 @@ int kvm_hv_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n static u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)\n {\n \tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n+\tunsigned long *vcpu_mask = hv_vcpu->vcpu_mask;\n \tu64 *sparse_banks = hv_vcpu->sparse_banks;\n \tstruct kvm *kvm = vcpu->kvm;\n \tstruct hv_tlb_flush_ex flush_ex;\n \tstruct hv_tlb_flush flush;\n-\tDECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);\n \tstruct kvm_vcpu_hv_tlb_flush_fifo *tlb_flush_fifo;\n \t/*\n \t * Normally, there can be no more than 'KVM_HV_TLB_FLUSH_FIFO_SIZE'\ndiff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c\nindex 459c3b791fd4..b201f77fcd49 100644\n--- a/arch/x86/kvm/svm/sev.c\n+++ b/arch/x86/kvm/svm/sev.c\n@@ -1971,6 +1971,10 @@ static int sev_check_source_vcpus(struct kvm *dst, struct kvm *src)\n \tstruct kvm_vcpu *src_vcpu;\n \tunsigned long i;\n \n+\tif (src->created_vcpus != atomic_read(&src->online_vcpus) ||\n+\t    dst->created_vcpus != atomic_read(&dst->online_vcpus))\n+\t\treturn -EBUSY;\n+\n \tif (!sev_es_guest(src))\n \t\treturn 0;\n \n@@ -4445,8 +4449,12 @@ static void sev_es_init_vmcb(struct vcpu_svm *svm)\n \t * the VMSA will be NULL if this vCPU is the destination for intrahost\n \t * migration, and will be copied later.\n \t */\n-\tif (svm->sev_es.vmsa && !svm->sev_es.snp_has_guest_vmsa)\n-\t\tsvm->vmcb->control.vmsa_pa = __pa(svm->sev_es.vmsa);\n+\tif (!svm->sev_es.snp_has_guest_vmsa) {\n+\t\tif (svm->sev_es.vmsa)\n+\t\t\tsvm->vmcb->control.vmsa_pa = __pa(svm->sev_es.vmsa);\n+\t\telse\n+\t\t\tsvm->vmcb->control.vmsa_pa = INVALID_PAGE;\n+\t}\n \n \tif (cpu_feature_enabled(X86_FEATURE_ALLOWED_SEV_FEATURES))\n \t\tsvm->vmcb->control.allowed_sev_features = sev->vmsa_features |\ndiff --git a/arch/x86/kvm/vmx/tdx.c b/arch/x86/kvm/vmx/tdx.c\nindex 1ad20c273f3b..f31ccdeb905b 100644\n--- a/arch/x86/kvm/vmx/tdx.c\n+++ b/arch/x86/kvm/vmx/tdx.c\n@@ -173,6 +173,9 @@ static void td_init_cpuid_entry2(struct kvm_cpuid_entry2 *entry, unsigned char i\n \ttdx_clear_unsupported_cpuid(entry);\n }\n \n+#define TDVMCALLINFO_GET_QUOTE\t\t\t\tBIT(0)\n+#define TDVMCALLINFO_SETUP_EVENT_NOTIFY_INTERRUPT\tBIT(1)\n+\n static int init_kvm_tdx_caps(const struct tdx_sys_info_td_conf *td_conf,\n \t\t\t     struct kvm_tdx_capabilities *caps)\n {\n@@ -188,6 +191,10 @@ static int init_kvm_tdx_caps(const struct tdx_sys_info_td_conf *td_conf,\n \n \tcaps->cpuid.nent = td_conf->num_cpuid_config;\n \n+\tcaps->user_tdvmcallinfo_1_r11 =\n+\t\tTDVMCALLINFO_GET_QUOTE |\n+\t\tTDVMCALLINFO_SETUP_EVENT_NOTIFY_INTERRUPT;\n+\n \tfor (i = 0; i < td_conf->num_cpuid_config; i++)\n \t\ttd_init_cpuid_entry2(&caps->cpuid.entries[i], i);\n \n@@ -1530,6 +1537,27 @@ static int tdx_get_quote(struct kvm_vcpu *vcpu)\n \treturn 0;\n }\n \n+static int tdx_setup_event_notify_interrupt(struct kvm_vcpu *vcpu)\n+{\n+\tstruct vcpu_tdx *tdx = to_tdx(vcpu);\n+\tu64 vector = tdx->vp_enter_args.r12;\n+\n+\tif (vector < 32 || vector > 255) {\n+\t\ttdvmcall_set_return_code(vcpu, TDVMCALL_STATUS_INVALID_OPERAND);\n+\t\treturn 1;\n+\t}\n+\n+\tvcpu->run->exit_reason = KVM_EXIT_TDX;\n+\tvcpu->run->tdx.flags = 0;\n+\tvcpu->run->tdx.nr = TDVMCALL_SETUP_EVENT_NOTIFY_INTERRUPT;\n+\tvcpu->run->tdx.setup_event_notify.ret = TDVMCALL_STATUS_SUBFUNC_UNSUPPORTED;\n+\tvcpu->run->tdx.setup_event_notify.vector = vector;\n+\n+\tvcpu->arch.complete_userspace_io = tdx_complete_simple;\n+\n+\treturn 0;\n+}\n+\n static int handle_tdvmcall(struct kvm_vcpu *vcpu)\n {\n \tswitch (tdvmcall_leaf(vcpu)) {\n@@ -1541,6 +1569,8 @@ static int handle_tdvmcall(struct kvm_vcpu *vcpu)\n \t\treturn tdx_get_td_vm_call_info(vcpu);\n \tcase TDVMCALL_GET_QUOTE:\n \t\treturn tdx_get_quote(vcpu);\n+\tcase TDVMCALL_SETUP_EVENT_NOTIFY_INTERRUPT:\n+\t\treturn tdx_setup_event_notify_interrupt(vcpu);\n \tdefault:\n \t\tbreak;\n \t}\ndiff --git a/arch/x86/kvm/xen.c b/arch/x86/kvm/xen.c\nindex 9b029bb29a16..5fa2cca43653 100644\n--- a/arch/x86/kvm/xen.c\n+++ b/arch/x86/kvm/xen.c\n@@ -1971,8 +1971,19 @@ int kvm_xen_setup_evtchn(struct kvm *kvm,\n {\n \tstruct kvm_vcpu *vcpu;\n \n-\tif (ue->u.xen_evtchn.port >= max_evtchn_port(kvm))\n-\t\treturn -EINVAL;\n+\t/*\n+\t * Don't check for the port being within range of max_evtchn_port().\n+\t * Userspace can configure what ever targets it likes; events just won't\n+\t * be delivered if/while the target is invalid, just like userspace can\n+\t * configure MSIs which target non-existent APICs.\n+\t *\n+\t * This allow on Live Migration and Live Update, the IRQ routing table\n+\t * can be restored *independently* of other things like creating vCPUs,\n+\t * without imposing an ordering dependency on userspace.  In this\n+\t * particular case, the problematic ordering would be with setting the\n+\t * Xen 'long mode' flag, which changes max_evtchn_port() to allow 4096\n+\t * instead of 1024 event channels.\n+\t */\n \n \t/* We only support 2 level event channels for now */\n \tif (ue->u.xen_evtchn.priority != KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL)\ndiff --git a/include/linux/psp-sev.h b/include/linux/psp-sev.h\nindex 0b3a36bdaa90..0f5f94137f6d 100644\n--- a/include/linux/psp-sev.h\n+++ b/include/linux/psp-sev.h\n@@ -594,6 +594,7 @@ struct sev_data_snp_addr {\n  * @imi_en: launch flow is launching an IMI (Incoming Migration Image) for the\n  *          purpose of guest-assisted migration.\n  * @rsvd: reserved\n+ * @desired_tsc_khz: hypervisor desired mean TSC freq in kHz of the guest\n  * @gosvw: guest OS-visible workarounds, as defined by hypervisor\n  */\n struct sev_data_snp_launch_start {\n@@ -603,6 +604,7 @@ struct sev_data_snp_launch_start {\n \tu32 ma_en:1;\t\t\t\t/* In */\n \tu32 imi_en:1;\t\t\t\t/* In */\n \tu32 rsvd:30;\n+\tu32 desired_tsc_khz;\t\t\t/* In */\n \tu8 gosvw[16];\t\t\t\t/* In */\n } __packed;\n \ndiff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h\nindex 37891580d05d..7a4c35ff03fe 100644\n--- a/include/uapi/linux/kvm.h\n+++ b/include/uapi/linux/kvm.h\n@@ -467,6 +467,10 @@ struct kvm_run {\n \t\t\t\t\t__u64 leaf;\n \t\t\t\t\t__u64 r11, r12, r13, r14;\n \t\t\t\t} get_tdvmcall_info;\n+\t\t\t\tstruct {\n+\t\t\t\t\t__u64 ret;\n+\t\t\t\t\t__u64 vector;\n+\t\t\t\t} setup_event_notify;\n \t\t\t};\n \t\t} tdx;\n \t\t/* Fix the size of the union. */\ndiff --git a/tools/testing/selftests/kvm/x86/monitor_mwait_test.c b/tools/testing/selftests/kvm/x86/monitor_mwait_test.c\nindex 390ae2d87493..0eb371c62ab8 100644\n--- a/tools/testing/selftests/kvm/x86/monitor_mwait_test.c\n+++ b/tools/testing/selftests/kvm/x86/monitor_mwait_test.c\n@@ -74,6 +74,7 @@ int main(int argc, char *argv[])\n \tint testcase;\n \tchar test[80];\n \n+\tTEST_REQUIRE(this_cpu_has(X86_FEATURE_MWAIT));\n \tTEST_REQUIRE(kvm_has_cap(KVM_CAP_DISABLE_QUIRKS2));\n \n \tksft_print_header();\ndiff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c\nindex eec82775c5bf..222f0e894a0c 100644\n--- a/virt/kvm/kvm_main.c\n+++ b/virt/kvm/kvm_main.c\n@@ -2572,6 +2572,8 @@ static int kvm_vm_set_mem_attributes(struct kvm *kvm, gfn_t start, gfn_t end,\n \t\tr = xa_reserve(&kvm->mem_attr_array, i, GFP_KERNEL_ACCOUNT);\n \t\tif (r)\n \t\t\tgoto out_unlock;\n+\n+\t\tcond_resched();\n \t}\n \n \tkvm_handle_gfn_range(kvm, &pre_set_range);\n@@ -2580,6 +2582,7 @@ static int kvm_vm_set_mem_attributes(struct kvm *kvm, gfn_t start, gfn_t end,\n \t\tr = xa_err(xa_store(&kvm->mem_attr_array, i, entry,\n \t\t\t\t    GFP_KERNEL_ACCOUNT));\n \t\tKVM_BUG_ON(r, kvm);\n+\t\tcond_resched();\n \t}\n \n \tkvm_handle_gfn_range(kvm, &post_set_range);",
    "stats": {
      "insertions": 117,
      "deletions": 23,
      "files": 13
    }
  }
]
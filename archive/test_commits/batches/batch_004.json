[
  {
    "sha": "6ee9b3d84775944fb8c8a447961cd01274ac671c",
    "message": "kasan: remove kasan_find_vm_area() to prevent possible deadlock\n\nfind_vm_area() couldn't be called in atomic_context.  If find_vm_area() is\ncalled to reports vm area information, kasan can trigger deadlock like:\n\nCPU0                                CPU1\nvmalloc();\n alloc_vmap_area();\n  spin_lock(&vn->busy.lock)\n                                    spin_lock_bh(&some_lock);\n   <interrupt occurs>\n   <in softirq>\n   spin_lock(&some_lock);\n                                    <access invalid address>\n                                    kasan_report();\n                                     print_report();\n                                      print_address_description();\n                                       kasan_find_vm_area();\n                                        find_vm_area();\n                                         spin_lock(&vn->busy.lock) // deadlock!\n\nTo prevent possible deadlock while kasan reports, remove kasan_find_vm_area().\n\nLink: https://lkml.kernel.org/r/20250703181018.580833-1-yeoreum.yun@arm.com\nFixes: c056a364e954 (\"kasan: print virtual mapping info in reports\")\nSigned-off-by: Yeoreum Yun <yeoreum.yun@arm.com>\nReported-by: Yunseong Kim <ysk@kzalloc.com>\nReviewed-by: Andrey Ryabinin <ryabinin.a.a@gmail.com>\nCc: Alexander Potapenko <glider@google.com>\nCc: Andrey Konovalov <andreyknvl@gmail.com>\nCc: Byungchul Park <byungchul@sk.com>\nCc: Dmitriy Vyukov <dvyukov@google.com>\nCc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>\nCc: Steven Rostedt <rostedt@goodmis.org>\nCc: Vincenzo Frascino <vincenzo.frascino@arm.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>",
    "author": "Yeoreum Yun",
    "date": "2025-07-09T21:07:54-07:00",
    "files_changed": [
      "mm/kasan/report.c"
    ],
    "diff": "diff --git a/mm/kasan/report.c b/mm/kasan/report.c\nindex 8357e1a33699..b0877035491f 100644\n--- a/mm/kasan/report.c\n+++ b/mm/kasan/report.c\n@@ -370,36 +370,6 @@ static inline bool init_task_stack_addr(const void *addr)\n \t\t\tsizeof(init_thread_union.stack));\n }\n \n-/*\n- * This function is invoked with report_lock (a raw_spinlock) held. A\n- * PREEMPT_RT kernel cannot call find_vm_area() as it will acquire a sleeping\n- * rt_spinlock.\n- *\n- * For !RT kernel, the PROVE_RAW_LOCK_NESTING config option will print a\n- * lockdep warning for this raw_spinlock -> spinlock dependency. This config\n- * option is enabled by default to ensure better test coverage to expose this\n- * kind of RT kernel problem. This lockdep splat, however, can be suppressed\n- * by using DEFINE_WAIT_OVERRIDE_MAP() if it serves a useful purpose and the\n- * invalid PREEMPT_RT case has been taken care of.\n- */\n-static inline struct vm_struct *kasan_find_vm_area(void *addr)\n-{\n-\tstatic DEFINE_WAIT_OVERRIDE_MAP(vmalloc_map, LD_WAIT_SLEEP);\n-\tstruct vm_struct *va;\n-\n-\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n-\t\treturn NULL;\n-\n-\t/*\n-\t * Suppress lockdep warning and fetch vmalloc area of the\n-\t * offending address.\n-\t */\n-\tlock_map_acquire_try(&vmalloc_map);\n-\tva = find_vm_area(addr);\n-\tlock_map_release(&vmalloc_map);\n-\treturn va;\n-}\n-\n static void print_address_description(void *addr, u8 tag,\n \t\t\t\t      struct kasan_report_info *info)\n {\n@@ -429,19 +399,8 @@ static void print_address_description(void *addr, u8 tag,\n \t}\n \n \tif (is_vmalloc_addr(addr)) {\n-\t\tstruct vm_struct *va = kasan_find_vm_area(addr);\n-\n-\t\tif (va) {\n-\t\t\tpr_err(\"The buggy address belongs to the virtual mapping at\\n\"\n-\t\t\t       \" [%px, %px) created by:\\n\"\n-\t\t\t       \" %pS\\n\",\n-\t\t\t       va->addr, va->addr + va->size, va->caller);\n-\t\t\tpr_err(\"\\n\");\n-\n-\t\t\tpage = vmalloc_to_page(addr);\n-\t\t} else {\n-\t\t\tpr_err(\"The buggy address %px belongs to a vmalloc virtual mapping\\n\", addr);\n-\t\t}\n+\t\tpr_err(\"The buggy address %px belongs to a vmalloc virtual mapping\\n\", addr);\n+\t\tpage = vmalloc_to_page(addr);\n \t}\n \n \tif (page) {",
    "stats": {
      "insertions": 2,
      "deletions": 43,
      "files": 1
    }
  },
  {
    "sha": "c39b87456411a7e4d97a0f6384ca31f2abb1a4b7",
    "message": "mm/hugetlb: don't crash when allocating a folio if there are no resv\n\nThere are cases when we try to pin a folio but discover that it has not\nbeen faulted-in.  So, we try to allocate it in memfd_alloc_folio() but\nthere is a chance that we might encounter a fatal crash/failure\n(VM_BUG_ON(!h->resv_huge_pages) in alloc_hugetlb_folio_reserve()) if there\nare no active reservations at that instant.  This issue was reported by\nsyzbot:\n\nkernel BUG at mm/hugetlb.c:2403!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 5315 Comm: syz.0.0 Not tainted\n6.13.0-rc5-syzkaller-00161-g63676eefb7a0 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS\n1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:alloc_hugetlb_folio_reserve+0xbc/0xc0 mm/hugetlb.c:2403\nCode: 1f eb 05 e8 56 18 a0 ff 48 c7 c7 40 56 61 8e e8 ba 21 cc 09 4c 89\nf0 5b 41 5c 41 5e 41 5f 5d c3 cc cc cc cc e8 35 18 a0 ff 90 <0f> 0b 66\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f\nRSP: 0018:ffffc9000d3d77f8 EFLAGS: 00010087\nRAX: ffffffff81ff6beb RBX: 0000000000000000 RCX: 0000000000100000\nRDX: ffffc9000e51a000 RSI: 00000000000003ec RDI: 00000000000003ed\nRBP: 1ffffffff34810d9 R08: ffffffff81ff6ba3 R09: 1ffffd4000093005\nR10: dffffc0000000000 R11: fffff94000093006 R12: dffffc0000000000\nR13: dffffc0000000000 R14: ffffea0000498000 R15: ffffffff9a4086c8\nFS:  00007f77ac12e6c0(0000) GS:ffff88801fc00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f77ab54b170 CR3: 0000000040b70000 CR4: 0000000000352ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n memfd_alloc_folio+0x1bd/0x370 mm/memfd.c:88\n memfd_pin_folios+0xf10/0x1570 mm/gup.c:3750\n udmabuf_pin_folios drivers/dma-buf/udmabuf.c:346 [inline]\n udmabuf_create+0x70e/0x10c0 drivers/dma-buf/udmabuf.c:443\n udmabuf_ioctl_create drivers/dma-buf/udmabuf.c:495 [inline]\n udmabuf_ioctl+0x301/0x4e0 drivers/dma-buf/udmabuf.c:526\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:906 [inline]\n __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nTherefore, prevent the above crash by removing the VM_BUG_ON() as there is\nno need to crash the system in this situation and instead we could just\nfail the allocation request.\n\nFurthermore, as described above, the specific situation where this happens\nis when we try to pin memfd folios before they are faulted-in.  Although,\nthis is a valid thing to do, it is not the regular or the common use-case.\nLet us consider the following scenarios:\n\n1) hugetlbfs_file_mmap()\n    memfd_alloc_folio()\n    hugetlb_fault()\n\n2) memfd_alloc_folio()\n    hugetlbfs_file_mmap()\n    hugetlb_fault()\n\n3) hugetlbfs_file_mmap()\n    hugetlb_fault()\n        alloc_hugetlb_folio()\n\n3) is the most common use-case where first a memfd is allocated followed\nby mmap(), user writes/updates and then the relevant folios are pinned\n(memfd_pin_folios()).  The BUG this patch is fixing occurs in 2) because\nwe try to pin the folios before hugetlbfs_file_mmap() is called.  So, in\nthis situation we try to allocate the folios before pinning them but since\nwe did not make any reservations, resv_huge_pages would be 0, leading to\nthis issue.\n\nLink: https://lkml.kernel.org/r/20250626191116.1377761-1-vivek.kasireddy@intel.com\nFixes: 26a8ea80929c (\"mm/hugetlb: fix memfd_pin_folios resv_huge_pages leak\")\nReported-by: syzbot+a504cb5bae4fe117ba94@syzkaller.appspotmail.com\nSigned-off-by: Vivek Kasireddy <vivek.kasireddy@intel.com>\nCloses: https://syzkaller.appspot.com/bug?extid=a504cb5bae4fe117ba94\nCloses: https://lore.kernel.org/all/677928b5.050a0220.3b53b0.004d.GAE@google.com/T/\nAcked-by: Oscar Salvador <osalvador@suse.de>\nCc: Steve Sistare <steven.sistare@oracle.com>\nCc: Muchun Song <muchun.song@linux.dev>\nCc: David Hildenbrand <david@redhat.com>\nCc: Anshuman Khandual <anshuman.khandual@arm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>",
    "author": "Vivek Kasireddy",
    "date": "2025-07-09T21:07:53-07:00",
    "files_changed": [
      "mm/hugetlb.c"
    ],
    "diff": "diff --git a/mm/hugetlb.c b/mm/hugetlb.c\nindex 9dc95eac558c..a0d285d20992 100644\n--- a/mm/hugetlb.c\n+++ b/mm/hugetlb.c\n@@ -2340,12 +2340,15 @@ struct folio *alloc_hugetlb_folio_reserve(struct hstate *h, int preferred_nid,\n \tstruct folio *folio;\n \n \tspin_lock_irq(&hugetlb_lock);\n+\tif (!h->resv_huge_pages) {\n+\t\tspin_unlock_irq(&hugetlb_lock);\n+\t\treturn NULL;\n+\t}\n+\n \tfolio = dequeue_hugetlb_folio_nodemask(h, gfp_mask, preferred_nid,\n \t\t\t\t\t       nmask);\n-\tif (folio) {\n-\t\tVM_BUG_ON(!h->resv_huge_pages);\n+\tif (folio)\n \t\th->resv_huge_pages--;\n-\t}\n \n \tspin_unlock_irq(&hugetlb_lock);\n \treturn folio;",
    "stats": {
      "insertions": 6,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "69e4186773c6445b258fb45b6e1df18df831ec45",
    "message": "rxrpc: Fix bug due to prealloc collision\n\nWhen userspace is using AF_RXRPC to provide a server, it has to preallocate\nincoming calls and assign to them call IDs that will be used to thread\nrelated recvmsg() and sendmsg() together.  The preallocated call IDs will\nautomatically be attached to calls as they come in until the pool is empty.\n\nTo the kernel, the call IDs are just arbitrary numbers, but userspace can\nuse the call ID to hold a pointer to prepared structs.  In any case, the\nuser isn't permitted to create two calls with the same call ID (call IDs\nbecome available again when the call ends) and EBADSLT should result from\nsendmsg() if an attempt is made to preallocate a call with an in-use call\nID.\n\nHowever, the cleanup in the error handling will trigger both assertions in\nrxrpc_cleanup_call() because the call isn't marked complete and isn't\nmarked as having been released.\n\nFix this by setting the call state in rxrpc_service_prealloc_one() and then\nmarking it as being released before calling the cleanup function.\n\nFixes: 00e907127e6f (\"rxrpc: Preallocate peers, conns and calls for incoming service requests\")\nReported-by: Junvyyang, Tencent Zhuque Lab <zhuque@tencent.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: LePremierHomme <kwqcheii@proton.me>\ncc: Marc Dionne <marc.dionne@auristor.com>\ncc: Simon Horman <horms@kernel.org>\ncc: linux-afs@lists.infradead.org\nLink: https://patch.msgid.link/20250708211506.2699012-2-dhowells@redhat.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "David Howells",
    "date": "2025-07-09T19:41:44-07:00",
    "files_changed": [
      "net/rxrpc/call_accept.c"
    ],
    "diff": "diff --git a/net/rxrpc/call_accept.c b/net/rxrpc/call_accept.c\nindex a4b363b47cca..7271977b1683 100644\n--- a/net/rxrpc/call_accept.c\n+++ b/net/rxrpc/call_accept.c\n@@ -149,6 +149,7 @@ static int rxrpc_service_prealloc_one(struct rxrpc_sock *rx,\n \n id_in_use:\n \twrite_unlock(&rx->call_lock);\n+\trxrpc_prefail_call(call, RXRPC_CALL_LOCAL_ERROR, -EBADSLT);\n \trxrpc_cleanup_call(call);\n \t_leave(\" = -EBADSLT\");\n \treturn -EBADSLT;",
    "stats": {
      "insertions": 1,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "22fc46cea91df3dce140a7dc6847c6fcf0354505",
    "message": "atm: clip: Fix NULL pointer dereference in vcc_sendmsg()\n\natmarpd_dev_ops does not implement the send method, which may cause crash\nas bellow.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\nPGD 0 P4D 0\nOops: Oops: 0010 [#1] SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 5324 Comm: syz.0.0 Not tainted 6.15.0-rc6-syzkaller-00346-g5723cc3450bc #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:0x0\nCode: Unable to access opcode bytes at 0xffffffffffffffd6.\nRSP: 0018:ffffc9000d3cf778 EFLAGS: 00010246\nRAX: 1ffffffff1910dd1 RBX: 00000000000000c0 RCX: dffffc0000000000\nRDX: ffffc9000dc82000 RSI: ffff88803e4c4640 RDI: ffff888052cd0000\nRBP: ffffc9000d3cf8d0 R08: ffff888052c9143f R09: 1ffff1100a592287\nR10: dffffc0000000000 R11: 0000000000000000 R12: 1ffff92001a79f00\nR13: ffff888052cd0000 R14: ffff88803e4c4640 R15: ffffffff8c886e88\nFS:  00007fbc762566c0(0000) GS:ffff88808d6c2000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffffffffd6 CR3: 0000000041f1b000 CR4: 0000000000352ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n vcc_sendmsg+0xa10/0xc50 net/atm/common.c:644\n sock_sendmsg_nosec net/socket.c:712 [inline]\n __sock_sendmsg+0x219/0x270 net/socket.c:727\n ____sys_sendmsg+0x52d/0x830 net/socket.c:2566\n ___sys_sendmsg+0x21f/0x2a0 net/socket.c:2620\n __sys_sendmmsg+0x227/0x430 net/socket.c:2709\n __do_sys_sendmmsg net/socket.c:2736 [inline]\n __se_sys_sendmmsg net/socket.c:2733 [inline]\n __x64_sys_sendmmsg+0xa0/0xc0 net/socket.c:2733\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xf6/0x210 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nReported-by: syzbot+e34e5e6b5eddb0014def@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/all/682f82d5.a70a0220.1765ec.0143.GAE@google.com/T\nSigned-off-by: Yue Haibing <yuehaibing@huawei.com>\nReviewed-by: Kuniyuki Iwashima <kuniyu@google.com>\nLink: https://patch.msgid.link/20250705085228.329202-1-yuehaibing@huawei.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Yue Haibing",
    "date": "2025-07-09T19:09:36-07:00",
    "files_changed": [
      "net/atm/clip.c"
    ],
    "diff": "diff --git a/net/atm/clip.c b/net/atm/clip.c\nindex a30c5a270545..f7a5565e794e 100644\n--- a/net/atm/clip.c\n+++ b/net/atm/clip.c\n@@ -632,8 +632,16 @@ static void atmarpd_close(struct atm_vcc *vcc)\n \tmodule_put(THIS_MODULE);\n }\n \n+static int atmarpd_send(struct atm_vcc *vcc, struct sk_buff *skb)\n+{\n+\tatm_return_tx(vcc, skb);\n+\tdev_kfree_skb_any(skb);\n+\treturn 0;\n+}\n+\n static const struct atmdev_ops atmarpd_dev_ops = {\n-\t.close = atmarpd_close\n+\t.close = atmarpd_close,\n+\t.send = atmarpd_send\n };\n \n ",
    "stats": {
      "insertions": 9,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "3aaea88f7dd1631301878231e6bf218d0124b9ca",
    "message": "Merge branch 'atm-clip-fix-infinite-recursion-potential-null-ptr-deref-and-memleak'\n\nKuniyuki Iwashima says:\n\n====================\natm: clip: Fix infinite recursion, potential null-ptr-deref, and memleak.\n\nPatch 1 fixes racy access to atmarpd found while checking RTNL usage\nin clip.c.\n\nPatch 2 fixes memory leak by ioctl(ATMARP_MKIP) and ioctl(ATMARPD_CTRL).\n\nPatch 3 fixes infinite recursive call of clip_vcc->old_push(), which\nwas reported by syzbot.\n\nv1: https://lore.kernel.org/20250702020437.703698-1-kuniyu@google.com\n====================\n\nLink: https://patch.msgid.link/20250704062416.1613927-1-kuniyu@google.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-07-09T17:52:31-07:00",
    "files_changed": [
      "net/atm/clip.c"
    ],
    "diff": "diff --git a/net/atm/clip.c b/net/atm/clip.c\nindex b234dc3bcb0d..a30c5a270545 100644\n--- a/net/atm/clip.c\n+++ b/net/atm/clip.c\n@@ -45,7 +45,8 @@\n #include <net/atmclip.h>\n \n static struct net_device *clip_devs;\n-static struct atm_vcc *atmarpd;\n+static struct atm_vcc __rcu *atmarpd;\n+static DEFINE_MUTEX(atmarpd_lock);\n static struct timer_list idle_timer;\n static const struct neigh_ops clip_neigh_ops;\n \n@@ -53,24 +54,35 @@ static int to_atmarpd(enum atmarp_ctrl_type type, int itf, __be32 ip)\n {\n \tstruct sock *sk;\n \tstruct atmarp_ctrl *ctrl;\n+\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n+\tint err = 0;\n \n \tpr_debug(\"(%d)\\n\", type);\n-\tif (!atmarpd)\n-\t\treturn -EUNATCH;\n+\n+\trcu_read_lock();\n+\tvcc = rcu_dereference(atmarpd);\n+\tif (!vcc) {\n+\t\terr = -EUNATCH;\n+\t\tgoto unlock;\n+\t}\n \tskb = alloc_skb(sizeof(struct atmarp_ctrl), GFP_ATOMIC);\n-\tif (!skb)\n-\t\treturn -ENOMEM;\n+\tif (!skb) {\n+\t\terr = -ENOMEM;\n+\t\tgoto unlock;\n+\t}\n \tctrl = skb_put(skb, sizeof(struct atmarp_ctrl));\n \tctrl->type = type;\n \tctrl->itf_num = itf;\n \tctrl->ip = ip;\n-\tatm_force_charge(atmarpd, skb->truesize);\n+\tatm_force_charge(vcc, skb->truesize);\n \n-\tsk = sk_atm(atmarpd);\n+\tsk = sk_atm(vcc);\n \tskb_queue_tail(&sk->sk_receive_queue, skb);\n \tsk->sk_data_ready(sk);\n-\treturn 0;\n+unlock:\n+\trcu_read_unlock();\n+\treturn err;\n }\n \n static void link_vcc(struct clip_vcc *clip_vcc, struct atmarp_entry *entry)\n@@ -417,6 +429,8 @@ static int clip_mkip(struct atm_vcc *vcc, int timeout)\n \n \tif (!vcc->push)\n \t\treturn -EBADFD;\n+\tif (vcc->user_back)\n+\t\treturn -EINVAL;\n \tclip_vcc = kmalloc(sizeof(struct clip_vcc), GFP_KERNEL);\n \tif (!clip_vcc)\n \t\treturn -ENOMEM;\n@@ -607,10 +621,12 @@ static void atmarpd_close(struct atm_vcc *vcc)\n {\n \tpr_debug(\"\\n\");\n \n-\trtnl_lock();\n-\tatmarpd = NULL;\n+\tmutex_lock(&atmarpd_lock);\n+\tRCU_INIT_POINTER(atmarpd, NULL);\n+\tmutex_unlock(&atmarpd_lock);\n+\n+\tsynchronize_rcu();\n \tskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\n-\trtnl_unlock();\n \n \tpr_debug(\"(done)\\n\");\n \tmodule_put(THIS_MODULE);\n@@ -631,15 +647,18 @@ static struct atm_dev atmarpd_dev = {\n \n static int atm_init_atmarp(struct atm_vcc *vcc)\n {\n-\trtnl_lock();\n+\tif (vcc->push == clip_push)\n+\t\treturn -EINVAL;\n+\n+\tmutex_lock(&atmarpd_lock);\n \tif (atmarpd) {\n-\t\trtnl_unlock();\n+\t\tmutex_unlock(&atmarpd_lock);\n \t\treturn -EADDRINUSE;\n \t}\n \n \tmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\n \n-\tatmarpd = vcc;\n+\trcu_assign_pointer(atmarpd, vcc);\n \tset_bit(ATM_VF_META, &vcc->flags);\n \tset_bit(ATM_VF_READY, &vcc->flags);\n \t    /* allow replies and avoid getting closed if signaling dies */\n@@ -648,13 +667,14 @@ static int atm_init_atmarp(struct atm_vcc *vcc)\n \tvcc->push = NULL;\n \tvcc->pop = NULL; /* crash */\n \tvcc->push_oam = NULL; /* crash */\n-\trtnl_unlock();\n+\tmutex_unlock(&atmarpd_lock);\n \treturn 0;\n }\n \n static int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n {\n \tstruct atm_vcc *vcc = ATM_SD(sock);\n+\tstruct sock *sk = sock->sk;\n \tint err = 0;\n \n \tswitch (cmd) {\n@@ -675,14 +695,18 @@ static int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n \t\terr = clip_create(arg);\n \t\tbreak;\n \tcase ATMARPD_CTRL:\n+\t\tlock_sock(sk);\n \t\terr = atm_init_atmarp(vcc);\n \t\tif (!err) {\n \t\t\tsock->state = SS_CONNECTED;\n \t\t\t__module_get(THIS_MODULE);\n \t\t}\n+\t\trelease_sock(sk);\n \t\tbreak;\n \tcase ATMARP_MKIP:\n+\t\tlock_sock(sk);\n \t\terr = clip_mkip(vcc, arg);\n+\t\trelease_sock(sk);\n \t\tbreak;\n \tcase ATMARP_SETENTRY:\n \t\terr = clip_setentry(vcc, (__force __be32)arg);",
    "stats": {
      "insertions": 39,
      "deletions": 15,
      "files": 1
    }
  }
]
[
  {
    "sha": "37fb58a7273726e59f9429c89ade5116083a213d",
    "message": "cgroup,freezer: fix incomplete freezing when attaching tasks\n\nAn issue was found:\n\n\t# cd /sys/fs/cgroup/freezer/\n\t# mkdir test\n\t# echo FROZEN > test/freezer.state\n\t# cat test/freezer.state\n\tFROZEN\n\t# sleep 1000 &\n\t[1] 863\n\t# echo 863 > test/cgroup.procs\n\t# cat test/freezer.state\n\tFREEZING\n\nWhen tasks are migrated to a frozen cgroup, the freezer fails to\nimmediately freeze the tasks, causing the cgroup to remain in the\n\"FREEZING\".\n\nThe freeze_task() function is called before clearing the CGROUP_FROZEN\nflag. This causes the freezing() check to incorrectly return false,\npreventing __freeze_task() from being invoked for the migrated task.\n\nTo fix this issue, clear the CGROUP_FROZEN state before calling\nfreeze_task().\n\nFixes: f5d39b020809 (\"freezer,sched: Rewrite core freezer logic\")\nCc: stable@vger.kernel.org # v6.1+\nReported-by: Zhong Jiawei <zhongjiawei1@huawei.com>\nSigned-off-by: Chen Ridong <chenridong@huawei.com>\nAcked-by: Michal Koutný <mkoutny@suse.com>\nSigned-off-by: Tejun Heo <tj@kernel.org>",
    "author": "Chen Ridong",
    "date": "2025-06-18T09:43:30-10:00",
    "files_changed": [
      "kernel/cgroup/legacy_freezer.c"
    ],
    "diff": "diff --git a/kernel/cgroup/legacy_freezer.c b/kernel/cgroup/legacy_freezer.c\nindex 039d1eb2f215..507b8f19a262 100644\n--- a/kernel/cgroup/legacy_freezer.c\n+++ b/kernel/cgroup/legacy_freezer.c\n@@ -188,13 +188,12 @@ static void freezer_attach(struct cgroup_taskset *tset)\n \t\tif (!(freezer->state & CGROUP_FREEZING)) {\n \t\t\t__thaw_task(task);\n \t\t} else {\n-\t\t\tfreeze_task(task);\n-\n \t\t\t/* clear FROZEN and propagate upwards */\n \t\t\twhile (freezer && (freezer->state & CGROUP_FROZEN)) {\n \t\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n \t\t\t\tfreezer = parent_freezer(freezer);\n \t\t\t}\n+\t\t\tfreeze_task(task);\n \t\t}\n \t}\n ",
    "stats": {
      "insertions": 1,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "6fcab2791543924d438e7fa49276d0998b0a069f",
    "message": "ACPICA: Refuse to evaluate a method if arguments are missing\n\nAs reported in [1], a platform firmware update that increased the number\nof method parameters and forgot to update a least one of its callers,\ncaused ACPICA to crash due to use-after-free.\n\nSince this a result of a clear AML issue that arguably cannot be fixed\nup by the interpreter (it cannot produce missing data out of thin air),\naddress it by making ACPICA refuse to evaluate a method if the caller\nattempts to pass fewer arguments than expected to it.\n\nCloses: https://github.com/acpica/acpica/issues/1027 [1]\nReported-by: Peter Williams <peter@newton.cx>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>\nReviewed-by: Hans de Goede <hansg@kernel.org>\nTested-by: Hans de Goede <hansg@kernel.org> # Dell XPS 9640 with BIOS 1.12.0\nLink: https://patch.msgid.link/5909446.DvuYhMxLoT@rjwysocki.net\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
    "author": "Rafael J. Wysocki",
    "date": "2025-06-18T21:12:13+02:00",
    "files_changed": [
      "drivers/acpi/acpica/dsmethod.c"
    ],
    "diff": "diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c\nindex c8f37f4e6626..fef6fb29ece4 100644\n--- a/drivers/acpi/acpica/dsmethod.c\n+++ b/drivers/acpi/acpica/dsmethod.c\n@@ -483,6 +483,13 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,\n \t\treturn_ACPI_STATUS(AE_NULL_OBJECT);\n \t}\n \n+\tif (this_walk_state->num_operands < obj_desc->method.param_count) {\n+\t\tACPI_ERROR((AE_INFO, \"Missing argument for method [%4.4s]\",\n+\t\t\t    acpi_ut_get_node_name(method_node)));\n+\n+\t\treturn_ACPI_STATUS(AE_AML_UNINITIALIZED_ARG);\n+\t}\n+\n \t/* Init for new method, possibly wait on method mutex */\n \n \tstatus =",
    "stats": {
      "insertions": 7,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "306cb65bb0cb243389fcbd0a66907d5bdea07d1e",
    "message": "smb: fix secondary channel creation issue with kerberos by populating hostname when adding channels\n\nWhen mounting a share with kerberos authentication with multichannel\nsupport, share mounts correctly, but fails to create secondary\nchannels. This occurs because the hostname is not populated when\nadding the channels. The hostname is necessary for the userspace\ncifs.upcall program to retrieve the required credentials and pass\nit back to kernel, without hostname secondary channels fails\nestablish.\n\nCc: stable@vger.kernel.org\nReviewed-by: Shyam Prasad N <sprasad@microsoft.com>\nSigned-off-by: Bharath SM <bharathsm@microsoft.com>\nReported-by: xfuren <xfuren@gmail.com>\nLink: https://bugzilla.samba.org/show_bug.cgi?id=15824\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "author": "Bharath SM",
    "date": "2025-06-18T13:27:45-05:00",
    "files_changed": [
      "fs/smb/client/sess.c"
    ],
    "diff": "diff --git a/fs/smb/client/sess.c b/fs/smb/client/sess.c\nindex ec0db32c7d98..330bc3d25bad 100644\n--- a/fs/smb/client/sess.c\n+++ b/fs/smb/client/sess.c\n@@ -498,8 +498,7 @@ cifs_ses_add_channel(struct cifs_ses *ses,\n \tctx->domainauto = ses->domainAuto;\n \tctx->domainname = ses->domainName;\n \n-\t/* no hostname for extra channels */\n-\tctx->server_hostname = \"\";\n+\tctx->server_hostname = ses->server->hostname;\n \n \tctx->username = ses->user_name;\n \tctx->password = ses->password;",
    "stats": {
      "insertions": 1,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "88efa0de3285be66969b71ec137d9dab1ee19e52",
    "message": "EDAC/igen6: Fix NULL pointer dereference\n\nA kernel panic was reported with the following kernel log:\n\n  EDAC igen6: Expected 2 mcs, but only 1 detected.\n  BUG: unable to handle page fault for address: 000000000000d570\n  ...\n  Hardware name: Notebook V54x_6x_TU/V54x_6x_TU, BIOS Dasharo (coreboot+UEFI) v0.9.0 07/17/2024\n  RIP: e030:ecclog_handler+0x7e/0xf0 [igen6_edac]\n  ...\n  igen6_probe+0x2a0/0x343 [igen6_edac]\n  ...\n  igen6_init+0xc5/0xff0 [igen6_edac]\n  ...\n\nThis issue occurred because one memory controller was disabled by\nthe BIOS but the igen6_edac driver still checked all the memory\ncontrollers, including this absent one, to identify the source of\nthe error. Accessing the null MMIO for the absent memory controller\nresulted in the oops above.\n\nFix this issue by reverting the configuration structure to non-const\nand updating the field 'res_cfg->num_imc' to reflect the number of\ndetected memory controllers.\n\nFixes: 20e190b1c1fd (\"EDAC/igen6: Skip absent memory controllers\")\nReported-by: Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>\nCloses: https://lore.kernel.org/all/aFFN7RlXkaK_loQb@mail-itl/\nSuggested-by: Borislav Petkov <bp@alien8.de>\nSigned-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>\nSigned-off-by: Tony Luck <tony.luck@intel.com>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nTested-by: Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>\nLink: https://lore.kernel.org/r/20250618162307.1523736-1-qiuxu.zhuo@intel.com",
    "author": "Qiuxu Zhuo",
    "date": "2025-06-18T20:19:45+02:00",
    "files_changed": [
      "drivers/edac/igen6_edac.c"
    ],
    "diff": "diff --git a/drivers/edac/igen6_edac.c b/drivers/edac/igen6_edac.c\nindex 1930dc00c791..1cb5c67e78ae 100644\n--- a/drivers/edac/igen6_edac.c\n+++ b/drivers/edac/igen6_edac.c\n@@ -125,7 +125,7 @@\n #define MEM_SLICE_HASH_MASK(v)\t\t(GET_BITFIELD(v, 6, 19) << 6)\n #define MEM_SLICE_HASH_LSB_MASK_BIT(v)\tGET_BITFIELD(v, 24, 26)\n \n-static const struct res_config {\n+static struct res_config {\n \tbool machine_check;\n \t/* The number of present memory controllers. */\n \tint num_imc;\n@@ -479,7 +479,7 @@ static u64 rpl_p_err_addr(u64 ecclog)\n \treturn ECC_ERROR_LOG_ADDR45(ecclog);\n }\n \n-static const struct res_config ehl_cfg = {\n+static struct res_config ehl_cfg = {\n \t.num_imc\t\t= 1,\n \t.imc_base\t\t= 0x5000,\n \t.ibecc_base\t\t= 0xdc00,\n@@ -489,7 +489,7 @@ static const struct res_config ehl_cfg = {\n \t.err_addr_to_imc_addr\t= ehl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config icl_cfg = {\n+static struct res_config icl_cfg = {\n \t.num_imc\t\t= 1,\n \t.imc_base\t\t= 0x5000,\n \t.ibecc_base\t\t= 0xd800,\n@@ -499,7 +499,7 @@ static const struct res_config icl_cfg = {\n \t.err_addr_to_imc_addr\t= ehl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config tgl_cfg = {\n+static struct res_config tgl_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 2,\n \t.imc_base\t\t= 0x5000,\n@@ -513,7 +513,7 @@ static const struct res_config tgl_cfg = {\n \t.err_addr_to_imc_addr\t= tgl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config adl_cfg = {\n+static struct res_config adl_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 2,\n \t.imc_base\t\t= 0xd800,\n@@ -524,7 +524,7 @@ static const struct res_config adl_cfg = {\n \t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config adl_n_cfg = {\n+static struct res_config adl_n_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 1,\n \t.imc_base\t\t= 0xd800,\n@@ -535,7 +535,7 @@ static const struct res_config adl_n_cfg = {\n \t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config rpl_p_cfg = {\n+static struct res_config rpl_p_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 2,\n \t.imc_base\t\t= 0xd800,\n@@ -547,7 +547,7 @@ static const struct res_config rpl_p_cfg = {\n \t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config mtl_ps_cfg = {\n+static struct res_config mtl_ps_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 2,\n \t.imc_base\t\t= 0xd800,\n@@ -558,7 +558,7 @@ static const struct res_config mtl_ps_cfg = {\n \t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n };\n \n-static const struct res_config mtl_p_cfg = {\n+static struct res_config mtl_p_cfg = {\n \t.machine_check\t\t= true,\n \t.num_imc\t\t= 2,\n \t.imc_base\t\t= 0xd800,\n@@ -569,7 +569,7 @@ static const struct res_config mtl_p_cfg = {\n \t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n };\n \n-static const struct pci_device_id igen6_pci_tbl[] = {\n+static struct pci_device_id igen6_pci_tbl[] = {\n \t{ PCI_VDEVICE(INTEL, DID_EHL_SKU5), (kernel_ulong_t)&ehl_cfg },\n \t{ PCI_VDEVICE(INTEL, DID_EHL_SKU6), (kernel_ulong_t)&ehl_cfg },\n \t{ PCI_VDEVICE(INTEL, DID_EHL_SKU7), (kernel_ulong_t)&ehl_cfg },\n@@ -1350,9 +1350,11 @@ static int igen6_register_mcis(struct pci_dev *pdev, u64 mchbar)\n \t\treturn -ENODEV;\n \t}\n \n-\tif (lmc < res_cfg->num_imc)\n+\tif (lmc < res_cfg->num_imc) {\n \t\tigen6_printk(KERN_WARNING, \"Expected %d mcs, but only %d detected.\",\n \t\t\t     res_cfg->num_imc, lmc);\n+\t\tres_cfg->num_imc = lmc;\n+\t}\n \n \treturn 0;\n ",
    "stats": {
      "insertions": 13,
      "deletions": 11,
      "files": 1
    }
  },
  {
    "sha": "5a3b583f2050870e0403ffed650f06c94d7968a4",
    "message": "Merge tag 'ata-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/libata/linux\n\nPull ata fixes from Niklas Cassel:\n\n - Force PIO for ATAPI devices on VT6415/VT6330 as the controller locks\n   up on ATAPI DMA (Tasos)\n\n - Fix ACPI PATA cable type detection such that the controller is not\n   forced down to a slow transfer mode (Tasos)\n\n - Fix build error on 32-bit UML (Johannes)\n\n - Fix a PCI region leak in the pata_macio driver so that the driver no\n   longer fails to load after rmmod (Philipp)\n\n - Use correct DMI BIOS build date for ThinkPad W541 quirk (me)\n\n - Disallow LPM for ASUSPRO-D840SA motherboard as this board\n   interestingly enough gets graphical corruptions on the iGPU when LPM\n   is enabled (me)\n\n - Disallow LPM for Asus B550-F motherboard as this board will get\n   command timeouts on ports 5 and 6, yet LPM with the same drive works\n   fine on all other ports (Mikko)\n\n* tag 'ata-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/libata/linux:\n  ata: ahci: Disallow LPM for Asus B550-F motherboard\n  ata: ahci: Disallow LPM for ASUSPRO-D840SA motherboard\n  ata: ahci: Use correct BIOS build date for ThinkPad W541 quirk\n  ata: pata_macio: Fix PCI region leak\n  ata: pata_cs5536: fix build on 32-bit UML\n  ata: libata-acpi: Do not assume 40 wire cable if no devices are enabled\n  ata: pata_via: Force PIO for ATAPI devices on VT6415/VT6330",
    "author": "Linus Torvalds",
    "date": "2025-06-18T10:21:39-07:00",
    "files_changed": [
      "drivers/ata/ahci.c",
      "drivers/ata/libata-acpi.c",
      "drivers/ata/pata_cs5536.c",
      "drivers/ata/pata_macio.c",
      "drivers/ata/pata_via.c",
      "include/linux/libata.h"
    ],
    "diff": "diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c\nindex 163ac909bd06..e5e5c2e81d09 100644\n--- a/drivers/ata/ahci.c\n+++ b/drivers/ata/ahci.c\n@@ -1410,8 +1410,15 @@ static bool ahci_broken_suspend(struct pci_dev *pdev)\n \n static bool ahci_broken_lpm(struct pci_dev *pdev)\n {\n+\t/*\n+\t * Platforms with LPM problems.\n+\t * If driver_data is NULL, there is no existing BIOS version with\n+\t * functioning LPM.\n+\t * If driver_data is non-NULL, then driver_data contains the DMI BIOS\n+\t * build date of the first BIOS version with functioning LPM (i.e. older\n+\t * BIOS versions have broken LPM).\n+\t */\n \tstatic const struct dmi_system_id sysids[] = {\n-\t\t/* Various Lenovo 50 series have LPM issues with older BIOSen */\n \t\t{\n \t\t\t.matches = {\n \t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n@@ -1438,13 +1445,30 @@ static bool ahci_broken_lpm(struct pci_dev *pdev)\n \t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n \t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ThinkPad W541\"),\n \t\t\t},\n+\t\t\t.driver_data = \"20180409\", /* 2.35 */\n+\t\t},\n+\t\t{\n+\t\t\t.matches = {\n+\t\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n+\t\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"ASUSPRO D840MB_M840SA\"),\n+\t\t\t},\n+\t\t\t/* 320 is broken, there is no known good version. */\n+\t\t},\n+\t\t{\n \t\t\t/*\n-\t\t\t * Note date based on release notes, 2.35 has been\n-\t\t\t * reported to be good, but I've been unable to get\n-\t\t\t * a hold of the reporter to get the DMI BIOS date.\n-\t\t\t * TODO: fix this.\n+\t\t\t * AMD 500 Series Chipset SATA Controller [1022:43eb]\n+\t\t\t * on this motherboard timeouts on ports 5 and 6 when\n+\t\t\t * LPM is enabled, at least with WDC WD20EFAX-68FB5N0\n+\t\t\t * hard drives. LPM with the same drive works fine on\n+\t\t\t * all other ports on the same controller.\n \t\t\t */\n-\t\t\t.driver_data = \"20180310\", /* 2.35 */\n+\t\t\t.matches = {\n+\t\t\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n+\t\t\t\t\t  \"ASUSTeK COMPUTER INC.\"),\n+\t\t\t\tDMI_MATCH(DMI_BOARD_NAME,\n+\t\t\t\t\t  \"ROG STRIX B550-F GAMING (WI-FI)\"),\n+\t\t\t},\n+\t\t\t/* 3621 is broken, there is no known good version. */\n \t\t},\n \t\t{ }\t/* terminate list */\n \t};\n@@ -1455,6 +1479,9 @@ static bool ahci_broken_lpm(struct pci_dev *pdev)\n \tif (!dmi)\n \t\treturn false;\n \n+\tif (!dmi->driver_data)\n+\t\treturn true;\n+\n \tdmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\n \tsnprintf(buf, sizeof(buf), \"%04d%02d%02d\", year, month, date);\n \ndiff --git a/drivers/ata/libata-acpi.c b/drivers/ata/libata-acpi.c\nindex b7f0bf795521..f2140fc06ba0 100644\n--- a/drivers/ata/libata-acpi.c\n+++ b/drivers/ata/libata-acpi.c\n@@ -514,15 +514,19 @@ unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n EXPORT_SYMBOL_GPL(ata_acpi_gtm_xfermask);\n \n /**\n- * ata_acpi_cbl_80wire\t\t-\tCheck for 80 wire cable\n+ * ata_acpi_cbl_pata_type - Return PATA cable type\n  * @ap: Port to check\n- * @gtm: GTM data to use\n  *\n- * Return 1 if the @gtm indicates the BIOS selected an 80wire mode.\n+ * Return ATA_CBL_PATA* according to the transfer mode selected by BIOS\n  */\n-int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm)\n+int ata_acpi_cbl_pata_type(struct ata_port *ap)\n {\n \tstruct ata_device *dev;\n+\tint ret = ATA_CBL_PATA_UNK;\n+\tconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\n+\n+\tif (!gtm)\n+\t\treturn ATA_CBL_PATA40;\n \n \tata_for_each_dev(dev, &ap->link, ENABLED) {\n \t\tunsigned int xfer_mask, udma_mask;\n@@ -530,13 +534,17 @@ int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm)\n \t\txfer_mask = ata_acpi_gtm_xfermask(dev, gtm);\n \t\tata_unpack_xfermask(xfer_mask, NULL, NULL, &udma_mask);\n \n-\t\tif (udma_mask & ~ATA_UDMA_MASK_40C)\n-\t\t\treturn 1;\n+\t\tret = ATA_CBL_PATA40;\n+\n+\t\tif (udma_mask & ~ATA_UDMA_MASK_40C) {\n+\t\t\tret = ATA_CBL_PATA80;\n+\t\t\tbreak;\n+\t\t}\n \t}\n \n-\treturn 0;\n+\treturn ret;\n }\n-EXPORT_SYMBOL_GPL(ata_acpi_cbl_80wire);\n+EXPORT_SYMBOL_GPL(ata_acpi_cbl_pata_type);\n \n static void ata_acpi_gtf_to_tf(struct ata_device *dev,\n \t\t\t       const struct ata_acpi_gtf *gtf,\ndiff --git a/drivers/ata/pata_cs5536.c b/drivers/ata/pata_cs5536.c\nindex b811efd2cc34..73e81e160c91 100644\n--- a/drivers/ata/pata_cs5536.c\n+++ b/drivers/ata/pata_cs5536.c\n@@ -27,7 +27,7 @@\n #include <scsi/scsi_host.h>\n #include <linux/dmi.h>\n \n-#ifdef CONFIG_X86_32\n+#if defined(CONFIG_X86) && defined(CONFIG_X86_32)\n #include <asm/msr.h>\n static int use_msr;\n module_param_named(msr, use_msr, int, 0644);\ndiff --git a/drivers/ata/pata_macio.c b/drivers/ata/pata_macio.c\nindex fbf5f07ea357..f7a933eefe05 100644\n--- a/drivers/ata/pata_macio.c\n+++ b/drivers/ata/pata_macio.c\n@@ -1298,7 +1298,7 @@ static int pata_macio_pci_attach(struct pci_dev *pdev,\n \tpriv->dev = &pdev->dev;\n \n \t/* Get MMIO regions */\n-\tif (pci_request_regions(pdev, \"pata-macio\")) {\n+\tif (pcim_request_all_regions(pdev, \"pata-macio\")) {\n \t\tdev_err(&pdev->dev,\n \t\t\t\"Cannot obtain PCI resources\\n\");\n \t\treturn -EBUSY;\ndiff --git a/drivers/ata/pata_via.c b/drivers/ata/pata_via.c\nindex 696b99720dcb..bb80e7800dcb 100644\n--- a/drivers/ata/pata_via.c\n+++ b/drivers/ata/pata_via.c\n@@ -201,11 +201,9 @@ static int via_cable_detect(struct ata_port *ap) {\n \t   two drives */\n \tif (ata66 & (0x10100000 >> (16 * ap->port_no)))\n \t\treturn ATA_CBL_PATA80;\n+\n \t/* Check with ACPI so we can spot BIOS reported SATA bridges */\n-\tif (ata_acpi_init_gtm(ap) &&\n-\t    ata_acpi_cbl_80wire(ap, ata_acpi_init_gtm(ap)))\n-\t\treturn ATA_CBL_PATA80;\n-\treturn ATA_CBL_PATA40;\n+\treturn ata_acpi_cbl_pata_type(ap);\n }\n \n static int via_pre_reset(struct ata_link *link, unsigned long deadline)\n@@ -368,7 +366,8 @@ static unsigned int via_mode_filter(struct ata_device *dev, unsigned int mask)\n \t}\n \n \tif (dev->class == ATA_DEV_ATAPI &&\n-\t    dmi_check_system(no_atapi_dma_dmi_table)) {\n+\t    (dmi_check_system(no_atapi_dma_dmi_table) ||\n+\t     config->id == PCI_DEVICE_ID_VIA_6415)) {\n \t\tata_dev_warn(dev, \"controller locks up on ATAPI DMA, forcing PIO\\n\");\n \t\tmask &= ATA_MASK_PIO;\n \t}\ndiff --git a/include/linux/libata.h b/include/linux/libata.h\nindex 31be45fd47a6..1e5aec839041 100644\n--- a/include/linux/libata.h\n+++ b/include/linux/libata.h\n@@ -1352,7 +1352,7 @@ int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm);\n int ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *stm);\n unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n \t\t\t\t   const struct ata_acpi_gtm *gtm);\n-int ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm);\n+int ata_acpi_cbl_pata_type(struct ata_port *ap);\n #else\n static inline const struct ata_acpi_gtm *ata_acpi_init_gtm(struct ata_port *ap)\n {\n@@ -1377,10 +1377,9 @@ static inline unsigned int ata_acpi_gtm_xfermask(struct ata_device *dev,\n \treturn 0;\n }\n \n-static inline int ata_acpi_cbl_80wire(struct ata_port *ap,\n-\t\t\t\t      const struct ata_acpi_gtm *gtm)\n+static inline int ata_acpi_cbl_pata_type(struct ata_port *ap)\n {\n-\treturn 0;\n+\treturn ATA_CBL_PATA40;\n }\n #endif\n ",
    "stats": {
      "insertions": 58,
      "deletions": 25,
      "files": 6
    }
  }
]
[
  {
    "sha": "3f75bfff44be0646580fe4efda45d646f9c1693b",
    "message": "Merge tag 'mtd/fixes-for-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/mtd/linux\n\nPull mtd fixes from Miquel Raynal:\n \"The main fix that really needs to get in is the revert of the patch\n  adding the new mtd_master class, because it entirely fails the\n  partitioning if a specific Kconfig option is set. We need to think how\n  to handle that differently, so let's revert it as we need to get back\n  to the pen and paper situation again.\n\n  Otherwise the definition of some Winbond SPI NAND chips are receiving\n  some fixes (geometry and maximum frequency, mostly).\n\n  And finally a small memory leak gets also fixed\"\n\n* tag 'mtd/fixes-for-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/mtd/linux:\n  mtd: spinand: fix memory leak of ECC engine conf\n  mtd: spinand: winbond: Prevent unsupported frequencies on dual/quad I/O variants\n  mtd: spinand: winbond: Increase maximum frequency on an octal operation\n  mtd: spinand: winbond: Fix W35N number of planes/LUN\n  Revert \"mtd: core: always create master device\"",
    "author": "Linus Torvalds",
    "date": "2025-06-20T22:36:48-07:00",
    "files_changed": [
      "drivers/mtd/mtdchar.c",
      "drivers/mtd/mtdcore.c",
      "drivers/mtd/mtdcore.h",
      "drivers/mtd/mtdpart.c",
      "drivers/mtd/nand/spi/core.c",
      "drivers/mtd/nand/spi/winbond.c",
      "include/linux/mtd/partitions.h",
      "include/linux/mtd/spinand.h"
    ],
    "diff": "diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c\nindex 391d81ad960c..8dc4f5c493fc 100644\n--- a/drivers/mtd/mtdchar.c\n+++ b/drivers/mtd/mtdchar.c\n@@ -559,7 +559,7 @@ static int mtdchar_blkpg_ioctl(struct mtd_info *mtd,\n \t\t/* Sanitize user input */\n \t\tp.devname[BLKPG_DEVNAMELTH - 1] = '\\0';\n \n-\t\treturn mtd_add_partition(mtd, p.devname, p.start, p.length, NULL);\n+\t\treturn mtd_add_partition(mtd, p.devname, p.start, p.length);\n \n \tcase BLKPG_DEL_PARTITION:\n \ndiff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c\nindex 429d8c16baf0..5ba9a741f5ac 100644\n--- a/drivers/mtd/mtdcore.c\n+++ b/drivers/mtd/mtdcore.c\n@@ -68,13 +68,7 @@ static struct class mtd_class = {\n \t.pm = MTD_CLS_PM_OPS,\n };\n \n-static struct class mtd_master_class = {\n-\t.name = \"mtd_master\",\n-\t.pm = MTD_CLS_PM_OPS,\n-};\n-\n static DEFINE_IDR(mtd_idr);\n-static DEFINE_IDR(mtd_master_idr);\n \n /* These are exported solely for the purpose of mtd_blkdevs.c. You\n    should not use them for _anything_ else */\n@@ -89,9 +83,8 @@ EXPORT_SYMBOL_GPL(__mtd_next_device);\n \n static LIST_HEAD(mtd_notifiers);\n \n-#define MTD_MASTER_DEVS 255\n+\n #define MTD_DEVT(index) MKDEV(MTD_CHAR_MAJOR, (index)*2)\n-static dev_t mtd_master_devt;\n \n /* REVISIT once MTD uses the driver model better, whoever allocates\n  * the mtd_info will probably want to use the release() hook...\n@@ -111,17 +104,6 @@ static void mtd_release(struct device *dev)\n \tdevice_destroy(&mtd_class, index + 1);\n }\n \n-static void mtd_master_release(struct device *dev)\n-{\n-\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n-\n-\tidr_remove(&mtd_master_idr, mtd->index);\n-\tof_node_put(mtd_get_of_node(mtd));\n-\n-\tif (mtd_is_partition(mtd))\n-\t\trelease_mtd_partition(mtd);\n-}\n-\n static void mtd_device_release(struct kref *kref)\n {\n \tstruct mtd_info *mtd = container_of(kref, struct mtd_info, refcnt);\n@@ -385,11 +367,6 @@ static const struct device_type mtd_devtype = {\n \t.release\t= mtd_release,\n };\n \n-static const struct device_type mtd_master_devtype = {\n-\t.name\t\t= \"mtd_master\",\n-\t.release\t= mtd_master_release,\n-};\n-\n static bool mtd_expert_analysis_mode;\n \n #ifdef CONFIG_DEBUG_FS\n@@ -657,13 +634,13 @@ static void mtd_check_of_node(struct mtd_info *mtd)\n /**\n  *\tadd_mtd_device - register an MTD device\n  *\t@mtd: pointer to new MTD device info structure\n- *\t@partitioned: create partitioned device\n  *\n  *\tAdd a device to the list of MTD devices present in the system, and\n  *\tnotify each currently active MTD 'user' of its arrival. Returns\n  *\tzero on success or non-zero on failure.\n  */\n-int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n+\n+int add_mtd_device(struct mtd_info *mtd)\n {\n \tstruct device_node *np = mtd_get_of_node(mtd);\n \tstruct mtd_info *master = mtd_get_master(mtd);\n@@ -710,17 +687,10 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \tofidx = -1;\n \tif (np)\n \t\tofidx = of_alias_get_id(np, \"mtd\");\n-\tif (partitioned) {\n-\t\tif (ofidx >= 0)\n-\t\t\ti = idr_alloc(&mtd_idr, mtd, ofidx, ofidx + 1, GFP_KERNEL);\n-\t\telse\n-\t\t\ti = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);\n-\t} else {\n-\t\tif (ofidx >= 0)\n-\t\t\ti = idr_alloc(&mtd_master_idr, mtd, ofidx, ofidx + 1, GFP_KERNEL);\n-\t\telse\n-\t\t\ti = idr_alloc(&mtd_master_idr, mtd, 0, 0, GFP_KERNEL);\n-\t}\n+\tif (ofidx >= 0)\n+\t\ti = idr_alloc(&mtd_idr, mtd, ofidx, ofidx + 1, GFP_KERNEL);\n+\telse\n+\t\ti = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);\n \tif (i < 0) {\n \t\terror = i;\n \t\tgoto fail_locked;\n@@ -768,18 +738,10 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \t/* Caller should have set dev.parent to match the\n \t * physical device, if appropriate.\n \t */\n-\tif (partitioned) {\n-\t\tmtd->dev.type = &mtd_devtype;\n-\t\tmtd->dev.class = &mtd_class;\n-\t\tmtd->dev.devt = MTD_DEVT(i);\n-\t\tdev_set_name(&mtd->dev, \"mtd%d\", i);\n-\t\terror = dev_set_name(&mtd->dev, \"mtd%d\", i);\n-\t} else {\n-\t\tmtd->dev.type = &mtd_master_devtype;\n-\t\tmtd->dev.class = &mtd_master_class;\n-\t\tmtd->dev.devt = MKDEV(MAJOR(mtd_master_devt), i);\n-\t\terror = dev_set_name(&mtd->dev, \"mtd_master%d\", i);\n-\t}\n+\tmtd->dev.type = &mtd_devtype;\n+\tmtd->dev.class = &mtd_class;\n+\tmtd->dev.devt = MTD_DEVT(i);\n+\terror = dev_set_name(&mtd->dev, \"mtd%d\", i);\n \tif (error)\n \t\tgoto fail_devname;\n \tdev_set_drvdata(&mtd->dev, mtd);\n@@ -787,7 +749,6 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \tof_node_get(mtd_get_of_node(mtd));\n \terror = device_register(&mtd->dev);\n \tif (error) {\n-\t\tpr_err(\"mtd: %s device_register fail %d\\n\", mtd->name, error);\n \t\tput_device(&mtd->dev);\n \t\tgoto fail_added;\n \t}\n@@ -799,13 +760,10 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \n \tmtd_debugfs_populate(mtd);\n \n-\tif (partitioned) {\n-\t\tdevice_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,\n-\t\t\t      \"mtd%dro\", i);\n-\t}\n+\tdevice_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,\n+\t\t      \"mtd%dro\", i);\n \n-\tpr_debug(\"mtd: Giving out %spartitioned device %d to %s\\n\",\n-\t\t partitioned ? \"\" : \"un-\", i, mtd->name);\n+\tpr_debug(\"mtd: Giving out device %d to %s\\n\", i, mtd->name);\n \t/* No need to get a refcount on the module containing\n \t   the notifier, since we hold the mtd_table_mutex */\n \tlist_for_each_entry(not, &mtd_notifiers, list)\n@@ -813,16 +771,13 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \n \tmutex_unlock(&mtd_table_mutex);\n \n-\tif (partitioned) {\n-\t\tif (of_property_read_bool(mtd_get_of_node(mtd), \"linux,rootfs\")) {\n-\t\t\tif (IS_BUILTIN(CONFIG_MTD)) {\n-\t\t\t\tpr_info(\"mtd: setting mtd%d (%s) as root device\\n\",\n-\t\t\t\t\tmtd->index, mtd->name);\n-\t\t\t\tROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);\n-\t\t\t} else {\n-\t\t\t\tpr_warn(\"mtd: can't set mtd%d (%s) as root device - mtd must be builtin\\n\",\n-\t\t\t\t\tmtd->index, mtd->name);\n-\t\t\t}\n+\tif (of_property_read_bool(mtd_get_of_node(mtd), \"linux,rootfs\")) {\n+\t\tif (IS_BUILTIN(CONFIG_MTD)) {\n+\t\t\tpr_info(\"mtd: setting mtd%d (%s) as root device\\n\", mtd->index, mtd->name);\n+\t\t\tROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);\n+\t\t} else {\n+\t\t\tpr_warn(\"mtd: can't set mtd%d (%s) as root device - mtd must be builtin\\n\",\n+\t\t\t\tmtd->index, mtd->name);\n \t\t}\n \t}\n \n@@ -838,10 +793,7 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n fail_added:\n \tof_node_put(mtd_get_of_node(mtd));\n fail_devname:\n-\tif (partitioned)\n-\t\tidr_remove(&mtd_idr, i);\n-\telse\n-\t\tidr_remove(&mtd_master_idr, i);\n+\tidr_remove(&mtd_idr, i);\n fail_locked:\n \tmutex_unlock(&mtd_table_mutex);\n \treturn error;\n@@ -859,14 +811,12 @@ int add_mtd_device(struct mtd_info *mtd, bool partitioned)\n \n int del_mtd_device(struct mtd_info *mtd)\n {\n-\tstruct mtd_notifier *not;\n-\tstruct idr *idr;\n \tint ret;\n+\tstruct mtd_notifier *not;\n \n \tmutex_lock(&mtd_table_mutex);\n \n-\tidr = mtd->dev.class == &mtd_class ? &mtd_idr : &mtd_master_idr;\n-\tif (idr_find(idr, mtd->index) != mtd) {\n+\tif (idr_find(&mtd_idr, mtd->index) != mtd) {\n \t\tret = -ENODEV;\n \t\tgoto out_error;\n \t}\n@@ -1106,7 +1056,6 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,\n \t\t\t      const struct mtd_partition *parts,\n \t\t\t      int nr_parts)\n {\n-\tstruct mtd_info *parent;\n \tint ret, err;\n \n \tmtd_set_dev_defaults(mtd);\n@@ -1115,30 +1064,25 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,\n \tif (ret)\n \t\tgoto out;\n \n-\tret = add_mtd_device(mtd, false);\n-\tif (ret)\n-\t\tgoto out;\n-\n \tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {\n-\t\tret = mtd_add_partition(mtd, mtd->name, 0, MTDPART_SIZ_FULL, &parent);\n+\t\tret = add_mtd_device(mtd);\n \t\tif (ret)\n \t\t\tgoto out;\n-\n-\t} else {\n-\t\tparent = mtd;\n \t}\n \n \t/* Prefer parsed partitions over driver-provided fallback */\n-\tret = parse_mtd_partitions(parent, types, parser_data);\n+\tret = parse_mtd_partitions(mtd, types, parser_data);\n \tif (ret == -EPROBE_DEFER)\n \t\tgoto out;\n \n \tif (ret > 0)\n \t\tret = 0;\n \telse if (nr_parts)\n-\t\tret = add_mtd_partitions(parent, parts, nr_parts);\n-\telse if (!IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n-\t\tret = mtd_add_partition(parent, mtd->name, 0, MTDPART_SIZ_FULL, NULL);\n+\t\tret = add_mtd_partitions(mtd, parts, nr_parts);\n+\telse if (!device_is_registered(&mtd->dev))\n+\t\tret = add_mtd_device(mtd);\n+\telse\n+\t\tret = 0;\n \n \tif (ret)\n \t\tgoto out;\n@@ -1158,14 +1102,13 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,\n \t\tregister_reboot_notifier(&mtd->reboot_notifier);\n \t}\n \n-\treturn 0;\n out:\n-\tnvmem_unregister(mtd->otp_user_nvmem);\n-\tnvmem_unregister(mtd->otp_factory_nvmem);\n-\n-\tdel_mtd_partitions(mtd);\n+\tif (ret) {\n+\t\tnvmem_unregister(mtd->otp_user_nvmem);\n+\t\tnvmem_unregister(mtd->otp_factory_nvmem);\n+\t}\n \n-\tif (device_is_registered(&mtd->dev)) {\n+\tif (ret && device_is_registered(&mtd->dev)) {\n \t\terr = del_mtd_device(mtd);\n \t\tif (err)\n \t\t\tpr_err(\"Error when deleting MTD device (%d)\\n\", err);\n@@ -1324,7 +1267,8 @@ int __get_mtd_device(struct mtd_info *mtd)\n \t\tmtd = mtd->parent;\n \t}\n \n-\tkref_get(&master->refcnt);\n+\tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n+\t\tkref_get(&master->refcnt);\n \n \treturn 0;\n }\n@@ -1418,7 +1362,8 @@ void __put_mtd_device(struct mtd_info *mtd)\n \t\tmtd = parent;\n \t}\n \n-\tkref_put(&master->refcnt, mtd_device_release);\n+\tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n+\t\tkref_put(&master->refcnt, mtd_device_release);\n \n \tmodule_put(master->owner);\n \n@@ -2585,16 +2530,6 @@ static int __init init_mtd(void)\n \tif (ret)\n \t\tgoto err_reg;\n \n-\tret = class_register(&mtd_master_class);\n-\tif (ret)\n-\t\tgoto err_reg2;\n-\n-\tret = alloc_chrdev_region(&mtd_master_devt, 0, MTD_MASTER_DEVS, \"mtd_master\");\n-\tif (ret < 0) {\n-\t\tpr_err(\"unable to allocate char dev region\\n\");\n-\t\tgoto err_chrdev;\n-\t}\n-\n \tmtd_bdi = mtd_bdi_init(\"mtd\");\n \tif (IS_ERR(mtd_bdi)) {\n \t\tret = PTR_ERR(mtd_bdi);\n@@ -2619,10 +2554,6 @@ static int __init init_mtd(void)\n \tbdi_unregister(mtd_bdi);\n \tbdi_put(mtd_bdi);\n err_bdi:\n-\tunregister_chrdev_region(mtd_master_devt, MTD_MASTER_DEVS);\n-err_chrdev:\n-\tclass_unregister(&mtd_master_class);\n-err_reg2:\n \tclass_unregister(&mtd_class);\n err_reg:\n \tpr_err(\"Error registering mtd class or bdi: %d\\n\", ret);\n@@ -2636,12 +2567,9 @@ static void __exit cleanup_mtd(void)\n \tif (proc_mtd)\n \t\tremove_proc_entry(\"mtd\", NULL);\n \tclass_unregister(&mtd_class);\n-\tclass_unregister(&mtd_master_class);\n-\tunregister_chrdev_region(mtd_master_devt, MTD_MASTER_DEVS);\n \tbdi_unregister(mtd_bdi);\n \tbdi_put(mtd_bdi);\n \tidr_destroy(&mtd_idr);\n-\tidr_destroy(&mtd_master_idr);\n }\n \n module_init(init_mtd);\ndiff --git a/drivers/mtd/mtdcore.h b/drivers/mtd/mtdcore.h\nindex 2258d31c5aa6..b014861a06a6 100644\n--- a/drivers/mtd/mtdcore.h\n+++ b/drivers/mtd/mtdcore.h\n@@ -8,7 +8,7 @@ extern struct mutex mtd_table_mutex;\n extern struct backing_dev_info *mtd_bdi;\n \n struct mtd_info *__mtd_next_device(int i);\n-int __must_check add_mtd_device(struct mtd_info *mtd, bool partitioned);\n+int __must_check add_mtd_device(struct mtd_info *mtd);\n int del_mtd_device(struct mtd_info *mtd);\n int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);\n int del_mtd_partitions(struct mtd_info *);\ndiff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c\nindex 5a3db36d734e..994e8c51e674 100644\n--- a/drivers/mtd/mtdpart.c\n+++ b/drivers/mtd/mtdpart.c\n@@ -86,7 +86,8 @@ static struct mtd_info *allocate_partition(struct mtd_info *parent,\n \t * parent conditional on that option. Note, this is a way to\n \t * distinguish between the parent and its partitions in sysfs.\n \t */\n-\tchild->dev.parent = &parent->dev;\n+\tchild->dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) || mtd_is_partition(parent) ?\n+\t\t\t    &parent->dev : parent->dev.parent;\n \tchild->dev.of_node = part->of_node;\n \tchild->parent = parent;\n \tchild->part.offset = part->offset;\n@@ -242,7 +243,7 @@ static int mtd_add_partition_attrs(struct mtd_info *new)\n }\n \n int mtd_add_partition(struct mtd_info *parent, const char *name,\n-\t\t      long long offset, long long length, struct mtd_info **out)\n+\t\t      long long offset, long long length)\n {\n \tstruct mtd_info *master = mtd_get_master(parent);\n \tu64 parent_size = mtd_is_partition(parent) ?\n@@ -275,15 +276,12 @@ int mtd_add_partition(struct mtd_info *parent, const char *name,\n \tlist_add_tail(&child->part.node, &parent->partitions);\n \tmutex_unlock(&master->master.partitions_lock);\n \n-\tret = add_mtd_device(child, true);\n+\tret = add_mtd_device(child);\n \tif (ret)\n \t\tgoto err_remove_part;\n \n \tmtd_add_partition_attrs(child);\n \n-\tif (out)\n-\t\t*out = child;\n-\n \treturn 0;\n \n err_remove_part:\n@@ -415,7 +413,7 @@ int add_mtd_partitions(struct mtd_info *parent,\n \t\tlist_add_tail(&child->part.node, &parent->partitions);\n \t\tmutex_unlock(&master->master.partitions_lock);\n \n-\t\tret = add_mtd_device(child, true);\n+\t\tret = add_mtd_device(child);\n \t\tif (ret) {\n \t\t\tmutex_lock(&master->master.partitions_lock);\n \t\t\tlist_del(&child->part.node);\n@@ -592,6 +590,9 @@ static int mtd_part_of_parse(struct mtd_info *master,\n \tint ret, err = 0;\n \n \tdev = &master->dev;\n+\t/* Use parent device (controller) if the top level MTD is not registered */\n+\tif (!IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) && !mtd_is_partition(master))\n+\t\tdev = master->dev.parent;\n \n \tnp = mtd_get_of_node(master);\n \tif (mtd_is_partition(master))\n@@ -710,7 +711,6 @@ int parse_mtd_partitions(struct mtd_info *master, const char *const *types,\n \t\tif (ret < 0 && !err)\n \t\t\terr = ret;\n \t}\n-\n \treturn err;\n }\n \ndiff --git a/drivers/mtd/nand/spi/core.c b/drivers/mtd/nand/spi/core.c\nindex 7099db7a62be..c411fe9be3ef 100644\n--- a/drivers/mtd/nand/spi/core.c\n+++ b/drivers/mtd/nand/spi/core.c\n@@ -1585,6 +1585,7 @@ static void spinand_cleanup(struct spinand_device *spinand)\n {\n \tstruct nand_device *nand = spinand_to_nand(spinand);\n \n+\tnanddev_ecc_engine_cleanup(nand);\n \tnanddev_cleanup(nand);\n \tspinand_manufacturer_cleanup(spinand);\n \tkfree(spinand->databuf);\ndiff --git a/drivers/mtd/nand/spi/winbond.c b/drivers/mtd/nand/spi/winbond.c\nindex 19f8dd4a6370..b7a28f001a38 100644\n--- a/drivers/mtd/nand/spi/winbond.c\n+++ b/drivers/mtd/nand/spi/winbond.c\n@@ -25,7 +25,7 @@\n \n static SPINAND_OP_VARIANTS(read_cache_octal_variants,\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1D_8D_OP(0, 2, NULL, 0, 105 * HZ_PER_MHZ),\n-\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_8S_8S_OP(0, 16, NULL, 0, 86 * HZ_PER_MHZ),\n+\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_8S_8S_OP(0, 16, NULL, 0, 162 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1S_8S_OP(0, 1, NULL, 0, 133 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_FAST_1S_1S_1S_OP(0, 1, NULL, 0),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1S_1S_OP(0, 1, NULL, 0));\n@@ -42,11 +42,11 @@ static SPINAND_OP_VARIANTS(update_cache_octal_variants,\n static SPINAND_OP_VARIANTS(read_cache_dual_quad_dtr_variants,\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_4D_4D_OP(0, 8, NULL, 0, 80 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1D_4D_OP(0, 2, NULL, 0, 80 * HZ_PER_MHZ),\n-\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_4S_4S_OP(0, 2, NULL, 0),\n+\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_4S_4S_OP(0, 2, NULL, 0, 104 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1S_4S_OP(0, 1, NULL, 0),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_2D_2D_OP(0, 4, NULL, 0, 80 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1D_2D_OP(0, 2, NULL, 0, 80 * HZ_PER_MHZ),\n-\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_2S_2S_OP(0, 1, NULL, 0),\n+\t\tSPINAND_PAGE_READ_FROM_CACHE_1S_2S_2S_OP(0, 1, NULL, 0, 104 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1S_2S_OP(0, 1, NULL, 0),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_1S_1D_1D_OP(0, 2, NULL, 0, 80 * HZ_PER_MHZ),\n \t\tSPINAND_PAGE_READ_FROM_CACHE_FAST_1S_1S_1S_OP(0, 1, NULL, 0),\n@@ -289,7 +289,7 @@ static const struct spinand_info winbond_spinand_table[] = {\n \t\t     SPINAND_ECCINFO(&w35n01jw_ooblayout, NULL)),\n \tSPINAND_INFO(\"W35N02JW\", /* 1.8V */\n \t\t     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xdf, 0x22),\n-\t\t     NAND_MEMORG(1, 4096, 128, 64, 512, 10, 2, 1, 1),\n+\t\t     NAND_MEMORG(1, 4096, 128, 64, 512, 10, 1, 2, 1),\n \t\t     NAND_ECCREQ(1, 512),\n \t\t     SPINAND_INFO_OP_VARIANTS(&read_cache_octal_variants,\n \t\t\t\t\t      &write_cache_octal_variants,\n@@ -298,7 +298,7 @@ static const struct spinand_info winbond_spinand_table[] = {\n \t\t     SPINAND_ECCINFO(&w35n01jw_ooblayout, NULL)),\n \tSPINAND_INFO(\"W35N04JW\", /* 1.8V */\n \t\t     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xdf, 0x23),\n-\t\t     NAND_MEMORG(1, 4096, 128, 64, 512, 10, 4, 1, 1),\n+\t\t     NAND_MEMORG(1, 4096, 128, 64, 512, 10, 1, 4, 1),\n \t\t     NAND_ECCREQ(1, 512),\n \t\t     SPINAND_INFO_OP_VARIANTS(&read_cache_octal_variants,\n \t\t\t\t\t      &write_cache_octal_variants,\ndiff --git a/include/linux/mtd/partitions.h b/include/linux/mtd/partitions.h\nindex 5daf80df9e89..b74a539ec581 100644\n--- a/include/linux/mtd/partitions.h\n+++ b/include/linux/mtd/partitions.h\n@@ -108,7 +108,7 @@ extern void deregister_mtd_parser(struct mtd_part_parser *parser);\n \t\t      deregister_mtd_parser)\n \n int mtd_add_partition(struct mtd_info *master, const char *name,\n-\t\t      long long offset, long long length, struct mtd_info **part);\n+\t\t      long long offset, long long length);\n int mtd_del_partition(struct mtd_info *master, int partno);\n uint64_t mtd_get_device_size(const struct mtd_info *mtd);\n \ndiff --git a/include/linux/mtd/spinand.h b/include/linux/mtd/spinand.h\nindex 811a0f356315..15eaa09da998 100644\n--- a/include/linux/mtd/spinand.h\n+++ b/include/linux/mtd/spinand.h\n@@ -113,11 +113,12 @@\n \t\t   SPI_MEM_DTR_OP_DATA_IN(len, buf, 2),\t\t\t\\\n \t\t   SPI_MEM_OP_MAX_FREQ(freq))\n \n-#define SPINAND_PAGE_READ_FROM_CACHE_1S_2S_2S_OP(addr, ndummy, buf, len) \\\n+#define SPINAND_PAGE_READ_FROM_CACHE_1S_2S_2S_OP(addr, ndummy, buf, len, ...) \\\n \tSPI_MEM_OP(SPI_MEM_OP_CMD(0xbb, 1),\t\t\t\t\\\n \t\t   SPI_MEM_OP_ADDR(2, addr, 2),\t\t\t\t\\\n \t\t   SPI_MEM_OP_DUMMY(ndummy, 2),\t\t\t\t\\\n-\t\t   SPI_MEM_OP_DATA_IN(len, buf, 2))\n+\t\t   SPI_MEM_OP_DATA_IN(len, buf, 2),\t\t\t\\\n+\t\t   SPI_MEM_OP_MAX_FREQ(__VA_ARGS__ + 0))\n \n #define SPINAND_PAGE_READ_FROM_CACHE_3A_1S_2S_2S_OP(addr, ndummy, buf, len) \\\n \tSPI_MEM_OP(SPI_MEM_OP_CMD(0xbb, 1),\t\t\t\t\\\n@@ -151,11 +152,12 @@\n \t\t   SPI_MEM_DTR_OP_DATA_IN(len, buf, 4),\t\t\t\\\n \t\t   SPI_MEM_OP_MAX_FREQ(freq))\n \n-#define SPINAND_PAGE_READ_FROM_CACHE_1S_4S_4S_OP(addr, ndummy, buf, len) \\\n+#define SPINAND_PAGE_READ_FROM_CACHE_1S_4S_4S_OP(addr, ndummy, buf, len, ...) \\\n \tSPI_MEM_OP(SPI_MEM_OP_CMD(0xeb, 1),\t\t\t\t\\\n \t\t   SPI_MEM_OP_ADDR(2, addr, 4),\t\t\t\t\\\n \t\t   SPI_MEM_OP_DUMMY(ndummy, 4),\t\t\t\t\\\n-\t\t   SPI_MEM_OP_DATA_IN(len, buf, 4))\n+\t\t   SPI_MEM_OP_DATA_IN(len, buf, 4),\t\t\t\\\n+\t\t   SPI_MEM_OP_MAX_FREQ(__VA_ARGS__ + 0))\n \n #define SPINAND_PAGE_READ_FROM_CACHE_3A_1S_4S_4S_OP(addr, ndummy, buf, len) \\\n \tSPI_MEM_OP(SPI_MEM_OP_CMD(0xeb, 1),\t\t\t\t\\",
    "stats": {
      "insertions": 63,
      "deletions": 132,
      "files": 8
    }
  },
  {
    "sha": "a765b9e6db4082eefe6e1581a9495518685e7abf",
    "message": "Merge tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi\n\nPull SCSI fixes from James Bottomley:\n \"Two small and obvious driver fixes\"\n\n* tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi:\n  scsi: elx: efct: Fix memory leak in efct_hw_parse_filter()\n  scsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port()",
    "author": "Linus Torvalds",
    "date": "2025-06-20T22:34:52-07:00",
    "files_changed": [
      "drivers/scsi/elx/efct/efct_hw.c",
      "drivers/target/target_core_pr.c"
    ],
    "diff": "diff --git a/drivers/scsi/elx/efct/efct_hw.c b/drivers/scsi/elx/efct/efct_hw.c\nindex 5a5525054d71..5b079b8b7a08 100644\n--- a/drivers/scsi/elx/efct/efct_hw.c\n+++ b/drivers/scsi/elx/efct/efct_hw.c\n@@ -1120,7 +1120,7 @@ int\n efct_hw_parse_filter(struct efct_hw *hw, void *value)\n {\n \tint rc = 0;\n-\tchar *p = NULL;\n+\tchar *p = NULL, *pp = NULL;\n \tchar *token;\n \tu32 idx = 0;\n \n@@ -1132,6 +1132,7 @@ efct_hw_parse_filter(struct efct_hw *hw, void *value)\n \t\tefc_log_err(hw->os, \"p is NULL\\n\");\n \t\treturn -ENOMEM;\n \t}\n+\tpp = p;\n \n \tidx = 0;\n \twhile ((token = strsep(&p, \",\")) && *token) {\n@@ -1144,7 +1145,7 @@ efct_hw_parse_filter(struct efct_hw *hw, void *value)\n \t\tif (idx == ARRAY_SIZE(hw->config.filter_def))\n \t\t\tbreak;\n \t}\n-\tkfree(p);\n+\tkfree(pp);\n \n \treturn rc;\n }\ndiff --git a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c\nindex 34cf2c399b39..70905805cb17 100644\n--- a/drivers/target/target_core_pr.c\n+++ b/drivers/target/target_core_pr.c\n@@ -1842,7 +1842,9 @@ core_scsi3_decode_spec_i_port(\n \t\t}\n \n \t\tkmem_cache_free(t10_pr_reg_cache, dest_pr_reg);\n-\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n+\n+\t\tif (dest_se_deve)\n+\t\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n \n \t\tif (is_local)\n \t\t\tcontinue;",
    "stats": {
      "insertions": 6,
      "deletions": 3,
      "files": 2
    }
  },
  {
    "sha": "33b6a1f155d627f5bd80c7485c598ce45428f74f",
    "message": "rcu: Return early if callback is not specified\n\nCurrently the call_rcu() API does not check whether a callback\npointer is NULL. If NULL is passed, rcu_core() will try to invoke\nit, resulting in NULL pointer dereference and a kernel crash.\n\nTo prevent this and improve debuggability, this patch adds a check\nfor NULL and emits a kernel stack trace to help identify a faulty\ncaller.\n\nSigned-off-by: Uladzislau Rezki (Sony) <urezki@gmail.com>\nReviewed-by: Joel Fernandes <joelagnelf@nvidia.com>\nSigned-off-by: Joel Fernandes <joelagnelf@nvidia.com>",
    "author": "Uladzislau Rezki (Sony)",
    "date": "2025-06-20T15:31:48-04:00",
    "files_changed": [
      "kernel/rcu/tree.c"
    ],
    "diff": "diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c\nindex e8a4b720d7d2..14d4499c6fc3 100644\n--- a/kernel/rcu/tree.c\n+++ b/kernel/rcu/tree.c\n@@ -3072,6 +3072,10 @@ __call_rcu_common(struct rcu_head *head, rcu_callback_t func, bool lazy_in)\n \t/* Misaligned rcu_head! */\n \tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n \n+\t/* Avoid NULL dereference if callback is NULL. */\n+\tif (WARN_ON_ONCE(!func))\n+\t\treturn;\n+\n \tif (debug_rcu_head_queue(head)) {\n \t\t/*\n \t\t * Probable double call_rcu(), so leak the callback.",
    "stats": {
      "insertions": 4,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "11313e2f78128c948e9b4eb58b3dacfc30964700",
    "message": "Merge tag 'gpio-fixes-for-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/brgl/linux\n\nPull gpio fixes from Bartosz Golaszewski:\n\n - correct the ACPI GPIO access mode in gpio-loongson-64bit\n\n - only obtain the interrupt for a single instance of the chip\n   controlled by gpio-mlxbf3\n\n - fix an invalid value return from probe() in gpio-pca953x\n\n - add missing MODULE_DEVICE_TABLE() to gpio-spacemit\n\n - update the HiSilicon GPIO driver maintainer entry\n\n* tag 'gpio-fixes-for-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/brgl/linux:\n  gpio: mlxbf3: only get IRQ for device instance 0\n  gpio: pca953x: fix wrong error probe return value\n  gpio: spacemit: Add missing MODULE_DEVICE_TABLE\n  gpio: loongson-64bit: Correct Loongson-7A2000 ACPI GPIO access mode\n  MAINTAINERS: Update HiSilicon GPIO driver maintainer",
    "author": "Linus Torvalds",
    "date": "2025-06-20T10:07:56-07:00",
    "files_changed": [
      "drivers/gpio/gpio-loongson-64bit.c",
      "drivers/gpio/gpio-mlxbf3.c",
      "drivers/gpio/gpio-pca953x.c",
      "drivers/gpio/gpio-spacemit-k1.c"
    ],
    "diff": "diff --git a/MAINTAINERS b/MAINTAINERS\nindex f584e170cfc3..c3f7fbd0d67a 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -10839,7 +10839,7 @@ S:\tMaintained\n F:\tdrivers/dma/hisi_dma.c\n \n HISILICON GPIO DRIVER\n-M:\tJay Fang <f.fangjian@huawei.com>\n+M:\tYang Shen <shenyang39@huawei.com>\n L:\tlinux-gpio@vger.kernel.org\n S:\tMaintained\n F:\tDocumentation/devicetree/bindings/gpio/hisilicon,ascend910-gpio.yaml\ndiff --git a/drivers/gpio/gpio-loongson-64bit.c b/drivers/gpio/gpio-loongson-64bit.c\nindex 26227669f026..70a01c5b8ad1 100644\n--- a/drivers/gpio/gpio-loongson-64bit.c\n+++ b/drivers/gpio/gpio-loongson-64bit.c\n@@ -268,7 +268,7 @@ static const struct loongson_gpio_chip_data loongson_gpio_ls7a2000_data0 = {\n /* LS7A2000 ACPI GPIO */\n static const struct loongson_gpio_chip_data loongson_gpio_ls7a2000_data1 = {\n \t.label = \"ls7a2000_gpio\",\n-\t.mode = BYTE_CTRL_MODE,\n+\t.mode = BIT_CTRL_MODE,\n \t.conf_offset = 0x4,\n \t.in_offset = 0x8,\n \t.out_offset = 0x0,\ndiff --git a/drivers/gpio/gpio-mlxbf3.c b/drivers/gpio/gpio-mlxbf3.c\nindex 10ea71273c89..9875e34bde72 100644\n--- a/drivers/gpio/gpio-mlxbf3.c\n+++ b/drivers/gpio/gpio-mlxbf3.c\n@@ -190,7 +190,9 @@ static int mlxbf3_gpio_probe(struct platform_device *pdev)\n \tstruct mlxbf3_gpio_context *gs;\n \tstruct gpio_irq_chip *girq;\n \tstruct gpio_chip *gc;\n+\tchar *colon_ptr;\n \tint ret, irq;\n+\tlong num;\n \n \tgs = devm_kzalloc(dev, sizeof(*gs), GFP_KERNEL);\n \tif (!gs)\n@@ -227,25 +229,39 @@ static int mlxbf3_gpio_probe(struct platform_device *pdev)\n \tgc->owner = THIS_MODULE;\n \tgc->add_pin_ranges = mlxbf3_gpio_add_pin_ranges;\n \n-\tirq = platform_get_irq(pdev, 0);\n-\tif (irq >= 0) {\n-\t\tgirq = &gs->gc.irq;\n-\t\tgpio_irq_chip_set_chip(girq, &gpio_mlxbf3_irqchip);\n-\t\tgirq->default_type = IRQ_TYPE_NONE;\n-\t\t/* This will let us handle the parent IRQ in the driver */\n-\t\tgirq->num_parents = 0;\n-\t\tgirq->parents = NULL;\n-\t\tgirq->parent_handler = NULL;\n-\t\tgirq->handler = handle_bad_irq;\n-\n-\t\t/*\n-\t\t * Directly request the irq here instead of passing\n-\t\t * a flow-handler because the irq is shared.\n-\t\t */\n-\t\tret = devm_request_irq(dev, irq, mlxbf3_gpio_irq_handler,\n-\t\t\t\t       IRQF_SHARED, dev_name(dev), gs);\n-\t\tif (ret)\n-\t\t\treturn dev_err_probe(dev, ret, \"failed to request IRQ\");\n+\tcolon_ptr = strchr(dev_name(dev), ':');\n+\tif (!colon_ptr) {\n+\t\tdev_err(dev, \"invalid device name format\\n\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tret = kstrtol(++colon_ptr, 16, &num);\n+\tif (ret) {\n+\t\tdev_err(dev, \"invalid device instance\\n\");\n+\t\treturn ret;\n+\t}\n+\n+\tif (!num) {\n+\t\tirq = platform_get_irq(pdev, 0);\n+\t\tif (irq >= 0) {\n+\t\t\tgirq = &gs->gc.irq;\n+\t\t\tgpio_irq_chip_set_chip(girq, &gpio_mlxbf3_irqchip);\n+\t\t\tgirq->default_type = IRQ_TYPE_NONE;\n+\t\t\t/* This will let us handle the parent IRQ in the driver */\n+\t\t\tgirq->num_parents = 0;\n+\t\t\tgirq->parents = NULL;\n+\t\t\tgirq->parent_handler = NULL;\n+\t\t\tgirq->handler = handle_bad_irq;\n+\n+\t\t\t/*\n+\t\t\t * Directly request the irq here instead of passing\n+\t\t\t * a flow-handler because the irq is shared.\n+\t\t\t */\n+\t\t\tret = devm_request_irq(dev, irq, mlxbf3_gpio_irq_handler,\n+\t\t\t\t\t       IRQF_SHARED, dev_name(dev), gs);\n+\t\t\tif (ret)\n+\t\t\t\treturn dev_err_probe(dev, ret, \"failed to request IRQ\");\n+\t\t}\n \t}\n \n \tplatform_set_drvdata(pdev, gs);\ndiff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c\nindex b852e4997629..e80a96f39788 100644\n--- a/drivers/gpio/gpio-pca953x.c\n+++ b/drivers/gpio/gpio-pca953x.c\n@@ -974,7 +974,7 @@ static int pca953x_irq_setup(struct pca953x_chip *chip, int irq_base)\n \t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, dev_name(dev),\n \t\t\t\t\tchip);\n \tif (ret)\n-\t\treturn dev_err_probe(dev, client->irq, \"failed to request irq\\n\");\n+\t\treturn dev_err_probe(dev, ret, \"failed to request irq\\n\");\n \n \treturn 0;\n }\ndiff --git a/drivers/gpio/gpio-spacemit-k1.c b/drivers/gpio/gpio-spacemit-k1.c\nindex f027066365ff..3cc75c701ec4 100644\n--- a/drivers/gpio/gpio-spacemit-k1.c\n+++ b/drivers/gpio/gpio-spacemit-k1.c\n@@ -278,6 +278,7 @@ static const struct of_device_id spacemit_gpio_dt_ids[] = {\n \t{ .compatible = \"spacemit,k1-gpio\" },\n \t{ /* sentinel */ }\n };\n+MODULE_DEVICE_TABLE(of, spacemit_gpio_dt_ids);\n \n static struct platform_driver spacemit_gpio_driver = {\n \t.probe\t\t= spacemit_gpio_probe,",
    "stats": {
      "insertions": 39,
      "deletions": 22,
      "files": 5
    }
  },
  {
    "sha": "299f489f5bad3554531f67335d1762225448ff39",
    "message": "Merge tag 'sound-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound\n\nPull sound fixes from Takashi Iwai:\n \"A collection of small fixes. All changes are device-specific at this\n  time:\n\n   - Fixes for Cirrus codecs with SoundWire, including firmware name\n     updates\n\n   - Fix for i.MX8 SoC DSP\n\n   - Usual HD-audio, USB-audio, and ASoC AMD quirks\n\n   - Fixes for legendary SoundBlaster AWE32 ISA device (a real one, we\n     still got a bug report after 25 years)\n\n   - Minor build fixes\"\n\n* tag 'sound-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (24 commits)\n  ALSA: hda/realtek: Enable headset Mic on Positivo P15X\n  ASoC: Intel: sof-function-topology-lib: Print out the unsupported dmic count\n  ASoC: doc: cs35l56: Add CS35L63 to the list of supported devices\n  ASoC: SOF: imx8: add core shutdown operation for imx8/imx8x\n  ALSA: hda/realtek: Add quirk for Asus GA605K\n  ALSA: hda/realtek: enable headset mic on Latitude 5420 Rugged\n  ASoC: amd: yc: update quirk data for HP Victus\n  ASoC: apple: mca: Drop default ARCH_APPLE in Kconfig\n  ALSA: usb-audio: Rename ALSA kcontrol PCM and PCM1 for the KTMicro sound card\n  ASoC: amd: yc: Add quirk for MSI Bravo 17 D7VF internal mic\n  ASoC: doc: cs35l56: Update to add new SoundWire firmware filename suffix\n  ASoC: cs35l56: Use SoundWire address as alternate firmware suffix on L56 B0\n  ASoC: cs35l56: Use SoundWire address as firmware name suffix for new silicon\n  ASoC: sdw_utils: Fix potential NULL pointer deref in is_sdca_endpoint_present()\n  ALSA: sb: Force to disable DMAs once when DMA mode is changed\n  ALSA: sb: Don't allow changing the DMA mode during operations\n  ALSA: hda/realtek: Add quirk for Asus GU605C\n  ALSA: hda/realtek: Fix built-in mic on ASUS VivoBook X513EA\n  ALSA: hda/realtek - Add mute LED support for HP Victus 16-s1xxx and HP Victus 15-fa1xxx\n  ALSA: ctxfi: Replace deprecated strcpy() with strscpy()\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-06-20T09:59:20-07:00",
    "files_changed": [
      "sound/isa/sb/sb16_main.c",
      "sound/pci/ctxfi/xfi.c",
      "sound/pci/hda/hda_intel.c",
      "sound/pci/hda/patch_realtek.c",
      "sound/soc/amd/yc/acp6x-mach.c",
      "sound/soc/codecs/cs35l56-sdw.c",
      "sound/soc/codecs/cs35l56.c",
      "sound/soc/codecs/cs35l56.h",
      "sound/soc/codecs/cs48l32.c",
      "sound/soc/codecs/es8326.c",
      "sound/soc/codecs/wm_adsp.c",
      "sound/soc/codecs/wm_adsp.h",
      "sound/soc/intel/common/sof-function-topology-lib.c",
      "sound/soc/loongson/loongson_i2s.c",
      "sound/soc/sdw_utils/soc_sdw_utils.c",
      "sound/soc/sof/imx/imx8.c",
      "sound/usb/mixer_maps.c"
    ],
    "diff": "diff --git a/Documentation/sound/codecs/cs35l56.rst b/Documentation/sound/codecs/cs35l56.rst\nindex 98c6f6c74394..57d1964453e1 100644\n--- a/Documentation/sound/codecs/cs35l56.rst\n+++ b/Documentation/sound/codecs/cs35l56.rst\n@@ -1,8 +1,8 @@\n .. SPDX-License-Identifier: GPL-2.0-only\n \n-=====================================================================\n-Audio drivers for Cirrus Logic CS35L54/56/57 Boosted Smart Amplifiers\n-=====================================================================\n+========================================================================\n+Audio drivers for Cirrus Logic CS35L54/56/57/63 Boosted Smart Amplifiers\n+========================================================================\n :Copyright: 2025 Cirrus Logic, Inc. and\n                  Cirrus Logic International Semiconductor Ltd.\n \n@@ -13,11 +13,11 @@ Summary\n \n The high-level summary of this document is:\n \n-**If you have a laptop that uses CS35L54/56/57 amplifiers but audio is not\n+**If you have a laptop that uses CS35L54/56/57/63 amplifiers but audio is not\n working, DO NOT ATTEMPT TO USE FIRMWARE AND SETTINGS FROM ANOTHER LAPTOP,\n EVEN IF THAT LAPTOP SEEMS SIMILAR.**\n \n-The CS35L54/56/57 amplifiers must be correctly configured for the power\n+The CS35L54/56/57/63 amplifiers must be correctly configured for the power\n supply voltage, speaker impedance, maximum speaker voltage/current, and\n other external hardware connections.\n \n@@ -34,6 +34,7 @@ The cs35l56 drivers support:\n * CS35L54\n * CS35L56\n * CS35L57\n+* CS35L63\n \n There are two drivers in the kernel\n \n@@ -104,6 +105,13 @@ In this example the SSID is 10280c63.\n \n The format of the firmware file names is:\n \n+SoundWire (except CS35L56 Rev B0):\n+    cs35lxx-b0-dsp1-misc-SSID[-spkidX]-l?u?\n+\n+SoundWire CS35L56 Rev B0:\n+    cs35lxx-b0-dsp1-misc-SSID[-spkidX]-ampN\n+\n+Non-SoundWire (HDA and I2S):\n     cs35lxx-b0-dsp1-misc-SSID[-spkidX]-ampN\n \n Where:\n@@ -111,12 +119,18 @@ Where:\n   * cs35lxx-b0 is the amplifier model and silicon revision. This information\n     is logged by the driver during initialization.\n   * SSID is the 8-digit hexadecimal SSID value.\n+  * l?u? is the physical address on the SoundWire bus of the amp this\n+    file applies to.\n   * ampN is the amplifier number (for example amp1). This is the same as\n     the prefix on the ALSA control names except that it is always lower-case\n     in the file name.\n   * spkidX is an optional part, used for laptops that have firmware\n     configurations for different makes and models of internal speakers.\n \n+The CS35L56 Rev B0 continues to use the old filename scheme because a\n+large number of firmware files have already been published with these\n+names.\n+\n Sound Open Firmware and ALSA topology files\n -------------------------------------------\n \ndiff --git a/sound/isa/sb/sb16_main.c b/sound/isa/sb/sb16_main.c\nindex 74db11525003..5a083eecaa6b 100644\n--- a/sound/isa/sb/sb16_main.c\n+++ b/sound/isa/sb/sb16_main.c\n@@ -703,6 +703,9 @@ static int snd_sb16_dma_control_put(struct snd_kcontrol *kcontrol, struct snd_ct\n \tunsigned char nval, oval;\n \tint change;\n \t\n+\tif (chip->mode & (SB_MODE_PLAYBACK | SB_MODE_CAPTURE))\n+\t\treturn -EBUSY;\n+\n \tnval = ucontrol->value.enumerated.item[0];\n \tif (nval > 2)\n \t\treturn -EINVAL;\n@@ -711,6 +714,10 @@ static int snd_sb16_dma_control_put(struct snd_kcontrol *kcontrol, struct snd_ct\n \tchange = nval != oval;\n \tsnd_sb16_set_dma_mode(chip, nval);\n \tspin_unlock_irqrestore(&chip->reg_lock, flags);\n+\tif (change) {\n+\t\tsnd_dma_disable(chip->dma8);\n+\t\tsnd_dma_disable(chip->dma16);\n+\t}\n \treturn change;\n }\n \ndiff --git a/sound/pci/ctxfi/xfi.c b/sound/pci/ctxfi/xfi.c\nindex 713d36ea40cb..d8dd84d41c87 100644\n--- a/sound/pci/ctxfi/xfi.c\n+++ b/sound/pci/ctxfi/xfi.c\n@@ -98,8 +98,8 @@ ct_card_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n \tif (err < 0)\n \t\tgoto error;\n \n-\tstrcpy(card->driver, \"SB-XFi\");\n-\tstrcpy(card->shortname, \"Creative X-Fi\");\n+\tstrscpy(card->driver, \"SB-XFi\");\n+\tstrscpy(card->shortname, \"Creative X-Fi\");\n \tsnprintf(card->longname, sizeof(card->longname), \"%s %s %s\",\n \t\t card->shortname, atc->chip_name, atc->model_name);\n \ndiff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c\nindex e5210ed48ddf..439cf1bda6e6 100644\n--- a/sound/pci/hda/hda_intel.c\n+++ b/sound/pci/hda/hda_intel.c\n@@ -2283,6 +2283,8 @@ static const struct snd_pci_quirk power_save_denylist[] = {\n \tSND_PCI_QUIRK(0x1734, 0x1232, \"KONTRON SinglePC\", 0),\n \t/* Dell ALC3271 */\n \tSND_PCI_QUIRK(0x1028, 0x0962, \"Dell ALC3271\", 0),\n+\t/* https://bugzilla.kernel.org/show_bug.cgi?id=220210 */\n+\tSND_PCI_QUIRK(0x17aa, 0x5079, \"Lenovo Thinkpad E15\", 0),\n \t{}\n };\n \ndiff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c\nindex cd0d7ba7320e..2e1618494c20 100644\n--- a/sound/pci/hda/patch_realtek.c\n+++ b/sound/pci/hda/patch_realtek.c\n@@ -8030,6 +8030,9 @@ enum {\n \tALC294_FIXUP_ASUS_CS35L41_SPI_2,\n \tALC274_FIXUP_HP_AIO_BIND_DACS,\n \tALC287_FIXUP_PREDATOR_SPK_CS35L41_I2C_2,\n+\tALC285_FIXUP_ASUS_GA605K_HEADSET_MIC,\n+\tALC285_FIXUP_ASUS_GA605K_I2C_SPEAKER2_TO_DAC1,\n+\tALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC,\n };\n \n /* A special fixup for Lenovo C940 and Yoga Duet 7;\n@@ -10414,6 +10417,26 @@ static const struct hda_fixup alc269_fixups[] = {\n \t\t.type = HDA_FIXUP_FUNC,\n \t\t.v.func = alc274_fixup_hp_aio_bind_dacs,\n \t},\n+\t[ALC285_FIXUP_ASUS_GA605K_HEADSET_MIC] = {\n+\t\t.type = HDA_FIXUP_PINS,\n+\t\t.v.pins = (const struct hda_pintbl[]) {\n+\t\t\t{ 0x19, 0x03a11050 },\n+\t\t\t{ 0x1b, 0x03a11c30 },\n+\t\t\t{ }\n+\t\t},\n+\t\t.chained = true,\n+\t\t.chain_id = ALC285_FIXUP_ASUS_GA605K_I2C_SPEAKER2_TO_DAC1\n+\t},\n+\t[ALC285_FIXUP_ASUS_GA605K_I2C_SPEAKER2_TO_DAC1] = {\n+\t\t.type = HDA_FIXUP_FUNC,\n+\t\t.v.func = alc285_fixup_speaker2_to_dac1,\n+\t},\n+\t[ALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC] = {\n+\t\t.type = HDA_FIXUP_FUNC,\n+\t\t.v.func = alc269_fixup_limit_int_mic_boost,\n+\t\t.chained = true,\n+\t\t.chain_id = ALC269VC_FIXUP_ACER_MIC_NO_PRESENCE,\n+\t},\n };\n \n static const struct hda_quirk alc269_fixup_tbl[] = {\n@@ -10509,6 +10532,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1028, 0x0871, \"Dell Precision 3630\", ALC255_FIXUP_DELL_HEADSET_MIC),\n \tSND_PCI_QUIRK(0x1028, 0x0872, \"Dell Precision 3630\", ALC255_FIXUP_DELL_HEADSET_MIC),\n \tSND_PCI_QUIRK(0x1028, 0x0873, \"Dell Precision 3930\", ALC255_FIXUP_DUMMY_LINEOUT_VERB),\n+\tSND_PCI_QUIRK(0x1028, 0x0879, \"Dell Latitude 5420 Rugged\", ALC269_FIXUP_DELL4_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1028, 0x08ad, \"Dell WYSE AIO\", ALC225_FIXUP_DELL_WYSE_AIO_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1028, 0x08ae, \"Dell WYSE NB\", ALC225_FIXUP_DELL1_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1028, 0x0935, \"Dell\", ALC274_FIXUP_DELL_AIO_LINEOUT_VERB),\n@@ -10787,6 +10811,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8b97, \"HP\", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),\n \tSND_PCI_QUIRK(0x103c, 0x8bb3, \"HP Slim OMEN\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8bb4, \"HP Slim OMEN\", ALC287_FIXUP_CS35L41_I2C_2),\n+\tSND_PCI_QUIRK(0x103c, 0x8bc8, \"HP Victus 15-fa1xxx\", ALC245_FIXUP_HP_MUTE_LED_COEFBIT),\n \tSND_PCI_QUIRK(0x103c, 0x8bcd, \"HP Omen 16-xd0xxx\", ALC245_FIXUP_HP_MUTE_LED_V1_COEFBIT),\n \tSND_PCI_QUIRK(0x103c, 0x8bdd, \"HP Envy 17\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8bde, \"HP Envy 17\", ALC287_FIXUP_CS35L41_I2C_2),\n@@ -10840,6 +10865,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8c91, \"HP EliteBook 660\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8c96, \"HP\", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),\n \tSND_PCI_QUIRK(0x103c, 0x8c97, \"HP ZBook\", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),\n+\tSND_PCI_QUIRK(0x103c, 0x8c9c, \"HP Victus 16-s1xxx (MB 8C9C)\", ALC245_FIXUP_HP_MUTE_LED_COEFBIT),\n \tSND_PCI_QUIRK(0x103c, 0x8ca1, \"HP ZBook Power\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8ca2, \"HP ZBook Power\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8ca4, \"HP ZBook Fury\", ALC245_FIXUP_CS35L41_SPI_2_HP_GPIO_LED),\n@@ -10904,6 +10930,8 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8e60, \"HP Trekker \", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8e61, \"HP Trekker \", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8e62, \"HP Trekker \", ALC287_FIXUP_CS35L41_I2C_2),\n+\tSND_PCI_QUIRK(0x1043, 0x1032, \"ASUS VivoBook X513EA\", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),\n+\tSND_PCI_QUIRK(0x1043, 0x1034, \"ASUS GU605C\", ALC285_FIXUP_ASUS_GU605_SPI_SPEAKER2_TO_DAC1),\n \tSND_PCI_QUIRK(0x1043, 0x103e, \"ASUS X540SA\", ALC256_FIXUP_ASUS_MIC),\n \tSND_PCI_QUIRK(0x1043, 0x103f, \"ASUS TX300\", ALC282_FIXUP_ASUS_TX300),\n \tSND_PCI_QUIRK(0x1043, 0x1054, \"ASUS G614FH/FM/FP\", ALC287_FIXUP_CS35L41_I2C_2),\n@@ -10932,6 +10960,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1043, 0x12e0, \"ASUS X541SA\", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1043, 0x12f0, \"ASUS X541UV\", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1043, 0x1313, \"Asus K42JZ\", ALC269VB_FIXUP_ASUS_MIC_NO_PRESENCE),\n+\tSND_PCI_QUIRK(0x1043, 0x1314, \"ASUS GA605K\", ALC285_FIXUP_ASUS_GA605K_HEADSET_MIC),\n \tSND_PCI_QUIRK(0x1043, 0x13b0, \"ASUS Z550SA\", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1043, 0x1427, \"Asus Zenbook UX31E\", ALC269VB_FIXUP_ASUS_ZENBOOK),\n \tSND_PCI_QUIRK(0x1043, 0x1433, \"ASUS GX650PY/PZ/PV/PU/PYV/PZV/PIV/PVV\", ALC285_FIXUP_ASUS_I2C_HEADSET_MIC),\n@@ -11384,6 +11413,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x2782, 0x0214, \"VAIO VJFE-CL\", ALC269_FIXUP_LIMIT_INT_MIC_BOOST),\n \tSND_PCI_QUIRK(0x2782, 0x0228, \"Infinix ZERO BOOK 13\", ALC269VB_FIXUP_INFINIX_ZERO_BOOK_13),\n \tSND_PCI_QUIRK(0x2782, 0x0232, \"CHUWI CoreBook XPro\", ALC269VB_FIXUP_CHUWI_COREBOOK_XPRO),\n+\tSND_PCI_QUIRK(0x2782, 0x1407, \"Positivo P15X\", ALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC),\n \tSND_PCI_QUIRK(0x2782, 0x1701, \"Infinix Y4 Max\", ALC269VC_FIXUP_INFINIX_Y4_MAX),\n \tSND_PCI_QUIRK(0x2782, 0x1705, \"MEDION E15433\", ALC269VC_FIXUP_INFINIX_Y4_MAX),\n \tSND_PCI_QUIRK(0x2782, 0x1707, \"Vaio VJFE-ADL\", ALC298_FIXUP_SPK_VOLUME),\ndiff --git a/sound/soc/amd/yc/acp6x-mach.c b/sound/soc/amd/yc/acp6x-mach.c\nindex 7e62445e02c1..98022e5fd428 100644\n--- a/sound/soc/amd/yc/acp6x-mach.c\n+++ b/sound/soc/amd/yc/acp6x-mach.c\n@@ -451,6 +451,13 @@ static const struct dmi_system_id yc_acp_quirk_table[] = {\n \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Bravo 17 D7VEK\"),\n \t\t}\n \t},\n+\t{\n+\t\t.driver_data = &acp6x_card,\n+\t\t.matches = {\n+\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Micro-Star International Co., Ltd.\"),\n+\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Bravo 17 D7VF\"),\n+\t\t}\n+\t},\n \t{\n \t\t.driver_data = &acp6x_card,\n \t\t.matches = {\n@@ -514,6 +521,13 @@ static const struct dmi_system_id yc_acp_quirk_table[] = {\n \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OMEN by HP Gaming Laptop 16z-n000\"),\n \t\t}\n \t},\n+\t{\n+\t\t.driver_data = &acp6x_card,\n+\t\t.matches = {\n+\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"HP\"),\n+\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Victus by HP Gaming Laptop 15-fb2xxx\"),\n+\t\t}\n+\t},\n \t{\n \t\t.driver_data = &acp6x_card,\n \t\t.matches = {\ndiff --git a/sound/soc/apple/Kconfig b/sound/soc/apple/Kconfig\nindex 793f7782e0d7..e9c777cdb6e3 100644\n--- a/sound/soc/apple/Kconfig\n+++ b/sound/soc/apple/Kconfig\n@@ -2,7 +2,6 @@ config SND_SOC_APPLE_MCA\n \ttristate \"Apple Silicon MCA driver\"\n \tdepends on ARCH_APPLE || COMPILE_TEST\n \tselect SND_DMAENGINE_PCM\n-\tdefault ARCH_APPLE\n \thelp\n \t  This option enables an ASoC platform driver for MCA peripherals found\n \t  on Apple Silicon SoCs.\ndiff --git a/sound/soc/codecs/cs35l56-sdw.c b/sound/soc/codecs/cs35l56-sdw.c\nindex 13f602f51bf3..fa9693af3722 100644\n--- a/sound/soc/codecs/cs35l56-sdw.c\n+++ b/sound/soc/codecs/cs35l56-sdw.c\n@@ -238,16 +238,15 @@ static const struct regmap_bus cs35l56_regmap_bus_sdw = {\n \t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n };\n \n-static int cs35l56_sdw_set_cal_index(struct cs35l56_private *cs35l56)\n+static int cs35l56_sdw_get_unique_id(struct cs35l56_private *cs35l56)\n {\n \tint ret;\n \n-\t/* SoundWire UniqueId is used to index the calibration array */\n \tret = sdw_read_no_pm(cs35l56->sdw_peripheral, SDW_SCP_DEVID_0);\n \tif (ret < 0)\n \t\treturn ret;\n \n-\tcs35l56->base.cal_index = ret & 0xf;\n+\tcs35l56->sdw_unique_id = ret & 0xf;\n \n \treturn 0;\n }\n@@ -259,11 +258,13 @@ static void cs35l56_sdw_init(struct sdw_slave *peripheral)\n \n \tpm_runtime_get_noresume(cs35l56->base.dev);\n \n-\tif (cs35l56->base.cal_index < 0) {\n-\t\tret = cs35l56_sdw_set_cal_index(cs35l56);\n-\t\tif (ret < 0)\n-\t\t\tgoto out;\n-\t}\n+\tret = cs35l56_sdw_get_unique_id(cs35l56);\n+\tif (ret)\n+\t\tgoto out;\n+\n+\t/* SoundWire UniqueId is used to index the calibration array */\n+\tif (cs35l56->base.cal_index < 0)\n+\t\tcs35l56->base.cal_index = cs35l56->sdw_unique_id;\n \n \tret = cs35l56_init(cs35l56);\n \tif (ret < 0) {\n@@ -587,6 +588,7 @@ static int cs35l56_sdw_probe(struct sdw_slave *peripheral, const struct sdw_devi\n \n \tcs35l56->base.dev = dev;\n \tcs35l56->sdw_peripheral = peripheral;\n+\tcs35l56->sdw_link_num = peripheral->bus->link_id;\n \tINIT_WORK(&cs35l56->sdw_irq_work, cs35l56_sdw_irq_work);\n \n \tdev_set_drvdata(dev, cs35l56);\ndiff --git a/sound/soc/codecs/cs35l56.c b/sound/soc/codecs/cs35l56.c\nindex c78e4746e428..1b42586794ad 100644\n--- a/sound/soc/codecs/cs35l56.c\n+++ b/sound/soc/codecs/cs35l56.c\n@@ -706,17 +706,41 @@ static int cs35l56_write_cal(struct cs35l56_private *cs35l56)\n \treturn ret;\n }\n \n-static void cs35l56_reinit_patch(struct cs35l56_private *cs35l56)\n+static int cs35l56_dsp_download_and_power_up(struct cs35l56_private *cs35l56,\n+\t\t\t\t\t     bool load_firmware)\n {\n \tint ret;\n \n-\t/* Use wm_adsp to load and apply the firmware patch and coefficient files */\n-\tret = wm_adsp_power_up(&cs35l56->dsp, true);\n+\t/*\n+\t * Abort the first load if it didn't find the suffixed bins and\n+\t * we have an alternate fallback suffix.\n+\t */\n+\tcs35l56->dsp.bin_mandatory = (load_firmware && cs35l56->fallback_fw_suffix);\n+\n+\tret = wm_adsp_power_up(&cs35l56->dsp, load_firmware);\n+\tif ((ret == -ENOENT) && cs35l56->dsp.bin_mandatory) {\n+\t\tcs35l56->dsp.fwf_suffix = cs35l56->fallback_fw_suffix;\n+\t\tcs35l56->fallback_fw_suffix = NULL;\n+\t\tcs35l56->dsp.bin_mandatory = false;\n+\t\tret = wm_adsp_power_up(&cs35l56->dsp, load_firmware);\n+\t}\n+\n \tif (ret) {\n-\t\tdev_dbg(cs35l56->base.dev, \"%s: wm_adsp_power_up ret %d\\n\", __func__, ret);\n-\t\treturn;\n+\t\tdev_dbg(cs35l56->base.dev, \"wm_adsp_power_up ret %d\\n\", ret);\n+\t\treturn ret;\n \t}\n \n+\treturn 0;\n+}\n+\n+static void cs35l56_reinit_patch(struct cs35l56_private *cs35l56)\n+{\n+\tint ret;\n+\n+\tret = cs35l56_dsp_download_and_power_up(cs35l56, true);\n+\tif (ret)\n+\t\treturn;\n+\n \tcs35l56_write_cal(cs35l56);\n \n \t/* Always REINIT after applying patch or coefficients */\n@@ -750,11 +774,9 @@ static void cs35l56_patch(struct cs35l56_private *cs35l56, bool firmware_missing\n \t * but only if firmware is missing. If firmware is already patched just\n \t * power-up wm_adsp without downloading firmware.\n \t */\n-\tret = wm_adsp_power_up(&cs35l56->dsp, !!firmware_missing);\n-\tif (ret) {\n-\t\tdev_dbg(cs35l56->base.dev, \"%s: wm_adsp_power_up ret %d\\n\", __func__, ret);\n+\tret = cs35l56_dsp_download_and_power_up(cs35l56, firmware_missing);\n+\tif (ret)\n \t\tgoto err;\n-\t}\n \n \tmutex_lock(&cs35l56->base.irq_lock);\n \n@@ -853,6 +875,34 @@ static void cs35l56_dsp_work(struct work_struct *work)\n \tpm_runtime_put_autosuspend(cs35l56->base.dev);\n }\n \n+static int cs35l56_set_fw_suffix(struct cs35l56_private *cs35l56)\n+{\n+\tif (cs35l56->dsp.fwf_suffix)\n+\t\treturn 0;\n+\n+\tif (!cs35l56->sdw_peripheral)\n+\t\treturn 0;\n+\n+\tcs35l56->dsp.fwf_suffix = devm_kasprintf(cs35l56->base.dev, GFP_KERNEL,\n+\t\t\t\t\t\t \"l%uu%u\",\n+\t\t\t\t\t\t cs35l56->sdw_link_num,\n+\t\t\t\t\t\t cs35l56->sdw_unique_id);\n+\tif (!cs35l56->dsp.fwf_suffix)\n+\t\treturn -ENOMEM;\n+\n+\t/*\n+\t * There are published firmware files for L56 B0 silicon using\n+\t * the ALSA prefix as the filename suffix. Default to trying these\n+\t * first, with the new name as an alternate.\n+\t */\n+\tif ((cs35l56->base.type == 0x56) && (cs35l56->base.rev == 0xb0)) {\n+\t\tcs35l56->fallback_fw_suffix = cs35l56->dsp.fwf_suffix;\n+\t\tcs35l56->dsp.fwf_suffix = cs35l56->component->name_prefix;\n+\t}\n+\n+\treturn 0;\n+}\n+\n static int cs35l56_component_probe(struct snd_soc_component *component)\n {\n \tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n@@ -892,6 +942,10 @@ static int cs35l56_component_probe(struct snd_soc_component *component)\n \t\treturn -ENOMEM;\n \n \tcs35l56->component = component;\n+\tret = cs35l56_set_fw_suffix(cs35l56);\n+\tif (ret)\n+\t\treturn ret;\n+\n \twm_adsp2_component_probe(&cs35l56->dsp, component);\n \n \tdebugfs_create_bool(\"init_done\", 0444, debugfs_root, &cs35l56->base.init_done);\ndiff --git a/sound/soc/codecs/cs35l56.h b/sound/soc/codecs/cs35l56.h\nindex 200f695efca3..bd77a57249d7 100644\n--- a/sound/soc/codecs/cs35l56.h\n+++ b/sound/soc/codecs/cs35l56.h\n@@ -38,6 +38,7 @@ struct cs35l56_private {\n \tstruct snd_soc_component *component;\n \tstruct regulator_bulk_data supplies[CS35L56_NUM_BULK_SUPPLIES];\n \tstruct sdw_slave *sdw_peripheral;\n+\tconst char *fallback_fw_suffix;\n \tstruct work_struct sdw_irq_work;\n \tbool sdw_irq_no_unmask;\n \tbool soft_resetting;\n@@ -52,6 +53,8 @@ struct cs35l56_private {\n \tbool tdm_mode;\n \tbool sysclk_set;\n \tu8 old_sdw_clock_scale;\n+\tu8 sdw_link_num;\n+\tu8 sdw_unique_id;\n };\n \n extern const struct dev_pm_ops cs35l56_pm_ops_i2c_spi;\ndiff --git a/sound/soc/codecs/cs48l32.c b/sound/soc/codecs/cs48l32.c\nindex 90a795230d27..9bdd48aab42a 100644\n--- a/sound/soc/codecs/cs48l32.c\n+++ b/sound/soc/codecs/cs48l32.c\n@@ -2162,6 +2162,10 @@ static int cs48l32_hw_params(struct snd_pcm_substream *substream,\n \t\tn_slots_multiple = 1;\n \n \tsclk_target = snd_soc_tdm_params_to_bclk(params, slotw, n_slots, n_slots_multiple);\n+\tif (sclk_target < 0) {\n+\t\tcs48l32_asp_err(dai, \"Invalid parameters\\n\");\n+\t\treturn sclk_target;\n+\t}\n \n \tfor (i = 0; i < ARRAY_SIZE(cs48l32_sclk_rates); i++) {\n \t\tif ((cs48l32_sclk_rates[i].freq >= sclk_target) &&\ndiff --git a/sound/soc/codecs/es8326.c b/sound/soc/codecs/es8326.c\nindex 066d92b54312..78c4e68f6002 100644\n--- a/sound/soc/codecs/es8326.c\n+++ b/sound/soc/codecs/es8326.c\n@@ -1079,8 +1079,7 @@ static void es8326_init(struct snd_soc_component *component)\n \tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);\n \tregmap_write(es8326->regmap, ES8326_INTOUT_IO,\n \t\t     es8326->interrupt_clk);\n-\tregmap_write(es8326->regmap, ES8326_SDINOUT1_IO,\n-\t\t    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));\n+\tregmap_write(es8326->regmap, ES8326_SDINOUT1_IO, ES8326_IO_INPUT);\n \tregmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);\n \n \tregmap_write(es8326->regmap, ES8326_ANA_PDN, 0x00);\ndiff --git a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c\nindex 3c580faab3b7..8a1d5cc75d6c 100644\n--- a/sound/soc/codecs/wm_adsp.c\n+++ b/sound/soc/codecs/wm_adsp.c\n@@ -783,16 +783,19 @@ static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,\n \t\t\t\t\t  char **coeff_filename)\n {\n \tconst char *system_name = dsp->system_name;\n-\tconst char *asoc_component_prefix = dsp->component->name_prefix;\n+\tconst char *suffix = dsp->component->name_prefix;\n \tint ret = 0;\n \n-\tif (system_name && asoc_component_prefix) {\n+\tif (dsp->fwf_suffix)\n+\t\tsuffix = dsp->fwf_suffix;\n+\n+\tif (system_name && suffix) {\n \t\tif (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n \t\t\t\t\t\t   cirrus_dir, system_name,\n-\t\t\t\t\t\t   asoc_component_prefix, \"wmfw\")) {\n+\t\t\t\t\t\t   suffix, \"wmfw\")) {\n \t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n \t\t\t\t\t\t      cirrus_dir, system_name,\n-\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n+\t\t\t\t\t\t      suffix, \"bin\");\n \t\t\treturn 0;\n \t\t}\n \t}\n@@ -801,10 +804,10 @@ static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,\n \t\tif (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n \t\t\t\t\t\t   cirrus_dir, system_name,\n \t\t\t\t\t\t   NULL, \"wmfw\")) {\n-\t\t\tif (asoc_component_prefix)\n+\t\t\tif (suffix)\n \t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n \t\t\t\t\t\t\t      cirrus_dir, system_name,\n-\t\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n+\t\t\t\t\t\t\t      suffix, \"bin\");\n \n \t\t\tif (!*coeff_firmware)\n \t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n@@ -816,10 +819,10 @@ static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,\n \n \t/* Check system-specific bin without wmfw before falling back to generic */\n \tif (dsp->wmfw_optional && system_name) {\n-\t\tif (asoc_component_prefix)\n+\t\tif (suffix)\n \t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n \t\t\t\t\t\t      cirrus_dir, system_name,\n-\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n+\t\t\t\t\t\t      suffix, \"bin\");\n \n \t\tif (!*coeff_firmware)\n \t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n@@ -850,7 +853,7 @@ static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,\n \tadsp_err(dsp, \"Failed to request firmware <%s>%s-%s-%s<-%s<%s>>.wmfw\\n\",\n \t\t cirrus_dir, dsp->part,\n \t\t dsp->fwf_name ? dsp->fwf_name : dsp->cs_dsp.name,\n-\t\t wm_adsp_fw[dsp->fw].file, system_name, asoc_component_prefix);\n+\t\t wm_adsp_fw[dsp->fw].file, system_name, suffix);\n \n \treturn -ENOENT;\n }\n@@ -997,11 +1000,17 @@ int wm_adsp_power_up(struct wm_adsp *dsp, bool load_firmware)\n \t\t\treturn ret;\n \t}\n \n+\tif (dsp->bin_mandatory && !coeff_firmware) {\n+\t\tret = -ENOENT;\n+\t\tgoto err;\n+\t}\n+\n \tret = cs_dsp_power_up(&dsp->cs_dsp,\n \t\t\t      wmfw_firmware, wmfw_filename,\n \t\t\t      coeff_firmware, coeff_filename,\n \t\t\t      wm_adsp_fw_text[dsp->fw]);\n \n+err:\n \twm_adsp_release_firmware_files(dsp,\n \t\t\t\t       wmfw_firmware, wmfw_filename,\n \t\t\t\t       coeff_firmware, coeff_filename);\ndiff --git a/sound/soc/codecs/wm_adsp.h b/sound/soc/codecs/wm_adsp.h\nindex edc5b02ae765..25210d404bf1 100644\n--- a/sound/soc/codecs/wm_adsp.h\n+++ b/sound/soc/codecs/wm_adsp.h\n@@ -29,12 +29,14 @@ struct wm_adsp {\n \tconst char *part;\n \tconst char *fwf_name;\n \tconst char *system_name;\n+\tconst char *fwf_suffix;\n \tstruct snd_soc_component *component;\n \n \tunsigned int sys_config_size;\n \n \tint fw;\n \tbool wmfw_optional;\n+\tbool bin_mandatory;\n \n \tstruct work_struct boot_work;\n \tint (*control_add)(struct wm_adsp *dsp, struct cs_dsp_coeff_ctl *cs_ctl);\ndiff --git a/sound/soc/intel/common/sof-function-topology-lib.c b/sound/soc/intel/common/sof-function-topology-lib.c\nindex 90fe7aa3df1c..3cc81dcf047e 100644\n--- a/sound/soc/intel/common/sof-function-topology-lib.c\n+++ b/sound/soc/intel/common/sof-function-topology-lib.c\n@@ -73,7 +73,8 @@ int sof_sdw_get_tplg_files(struct snd_soc_card *card, const struct snd_soc_acpi_\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tdev_warn(card->dev,\n-\t\t\t\t\t \"only -2ch and -4ch are supported for dmic\\n\");\n+\t\t\t\t\t \"unsupported number of dmics: %d\\n\",\n+\t\t\t\t\t mach_params.dmic_num);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\ttplg_dev = TPLG_DEVICE_INTEL_PCH_DMIC;\ndiff --git a/sound/soc/loongson/loongson_i2s.c b/sound/soc/loongson/loongson_i2s.c\nindex e8852a30f213..e336656e13eb 100644\n--- a/sound/soc/loongson/loongson_i2s.c\n+++ b/sound/soc/loongson/loongson_i2s.c\n@@ -9,6 +9,7 @@\n #include <linux/module.h>\n #include <linux/platform_device.h>\n #include <linux/delay.h>\n+#include <linux/export.h>\n #include <linux/pm_runtime.h>\n #include <linux/dma-mapping.h>\n #include <sound/soc.h>\ndiff --git a/sound/soc/sdw_utils/soc_sdw_utils.c b/sound/soc/sdw_utils/soc_sdw_utils.c\nindex b7060b746356..d75e7292240b 100644\n--- a/sound/soc/sdw_utils/soc_sdw_utils.c\n+++ b/sound/soc/sdw_utils/soc_sdw_utils.c\n@@ -1205,6 +1205,8 @@ static int is_sdca_endpoint_present(struct device *dev,\n \tint i;\n \n \tdlc = kzalloc(sizeof(*dlc), GFP_KERNEL);\n+\tif (!dlc)\n+\t\treturn -ENOMEM;\n \n \tadr_end = &adr_dev->endpoints[end_index];\n \tdai_info = &codec_info->dais[adr_end->num];\ndiff --git a/sound/soc/sof/imx/imx8.c b/sound/soc/sof/imx/imx8.c\nindex a40a8047873e..b73dd91bd529 100644\n--- a/sound/soc/sof/imx/imx8.c\n+++ b/sound/soc/sof/imx/imx8.c\n@@ -40,6 +40,19 @@ struct imx8m_chip_data {\n \tstruct reset_control *run_stall;\n };\n \n+static int imx8_shutdown(struct snd_sof_dev *sdev)\n+{\n+\t/*\n+\t * Force the DSP to stall. After the firmware image is loaded,\n+\t * the stall will be removed during run() by a matching\n+\t * imx_sc_pm_cpu_start() call.\n+\t */\n+\timx_sc_pm_cpu_start(get_chip_pdata(sdev), IMX_SC_R_DSP, false,\n+\t\t\t    RESET_VECTOR_VADDR);\n+\n+\treturn 0;\n+}\n+\n /*\n  * DSP control.\n  */\n@@ -281,11 +294,13 @@ static int imx8_ops_init(struct snd_sof_dev *sdev)\n static const struct imx_chip_ops imx8_chip_ops = {\n \t.probe = imx8_probe,\n \t.core_kick = imx8_run,\n+\t.core_shutdown = imx8_shutdown,\n };\n \n static const struct imx_chip_ops imx8x_chip_ops = {\n \t.probe = imx8_probe,\n \t.core_kick = imx8x_run,\n+\t.core_shutdown = imx8_shutdown,\n };\n \n static const struct imx_chip_ops imx8m_chip_ops = {\ndiff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c\nindex 0e9b5431a47f..faac7df1fbcf 100644\n--- a/sound/usb/mixer_maps.c\n+++ b/sound/usb/mixer_maps.c\n@@ -383,6 +383,13 @@ static const struct usbmix_name_map ms_usb_link_map[] = {\n \t{ 0 }   /* terminator */\n };\n \n+/* KTMicro USB */\n+static struct usbmix_name_map s31b2_0022_map[] = {\n+\t{ 23, \"Speaker Playback\" },\n+\t{ 18, \"Headphone Playback\" },\n+\t{ 0 }\n+};\n+\n /* ASUS ROG Zenith II with Realtek ALC1220-VB */\n static const struct usbmix_name_map asus_zenith_ii_map[] = {\n \t{ 19, NULL, 12 }, /* FU, Input Gain Pad - broken response, disabled */\n@@ -692,6 +699,11 @@ static const struct usbmix_ctl_map usbmix_ctl_maps[] = {\n \t\t.id = USB_ID(0x045e, 0x083c),\n \t\t.map = ms_usb_link_map,\n \t},\n+\t{\n+\t\t/* KTMicro USB */\n+\t\t.id = USB_ID(0X31b2, 0x0022),\n+\t\t.map = s31b2_0022_map,\n+\t},\n \t{ 0 } /* terminator */\n };\n ",
    "stats": {
      "insertions": 207,
      "deletions": 37,
      "files": 19
    }
  }
]
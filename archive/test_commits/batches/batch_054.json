[
  {
    "sha": "cb6075bc62dc6a9cd7ab3572758685fdf78e3e20",
    "message": "x86/mm: Fix early boot use of INVPLGB\n\nThe INVLPGB instruction has limits on how many pages it can invalidate\nat once. That limit is enumerated in CPUID, read by the kernel, and\nstored in 'invpgb_count_max'. Ranged invalidation, like\ninvlpgb_kernel_range_flush() break up their invalidations so\nthat they do not exceed the limit.\n\nHowever, early boot code currently attempts to do ranged\ninvalidation before populating 'invlpgb_count_max'. There is a\nfor loop which is basically:\n\n\tfor (...; addr < end; addr += invlpgb_count_max*PAGE_SIZE)\n\nIf invlpgb_kernel_range_flush is called before the kernel has read\nthe value of invlpgb_count_max from the hardware, the normally\nbounded loop can become an infinite loop if invlpgb_count_max is\ninitialized to zero.\n\nFix that issue by initializing invlpgb_count_max to 1.\n\nThis way INVPLGB at early boot time will be a little bit slower\nthan normal (with initialized invplgb_count_max), and not an\ninstant hang at bootup time.\n\nFixes: b7aa05cbdc52 (\"x86/mm: Add INVLPGB support code\")\nSigned-off-by: Rik van Riel <riel@surriel.com>\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nLink: https://lore.kernel.org/all/20250606171112.4013261-3-riel%40surriel.com",
    "author": "Rik van Riel",
    "date": "2025-06-17T16:36:58-07:00",
    "files_changed": [
      "arch/x86/kernel/cpu/amd.c"
    ],
    "diff": "diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c\nindex 93da466dfe2c..b2ad8d13211a 100644\n--- a/arch/x86/kernel/cpu/amd.c\n+++ b/arch/x86/kernel/cpu/amd.c\n@@ -31,7 +31,7 @@\n \n #include \"cpu.h\"\n \n-u16 invlpgb_count_max __ro_after_init;\n+u16 invlpgb_count_max __ro_after_init = 1;\n \n static inline int rdmsrq_amd_safe(unsigned msr, u64 *p)\n {",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "b160766e26d4e2e2d6fe2294e0b02f92baefcec5",
    "message": "net/sched: fix use-after-free in taprio_dev_notifier\n\nSince taprio’s taprio_dev_notifier() isn’t protected by an\nRCU read-side critical section, a race with advance_sched()\ncan lead to a use-after-free.\n\nAdding rcu_read_lock() inside taprio_dev_notifier() prevents this.\n\nFixes: fed87cc6718a (\"net/sched: taprio: automatically calculate queueMaxSDU based on TC gate durations\")\nCc: stable@vger.kernel.org\nSigned-off-by: Hyunwoo Kim <imv4bel@gmail.com>\nReviewed-by: Simon Horman <horms@kernel.org>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nLink: https://patch.msgid.link/aEzIYYxt0is9upYG@v4bel-B760M-AORUS-ELITE-AX\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Hyunwoo Kim",
    "date": "2025-06-17T16:14:04-07:00",
    "files_changed": [
      "net/sched/sch_taprio.c"
    ],
    "diff": "diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c\nindex 14021b812329..2b14c81a87e5 100644\n--- a/net/sched/sch_taprio.c\n+++ b/net/sched/sch_taprio.c\n@@ -1328,13 +1328,15 @@ static int taprio_dev_notifier(struct notifier_block *nb, unsigned long event,\n \n \t\tstab = rtnl_dereference(q->root->stab);\n \n-\t\toper = rtnl_dereference(q->oper_sched);\n+\t\trcu_read_lock();\n+\t\toper = rcu_dereference(q->oper_sched);\n \t\tif (oper)\n \t\t\ttaprio_update_queue_max_sdu(q, oper, stab);\n \n-\t\tadmin = rtnl_dereference(q->admin_sched);\n+\t\tadmin = rcu_dereference(q->admin_sched);\n \t\tif (admin)\n \t\t\ttaprio_update_queue_max_sdu(q, admin, stab);\n+\t\trcu_read_unlock();\n \n \t\tbreak;\n \t}",
    "stats": {
      "insertions": 4,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "5ab73b010cad294851e558f1d4714a85c6f206c7",
    "message": "ptp: fix breakage after ptp_vclock_in_use() rework\n\nWhat is broken\n--------------\n\nptp4l, and any other application which calls clock_adjtime() on a\nphysical clock, is greeted with error -EBUSY after commit 87f7ce260a3c\n(\"ptp: remove ptp->n_vclocks check logic in ptp_vclock_in_use()\").\n\nExplanation for the breakage\n----------------------------\n\nThe blamed commit was based on the false assumption that\nptp_vclock_in_use() callers already test for n_vclocks prior to calling\nthis function.\n\nThis is notably incorrect for the code path below, in which there is, in\nfact, no n_vclocks test:\n\nptp_clock_adjtime()\n-> ptp_clock_freerun()\n   -> ptp_vclock_in_use()\n\nThe result is that any clock adjustment on any physical clock is now\nimpossible. This is _despite_ there not being any vclock over this\nphysical clock.\n\n$ ptp4l -i eno0 -2 -P -m\nptp4l[58.425]: selected /dev/ptp0 as PTP clock\n[   58.429749] ptp: physical clock is free running\nptp4l[58.431]: Failed to open /dev/ptp0: Device or resource busy\nfailed to create a clock\n$ cat /sys/class/ptp/ptp0/n_vclocks\n0\n\nThe patch makes the ptp_vclock_in_use() function say \"if it's not a\nvirtual clock, then this physical clock does have virtual clocks on\ntop\".\n\nThen ptp_clock_freerun() uses this information to say \"this physical\nclock has virtual clocks on top, so it must stay free-running\".\n\nThen ptp_clock_adjtime() uses this information to say \"well, if this\nphysical clock has to be free-running, I can't do it, return -EBUSY\".\n\nSimply put, ptp_vclock_in_use() cannot be simplified so as to remove the\ntest whether vclocks are in use.\n\nWhat did the blamed commit intend to fix\n----------------------------------------\n\nThe blamed commit presents a lockdep warning stating \"possible recursive\nlocking detected\", with the n_vclocks_store() and ptp_clock_unregister()\nfunctions involved.\n\nThe recursive locking seems this:\nn_vclocks_store()\n-> mutex_lock_interruptible(&ptp->n_vclocks_mux) // 1\n-> device_for_each_child_reverse(..., unregister_vclock)\n   -> unregister_vclock()\n      -> ptp_vclock_unregister()\n         -> ptp_clock_unregister()\n            -> ptp_vclock_in_use()\n               -> mutex_lock_interruptible(&ptp->n_vclocks_mux) // 2\n\nThe issue can be triggered by creating and then deleting vclocks:\n$ echo 2 > /sys/class/ptp/ptp0/n_vclocks\n$ echo 0 > /sys/class/ptp/ptp0/n_vclocks\n\nBut note that in the original stack trace, the address of the first lock\nis different from the address of the second lock. This is because at\nstep 1 marked above, &ptp->n_vclocks_mux is the lock of the parent\n(physical) PTP clock, and at step 2, the lock is of the child (virtual)\nPTP clock. They are different locks of different devices.\n\nIn this situation there is no real deadlock, the lockdep warning is\ncaused by the fact that the mutexes have the same lock class on both the\nparent and the child. Functionally it is fine.\n\nProposed alternative solution\n-----------------------------\n\nWe must reintroduce the body of ptp_vclock_in_use() mostly as it was\nstructured prior to the blamed commit, but avoid the lockdep warning.\n\nBased on the fact that vclocks cannot be nested on top of one another\n(ptp_is_attribute_visible() hides n_vclocks for virtual clocks), we\nalready know that ptp->n_vclocks is zero for a virtual clock. And\nptp->is_virtual_clock is a runtime invariant, established at\nptp_clock_register() time and never changed. There is no need to\nserialize on any mutex in order to read ptp->is_virtual_clock, and we\ntake advantage of that by moving it outside the lock.\n\nThus, virtual clocks do not need to acquire &ptp->n_vclocks_mux at\nall, and step 2 in the code walkthrough above can simply go away.\nWe can simply return false to the question \"ptp_vclock_in_use(a virtual\nclock)\".\n\nOther notes\n-----------\n\nReleasing &ptp->n_vclocks_mux before ptp_vclock_in_use() returns\nexecution seems racy, because the returned value can become stale as\nsoon as the function returns and before the return value is used (i.e.\nn_vclocks_store() can run any time). The locking requirement should\nsomehow be transferred to the caller, to ensure a longer life time for\nthe returned value, but this seems out of scope for this severe bug fix.\n\nBecause we are also fixing up the logic from the original commit, there\nis another Fixes: tag for that.\n\nFixes: 87f7ce260a3c (\"ptp: remove ptp->n_vclocks check logic in ptp_vclock_in_use()\")\nFixes: 73f37068d540 (\"ptp: support ptp physical/virtual clocks conversion\")\nSigned-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nLink: https://patch.msgid.link/20250613174749.406826-2-vladimir.oltean@nxp.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Vladimir Oltean",
    "date": "2025-06-17T16:13:09-07:00",
    "files_changed": [
      "drivers/ptp/ptp_private.h"
    ],
    "diff": "diff --git a/drivers/ptp/ptp_private.h b/drivers/ptp/ptp_private.h\nindex 528d86a33f37..a6aad743c282 100644\n--- a/drivers/ptp/ptp_private.h\n+++ b/drivers/ptp/ptp_private.h\n@@ -98,7 +98,27 @@ static inline int queue_cnt(const struct timestamp_event_queue *q)\n /* Check if ptp virtual clock is in use */\n static inline bool ptp_vclock_in_use(struct ptp_clock *ptp)\n {\n-\treturn !ptp->is_virtual_clock;\n+\tbool in_use = false;\n+\n+\t/* Virtual clocks can't be stacked on top of virtual clocks.\n+\t * Avoid acquiring the n_vclocks_mux on virtual clocks, to allow this\n+\t * function to be called from code paths where the n_vclocks_mux of the\n+\t * parent physical clock is already held. Functionally that's not an\n+\t * issue, but lockdep would complain, because they have the same lock\n+\t * class.\n+\t */\n+\tif (ptp->is_virtual_clock)\n+\t\treturn false;\n+\n+\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n+\t\treturn true;\n+\n+\tif (ptp->n_vclocks)\n+\t\tin_use = true;\n+\n+\tmutex_unlock(&ptp->n_vclocks_mux);\n+\n+\treturn in_use;\n }\n \n /* Check if ptp clock shall be free running */",
    "stats": {
      "insertions": 21,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "1e9ac33fa271be0d2480fd732f9642d81542500b",
    "message": "bnxt_en: Fix double invocation of bnxt_ulp_stop()/bnxt_ulp_start()\n\nBefore the commit under the Fixes tag below, bnxt_ulp_stop() and\nbnxt_ulp_start() were always invoked in pairs.  After that commit,\nthe new bnxt_ulp_restart() can be invoked after bnxt_ulp_stop()\nhas been called.  This may result in the RoCE driver's aux driver\n.suspend() method being invoked twice.  The 2nd bnxt_re_suspend()\ncall will crash when it dereferences a NULL pointer:\n\n(NULL ib_device): Handle device suspend call\nBUG: kernel NULL pointer dereference, address: 0000000000000b78\nPGD 0 P4D 0\nOops: Oops: 0000 [#1] SMP PTI\nCPU: 20 UID: 0 PID: 181 Comm: kworker/u96:5 Tainted: G S                  6.15.0-rc1 #4 PREEMPT(voluntary)\nTainted: [S]=CPU_OUT_OF_SPEC\nHardware name: Dell Inc. PowerEdge R730/072T6D, BIOS 2.4.3 01/17/2017\nWorkqueue: bnxt_pf_wq bnxt_sp_task [bnxt_en]\nRIP: 0010:bnxt_re_suspend+0x45/0x1f0 [bnxt_re]\nCode: 8b 05 a7 3c 5b f5 48 89 44 24 18 31 c0 49 8b 5c 24 08 4d 8b 2c 24 e8 ea 06 0a f4 48 c7 c6 04 60 52 c0 48 89 df e8 1b ce f9 ff <48> 8b 83 78 0b 00 00 48 8b 80 38 03 00 00 a8 40 0f 85 b5 00 00 00\nRSP: 0018:ffffa2e84084fd88 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000001\nRDX: 0000000000000000 RSI: ffffffffb4b6b934 RDI: 00000000ffffffff\nRBP: ffffa1760954c9c0 R08: 0000000000000000 R09: c0000000ffffdfff\nR10: 0000000000000001 R11: ffffa2e84084fb50 R12: ffffa176031ef070\nR13: ffffa17609775000 R14: ffffa17603adc180 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffffa17daa397000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000b78 CR3: 00000004aaa30003 CR4: 00000000003706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n<TASK>\nbnxt_ulp_stop+0x69/0x90 [bnxt_en]\nbnxt_sp_task+0x678/0x920 [bnxt_en]\n? __schedule+0x514/0xf50\nprocess_scheduled_works+0x9d/0x400\nworker_thread+0x11c/0x260\n? __pfx_worker_thread+0x10/0x10\nkthread+0xfe/0x1e0\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x2b/0x40\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n\nCheck the BNXT_EN_FLAG_ULP_STOPPED flag and do not proceed if the flag\nis already set.  This will preserve the original symmetrical\nbnxt_ulp_stop() and bnxt_ulp_start().\n\nAlso, inside bnxt_ulp_start(), clear the BNXT_EN_FLAG_ULP_STOPPED\nflag after taking the mutex to avoid any race condition.  And for\nsymmetry, only proceed in bnxt_ulp_start() if the\nBNXT_EN_FLAG_ULP_STOPPED is set.\n\nFixes: 3c163f35bd50 (\"bnxt_en: Optimize recovery path ULP locking in the driver\")\nSigned-off-by: Kalesh AP <kalesh-anakkur.purayil@broadcom.com>\nCo-developed-by: Michael Chan <michael.chan@broadcom.com>\nSigned-off-by: Michael Chan <michael.chan@broadcom.com>\nReviewed-by: Simon Horman <horms@kernel.org>\nLink: https://patch.msgid.link/20250613231841.377988-2-michael.chan@broadcom.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Kalesh AP",
    "date": "2025-06-17T15:56:22-07:00",
    "files_changed": [
      "drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nindex 84c4812414fd..2450a369b792 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n@@ -231,10 +231,9 @@ void bnxt_ulp_stop(struct bnxt *bp)\n \t\treturn;\n \n \tmutex_lock(&edev->en_dev_lock);\n-\tif (!bnxt_ulp_registered(edev)) {\n-\t\tmutex_unlock(&edev->en_dev_lock);\n-\t\treturn;\n-\t}\n+\tif (!bnxt_ulp_registered(edev) ||\n+\t    (edev->flags & BNXT_EN_FLAG_ULP_STOPPED))\n+\t\tgoto ulp_stop_exit;\n \n \tedev->flags |= BNXT_EN_FLAG_ULP_STOPPED;\n \tif (aux_priv) {\n@@ -250,6 +249,7 @@ void bnxt_ulp_stop(struct bnxt *bp)\n \t\t\tadrv->suspend(adev, pm);\n \t\t}\n \t}\n+ulp_stop_exit:\n \tmutex_unlock(&edev->en_dev_lock);\n }\n \n@@ -258,19 +258,13 @@ void bnxt_ulp_start(struct bnxt *bp, int err)\n \tstruct bnxt_aux_priv *aux_priv = bp->aux_priv;\n \tstruct bnxt_en_dev *edev = bp->edev;\n \n-\tif (!edev)\n-\t\treturn;\n-\n-\tedev->flags &= ~BNXT_EN_FLAG_ULP_STOPPED;\n-\n-\tif (err)\n+\tif (!edev || err)\n \t\treturn;\n \n \tmutex_lock(&edev->en_dev_lock);\n-\tif (!bnxt_ulp_registered(edev)) {\n-\t\tmutex_unlock(&edev->en_dev_lock);\n-\t\treturn;\n-\t}\n+\tif (!bnxt_ulp_registered(edev) ||\n+\t    !(edev->flags & BNXT_EN_FLAG_ULP_STOPPED))\n+\t\tgoto ulp_start_exit;\n \n \tif (edev->ulp_tbl->msix_requested)\n \t\tbnxt_fill_msix_vecs(bp, edev->msix_entries);\n@@ -287,6 +281,8 @@ void bnxt_ulp_start(struct bnxt *bp, int err)\n \t\t\tadrv->resume(adev);\n \t\t}\n \t}\n+ulp_start_exit:\n+\tedev->flags &= ~BNXT_EN_FLAG_ULP_STOPPED;\n \tmutex_unlock(&edev->en_dev_lock);\n }\n ",
    "stats": {
      "insertions": 10,
      "deletions": 14,
      "files": 1
    }
  },
  {
    "sha": "94a17f2dc90bc7eae36c0f478515d4bd1c23e877",
    "message": "x86/mm: Disable INVLPGB when PTI is enabled\n\nPTI uses separate ASIDs (aka. PCIDs) for kernel and user address\nspaces. When the kernel needs to flush the user address space, it\njust sets a bit in a bitmap and then flushes the entire PCID on\nthe next switch to userspace.\n\nThis bitmap is a single 'unsigned long' which is plenty for all 6\ndynamic ASIDs. But, unfortunately, the INVLPGB support brings along a\nbunch more user ASIDs, as many as ~2k more. The bitmap can't address\nthat many.\n\nFortunately, the bitmap is only needed for PTI and all the CPUs\nwith INVLPGB are AMD CPUs that aren't vulnerable to Meltdown and\ndon't need PTI. The only way someone can run into an issue in\npractice is by booting with pti=on on a newer AMD CPU.\n\nDisable INVLPGB if PTI is enabled. Avoid overrunning the small\nbitmap.\n\nNote: this will be fixed up properly by making the bitmap bigger.\nFor now, just avoid the mostly theoretical bug.\n\nFixes: 4afeb0ed1753 (\"x86/mm: Enable broadcast TLB invalidation for multi-threaded processes\")\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nAcked-by: Rik van Riel <riel@surriel.com>\nCc:stable@vger.kernel.org\nLink: https://lore.kernel.org/all/20250610222420.E8CBF472%40davehans-spike.ostc.intel.com",
    "author": "Dave Hansen",
    "date": "2025-06-17T15:36:57-07:00",
    "files_changed": [
      "arch/x86/mm/pti.c"
    ],
    "diff": "diff --git a/arch/x86/mm/pti.c b/arch/x86/mm/pti.c\nindex 190299834011..c0c40b67524e 100644\n--- a/arch/x86/mm/pti.c\n+++ b/arch/x86/mm/pti.c\n@@ -98,6 +98,11 @@ void __init pti_check_boottime_disable(void)\n \t\treturn;\n \n \tsetup_force_cpu_cap(X86_FEATURE_PTI);\n+\n+\tif (cpu_feature_enabled(X86_FEATURE_INVLPGB)) {\n+\t\tpr_debug(\"PTI enabled, disabling INVLPGB\\n\");\n+\t\tsetup_clear_cpu_cap(X86_FEATURE_INVLPGB);\n+\t}\n }\n \n static int __init pti_parse_cmdline(char *arg)",
    "stats": {
      "insertions": 5,
      "deletions": 0,
      "files": 1
    }
  }
]
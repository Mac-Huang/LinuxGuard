[
  {
    "sha": "5f6e3b720694ad771911f637a51930f511427ce1",
    "message": "x86/mce/amd: Fix threshold limit reset\n\nThe MCA threshold limit must be reset after servicing the interrupt.\n\nCurrently, the restart function doesn't have an explicit check for this.  It\nmakes some assumptions based on the current limit and what's in the registers.\nThese assumptions don't always hold, so the limit won't be reset in some\ncases.\n\nMake the reset condition explicit. Either an interrupt/overflow has occurred\nor the bank is being initialized.\n\nSigned-off-by: Yazen Ghannam <yazen.ghannam@amd.com>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nCc: stable@vger.kernel.org\nLink: https://lore.kernel.org/20250624-wip-mca-updates-v4-4-236dd74f645f@amd.com",
    "author": "Yazen Ghannam",
    "date": "2025-06-27T13:16:23+02:00",
    "files_changed": [
      "arch/x86/kernel/cpu/mce/amd.c"
    ],
    "diff": "diff --git a/arch/x86/kernel/cpu/mce/amd.c b/arch/x86/kernel/cpu/mce/amd.c\nindex 6820ebce5d46..5c4eb28c3ac9 100644\n--- a/arch/x86/kernel/cpu/mce/amd.c\n+++ b/arch/x86/kernel/cpu/mce/amd.c\n@@ -350,7 +350,6 @@ static void smca_configure(unsigned int bank, unsigned int cpu)\n \n struct thresh_restart {\n \tstruct threshold_block\t*b;\n-\tint\t\t\treset;\n \tint\t\t\tset_lvt_off;\n \tint\t\t\tlvt_off;\n \tu16\t\t\told_limit;\n@@ -432,13 +431,13 @@ static void threshold_restart_bank(void *_tr)\n \n \trdmsr(tr->b->address, lo, hi);\n \n-\tif (tr->b->threshold_limit < (hi & THRESHOLD_MAX))\n-\t\ttr->reset = 1;\t/* limit cannot be lower than err count */\n-\n-\tif (tr->reset) {\t\t/* reset err count and overflow bit */\n-\t\thi =\n-\t\t    (hi & ~(MASK_ERR_COUNT_HI | MASK_OVERFLOW_HI)) |\n-\t\t    (THRESHOLD_MAX - tr->b->threshold_limit);\n+\t/*\n+\t * Reset error count and overflow bit.\n+\t * This is done during init or after handling an interrupt.\n+\t */\n+\tif (hi & MASK_OVERFLOW_HI || tr->set_lvt_off) {\n+\t\thi &= ~(MASK_ERR_COUNT_HI | MASK_OVERFLOW_HI);\n+\t\thi |= THRESHOLD_MAX - tr->b->threshold_limit;\n \t} else if (tr->old_limit) {\t/* change limit w/o reset */\n \t\tint new_count = (hi & THRESHOLD_MAX) +\n \t\t    (tr->old_limit - tr->b->threshold_limit);",
    "stats": {
      "insertions": 7,
      "deletions": 8,
      "files": 1
    }
  },
  {
    "sha": "cc8d5b209e09d3b52bca1ffe00045876842d96ae",
    "message": "LoongArch: KVM: Check validity of \"num_cpu\" from user space\n\nThe maximum supported cpu number is EIOINTC_ROUTE_MAX_VCPUS about\nirqchip EIOINTC, here add validation about cpu number to avoid array\npointer overflow.\n\nCc: stable@vger.kernel.org\nFixes: 1ad7efa552fd (\"LoongArch: KVM: Add EIOINTC user mode read and write functions\")\nSigned-off-by: Bibo Mao <maobibo@loongson.cn>\nSigned-off-by: Huacai Chen <chenhuacai@loongson.cn>",
    "author": "Bibo Mao",
    "date": "2025-06-27T18:27:44+08:00",
    "files_changed": [
      "arch/loongarch/kvm/intc/eiointc.c"
    ],
    "diff": "diff --git a/arch/loongarch/kvm/intc/eiointc.c b/arch/loongarch/kvm/intc/eiointc.c\nindex 644fb7785c07..056a75f7d090 100644\n--- a/arch/loongarch/kvm/intc/eiointc.c\n+++ b/arch/loongarch/kvm/intc/eiointc.c\n@@ -805,7 +805,7 @@ static int kvm_eiointc_ctrl_access(struct kvm_device *dev,\n \tint ret = 0;\n \tunsigned long flags;\n \tunsigned long type = (unsigned long)attr->attr;\n-\tu32 i, start_irq;\n+\tu32 i, start_irq, val;\n \tvoid __user *data;\n \tstruct loongarch_eiointc *s = dev->kvm->arch.eiointc;\n \n@@ -813,8 +813,14 @@ static int kvm_eiointc_ctrl_access(struct kvm_device *dev,\n \tspin_lock_irqsave(&s->lock, flags);\n \tswitch (type) {\n \tcase KVM_DEV_LOONGARCH_EXTIOI_CTRL_INIT_NUM_CPU:\n-\t\tif (copy_from_user(&s->num_cpu, data, 4))\n+\t\tif (copy_from_user(&val, data, 4))\n \t\t\tret = -EFAULT;\n+\t\telse {\n+\t\t\tif (val >= EIOINTC_ROUTE_MAX_VCPUS)\n+\t\t\t\tret = -EINVAL;\n+\t\t\telse\n+\t\t\t\ts->num_cpu = val;\n+\t\t}\n \t\tbreak;\n \tcase KVM_DEV_LOONGARCH_EXTIOI_CTRL_INIT_FEATURE:\n \t\tif (copy_from_user(&s->features, data, 4))\n@@ -842,7 +848,7 @@ static int kvm_eiointc_regs_access(struct kvm_device *dev,\n \t\t\t\t\tstruct kvm_device_attr *attr,\n \t\t\t\t\tbool is_write)\n {\n-\tint addr, cpuid, offset, ret = 0;\n+\tint addr, cpu, offset, ret = 0;\n \tunsigned long flags;\n \tvoid *p = NULL;\n \tvoid __user *data;\n@@ -850,7 +856,7 @@ static int kvm_eiointc_regs_access(struct kvm_device *dev,\n \n \ts = dev->kvm->arch.eiointc;\n \taddr = attr->attr;\n-\tcpuid = addr >> 16;\n+\tcpu = addr >> 16;\n \taddr &= 0xffff;\n \tdata = (void __user *)attr->addr;\n \tswitch (addr) {\n@@ -875,8 +881,11 @@ static int kvm_eiointc_regs_access(struct kvm_device *dev,\n \t\tp = &s->isr.reg_u32[offset];\n \t\tbreak;\n \tcase EIOINTC_COREISR_START ... EIOINTC_COREISR_END:\n+\t\tif (cpu >= s->num_cpu)\n+\t\t\treturn -EINVAL;\n+\n \t\toffset = (addr - EIOINTC_COREISR_START) / 4;\n-\t\tp = &s->coreisr.reg_u32[cpuid][offset];\n+\t\tp = &s->coreisr.reg_u32[cpu][offset];\n \t\tbreak;\n \tcase EIOINTC_COREMAP_START ... EIOINTC_COREMAP_END:\n \t\toffset = (addr - EIOINTC_COREMAP_START) / 4;",
    "stats": {
      "insertions": 14,
      "deletions": 5,
      "files": 1
    }
  },
  {
    "sha": "48e29133ae880a8f30ff098a9843d22e012350e0",
    "message": "Merge tag 'i2c-host-fixes-6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/andi.shyti/linux into i2c/for-current\n\ni2c-host fixes for v6.16-rc4\n\n- imx: fix SMBus protocol compliance during block read\n- omap: fix error handling path in probe\n- robotfuzz, tiny-usb: prevent zero-length reads\n- x86, designware, amdisp: fix build error when modules are\n  disabled",
    "author": "Wolfram Sang",
    "date": "2025-06-27T11:58:27+02:00",
    "files_changed": [
      "drivers/i2c/busses/i2c-designware-amdisp.c",
      "drivers/i2c/busses/i2c-designware-master.c",
      "drivers/i2c/busses/i2c-imx.c",
      "drivers/i2c/busses/i2c-omap.c",
      "drivers/i2c/busses/i2c-robotfuzz-osif.c",
      "drivers/i2c/busses/i2c-tiny-usb.c",
      "drivers/platform/x86/amd/amd_isp4.c",
      "include/linux/soc/amd/isp4_misc.h"
    ],
    "diff": "diff --git a/MAINTAINERS b/MAINTAINERS\nindex c3f7fbd0d67a..8719f097aae3 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -24063,6 +24063,7 @@ M:\tBin Du <bin.du@amd.com>\n L:\tlinux-i2c@vger.kernel.org\n S:\tMaintained\n F:\tdrivers/i2c/busses/i2c-designware-amdisp.c\n+F:\tinclude/linux/soc/amd/isp4_misc.h\n \n SYNOPSYS DESIGNWARE MMC/SD/SDIO DRIVER\n M:\tJaehoon Chung <jh80.chung@samsung.com>\ndiff --git a/drivers/i2c/busses/i2c-designware-amdisp.c b/drivers/i2c/busses/i2c-designware-amdisp.c\nindex ad6f08338124..450793d5f839 100644\n--- a/drivers/i2c/busses/i2c-designware-amdisp.c\n+++ b/drivers/i2c/busses/i2c-designware-amdisp.c\n@@ -8,6 +8,7 @@\n #include <linux/module.h>\n #include <linux/platform_device.h>\n #include <linux/pm_runtime.h>\n+#include <linux/soc/amd/isp4_misc.h>\n \n #include \"i2c-designware-core.h\"\n \n@@ -62,6 +63,7 @@ static int amd_isp_dw_i2c_plat_probe(struct platform_device *pdev)\n \n \tadap = &isp_i2c_dev->adapter;\n \tadap->owner = THIS_MODULE;\n+\tscnprintf(adap->name, sizeof(adap->name), AMDISP_I2C_ADAP_NAME);\n \tACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));\n \tadap->dev.of_node = pdev->dev.of_node;\n \t/* use dynamically allocated adapter id */\ndiff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c\nindex c5394229b77f..9d7d9e47564a 100644\n--- a/drivers/i2c/busses/i2c-designware-master.c\n+++ b/drivers/i2c/busses/i2c-designware-master.c\n@@ -1042,8 +1042,9 @@ int i2c_dw_probe_master(struct dw_i2c_dev *dev)\n \tif (ret)\n \t\treturn ret;\n \n-\tsnprintf(adap->name, sizeof(adap->name),\n-\t\t \"Synopsys DesignWare I2C adapter\");\n+\tif (!adap->name[0])\n+\t\tscnprintf(adap->name, sizeof(adap->name),\n+\t\t\t  \"Synopsys DesignWare I2C adapter\");\n \tadap->retries = 3;\n \tadap->algo = &i2c_dw_algo;\n \tadap->quirks = &i2c_dw_quirks;\ndiff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c\nindex e5732b0557fb..205cc132fdec 100644\n--- a/drivers/i2c/busses/i2c-imx.c\n+++ b/drivers/i2c/busses/i2c-imx.c\n@@ -1008,7 +1008,7 @@ static inline int i2c_imx_isr_read(struct imx_i2c_struct *i2c_imx)\n \t/* setup bus to read data */\n \ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n \ttemp &= ~I2CR_MTX;\n-\tif (i2c_imx->msg->len - 1)\n+\tif ((i2c_imx->msg->len - 1) || (i2c_imx->msg->flags & I2C_M_RECV_LEN))\n \t\ttemp &= ~I2CR_TXAK;\n \n \timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n@@ -1063,6 +1063,7 @@ static inline void i2c_imx_isr_read_block_data_len(struct imx_i2c_struct *i2c_im\n \t\twake_up(&i2c_imx->queue);\n \t}\n \ti2c_imx->msg->len += len;\n+\ti2c_imx->msg->buf[i2c_imx->msg_buf_idx++] = len;\n }\n \n static irqreturn_t i2c_imx_master_isr(struct imx_i2c_struct *i2c_imx, unsigned int status)\ndiff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c\nindex f1cc26ac5b80..8b01df3cc8e9 100644\n--- a/drivers/i2c/busses/i2c-omap.c\n+++ b/drivers/i2c/busses/i2c-omap.c\n@@ -1461,13 +1461,13 @@ omap_i2c_probe(struct platform_device *pdev)\n \t\tif (IS_ERR(mux_state)) {\n \t\t\tr = PTR_ERR(mux_state);\n \t\t\tdev_dbg(&pdev->dev, \"failed to get I2C mux: %d\\n\", r);\n-\t\t\tgoto err_disable_pm;\n+\t\t\tgoto err_put_pm;\n \t\t}\n \t\tomap->mux_state = mux_state;\n \t\tr = mux_state_select(omap->mux_state);\n \t\tif (r) {\n \t\t\tdev_err(&pdev->dev, \"failed to select I2C mux: %d\\n\", r);\n-\t\t\tgoto err_disable_pm;\n+\t\t\tgoto err_put_pm;\n \t\t}\n \t}\n \n@@ -1515,6 +1515,9 @@ omap_i2c_probe(struct platform_device *pdev)\n \n err_unuse_clocks:\n \tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\n+\tif (omap->mux_state)\n+\t\tmux_state_deselect(omap->mux_state);\n+err_put_pm:\n \tpm_runtime_dont_use_autosuspend(omap->dev);\n \tpm_runtime_put_sync(omap->dev);\n err_disable_pm:\ndiff --git a/drivers/i2c/busses/i2c-robotfuzz-osif.c b/drivers/i2c/busses/i2c-robotfuzz-osif.c\nindex 80d45079b763..e0a76fb5bc31 100644\n--- a/drivers/i2c/busses/i2c-robotfuzz-osif.c\n+++ b/drivers/i2c/busses/i2c-robotfuzz-osif.c\n@@ -111,6 +111,11 @@ static u32 osif_func(struct i2c_adapter *adapter)\n \treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n }\n \n+/* prevent invalid 0-length usb_control_msg */\n+static const struct i2c_adapter_quirks osif_quirks = {\n+\t.flags = I2C_AQ_NO_ZERO_LEN_READ,\n+};\n+\n static const struct i2c_algorithm osif_algorithm = {\n \t.xfer = osif_xfer,\n \t.functionality = osif_func,\n@@ -143,6 +148,7 @@ static int osif_probe(struct usb_interface *interface,\n \n \tpriv->adapter.owner = THIS_MODULE;\n \tpriv->adapter.class = I2C_CLASS_HWMON;\n+\tpriv->adapter.quirks = &osif_quirks;\n \tpriv->adapter.algo = &osif_algorithm;\n \tpriv->adapter.algo_data = priv;\n \tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\ndiff --git a/drivers/i2c/busses/i2c-tiny-usb.c b/drivers/i2c/busses/i2c-tiny-usb.c\nindex a18eab0992a1..57dfe5f1a7d9 100644\n--- a/drivers/i2c/busses/i2c-tiny-usb.c\n+++ b/drivers/i2c/busses/i2c-tiny-usb.c\n@@ -139,6 +139,11 @@ static u32 usb_func(struct i2c_adapter *adapter)\n \treturn ret;\n }\n \n+/* prevent invalid 0-length usb_control_msg */\n+static const struct i2c_adapter_quirks usb_quirks = {\n+\t.flags = I2C_AQ_NO_ZERO_LEN_READ,\n+};\n+\n /* This is the actual algorithm we define */\n static const struct i2c_algorithm usb_algorithm = {\n \t.xfer = usb_xfer,\n@@ -247,6 +252,7 @@ static int i2c_tiny_usb_probe(struct usb_interface *interface,\n \t/* setup i2c adapter description */\n \tdev->adapter.owner = THIS_MODULE;\n \tdev->adapter.class = I2C_CLASS_HWMON;\n+\tdev->adapter.quirks = &usb_quirks;\n \tdev->adapter.algo = &usb_algorithm;\n \tdev->adapter.algo_data = dev;\n \tsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\ndiff --git a/drivers/platform/x86/amd/amd_isp4.c b/drivers/platform/x86/amd/amd_isp4.c\nindex 0cc01441bcbb..9f291aeb35f1 100644\n--- a/drivers/platform/x86/amd/amd_isp4.c\n+++ b/drivers/platform/x86/amd/amd_isp4.c\n@@ -11,6 +11,7 @@\n #include <linux/mutex.h>\n #include <linux/platform_device.h>\n #include <linux/property.h>\n+#include <linux/soc/amd/isp4_misc.h>\n #include <linux/string.h>\n #include <linux/types.h>\n #include <linux/units.h>\n@@ -151,7 +152,7 @@ MODULE_DEVICE_TABLE(acpi, amdisp_sensor_ids);\n \n static inline bool is_isp_i2c_adapter(struct i2c_adapter *adap)\n {\n-\treturn !strcmp(adap->owner->name, \"i2c_designware_amdisp\");\n+\treturn !strcmp(adap->name, AMDISP_I2C_ADAP_NAME);\n }\n \n static void instantiate_isp_i2c_client(struct amdisp_platform *isp4_platform,\ndiff --git a/include/linux/soc/amd/isp4_misc.h b/include/linux/soc/amd/isp4_misc.h\nnew file mode 100644\nindex 000000000000..6738796986a7\n--- /dev/null\n+++ b/include/linux/soc/amd/isp4_misc.h\n@@ -0,0 +1,12 @@\n+// SPDX-License-Identifier: GPL-2.0+\n+\n+/*\n+ * Copyright (C) 2025 Advanced Micro Devices, Inc.\n+ */\n+\n+#ifndef __SOC_ISP4_MISC_H\n+#define __SOC_ISP4_MISC_H\n+\n+#define AMDISP_I2C_ADAP_NAME \"AMDISP DesignWare I2C adapter\"\n+\n+#endif",
    "stats": {
      "insertions": 39,
      "deletions": 6,
      "files": 9
    }
  },
  {
    "sha": "6f2a71a99ebd5dfaa7948a2e9c59eae94b741bd8",
    "message": "Merge tag 'bcachefs-2025-06-26' of git://evilpiepirate.org/bcachefs\n\nPull bcachefs fixes from Kent Overstreet:\n\n - Lots of small check/repair fixes, primarily in subvol loop and\n   directory structure loop (when involving snapshots).\n\n - Fix a few 6.16 regressions: rare UAF in the foreground allocator path\n   when taking a transaction restart from the transaction bump\n   allocator, and some small fallout from the change to log the error\n   being corrected in the journal when repairing errors, also some\n   fallout from the btree node read error logging improvements.\n\n   (Alan, Bharadwaj)\n\n - New option: journal_rewind\n\n   This lets the entire filesystem be reset to an earlier point in time.\n\n   Note that this is only a disaster recovery tool, and right now there\n   are major caveats to using it (discards should be disabled, in\n   particular), but it successfully restored the filesystem of one of\n   the users who was bit by the subvolume deletion bug and didn't have\n   backups. I'll likely be making some changes to the discard path in\n   the future to make this a reliable recovery tool.\n\n - Some new btree iterator tracepoints, for tracking down some\n   livelock-ish behaviour we've been seeing in the main data write path.\n\n* tag 'bcachefs-2025-06-26' of git://evilpiepirate.org/bcachefs: (51 commits)\n  bcachefs: Plumb correct ip to trans_relock_fail tracepoint\n  bcachefs: Ensure we rewind to run recovery passes\n  bcachefs: Ensure btree node scan runs before checking for scanned nodes\n  bcachefs: btree_root_unreadable_and_scan_found_nothing should not be autofix\n  bcachefs: fix bch2_journal_keys_peek_prev_min() underflow\n  bcachefs: Use wait_on_allocator() when allocating journal\n  bcachefs: Check for bad write buffer key when moving from journal\n  bcachefs: Don't unlock the trans if ret doesn't match BCH_ERR_operation_blocked\n  bcachefs: Fix range in bch2_lookup_indirect_extent() error path\n  bcachefs: fix spurious error_throw\n  bcachefs: Add missing bch2_err_class() to fileattr_set()\n  bcachefs: Add missing key type checks to check_snapshot_exists()\n  bcachefs: Don't log fsck err in the journal if doing repair elsewhere\n  bcachefs: Fix *__bch2_trans_subbuf_alloc() error path\n  bcachefs: Fix missing newlines before ero\n  bcachefs: fix spurious error in read_btree_roots()\n  bcachefs: fsck: Fix oops in key_visible_in_snapshot()\n  bcachefs: fsck: fix unhandled restart in topology repair\n  bcachefs: fsck: Fix check_directory_structure when no check_dirents\n  bcachefs: Fix restart handling in btree_node_scrub_work()\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-06-26T19:49:12-07:00",
    "files_changed": [
      "fs/bcachefs/alloc_background.c",
      "fs/bcachefs/backpointers.c",
      "fs/bcachefs/bcachefs.h",
      "fs/bcachefs/btree_gc.c",
      "fs/bcachefs/btree_io.c",
      "fs/bcachefs/btree_iter.c",
      "fs/bcachefs/btree_journal_iter.c",
      "fs/bcachefs/btree_journal_iter_types.h",
      "fs/bcachefs/btree_locking.c",
      "fs/bcachefs/btree_node_scan.c",
      "fs/bcachefs/btree_node_scan.h",
      "fs/bcachefs/btree_trans_commit.c",
      "fs/bcachefs/btree_types.h",
      "fs/bcachefs/btree_update.c",
      "fs/bcachefs/btree_update.h",
      "fs/bcachefs/btree_update_interior.c",
      "fs/bcachefs/btree_update_interior.h",
      "fs/bcachefs/btree_write_buffer.c",
      "fs/bcachefs/btree_write_buffer.h",
      "fs/bcachefs/chardev.c",
      "fs/bcachefs/data_update.c",
      "fs/bcachefs/errcode.h",
      "fs/bcachefs/error.c",
      "fs/bcachefs/extent_update.c",
      "fs/bcachefs/fs.c",
      "fs/bcachefs/fsck.c",
      "fs/bcachefs/inode.h",
      "fs/bcachefs/io_read.c",
      "fs/bcachefs/journal.c",
      "fs/bcachefs/journal.h",
      "fs/bcachefs/journal_io.c",
      "fs/bcachefs/namei.c",
      "fs/bcachefs/opts.h",
      "fs/bcachefs/recovery.c",
      "fs/bcachefs/recovery_passes.c",
      "fs/bcachefs/recovery_passes.h",
      "fs/bcachefs/reflink.c",
      "fs/bcachefs/sb-errors_format.h",
      "fs/bcachefs/snapshot.c",
      "fs/bcachefs/super.c",
      "fs/bcachefs/super.h",
      "fs/bcachefs/trace.h"
    ],
    "diff": "diff --git a/fs/bcachefs/alloc_background.c b/fs/bcachefs/alloc_background.c\nindex b228a5a64479..66de46318620 100644\n--- a/fs/bcachefs/alloc_background.c\n+++ b/fs/bcachefs/alloc_background.c\n@@ -1406,6 +1406,9 @@ int bch2_check_discard_freespace_key(struct btree_trans *trans, struct btree_ite\n \t\t: BCH_DATA_free;\n \tstruct printbuf buf = PRINTBUF;\n \n+\tunsigned fsck_flags = (async_repair ? FSCK_ERR_NO_LOG : 0)|\n+\t\tFSCK_CAN_FIX|FSCK_CAN_IGNORE;\n+\n \tstruct bpos bucket = iter->pos;\n \tbucket.offset &= ~(~0ULL << 56);\n \tu64 genbits = iter->pos.offset & (~0ULL << 56);\n@@ -1419,9 +1422,10 @@ int bch2_check_discard_freespace_key(struct btree_trans *trans, struct btree_ite\n \t\treturn ret;\n \n \tif (!bch2_dev_bucket_exists(c, bucket)) {\n-\t\tif (fsck_err(trans, need_discard_freespace_key_to_invalid_dev_bucket,\n-\t\t\t     \"entry in %s btree for nonexistant dev:bucket %llu:%llu\",\n-\t\t\t     bch2_btree_id_str(iter->btree_id), bucket.inode, bucket.offset))\n+\t\tif (__fsck_err(trans, fsck_flags,\n+\t\t\t       need_discard_freespace_key_to_invalid_dev_bucket,\n+\t\t\t       \"entry in %s btree for nonexistant dev:bucket %llu:%llu\",\n+\t\t\t       bch2_btree_id_str(iter->btree_id), bucket.inode, bucket.offset))\n \t\t\tgoto delete;\n \t\tret = 1;\n \t\tgoto out;\n@@ -1433,7 +1437,8 @@ int bch2_check_discard_freespace_key(struct btree_trans *trans, struct btree_ite\n \tif (a->data_type != state ||\n \t    (state == BCH_DATA_free &&\n \t     genbits != alloc_freespace_genbits(*a))) {\n-\t\tif (fsck_err(trans, need_discard_freespace_key_bad,\n+\t\tif (__fsck_err(trans, fsck_flags,\n+\t\t\t       need_discard_freespace_key_bad,\n \t\t\t     \"%s\\nincorrectly set at %s:%llu:%llu:0 (free %u, genbits %llu should be %llu)\",\n \t\t\t     (bch2_bkey_val_to_text(&buf, c, alloc_k), buf.buf),\n \t\t\t     bch2_btree_id_str(iter->btree_id),\ndiff --git a/fs/bcachefs/backpointers.c b/fs/bcachefs/backpointers.c\nindex e76809e71858..77d93beb3c8f 100644\n--- a/fs/bcachefs/backpointers.c\n+++ b/fs/bcachefs/backpointers.c\n@@ -353,7 +353,7 @@ static struct bkey_s_c __bch2_backpointer_get_key(struct btree_trans *trans,\n \t\treturn ret ? bkey_s_c_err(ret) : bkey_s_c_null;\n \t} else {\n \t\tstruct btree *b = __bch2_backpointer_get_node(trans, bp, iter, last_flushed, commit);\n-\t\tif (b == ERR_PTR(bch_err_throw(c, backpointer_to_overwritten_btree_node)))\n+\t\tif (b == ERR_PTR(-BCH_ERR_backpointer_to_overwritten_btree_node))\n \t\t\treturn bkey_s_c_null;\n \t\tif (IS_ERR_OR_NULL(b))\n \t\t\treturn ((struct bkey_s_c) { .k = ERR_CAST(b) });\ndiff --git a/fs/bcachefs/bcachefs.h b/fs/bcachefs/bcachefs.h\nindex 5a1cede2febf..8043943cdf6a 100644\n--- a/fs/bcachefs/bcachefs.h\n+++ b/fs/bcachefs/bcachefs.h\n@@ -767,7 +767,8 @@ struct btree_trans_buf {\n \tx(sysfs)\t\t\t\t\t\t\t\\\n \tx(btree_write_buffer)\t\t\t\t\t\t\\\n \tx(btree_node_scrub)\t\t\t\t\t\t\\\n-\tx(async_recovery_passes)\n+\tx(async_recovery_passes)\t\t\t\t\t\\\n+\tx(ioctl_data)\n \n enum bch_write_ref {\n #define x(n) BCH_WRITE_REF_##n,\ndiff --git a/fs/bcachefs/btree_gc.c b/fs/bcachefs/btree_gc.c\nindex e92cf3928c63..bac108e93823 100644\n--- a/fs/bcachefs/btree_gc.c\n+++ b/fs/bcachefs/btree_gc.c\n@@ -503,8 +503,14 @@ static int bch2_btree_repair_topology_recurse(struct btree_trans *trans, struct\n \tprt_newline(&buf);\n \tbch2_bkey_val_to_text(&buf, c, bkey_i_to_s_c(&b->key));\n \n+\t/*\n+\t * XXX: we're not passing the trans object here because we're not set up\n+\t * to handle a transaction restart - this code needs to be rewritten\n+\t * when we start doing online topology repair\n+\t */\n+\tbch2_trans_unlock_long(trans);\n \tif (mustfix_fsck_err_on(!have_child,\n-\t\t\ttrans, btree_node_topology_interior_node_empty,\n+\t\t\tc, btree_node_topology_interior_node_empty,\n \t\t\t\"empty interior btree node at %s\", buf.buf))\n \t\tret = DROP_THIS_NODE;\n err:\n@@ -528,32 +534,39 @@ static int bch2_btree_repair_topology_recurse(struct btree_trans *trans, struct\n \treturn ret;\n }\n \n-static int bch2_check_root(struct btree_trans *trans, enum btree_id i,\n+static int bch2_check_root(struct btree_trans *trans, enum btree_id btree,\n \t\t\t   bool *reconstructed_root)\n {\n \tstruct bch_fs *c = trans->c;\n-\tstruct btree_root *r = bch2_btree_id_root(c, i);\n+\tstruct btree_root *r = bch2_btree_id_root(c, btree);\n \tstruct printbuf buf = PRINTBUF;\n \tint ret = 0;\n \n-\tbch2_btree_id_to_text(&buf, i);\n+\tbch2_btree_id_to_text(&buf, btree);\n \n \tif (r->error) {\n \t\tbch_info(c, \"btree root %s unreadable, must recover from scan\", buf.buf);\n \n-\t\tr->alive = false;\n-\t\tr->error = 0;\n+\t\tret = bch2_btree_has_scanned_nodes(c, btree);\n+\t\tif (ret < 0)\n+\t\t\tgoto err;\n \n-\t\tif (!bch2_btree_has_scanned_nodes(c, i)) {\n+\t\tif (!ret) {\n \t\t\t__fsck_err(trans,\n-\t\t\t\t   FSCK_CAN_FIX|(!btree_id_important(i) ? FSCK_AUTOFIX : 0),\n+\t\t\t\t   FSCK_CAN_FIX|(!btree_id_important(btree) ? FSCK_AUTOFIX : 0),\n \t\t\t\t   btree_root_unreadable_and_scan_found_nothing,\n \t\t\t\t   \"no nodes found for btree %s, continue?\", buf.buf);\n-\t\t\tbch2_btree_root_alloc_fake_trans(trans, i, 0);\n+\n+\t\t\tr->alive = false;\n+\t\t\tr->error = 0;\n+\t\t\tbch2_btree_root_alloc_fake_trans(trans, btree, 0);\n \t\t} else {\n-\t\t\tbch2_btree_root_alloc_fake_trans(trans, i, 1);\n-\t\t\tbch2_shoot_down_journal_keys(c, i, 1, BTREE_MAX_DEPTH, POS_MIN, SPOS_MAX);\n-\t\t\tret = bch2_get_scanned_nodes(c, i, 0, POS_MIN, SPOS_MAX);\n+\t\t\tr->alive = false;\n+\t\t\tr->error = 0;\n+\t\t\tbch2_btree_root_alloc_fake_trans(trans, btree, 1);\n+\n+\t\t\tbch2_shoot_down_journal_keys(c, btree, 1, BTREE_MAX_DEPTH, POS_MIN, SPOS_MAX);\n+\t\t\tret = bch2_get_scanned_nodes(c, btree, 0, POS_MIN, SPOS_MAX);\n \t\t\tif (ret)\n \t\t\t\tgoto err;\n \t\t}\ndiff --git a/fs/bcachefs/btree_io.c b/fs/bcachefs/btree_io.c\nindex d8f3c4c65e90..08b22bddd747 100644\n--- a/fs/bcachefs/btree_io.c\n+++ b/fs/bcachefs/btree_io.c\n@@ -557,7 +557,9 @@ static int __btree_err(int ret,\n \t\t       const char *fmt, ...)\n {\n \tif (c->recovery.curr_pass == BCH_RECOVERY_PASS_scan_for_btree_nodes)\n-\t\treturn bch_err_throw(c, fsck_fix);\n+\t\treturn ret == -BCH_ERR_btree_node_read_err_fixable\n+\t\t\t? bch_err_throw(c, fsck_fix)\n+\t\t\t: ret;\n \n \tbool have_retry = false;\n \tint ret2;\n@@ -723,12 +725,11 @@ void bch2_btree_node_drop_keys_outside_node(struct btree *b)\n \n static int validate_bset(struct bch_fs *c, struct bch_dev *ca,\n \t\t\t struct btree *b, struct bset *i,\n-\t\t\t unsigned offset, unsigned sectors, int write,\n+\t\t\t unsigned offset, int write,\n \t\t\t struct bch_io_failures *failed,\n \t\t\t struct printbuf *err_msg)\n {\n \tunsigned version = le16_to_cpu(i->version);\n-\tunsigned ptr_written = btree_ptr_sectors_written(bkey_i_to_s_c(&b->key));\n \tstruct printbuf buf1 = PRINTBUF;\n \tstruct printbuf buf2 = PRINTBUF;\n \tint ret = 0;\n@@ -778,15 +779,6 @@ static int validate_bset(struct bch_fs *c, struct bch_dev *ca,\n \t\t     btree_node_unsupported_version,\n \t\t     \"BSET_SEPARATE_WHITEOUTS no longer supported\");\n \n-\tif (!write &&\n-\t    btree_err_on(offset + sectors > (ptr_written ?: btree_sectors(c)),\n-\t\t\t -BCH_ERR_btree_node_read_err_fixable,\n-\t\t\t c, ca, b, i, NULL,\n-\t\t\t bset_past_end_of_btree_node,\n-\t\t\t \"bset past end of btree node (offset %u len %u but written %zu)\",\n-\t\t\t offset, sectors, ptr_written ?: btree_sectors(c)))\n-\t\ti->u64s = 0;\n-\n \tbtree_err_on(offset && !i->u64s,\n \t\t     -BCH_ERR_btree_node_read_err_fixable,\n \t\t     c, ca, b, i, NULL,\n@@ -1151,6 +1143,14 @@ int bch2_btree_node_read_done(struct bch_fs *c, struct bch_dev *ca,\n \t\t\t     \"unknown checksum type %llu\", BSET_CSUM_TYPE(i));\n \n \t\tif (first) {\n+\t\t\tsectors = vstruct_sectors(b->data, c->block_bits);\n+\t\t\tif (btree_err_on(b->written + sectors > (ptr_written ?: btree_sectors(c)),\n+\t\t\t\t\t -BCH_ERR_btree_node_read_err_fixable,\n+\t\t\t\t\t c, ca, b, i, NULL,\n+\t\t\t\t\t bset_past_end_of_btree_node,\n+\t\t\t\t\t \"bset past end of btree node (offset %u len %u but written %zu)\",\n+\t\t\t\t\t b->written, sectors, ptr_written ?: btree_sectors(c)))\n+\t\t\t\ti->u64s = 0;\n \t\t\tif (good_csum_type) {\n \t\t\t\tstruct bch_csum csum = csum_vstruct(c, BSET_CSUM_TYPE(i), nonce, b->data);\n \t\t\t\tbool csum_bad = bch2_crc_cmp(b->data->csum, csum);\n@@ -1178,9 +1178,15 @@ int bch2_btree_node_read_done(struct bch_fs *c, struct bch_dev *ca,\n \t\t\t\t     c, NULL, b, NULL, NULL,\n \t\t\t\t     btree_node_unsupported_version,\n \t\t\t\t     \"btree node does not have NEW_EXTENT_OVERWRITE set\");\n-\n-\t\t\tsectors = vstruct_sectors(b->data, c->block_bits);\n \t\t} else {\n+\t\t\tsectors = vstruct_sectors(bne, c->block_bits);\n+\t\t\tif (btree_err_on(b->written + sectors > (ptr_written ?: btree_sectors(c)),\n+\t\t\t\t\t -BCH_ERR_btree_node_read_err_fixable,\n+\t\t\t\t\t c, ca, b, i, NULL,\n+\t\t\t\t\t bset_past_end_of_btree_node,\n+\t\t\t\t\t \"bset past end of btree node (offset %u len %u but written %zu)\",\n+\t\t\t\t\t b->written, sectors, ptr_written ?: btree_sectors(c)))\n+\t\t\t\ti->u64s = 0;\n \t\t\tif (good_csum_type) {\n \t\t\t\tstruct bch_csum csum = csum_vstruct(c, BSET_CSUM_TYPE(i), nonce, bne);\n \t\t\t\tbool csum_bad = bch2_crc_cmp(bne->csum, csum);\n@@ -1201,14 +1207,12 @@ int bch2_btree_node_read_done(struct bch_fs *c, struct bch_dev *ca,\n \t\t\t\t\t\t\"decrypting btree node: %s\", bch2_err_str(ret)))\n \t\t\t\t\tgoto fsck_err;\n \t\t\t}\n-\n-\t\t\tsectors = vstruct_sectors(bne, c->block_bits);\n \t\t}\n \n \t\tb->version_ondisk = min(b->version_ondisk,\n \t\t\t\t\tle16_to_cpu(i->version));\n \n-\t\tret = validate_bset(c, ca, b, i, b->written, sectors, READ, failed, err_msg);\n+\t\tret = validate_bset(c, ca, b, i, b->written, READ, failed, err_msg);\n \t\tif (ret)\n \t\t\tgoto fsck_err;\n \n@@ -1982,28 +1986,12 @@ static void btree_node_scrub_work(struct work_struct *work)\n \tprt_newline(&err);\n \n \tif (!btree_node_scrub_check(c, scrub->buf, scrub->written, &err)) {\n-\t\tstruct btree_trans *trans = bch2_trans_get(c);\n-\n-\t\tstruct btree_iter iter;\n-\t\tbch2_trans_node_iter_init(trans, &iter, scrub->btree,\n-\t\t\t\t\t  scrub->key.k->k.p, 0, scrub->level - 1, 0);\n-\n-\t\tstruct btree *b;\n-\t\tint ret = lockrestart_do(trans,\n-\t\t\tPTR_ERR_OR_ZERO(b = bch2_btree_iter_peek_node(trans, &iter)));\n-\t\tif (ret)\n-\t\t\tgoto err;\n-\n-\t\tif (bkey_i_to_btree_ptr_v2(&b->key)->v.seq == scrub->seq) {\n-\t\t\tbch_err(c, \"error validating btree node during scrub on %s at btree %s\",\n-\t\t\t\tscrub->ca->name, err.buf);\n-\n-\t\t\tret = bch2_btree_node_rewrite(trans, &iter, b, 0, 0);\n-\t\t}\n-err:\n-\t\tbch2_trans_iter_exit(trans, &iter);\n-\t\tbch2_trans_begin(trans);\n-\t\tbch2_trans_put(trans);\n+\t\tint ret = bch2_trans_do(c,\n+\t\t\tbch2_btree_node_rewrite_key(trans, scrub->btree, scrub->level - 1,\n+\t\t\t\t\t\t    scrub->key.k, 0));\n+\t\tif (!bch2_err_matches(ret, ENOENT) &&\n+\t\t    !bch2_err_matches(ret, EROFS))\n+\t\t\tbch_err_fn_ratelimited(c, ret);\n \t}\n \n \tprintbuf_exit(&err);\n@@ -2267,7 +2255,7 @@ static void btree_node_write_endio(struct bio *bio)\n }\n \n static int validate_bset_for_write(struct bch_fs *c, struct btree *b,\n-\t\t\t\t   struct bset *i, unsigned sectors)\n+\t\t\t\t   struct bset *i)\n {\n \tint ret = bch2_bkey_validate(c, bkey_i_to_s_c(&b->key),\n \t\t\t\t     (struct bkey_validate_context) {\n@@ -2282,7 +2270,7 @@ static int validate_bset_for_write(struct bch_fs *c, struct btree *b,\n \t}\n \n \tret = validate_bset_keys(c, b, i, WRITE, NULL, NULL) ?:\n-\t\tvalidate_bset(c, NULL, b, i, b->written, sectors, WRITE, NULL, NULL);\n+\t\tvalidate_bset(c, NULL, b, i, b->written, WRITE, NULL, NULL);\n \tif (ret) {\n \t\tbch2_inconsistent_error(c);\n \t\tdump_stack();\n@@ -2475,7 +2463,7 @@ void __bch2_btree_node_write(struct bch_fs *c, struct btree *b, unsigned flags)\n \n \t/* if we're going to be encrypting, check metadata validity first: */\n \tif (validate_before_checksum &&\n-\t    validate_bset_for_write(c, b, i, sectors_to_write))\n+\t    validate_bset_for_write(c, b, i))\n \t\tgoto err;\n \n \tret = bset_encrypt(c, i, b->written << 9);\n@@ -2492,7 +2480,7 @@ void __bch2_btree_node_write(struct bch_fs *c, struct btree *b, unsigned flags)\n \n \t/* if we're not encrypting, check metadata after checksumming: */\n \tif (!validate_before_checksum &&\n-\t    validate_bset_for_write(c, b, i, sectors_to_write))\n+\t    validate_bset_for_write(c, b, i))\n \t\tgoto err;\n \n \t/*\ndiff --git a/fs/bcachefs/btree_iter.c b/fs/bcachefs/btree_iter.c\nindex b78403376c07..352f9cd2634f 100644\n--- a/fs/bcachefs/btree_iter.c\n+++ b/fs/bcachefs/btree_iter.c\n@@ -2076,14 +2076,14 @@ inline bool bch2_btree_iter_rewind(struct btree_trans *trans, struct btree_iter\n \n static noinline\n void bch2_btree_trans_peek_prev_updates(struct btree_trans *trans, struct btree_iter *iter,\n-\t\t\t\t\tstruct bkey_s_c *k)\n+\t\t\t\t\tstruct bpos search_key, struct bkey_s_c *k)\n {\n \tstruct bpos end = path_l(btree_iter_path(trans, iter))->b->data->min_key;\n \n \ttrans_for_each_update(trans, i)\n \t\tif (!i->key_cache_already_flushed &&\n \t\t    i->btree_id == iter->btree_id &&\n-\t\t    bpos_le(i->k->k.p, iter->pos) &&\n+\t\t    bpos_le(i->k->k.p, search_key) &&\n \t\t    bpos_ge(i->k->k.p, k->k ? k->k->p : end)) {\n \t\t\titer->k = i->k->k;\n \t\t\t*k = bkey_i_to_s_c(i->k);\n@@ -2092,6 +2092,7 @@ void bch2_btree_trans_peek_prev_updates(struct btree_trans *trans, struct btree_\n \n static noinline\n void bch2_btree_trans_peek_updates(struct btree_trans *trans, struct btree_iter *iter,\n+\t\t\t\t   struct bpos search_key,\n \t\t\t\t   struct bkey_s_c *k)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n@@ -2100,7 +2101,7 @@ void bch2_btree_trans_peek_updates(struct btree_trans *trans, struct btree_iter\n \ttrans_for_each_update(trans, i)\n \t\tif (!i->key_cache_already_flushed &&\n \t\t    i->btree_id == iter->btree_id &&\n-\t\t    bpos_ge(i->k->k.p, path->pos) &&\n+\t\t    bpos_ge(i->k->k.p, search_key) &&\n \t\t    bpos_le(i->k->k.p, k->k ? k->k->p : end)) {\n \t\t\titer->k = i->k->k;\n \t\t\t*k = bkey_i_to_s_c(i->k);\n@@ -2122,13 +2123,14 @@ void bch2_btree_trans_peek_slot_updates(struct btree_trans *trans, struct btree_\n \n static struct bkey_i *bch2_btree_journal_peek(struct btree_trans *trans,\n \t\t\t\t\t      struct btree_iter *iter,\n+\t\t\t\t\t      struct bpos search_pos,\n \t\t\t\t\t      struct bpos end_pos)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n \n \treturn bch2_journal_keys_peek_max(trans->c, iter->btree_id,\n \t\t\t\t\t   path->level,\n-\t\t\t\t\t   path->pos,\n+\t\t\t\t\t   search_pos,\n \t\t\t\t\t   end_pos,\n \t\t\t\t\t   &iter->journal_idx);\n }\n@@ -2138,7 +2140,7 @@ struct bkey_s_c btree_trans_peek_slot_journal(struct btree_trans *trans,\n \t\t\t\t\t      struct btree_iter *iter)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n-\tstruct bkey_i *k = bch2_btree_journal_peek(trans, iter, path->pos);\n+\tstruct bkey_i *k = bch2_btree_journal_peek(trans, iter, path->pos, path->pos);\n \n \tif (k) {\n \t\titer->k = k->k;\n@@ -2151,11 +2153,12 @@ struct bkey_s_c btree_trans_peek_slot_journal(struct btree_trans *trans,\n static noinline\n void btree_trans_peek_journal(struct btree_trans *trans,\n \t\t\t      struct btree_iter *iter,\n+\t\t\t      struct bpos search_key,\n \t\t\t      struct bkey_s_c *k)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n \tstruct bkey_i *next_journal =\n-\t\tbch2_btree_journal_peek(trans, iter,\n+\t\tbch2_btree_journal_peek(trans, iter, search_key,\n \t\t\t\tk->k ? k->k->p : path_l(path)->b->key.k.p);\n \tif (next_journal) {\n \t\titer->k = next_journal->k;\n@@ -2165,13 +2168,14 @@ void btree_trans_peek_journal(struct btree_trans *trans,\n \n static struct bkey_i *bch2_btree_journal_peek_prev(struct btree_trans *trans,\n \t\t\t\t\t      struct btree_iter *iter,\n+\t\t\t\t\t      struct bpos search_key,\n \t\t\t\t\t      struct bpos end_pos)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n \n \treturn bch2_journal_keys_peek_prev_min(trans->c, iter->btree_id,\n \t\t\t\t\t   path->level,\n-\t\t\t\t\t   path->pos,\n+\t\t\t\t\t   search_key,\n \t\t\t\t\t   end_pos,\n \t\t\t\t\t   &iter->journal_idx);\n }\n@@ -2179,11 +2183,12 @@ static struct bkey_i *bch2_btree_journal_peek_prev(struct btree_trans *trans,\n static noinline\n void btree_trans_peek_prev_journal(struct btree_trans *trans,\n \t\t\t\t   struct btree_iter *iter,\n+\t\t\t\t   struct bpos search_key,\n \t\t\t\t   struct bkey_s_c *k)\n {\n \tstruct btree_path *path = btree_iter_path(trans, iter);\n \tstruct bkey_i *next_journal =\n-\t\tbch2_btree_journal_peek_prev(trans, iter,\n+\t\tbch2_btree_journal_peek_prev(trans, iter, search_key,\n \t\t\t\tk->k ? k->k->p : path_l(path)->b->key.k.p);\n \n \tif (next_journal) {\n@@ -2292,11 +2297,11 @@ static struct bkey_s_c __bch2_btree_iter_peek(struct btree_trans *trans, struct\n \t\t}\n \n \t\tif (unlikely(iter->flags & BTREE_ITER_with_journal))\n-\t\t\tbtree_trans_peek_journal(trans, iter, &k);\n+\t\t\tbtree_trans_peek_journal(trans, iter, search_key, &k);\n \n \t\tif (unlikely((iter->flags & BTREE_ITER_with_updates) &&\n \t\t\t     trans->nr_updates))\n-\t\t\tbch2_btree_trans_peek_updates(trans, iter, &k);\n+\t\t\tbch2_btree_trans_peek_updates(trans, iter, search_key, &k);\n \n \t\tif (k.k && bkey_deleted(k.k)) {\n \t\t\t/*\n@@ -2326,6 +2331,20 @@ static struct bkey_s_c __bch2_btree_iter_peek(struct btree_trans *trans, struct\n \t}\n \n \tbch2_btree_iter_verify(trans, iter);\n+\n+\tif (trace___btree_iter_peek_enabled()) {\n+\t\tCLASS(printbuf, buf)();\n+\n+\t\tint ret = bkey_err(k);\n+\t\tif (ret)\n+\t\t\tprt_str(&buf, bch2_err_str(ret));\n+\t\telse if (k.k)\n+\t\t\tbch2_bkey_val_to_text(&buf, trans->c, k);\n+\t\telse\n+\t\t\tprt_str(&buf, \"(null)\");\n+\t\ttrace___btree_iter_peek(trans->c, buf.buf);\n+\t}\n+\n \treturn k;\n }\n \n@@ -2484,6 +2503,19 @@ struct bkey_s_c bch2_btree_iter_peek_max(struct btree_trans *trans, struct btree\n \n \tbch2_btree_iter_verify_entry_exit(iter);\n \n+\tif (trace_btree_iter_peek_max_enabled()) {\n+\t\tCLASS(printbuf, buf)();\n+\n+\t\tint ret = bkey_err(k);\n+\t\tif (ret)\n+\t\t\tprt_str(&buf, bch2_err_str(ret));\n+\t\telse if (k.k)\n+\t\t\tbch2_bkey_val_to_text(&buf, trans->c, k);\n+\t\telse\n+\t\t\tprt_str(&buf, \"(null)\");\n+\t\ttrace_btree_iter_peek_max(trans->c, buf.buf);\n+\t}\n+\n \treturn k;\n end:\n \tbch2_btree_iter_set_pos(trans, iter, end);\n@@ -2557,11 +2589,11 @@ static struct bkey_s_c __bch2_btree_iter_peek_prev(struct btree_trans *trans, st\n \t\t}\n \n \t\tif (unlikely(iter->flags & BTREE_ITER_with_journal))\n-\t\t\tbtree_trans_peek_prev_journal(trans, iter, &k);\n+\t\t\tbtree_trans_peek_prev_journal(trans, iter, search_key, &k);\n \n \t\tif (unlikely((iter->flags & BTREE_ITER_with_updates) &&\n \t\t\t     trans->nr_updates))\n-\t\t\tbch2_btree_trans_peek_prev_updates(trans, iter, &k);\n+\t\t\tbch2_btree_trans_peek_prev_updates(trans, iter, search_key, &k);\n \n \t\tif (likely(k.k && !bkey_deleted(k.k))) {\n \t\t\tbreak;\n@@ -2724,6 +2756,19 @@ struct bkey_s_c bch2_btree_iter_peek_prev_min(struct btree_trans *trans, struct\n \n \tbch2_btree_iter_verify_entry_exit(iter);\n \tbch2_btree_iter_verify(trans, iter);\n+\n+\tif (trace_btree_iter_peek_prev_min_enabled()) {\n+\t\tCLASS(printbuf, buf)();\n+\n+\t\tint ret = bkey_err(k);\n+\t\tif (ret)\n+\t\t\tprt_str(&buf, bch2_err_str(ret));\n+\t\telse if (k.k)\n+\t\t\tbch2_bkey_val_to_text(&buf, trans->c, k);\n+\t\telse\n+\t\t\tprt_str(&buf, \"(null)\");\n+\t\ttrace_btree_iter_peek_prev_min(trans->c, buf.buf);\n+\t}\n \treturn k;\n end:\n \tbch2_btree_iter_set_pos(trans, iter, end);\n@@ -2767,8 +2812,10 @@ struct bkey_s_c bch2_btree_iter_peek_slot(struct btree_trans *trans, struct btre\n \t/* extents can't span inode numbers: */\n \tif ((iter->flags & BTREE_ITER_is_extents) &&\n \t    unlikely(iter->pos.offset == KEY_OFFSET_MAX)) {\n-\t\tif (iter->pos.inode == KEY_INODE_MAX)\n-\t\t\treturn bkey_s_c_null;\n+\t\tif (iter->pos.inode == KEY_INODE_MAX) {\n+\t\t\tk = bkey_s_c_null;\n+\t\t\tgoto out2;\n+\t\t}\n \n \t\tbch2_btree_iter_set_pos(trans, iter, bpos_nosnap_successor(iter->pos));\n \t}\n@@ -2785,8 +2832,10 @@ struct bkey_s_c bch2_btree_iter_peek_slot(struct btree_trans *trans, struct btre\n \t}\n \n \tstruct btree_path *path = btree_iter_path(trans, iter);\n-\tif (unlikely(!btree_path_node(path, path->level)))\n-\t\treturn bkey_s_c_null;\n+\tif (unlikely(!btree_path_node(path, path->level))) {\n+\t\tk = bkey_s_c_null;\n+\t\tgoto out2;\n+\t}\n \n \tbtree_path_set_should_be_locked(trans, path);\n \n@@ -2879,7 +2928,20 @@ struct bkey_s_c bch2_btree_iter_peek_slot(struct btree_trans *trans, struct btre\n \tbch2_btree_iter_verify(trans, iter);\n \tret = bch2_btree_iter_verify_ret(trans, iter, k);\n \tif (unlikely(ret))\n-\t\treturn bkey_s_c_err(ret);\n+\t\tk = bkey_s_c_err(ret);\n+out2:\n+\tif (trace_btree_iter_peek_slot_enabled()) {\n+\t\tCLASS(printbuf, buf)();\n+\n+\t\tint ret = bkey_err(k);\n+\t\tif (ret)\n+\t\t\tprt_str(&buf, bch2_err_str(ret));\n+\t\telse if (k.k)\n+\t\t\tbch2_bkey_val_to_text(&buf, trans->c, k);\n+\t\telse\n+\t\t\tprt_str(&buf, \"(null)\");\n+\t\ttrace_btree_iter_peek_slot(trans->c, buf.buf);\n+\t}\n \n \treturn k;\n }\n@@ -3132,6 +3194,10 @@ void *__bch2_trans_kmalloc(struct btree_trans *trans, size_t size, unsigned long\n \tif (WARN_ON_ONCE(new_bytes > BTREE_TRANS_MEM_MAX)) {\n #ifdef CONFIG_BCACHEFS_TRANS_KMALLOC_TRACE\n \t\tstruct printbuf buf = PRINTBUF;\n+\t\tbch2_log_msg_start(c, &buf);\n+\t\tprt_printf(&buf, \"bump allocator exceeded BTREE_TRANS_MEM_MAX (%u)\\n\",\n+\t\t\t   BTREE_TRANS_MEM_MAX);\n+\n \t\tbch2_trans_kmalloc_trace_to_text(&buf, &trans->trans_kmalloc_trace);\n \t\tbch2_print_str(c, KERN_ERR, buf.buf);\n \t\tprintbuf_exit(&buf);\n@@ -3159,46 +3225,32 @@ void *__bch2_trans_kmalloc(struct btree_trans *trans, size_t size, unsigned long\n \t\tmutex_unlock(&s->lock);\n \t}\n \n-\tif (trans->used_mempool) {\n-\t\tif (trans->mem_bytes >= new_bytes)\n-\t\t\tgoto out_change_top;\n-\n-\t\t/* No more space from mempool item, need malloc new one */\n-\t\tnew_mem = kmalloc(new_bytes, GFP_NOWAIT|__GFP_NOWARN);\n-\t\tif (unlikely(!new_mem)) {\n-\t\t\tbch2_trans_unlock(trans);\n-\n-\t\t\tnew_mem = kmalloc(new_bytes, GFP_KERNEL);\n-\t\t\tif (!new_mem)\n-\t\t\t\treturn ERR_PTR(-BCH_ERR_ENOMEM_trans_kmalloc);\n+\tif (trans->used_mempool || new_bytes > BTREE_TRANS_MEM_MAX) {\n+\t\tEBUG_ON(trans->mem_bytes >= new_bytes);\n+\t\treturn ERR_PTR(-BCH_ERR_ENOMEM_trans_kmalloc);\n+\t}\n \n-\t\t\tret = bch2_trans_relock(trans);\n-\t\t\tif (ret) {\n-\t\t\t\tkfree(new_mem);\n-\t\t\t\treturn ERR_PTR(ret);\n-\t\t\t}\n-\t\t}\n-\t\tmemcpy(new_mem, trans->mem, trans->mem_top);\n-\t\ttrans->used_mempool = false;\n-\t\tmempool_free(trans->mem, &c->btree_trans_mem_pool);\n-\t\tgoto out_new_mem;\n+\tif (old_bytes) {\n+\t\ttrans->realloc_bytes_required = new_bytes;\n+\t\ttrace_and_count(c, trans_restart_mem_realloced, trans, _RET_IP_, new_bytes);\n+\t\treturn ERR_PTR(btree_trans_restart_ip(trans,\n+\t\t\t\t\tBCH_ERR_transaction_restart_mem_realloced, _RET_IP_));\n \t}\n \n-\tnew_mem = krealloc(trans->mem, new_bytes, GFP_NOWAIT|__GFP_NOWARN);\n+\tEBUG_ON(trans->mem);\n+\n+\tnew_mem = kmalloc(new_bytes, GFP_NOWAIT|__GFP_NOWARN);\n \tif (unlikely(!new_mem)) {\n \t\tbch2_trans_unlock(trans);\n \n-\t\tnew_mem = krealloc(trans->mem, new_bytes, GFP_KERNEL);\n+\t\tnew_mem = kmalloc(new_bytes, GFP_KERNEL);\n \t\tif (!new_mem && new_bytes <= BTREE_TRANS_MEM_MAX) {\n \t\t\tnew_mem = mempool_alloc(&c->btree_trans_mem_pool, GFP_KERNEL);\n \t\t\tnew_bytes = BTREE_TRANS_MEM_MAX;\n-\t\t\tmemcpy(new_mem, trans->mem, trans->mem_top);\n \t\t\ttrans->used_mempool = true;\n-\t\t\tkfree(trans->mem);\n \t\t}\n \n-\t\tif (!new_mem)\n-\t\t\treturn ERR_PTR(-BCH_ERR_ENOMEM_trans_kmalloc);\n+\t\tEBUG_ON(!new_mem);\n \n \t\ttrans->mem = new_mem;\n \t\ttrans->mem_bytes = new_bytes;\n@@ -3207,18 +3259,10 @@ void *__bch2_trans_kmalloc(struct btree_trans *trans, size_t size, unsigned long\n \t\tif (ret)\n \t\t\treturn ERR_PTR(ret);\n \t}\n-out_new_mem:\n+\n \ttrans->mem = new_mem;\n \ttrans->mem_bytes = new_bytes;\n \n-\tif (old_bytes) {\n-\t\ttrace_and_count(c, trans_restart_mem_realloced, trans, _RET_IP_, new_bytes);\n-\t\treturn ERR_PTR(btree_trans_restart_ip(trans,\n-\t\t\t\t\tBCH_ERR_transaction_restart_mem_realloced, _RET_IP_));\n-\t}\n-out_change_top:\n-\tbch2_trans_kmalloc_trace(trans, size, ip);\n-\n \tp = trans->mem + trans->mem_top;\n \ttrans->mem_top += size;\n \tmemset(p, 0, size);\n@@ -3279,6 +3323,27 @@ u32 bch2_trans_begin(struct btree_trans *trans)\n \ttrans->restart_count++;\n \ttrans->mem_top\t\t\t= 0;\n \n+\tif (trans->restarted == BCH_ERR_transaction_restart_mem_realloced) {\n+\t\tEBUG_ON(!trans->mem || !trans->mem_bytes);\n+\t\tunsigned new_bytes = trans->realloc_bytes_required;\n+\t\tvoid *new_mem = krealloc(trans->mem, new_bytes, GFP_NOWAIT|__GFP_NOWARN);\n+\t\tif (unlikely(!new_mem)) {\n+\t\t\tbch2_trans_unlock(trans);\n+\t\t\tnew_mem = krealloc(trans->mem, new_bytes, GFP_KERNEL);\n+\n+\t\t\tEBUG_ON(new_bytes > BTREE_TRANS_MEM_MAX);\n+\n+\t\t\tif (!new_mem) {\n+\t\t\t\tnew_mem = mempool_alloc(&trans->c->btree_trans_mem_pool, GFP_KERNEL);\n+\t\t\t\tnew_bytes = BTREE_TRANS_MEM_MAX;\n+\t\t\t\ttrans->used_mempool = true;\n+\t\t\t\tkfree(trans->mem);\n+\t\t\t}\n+                }\n+\t\ttrans->mem = new_mem;\n+\t\ttrans->mem_bytes = new_bytes;\n+\t}\n+\n \ttrans_for_each_path(trans, path, i) {\n \t\tpath->should_be_locked = false;\n \ndiff --git a/fs/bcachefs/btree_journal_iter.c b/fs/bcachefs/btree_journal_iter.c\nindex cf7398751644..ea839560a136 100644\n--- a/fs/bcachefs/btree_journal_iter.c\n+++ b/fs/bcachefs/btree_journal_iter.c\n@@ -137,12 +137,15 @@ struct bkey_i *bch2_journal_keys_peek_prev_min(struct bch_fs *c, enum btree_id b\n \tstruct journal_key *k;\n \n \tBUG_ON(*idx > keys->nr);\n+\n+\tif (!keys->nr)\n+\t\treturn NULL;\n search:\n \tif (!*idx)\n \t\t*idx = __bch2_journal_key_search(keys, btree_id, level, pos);\n \n-\twhile (*idx &&\n-\t       __journal_key_cmp(btree_id, level, end_pos, idx_to_key(keys, *idx - 1)) <= 0) {\n+\twhile (*idx < keys->nr &&\n+\t       __journal_key_cmp(btree_id, level, end_pos, idx_to_key(keys, *idx)) >= 0) {\n \t\t(*idx)++;\n \t\titers++;\n \t\tif (iters == 10) {\n@@ -151,18 +154,23 @@ struct bkey_i *bch2_journal_keys_peek_prev_min(struct bch_fs *c, enum btree_id b\n \t\t}\n \t}\n \n+\tif (*idx == keys->nr)\n+\t\t--(*idx);\n+\n \tstruct bkey_i *ret = NULL;\n \trcu_read_lock(); /* for overwritten_ranges */\n \n-\twhile ((k = *idx < keys->nr ? idx_to_key(keys, *idx) : NULL)) {\n+\twhile (true) {\n+\t\tk = idx_to_key(keys, *idx);\n \t\tif (__journal_key_cmp(btree_id, level, end_pos, k) > 0)\n \t\t\tbreak;\n \n \t\tif (k->overwritten) {\n \t\t\tif (k->overwritten_range)\n-\t\t\t\t*idx = rcu_dereference(k->overwritten_range)->start - 1;\n-\t\t\telse\n-\t\t\t\t*idx -= 1;\n+\t\t\t\t*idx = rcu_dereference(k->overwritten_range)->start;\n+\t\t\tif (!*idx)\n+\t\t\t\tbreak;\n+\t\t\t--(*idx);\n \t\t\tcontinue;\n \t\t}\n \n@@ -171,6 +179,8 @@ struct bkey_i *bch2_journal_keys_peek_prev_min(struct bch_fs *c, enum btree_id b\n \t\t\tbreak;\n \t\t}\n \n+\t\tif (!*idx)\n+\t\t\tbreak;\n \t\t--(*idx);\n \t\titers++;\n \t\tif (iters == 10) {\n@@ -641,10 +651,11 @@ static int journal_sort_key_cmp(const void *_l, const void *_r)\n {\n \tconst struct journal_key *l = _l;\n \tconst struct journal_key *r = _r;\n+\tint rewind = l->rewind && r->rewind ? -1 : 1;\n \n \treturn  journal_key_cmp(l, r) ?:\n-\t\tcmp_int(l->journal_seq, r->journal_seq) ?:\n-\t\tcmp_int(l->journal_offset, r->journal_offset);\n+\t\t((cmp_int(l->journal_seq, r->journal_seq) ?:\n+\t\t  cmp_int(l->journal_offset, r->journal_offset)) * rewind);\n }\n \n void bch2_journal_keys_put(struct bch_fs *c)\n@@ -713,6 +724,8 @@ int bch2_journal_keys_sort(struct bch_fs *c)\n \tstruct journal_keys *keys = &c->journal_keys;\n \tsize_t nr_read = 0;\n \n+\tu64 rewind_seq = c->opts.journal_rewind ?: U64_MAX;\n+\n \tgenradix_for_each(&c->journal_entries, iter, _i) {\n \t\ti = *_i;\n \n@@ -721,28 +734,43 @@ int bch2_journal_keys_sort(struct bch_fs *c)\n \n \t\tcond_resched();\n \n-\t\tfor_each_jset_key(k, entry, &i->j) {\n-\t\t\tstruct journal_key n = (struct journal_key) {\n-\t\t\t\t.btree_id\t= entry->btree_id,\n-\t\t\t\t.level\t\t= entry->level,\n-\t\t\t\t.k\t\t= k,\n-\t\t\t\t.journal_seq\t= le64_to_cpu(i->j.seq),\n-\t\t\t\t.journal_offset\t= k->_data - i->j._data,\n-\t\t\t};\n-\n-\t\t\tif (darray_push(keys, n)) {\n-\t\t\t\t__journal_keys_sort(keys);\n-\n-\t\t\t\tif (keys->nr * 8 > keys->size * 7) {\n-\t\t\t\t\tbch_err(c, \"Too many journal keys for slowpath; have %zu compacted, buf size %zu, processed %zu keys at seq %llu\",\n-\t\t\t\t\t\tkeys->nr, keys->size, nr_read, le64_to_cpu(i->j.seq));\n-\t\t\t\t\treturn bch_err_throw(c, ENOMEM_journal_keys_sort);\n+\t\tvstruct_for_each(&i->j, entry) {\n+\t\t\tbool rewind = !entry->level &&\n+\t\t\t\t!btree_id_is_alloc(entry->btree_id) &&\n+\t\t\t\tle64_to_cpu(i->j.seq) >= rewind_seq;\n+\n+\t\t\tif (entry->type != (rewind\n+\t\t\t\t\t    ? BCH_JSET_ENTRY_overwrite\n+\t\t\t\t\t    : BCH_JSET_ENTRY_btree_keys))\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (!rewind && le64_to_cpu(i->j.seq) < c->journal_replay_seq_start)\n+\t\t\t\tcontinue;\n+\n+\t\t\tjset_entry_for_each_key(entry, k) {\n+\t\t\t\tstruct journal_key n = (struct journal_key) {\n+\t\t\t\t\t.btree_id\t= entry->btree_id,\n+\t\t\t\t\t.level\t\t= entry->level,\n+\t\t\t\t\t.rewind\t\t= rewind,\n+\t\t\t\t\t.k\t\t= k,\n+\t\t\t\t\t.journal_seq\t= le64_to_cpu(i->j.seq),\n+\t\t\t\t\t.journal_offset\t= k->_data - i->j._data,\n+\t\t\t\t};\n+\n+\t\t\t\tif (darray_push(keys, n)) {\n+\t\t\t\t\t__journal_keys_sort(keys);\n+\n+\t\t\t\t\tif (keys->nr * 8 > keys->size * 7) {\n+\t\t\t\t\t\tbch_err(c, \"Too many journal keys for slowpath; have %zu compacted, buf size %zu, processed %zu keys at seq %llu\",\n+\t\t\t\t\t\t\tkeys->nr, keys->size, nr_read, le64_to_cpu(i->j.seq));\n+\t\t\t\t\t\treturn bch_err_throw(c, ENOMEM_journal_keys_sort);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tBUG_ON(darray_push(keys, n));\n \t\t\t\t}\n \n-\t\t\t\tBUG_ON(darray_push(keys, n));\n+\t\t\t\tnr_read++;\n \t\t\t}\n-\n-\t\t\tnr_read++;\n \t\t}\n \t}\n \ndiff --git a/fs/bcachefs/btree_journal_iter_types.h b/fs/bcachefs/btree_journal_iter_types.h\nindex 8b773823704f..86aacb254fb2 100644\n--- a/fs/bcachefs/btree_journal_iter_types.h\n+++ b/fs/bcachefs/btree_journal_iter_types.h\n@@ -11,8 +11,9 @@ struct journal_key {\n \tu32\t\t\tjournal_offset;\n \tenum btree_id\t\tbtree_id:8;\n \tunsigned\t\tlevel:8;\n-\tbool\t\t\tallocated;\n-\tbool\t\t\toverwritten;\n+\tbool\t\t\tallocated:1;\n+\tbool\t\t\toverwritten:1;\n+\tbool\t\t\trewind:1;\n \tstruct journal_key_range_overwritten __rcu *\n \t\t\t\toverwritten_range;\n \tstruct bkey_i\t\t*k;\ndiff --git a/fs/bcachefs/btree_locking.c b/fs/bcachefs/btree_locking.c\nindex 91a51aef82f1..bed2b4b6ffb9 100644\n--- a/fs/bcachefs/btree_locking.c\n+++ b/fs/bcachefs/btree_locking.c\n@@ -771,7 +771,7 @@ static inline void __bch2_trans_unlock(struct btree_trans *trans)\n }\n \n static noinline __cold void bch2_trans_relock_fail(struct btree_trans *trans, struct btree_path *path,\n-\t\t\t\t\t\t  struct get_locks_fail *f, bool trace)\n+\t\t\t\t\t\t   struct get_locks_fail *f, bool trace, ulong ip)\n {\n \tif (!trace)\n \t\tgoto out;\n@@ -796,7 +796,7 @@ static noinline __cold void bch2_trans_relock_fail(struct btree_trans *trans, st\n \t\t\tprt_printf(&buf, \" total locked %u.%u.%u\", c.n[0], c.n[1], c.n[2]);\n \t\t}\n \n-\t\ttrace_trans_restart_relock(trans, _RET_IP_, buf.buf);\n+\t\ttrace_trans_restart_relock(trans, ip, buf.buf);\n \t\tprintbuf_exit(&buf);\n \t}\n \n@@ -806,7 +806,7 @@ static noinline __cold void bch2_trans_relock_fail(struct btree_trans *trans, st\n \tbch2_trans_verify_locks(trans);\n }\n \n-static inline int __bch2_trans_relock(struct btree_trans *trans, bool trace)\n+static inline int __bch2_trans_relock(struct btree_trans *trans, bool trace, ulong ip)\n {\n \tbch2_trans_verify_locks(trans);\n \n@@ -825,7 +825,7 @@ static inline int __bch2_trans_relock(struct btree_trans *trans, bool trace)\n \t\tif (path->should_be_locked &&\n \t\t    (ret = btree_path_get_locks(trans, path, false, &f,\n \t\t\t\t\tBCH_ERR_transaction_restart_relock))) {\n-\t\t\tbch2_trans_relock_fail(trans, path, &f, trace);\n+\t\t\tbch2_trans_relock_fail(trans, path, &f, trace, ip);\n \t\t\treturn ret;\n \t\t}\n \t}\n@@ -838,12 +838,12 @@ static inline int __bch2_trans_relock(struct btree_trans *trans, bool trace)\n \n int bch2_trans_relock(struct btree_trans *trans)\n {\n-\treturn __bch2_trans_relock(trans, true);\n+\treturn __bch2_trans_relock(trans, true, _RET_IP_);\n }\n \n int bch2_trans_relock_notrace(struct btree_trans *trans)\n {\n-\treturn __bch2_trans_relock(trans, false);\n+\treturn __bch2_trans_relock(trans, false, _RET_IP_);\n }\n \n void bch2_trans_unlock(struct btree_trans *trans)\ndiff --git a/fs/bcachefs/btree_node_scan.c b/fs/bcachefs/btree_node_scan.c\nindex a35847734a60..23d8c62ea4b6 100644\n--- a/fs/bcachefs/btree_node_scan.c\n+++ b/fs/bcachefs/btree_node_scan.c\n@@ -521,8 +521,12 @@ bool bch2_btree_node_is_stale(struct bch_fs *c, struct btree *b)\n \treturn false;\n }\n \n-bool bch2_btree_has_scanned_nodes(struct bch_fs *c, enum btree_id btree)\n+int bch2_btree_has_scanned_nodes(struct bch_fs *c, enum btree_id btree)\n {\n+\tint ret = bch2_run_print_explicit_recovery_pass(c, BCH_RECOVERY_PASS_scan_for_btree_nodes);\n+\tif (ret)\n+\t\treturn ret;\n+\n \tstruct found_btree_node search = {\n \t\t.btree_id\t= btree,\n \t\t.level\t\t= 0,\ndiff --git a/fs/bcachefs/btree_node_scan.h b/fs/bcachefs/btree_node_scan.h\nindex 08687b209787..66e6f9ed19d0 100644\n--- a/fs/bcachefs/btree_node_scan.h\n+++ b/fs/bcachefs/btree_node_scan.h\n@@ -4,7 +4,7 @@\n \n int bch2_scan_for_btree_nodes(struct bch_fs *);\n bool bch2_btree_node_is_stale(struct bch_fs *, struct btree *);\n-bool bch2_btree_has_scanned_nodes(struct bch_fs *, enum btree_id);\n+int bch2_btree_has_scanned_nodes(struct bch_fs *, enum btree_id);\n int bch2_get_scanned_nodes(struct bch_fs *, enum btree_id, unsigned, struct bpos, struct bpos);\n void bch2_find_btree_nodes_exit(struct find_btree_nodes *);\n \ndiff --git a/fs/bcachefs/btree_trans_commit.c b/fs/bcachefs/btree_trans_commit.c\nindex d9710801e3ee..639ef75b3dbd 100644\n--- a/fs/bcachefs/btree_trans_commit.c\n+++ b/fs/bcachefs/btree_trans_commit.c\n@@ -595,12 +595,13 @@ bch2_trans_commit_write_locked(struct btree_trans *trans, unsigned flags,\n \tint ret = 0;\n \n \tbch2_trans_verify_not_unlocked_or_in_restart(trans);\n-\n+#if 0\n+\t/* todo: bring back dynamic fault injection */\n \tif (race_fault()) {\n \t\ttrace_and_count(c, trans_restart_fault_inject, trans, trace_ip);\n \t\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_fault_inject);\n \t}\n-\n+#endif\n \t/*\n \t * Check if the insert will fit in the leaf node with the write lock\n \t * held, otherwise another thread could write the node changing the\n@@ -757,6 +758,8 @@ bch2_trans_commit_write_locked(struct btree_trans *trans, unsigned flags,\n \t\t\t\t  btree_trans_journal_entries_start(trans),\n \t\t\t\t  trans->journal_entries.u64s);\n \n+\t\tEBUG_ON(trans->journal_res.u64s < trans->journal_entries.u64s);\n+\n \t\ttrans->journal_res.offset\t+= trans->journal_entries.u64s;\n \t\ttrans->journal_res.u64s\t\t-= trans->journal_entries.u64s;\n \n@@ -1003,6 +1006,7 @@ int __bch2_trans_commit(struct btree_trans *trans, unsigned flags)\n {\n \tstruct btree_insert_entry *errored_at = NULL;\n \tstruct bch_fs *c = trans->c;\n+\tunsigned journal_u64s = 0;\n \tint ret = 0;\n \n \tbch2_trans_verify_not_unlocked_or_in_restart(trans);\n@@ -1031,10 +1035,10 @@ int __bch2_trans_commit(struct btree_trans *trans, unsigned flags)\n \n \tEBUG_ON(test_bit(BCH_FS_clean_shutdown, &c->flags));\n \n-\ttrans->journal_u64s\t\t= trans->journal_entries.u64s + jset_u64s(trans->accounting.u64s);\n+\tjournal_u64s = jset_u64s(trans->accounting.u64s);\n \ttrans->journal_transaction_names = READ_ONCE(c->opts.journal_transaction_names);\n \tif (trans->journal_transaction_names)\n-\t\ttrans->journal_u64s += jset_u64s(JSET_ENTRY_LOG_U64s);\n+\t\tjournal_u64s += jset_u64s(JSET_ENTRY_LOG_U64s);\n \n \ttrans_for_each_update(trans, i) {\n \t\tstruct btree_path *path = trans->paths + i->path;\n@@ -1054,11 +1058,11 @@ int __bch2_trans_commit(struct btree_trans *trans, unsigned flags)\n \t\t\tcontinue;\n \n \t\t/* we're going to journal the key being updated: */\n-\t\ttrans->journal_u64s += jset_u64s(i->k->k.u64s);\n+\t\tjournal_u64s += jset_u64s(i->k->k.u64s);\n \n \t\t/* and we're also going to log the overwrite: */\n \t\tif (trans->journal_transaction_names)\n-\t\t\ttrans->journal_u64s += jset_u64s(i->old_k.u64s);\n+\t\t\tjournal_u64s += jset_u64s(i->old_k.u64s);\n \t}\n \n \tif (trans->extra_disk_res) {\n@@ -1076,6 +1080,8 @@ int __bch2_trans_commit(struct btree_trans *trans, unsigned flags)\n \t\tmemset(&trans->journal_res, 0, sizeof(trans->journal_res));\n \tmemset(&trans->fs_usage_delta, 0, sizeof(trans->fs_usage_delta));\n \n+\ttrans->journal_u64s = journal_u64s + trans->journal_entries.u64s;\n+\n \tret = do_bch2_trans_commit(trans, flags, &errored_at, _RET_IP_);\n \n \t/* make sure we didn't drop or screw up locks: */\ndiff --git a/fs/bcachefs/btree_types.h b/fs/bcachefs/btree_types.h\nindex 3aa4a602bd02..112170fd9c8f 100644\n--- a/fs/bcachefs/btree_types.h\n+++ b/fs/bcachefs/btree_types.h\n@@ -497,6 +497,7 @@ struct btree_trans {\n \tvoid\t\t\t*mem;\n \tunsigned\t\tmem_top;\n \tunsigned\t\tmem_bytes;\n+\tunsigned\t\trealloc_bytes_required;\n #ifdef CONFIG_BCACHEFS_TRANS_KMALLOC_TRACE\n \tdarray_trans_kmalloc_trace trans_kmalloc_trace;\n #endif\ndiff --git a/fs/bcachefs/btree_update.c b/fs/bcachefs/btree_update.c\nindex e97e78c10f49..ee657b9f4b96 100644\n--- a/fs/bcachefs/btree_update.c\n+++ b/fs/bcachefs/btree_update.c\n@@ -549,20 +549,26 @@ void *__bch2_trans_subbuf_alloc(struct btree_trans *trans,\n \t\t\t\tunsigned u64s)\n {\n \tunsigned new_top = buf->u64s + u64s;\n-\tunsigned old_size = buf->size;\n+\tunsigned new_size = buf->size;\n \n-\tif (new_top > buf->size)\n-\t\tbuf->size = roundup_pow_of_two(new_top);\n+\tBUG_ON(roundup_pow_of_two(new_top) > U16_MAX);\n \n-\tvoid *n = bch2_trans_kmalloc_nomemzero(trans, buf->size * sizeof(u64));\n+\tif (new_top > new_size)\n+\t\tnew_size = roundup_pow_of_two(new_top);\n+\n+\tvoid *n = bch2_trans_kmalloc_nomemzero(trans, new_size * sizeof(u64));\n \tif (IS_ERR(n))\n \t\treturn n;\n \n+\tunsigned offset = (u64 *) n - (u64 *) trans->mem;\n+\tBUG_ON(offset > U16_MAX);\n+\n \tif (buf->u64s)\n \t\tmemcpy(n,\n \t\t       btree_trans_subbuf_base(trans, buf),\n-\t\t       old_size * sizeof(u64));\n+\t\t       buf->size * sizeof(u64));\n \tbuf->base = (u64 *) n - (u64 *) trans->mem;\n+\tbuf->size = new_size;\n \n \tvoid *p = btree_trans_subbuf_top(trans, buf);\n \tbuf->u64s = new_top;\ndiff --git a/fs/bcachefs/btree_update.h b/fs/bcachefs/btree_update.h\nindex 9feef1dc4de5..0b98ab959719 100644\n--- a/fs/bcachefs/btree_update.h\n+++ b/fs/bcachefs/btree_update.h\n@@ -170,8 +170,7 @@ bch2_trans_jset_entry_alloc(struct btree_trans *trans, unsigned u64s)\n \n int bch2_btree_insert_clone_trans(struct btree_trans *, enum btree_id, struct bkey_i *);\n \n-int bch2_btree_write_buffer_insert_err(struct btree_trans *,\n-\t\t\t\t       enum btree_id, struct bkey_i *);\n+int bch2_btree_write_buffer_insert_err(struct bch_fs *, enum btree_id, struct bkey_i *);\n \n static inline int __must_check bch2_trans_update_buffered(struct btree_trans *trans,\n \t\t\t\t\t    enum btree_id btree,\n@@ -182,7 +181,7 @@ static inline int __must_check bch2_trans_update_buffered(struct btree_trans *tr\n \tEBUG_ON(k->k.u64s > BTREE_WRITE_BUFERED_U64s_MAX);\n \n \tif (unlikely(!btree_type_uses_write_buffer(btree))) {\n-\t\tint ret = bch2_btree_write_buffer_insert_err(trans, btree, k);\n+\t\tint ret = bch2_btree_write_buffer_insert_err(trans->c, btree, k);\n \t\tdump_stack();\n \t\treturn ret;\n \t}\ndiff --git a/fs/bcachefs/btree_update_interior.c b/fs/bcachefs/btree_update_interior.c\nindex e77584607f0d..553059b33bfd 100644\n--- a/fs/bcachefs/btree_update_interior.c\n+++ b/fs/bcachefs/btree_update_interior.c\n@@ -1287,10 +1287,11 @@ bch2_btree_update_start(struct btree_trans *trans, struct btree_path *path,\n \n \t\tdo {\n \t\t\tret = bch2_btree_reserve_get(trans, as, nr_nodes, target, flags, &cl);\n-\n+\t\t\tif (!bch2_err_matches(ret, BCH_ERR_operation_blocked))\n+\t\t\t\tbreak;\n \t\t\tbch2_trans_unlock(trans);\n \t\t\tbch2_wait_on_allocator(c, &cl);\n-\t\t} while (bch2_err_matches(ret, BCH_ERR_operation_blocked));\n+\t\t} while (1);\n \t}\n \n \tif (ret) {\n@@ -2293,9 +2294,9 @@ int bch2_btree_node_rewrite(struct btree_trans *trans,\n \tgoto out;\n }\n \n-static int bch2_btree_node_rewrite_key(struct btree_trans *trans,\n-\t\t\t\t       enum btree_id btree, unsigned level,\n-\t\t\t\t       struct bkey_i *k, unsigned flags)\n+int bch2_btree_node_rewrite_key(struct btree_trans *trans,\n+\t\t\t\tenum btree_id btree, unsigned level,\n+\t\t\t\tstruct bkey_i *k, unsigned flags)\n {\n \tstruct btree_iter iter;\n \tbch2_trans_node_iter_init(trans, &iter,\n@@ -2367,9 +2368,8 @@ static void async_btree_node_rewrite_work(struct work_struct *work)\n \n \tint ret = bch2_trans_do(c, bch2_btree_node_rewrite_key(trans,\n \t\t\t\t\t\ta->btree_id, a->level, a->key.k, 0));\n-\tif (ret != -ENOENT &&\n-\t    !bch2_err_matches(ret, EROFS) &&\n-\t    ret != -BCH_ERR_journal_shutdown)\n+\tif (!bch2_err_matches(ret, ENOENT) &&\n+\t    !bch2_err_matches(ret, EROFS))\n \t\tbch_err_fn_ratelimited(c, ret);\n \n \tspin_lock(&c->btree_node_rewrites_lock);\ndiff --git a/fs/bcachefs/btree_update_interior.h b/fs/bcachefs/btree_update_interior.h\nindex b649c36c3fbb..ac04e45a8515 100644\n--- a/fs/bcachefs/btree_update_interior.h\n+++ b/fs/bcachefs/btree_update_interior.h\n@@ -176,6 +176,9 @@ static inline int bch2_foreground_maybe_merge(struct btree_trans *trans,\n \n int bch2_btree_node_rewrite(struct btree_trans *, struct btree_iter *,\n \t\t\t    struct btree *, unsigned, unsigned);\n+int bch2_btree_node_rewrite_key(struct btree_trans *,\n+\t\t\t\tenum btree_id, unsigned,\n+\t\t\t\tstruct bkey_i *, unsigned);\n int bch2_btree_node_rewrite_pos(struct btree_trans *,\n \t\t\t\tenum btree_id, unsigned,\n \t\t\t\tstruct bpos, unsigned, unsigned);\ndiff --git a/fs/bcachefs/btree_write_buffer.c b/fs/bcachefs/btree_write_buffer.c\nindex 90b21e61d2b6..4b095235a0d2 100644\n--- a/fs/bcachefs/btree_write_buffer.c\n+++ b/fs/bcachefs/btree_write_buffer.c\n@@ -267,10 +267,9 @@ static void move_keys_from_inc_to_flushing(struct btree_write_buffer *wb)\n \tBUG_ON(wb->sorted.size < wb->flushing.keys.nr);\n }\n \n-int bch2_btree_write_buffer_insert_err(struct btree_trans *trans,\n+int bch2_btree_write_buffer_insert_err(struct bch_fs *c,\n \t\t\t\t       enum btree_id btree, struct bkey_i *k)\n {\n-\tstruct bch_fs *c = trans->c;\n \tstruct printbuf buf = PRINTBUF;\n \n \tprt_printf(&buf, \"attempting to do write buffer update on non wb btree=\");\n@@ -332,7 +331,7 @@ static int bch2_btree_write_buffer_flush_locked(struct btree_trans *trans)\n \t\tstruct btree_write_buffered_key *k = &wb->flushing.keys.data[i->idx];\n \n \t\tif (unlikely(!btree_type_uses_write_buffer(k->btree))) {\n-\t\t\tret = bch2_btree_write_buffer_insert_err(trans, k->btree, &k->k);\n+\t\t\tret = bch2_btree_write_buffer_insert_err(trans->c, k->btree, &k->k);\n \t\t\tgoto err;\n \t\t}\n \n@@ -676,6 +675,9 @@ int bch2_btree_write_buffer_maybe_flush(struct btree_trans *trans,\n \t\t\tgoto err;\n \n \t\tbch2_bkey_buf_copy(last_flushed, c, tmp.k);\n+\n+\t\t/* can we avoid the unconditional restart? */\n+\t\ttrace_and_count(c, trans_restart_write_buffer_flush, trans, _RET_IP_);\n \t\tret = bch_err_throw(c, transaction_restart_write_buffer_flush);\n \t}\n err:\ndiff --git a/fs/bcachefs/btree_write_buffer.h b/fs/bcachefs/btree_write_buffer.h\nindex 05f56fd1eed0..c351d21aca0b 100644\n--- a/fs/bcachefs/btree_write_buffer.h\n+++ b/fs/bcachefs/btree_write_buffer.h\n@@ -89,6 +89,12 @@ static inline int bch2_journal_key_to_wb(struct bch_fs *c,\n \t\t\t     struct journal_keys_to_wb *dst,\n \t\t\t     enum btree_id btree, struct bkey_i *k)\n {\n+\tif (unlikely(!btree_type_uses_write_buffer(btree))) {\n+\t\tint ret = bch2_btree_write_buffer_insert_err(c, btree, k);\n+\t\tdump_stack();\n+\t\treturn ret;\n+\t}\n+\n \tEBUG_ON(!dst->seq);\n \n \treturn k->k.type == KEY_TYPE_accounting\ndiff --git a/fs/bcachefs/chardev.c b/fs/bcachefs/chardev.c\nindex fde3c2380e28..5ea89aa2b0c4 100644\n--- a/fs/bcachefs/chardev.c\n+++ b/fs/bcachefs/chardev.c\n@@ -319,6 +319,7 @@ static int bch2_data_thread(void *arg)\n \t\tctx->stats.ret = BCH_IOCTL_DATA_EVENT_RET_done;\n \t\tctx->stats.data_type = (int) DATA_PROGRESS_DATA_TYPE_done;\n \t}\n+\tenumerated_ref_put(&ctx->c->writes, BCH_WRITE_REF_ioctl_data);\n \treturn 0;\n }\n \n@@ -378,15 +379,24 @@ static long bch2_ioctl_data(struct bch_fs *c,\n \tstruct bch_data_ctx *ctx;\n \tint ret;\n \n-\tif (!capable(CAP_SYS_ADMIN))\n-\t\treturn -EPERM;\n+\tif (!enumerated_ref_tryget(&c->writes, BCH_WRITE_REF_ioctl_data))\n+\t\treturn -EROFS;\n \n-\tif (arg.op >= BCH_DATA_OP_NR || arg.flags)\n-\t\treturn -EINVAL;\n+\tif (!capable(CAP_SYS_ADMIN)) {\n+\t\tret = -EPERM;\n+\t\tgoto put_ref;\n+\t}\n+\n+\tif (arg.op >= BCH_DATA_OP_NR || arg.flags) {\n+\t\tret = -EINVAL;\n+\t\tgoto put_ref;\n+\t}\n \n \tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n-\tif (!ctx)\n-\t\treturn -ENOMEM;\n+\tif (!ctx) {\n+\t\tret = -ENOMEM;\n+\t\tgoto put_ref;\n+\t}\n \n \tctx->c = c;\n \tctx->arg = arg;\n@@ -395,7 +405,12 @@ static long bch2_ioctl_data(struct bch_fs *c,\n \t\t\t&bcachefs_data_ops,\n \t\t\tbch2_data_thread);\n \tif (ret < 0)\n-\t\tkfree(ctx);\n+\t\tgoto cleanup;\n+\treturn ret;\n+cleanup:\n+\tkfree(ctx);\n+put_ref:\n+\tenumerated_ref_put(&c->writes, BCH_WRITE_REF_ioctl_data);\n \treturn ret;\n }\n \ndiff --git a/fs/bcachefs/data_update.c b/fs/bcachefs/data_update.c\nindex 5f1174348974..e848e210a9bf 100644\n--- a/fs/bcachefs/data_update.c\n+++ b/fs/bcachefs/data_update.c\n@@ -249,6 +249,7 @@ static int data_update_invalid_bkey(struct data_update *m,\n \tbch2_bkey_val_to_text(&buf, c, k);\n \tprt_str(&buf, \"\\nnew: \");\n \tbch2_bkey_val_to_text(&buf, c, bkey_i_to_s_c(insert));\n+\tprt_newline(&buf);\n \n \tbch2_fs_emergency_read_only2(c, &buf);\n \ndiff --git a/fs/bcachefs/errcode.h b/fs/bcachefs/errcode.h\nindex ac3264134a15..86a842f1e88e 100644\n--- a/fs/bcachefs/errcode.h\n+++ b/fs/bcachefs/errcode.h\n@@ -137,7 +137,6 @@\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_relock)\t\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_relock_path)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_relock_path_intent)\t\\\n-\tx(BCH_ERR_transaction_restart,\ttransaction_restart_relock_after_fill)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_too_many_iters)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_lock_node_reused)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_fill_relock)\t\\\n@@ -148,11 +147,8 @@\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_would_deadlock_write)\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_deadlock_recursion_limit)\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_upgrade)\t\t\\\n-\tx(BCH_ERR_transaction_restart,\ttransaction_restart_key_cache_upgrade)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_key_cache_fill)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_key_cache_raced)\t\\\n-\tx(BCH_ERR_transaction_restart,\ttransaction_restart_key_cache_realloced)\\\n-\tx(BCH_ERR_transaction_restart,\ttransaction_restart_journal_preres_get)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_split_race)\t\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_write_buffer_flush)\t\\\n \tx(BCH_ERR_transaction_restart,\ttransaction_restart_nested)\t\t\\\n@@ -241,7 +237,6 @@\n \tx(BCH_ERR_journal_res_blocked,\tjournal_buf_enomem)\t\t\t\\\n \tx(BCH_ERR_journal_res_blocked,\tjournal_stuck)\t\t\t\t\\\n \tx(BCH_ERR_journal_res_blocked,\tjournal_retry_open)\t\t\t\\\n-\tx(BCH_ERR_journal_res_blocked,\tjournal_preres_get_blocked)\t\t\\\n \tx(BCH_ERR_journal_res_blocked,\tbucket_alloc_blocked)\t\t\t\\\n \tx(BCH_ERR_journal_res_blocked,\tstripe_alloc_blocked)\t\t\t\\\n \tx(BCH_ERR_invalid,\t\tinvalid_sb)\t\t\t\t\\\ndiff --git a/fs/bcachefs/error.c b/fs/bcachefs/error.c\nindex a8ec6aae5738..b2a6c041e165 100644\n--- a/fs/bcachefs/error.c\n+++ b/fs/bcachefs/error.c\n@@ -621,7 +621,9 @@ int __bch2_fsck_err(struct bch_fs *c,\n \tif (s)\n \t\ts->ret = ret;\n \n-\tif (trans)\n+\tif (trans &&\n+\t    !(flags & FSCK_ERR_NO_LOG) &&\n+\t    ret == -BCH_ERR_fsck_fix)\n \t\tret = bch2_trans_log_str(trans, bch2_sb_error_strs[err]) ?: ret;\n err_unlock:\n \tmutex_unlock(&c->fsck_error_msgs_lock);\ndiff --git a/fs/bcachefs/extent_update.c b/fs/bcachefs/extent_update.c\nindex b899ee75f5b9..e76e58a568bf 100644\n--- a/fs/bcachefs/extent_update.c\n+++ b/fs/bcachefs/extent_update.c\n@@ -139,6 +139,17 @@ int bch2_extent_trim_atomic(struct btree_trans *trans,\n \tif (ret)\n \t\treturn ret;\n \n-\tbch2_cut_back(end, k);\n+\t/* tracepoint */\n+\n+\tif (bpos_lt(end, k->k.p)) {\n+\t\tif (trace_extent_trim_atomic_enabled()) {\n+\t\t\tCLASS(printbuf, buf)();\n+\t\t\tbch2_bpos_to_text(&buf, end);\n+\t\t\tprt_newline(&buf);\n+\t\t\tbch2_bkey_val_to_text(&buf, trans->c, bkey_i_to_s_c(k));\n+\t\t\ttrace_extent_trim_atomic(trans->c, buf.buf);\n+\t\t}\n+\t\tbch2_cut_back(end, k);\n+\t}\n \treturn 0;\n }\ndiff --git a/fs/bcachefs/fs.c b/fs/bcachefs/fs.c\nindex 3063a8ddc2df..db24a76563f8 100644\n--- a/fs/bcachefs/fs.c\n+++ b/fs/bcachefs/fs.c\n@@ -1732,7 +1732,8 @@ static int bch2_fileattr_set(struct mnt_idmap *idmap,\n \t\tbch2_write_inode(c, inode, fssetxattr_inode_update_fn, &s,\n \t\t\t       ATTR_CTIME);\n \tmutex_unlock(&inode->ei_update_lock);\n-\treturn ret;\n+\n+\treturn bch2_err_class(ret);\n }\n \n static const struct file_operations bch_file_operations = {\ndiff --git a/fs/bcachefs/fsck.c b/fs/bcachefs/fsck.c\nindex 68ed69a255e1..9920f1affc5b 100644\n--- a/fs/bcachefs/fsck.c\n+++ b/fs/bcachefs/fsck.c\n@@ -327,7 +327,8 @@ static inline bool inode_should_reattach(struct bch_inode_unpacked *inode)\n \t    (inode->bi_flags & BCH_INODE_has_child_snapshot))\n \t\treturn false;\n \n-\treturn !inode->bi_dir && !(inode->bi_flags & BCH_INODE_unlinked);\n+\treturn !bch2_inode_has_backpointer(inode) &&\n+\t\t!(inode->bi_flags & BCH_INODE_unlinked);\n }\n \n static int maybe_delete_dirent(struct btree_trans *trans, struct bpos d_pos, u32 snapshot)\n@@ -372,6 +373,18 @@ static int reattach_inode(struct btree_trans *trans, struct bch_inode_unpacked *\n \tif (inode->bi_subvol) {\n \t\tinode->bi_parent_subvol = BCACHEFS_ROOT_SUBVOL;\n \n+\t\tstruct btree_iter subvol_iter;\n+\t\tstruct bkey_i_subvolume *subvol =\n+\t\t\tbch2_bkey_get_mut_typed(trans, &subvol_iter,\n+\t\t\t\t\t\tBTREE_ID_subvolumes, POS(0, inode->bi_subvol),\n+\t\t\t\t\t\t0, subvolume);\n+\t\tret = PTR_ERR_OR_ZERO(subvol);\n+\t\tif (ret)\n+\t\t\treturn ret;\n+\n+\t\tsubvol->v.fs_path_parent = BCACHEFS_ROOT_SUBVOL;\n+\t\tbch2_trans_iter_exit(trans, &subvol_iter);\n+\n \t\tu64 root_inum;\n \t\tret = subvol_lookup(trans, inode->bi_parent_subvol,\n \t\t\t\t    &dirent_snapshot, &root_inum);\n@@ -387,6 +400,8 @@ static int reattach_inode(struct btree_trans *trans, struct bch_inode_unpacked *\n \tif (ret)\n \t\treturn ret;\n \n+\tbch_verbose(c, \"got lostfound inum %llu\", lostfound.bi_inum);\n+\n \tlostfound.bi_nlink += S_ISDIR(inode->bi_mode);\n \n \t/* ensure lost+found inode is also present in inode snapshot */\n@@ -423,6 +438,16 @@ static int reattach_inode(struct btree_trans *trans, struct bch_inode_unpacked *\n \tif (ret)\n \t\treturn ret;\n \n+\t{\n+\t\tCLASS(printbuf, buf)();\n+\t\tret = bch2_inum_snapshot_to_path(trans, inode->bi_inum,\n+\t\t\t\t\t\t inode->bi_snapshot, NULL, &buf);\n+\t\tif (ret)\n+\t\t\treturn ret;\n+\n+\t\tbch_info(c, \"reattached at %s\", buf.buf);\n+\t}\n+\n \t/*\n \t * Fix up inodes in child snapshots: if they should also be reattached\n \t * update the backpointer field, if they should not be we need to emit\n@@ -490,13 +515,21 @@ static struct bkey_s_c_dirent dirent_get_by_pos(struct btree_trans *trans,\n static int remove_backpointer(struct btree_trans *trans,\n \t\t\t      struct bch_inode_unpacked *inode)\n {\n-\tif (!inode->bi_dir)\n+\tif (!bch2_inode_has_backpointer(inode))\n \t\treturn 0;\n \n+\tu32 snapshot = inode->bi_snapshot;\n+\n+\tif (inode->bi_parent_subvol) {\n+\t\tint ret = bch2_subvolume_get_snapshot(trans, inode->bi_parent_subvol, &snapshot);\n+\t\tif (ret)\n+\t\t\treturn ret;\n+\t}\n+\n \tstruct bch_fs *c = trans->c;\n \tstruct btree_iter iter;\n \tstruct bkey_s_c_dirent d = dirent_get_by_pos(trans, &iter,\n-\t\t\t\t     SPOS(inode->bi_dir, inode->bi_dir_offset, inode->bi_snapshot));\n+\t\t\t\t     SPOS(inode->bi_dir, inode->bi_dir_offset, snapshot));\n \tint ret = bkey_err(d) ?:\n \t\t  dirent_points_to_inode(c, d, inode) ?:\n \t\t  bch2_fsck_remove_dirent(trans, d.k->p);\n@@ -695,14 +728,8 @@ static int snapshots_seen_update(struct bch_fs *c, struct snapshots_seen *s,\n static bool key_visible_in_snapshot(struct bch_fs *c, struct snapshots_seen *seen,\n \t\t\t\t    u32 id, u32 ancestor)\n {\n-\tssize_t i;\n-\n \tEBUG_ON(id > ancestor);\n \n-\t/* @ancestor should be the snapshot most recently added to @seen */\n-\tEBUG_ON(ancestor != seen->pos.snapshot);\n-\tEBUG_ON(ancestor != darray_last(seen->ids));\n-\n \tif (id == ancestor)\n \t\treturn true;\n \n@@ -718,11 +745,8 @@ static bool key_visible_in_snapshot(struct bch_fs *c, struct snapshots_seen *see\n \t * numerically, since snapshot ID lists are kept sorted, so if we find\n \t * an id that's an ancestor of @id we're done:\n \t */\n-\n-\tfor (i = seen->ids.nr - 2;\n-\t     i >= 0 && seen->ids.data[i] >= id;\n-\t     --i)\n-\t\tif (bch2_snapshot_is_ancestor(c, id, seen->ids.data[i]))\n+\tdarray_for_each_reverse(seen->ids, i)\n+\t\tif (*i != ancestor && bch2_snapshot_is_ancestor(c, id, *i))\n \t\t\treturn false;\n \n \treturn true;\n@@ -806,7 +830,7 @@ static int add_inode(struct bch_fs *c, struct inode_walker *w,\n \tif (!n->whiteout) {\n \t\treturn bch2_inode_unpack(inode, &n->inode);\n \t} else {\n-\t\tn->inode.bi_inum\t= inode.k->p.inode;\n+\t\tn->inode.bi_inum\t= inode.k->p.offset;\n \t\tn->inode.bi_snapshot\t= inode.k->p.snapshot;\n \t\treturn 0;\n \t}\n@@ -903,17 +927,15 @@ lookup_inode_for_snapshot(struct btree_trans *trans, struct inode_walker *w, str\n \t\t\t w->last_pos.inode, k.k->p.snapshot, i->inode.bi_snapshot,\n \t\t\t (bch2_bkey_val_to_text(&buf, c, k),\n \t\t\t  buf.buf))) {\n-\t\tstruct bch_inode_unpacked new = i->inode;\n-\t\tstruct bkey_i whiteout;\n-\n-\t\tnew.bi_snapshot = k.k->p.snapshot;\n-\n \t\tif (!i->whiteout) {\n+\t\t\tstruct bch_inode_unpacked new = i->inode;\n+\t\t\tnew.bi_snapshot = k.k->p.snapshot;\n \t\t\tret = __bch2_fsck_write_inode(trans, &new);\n \t\t} else {\n+\t\t\tstruct bkey_i whiteout;\n \t\t\tbkey_init(&whiteout.k);\n \t\t\twhiteout.k.type = KEY_TYPE_whiteout;\n-\t\t\twhiteout.k.p = SPOS(0, i->inode.bi_inum, i->inode.bi_snapshot);\n+\t\t\twhiteout.k.p = SPOS(0, i->inode.bi_inum, k.k->p.snapshot);\n \t\t\tret = bch2_btree_insert_nonextent(trans, BTREE_ID_inodes,\n \t\t\t\t\t\t\t  &whiteout,\n \t\t\t\t\t\t\t  BTREE_UPDATE_internal_snapshot_node);\n@@ -1135,13 +1157,14 @@ static int check_inode(struct btree_trans *trans,\n \tif (ret)\n \t\tgoto err;\n \n-\tif (u.bi_dir || u.bi_dir_offset) {\n+\tif (bch2_inode_has_backpointer(&u)) {\n \t\tret = check_inode_dirent_inode(trans, &u, &do_update);\n \t\tif (ret)\n \t\t\tgoto err;\n \t}\n \n-\tif (fsck_err_on(u.bi_dir && (u.bi_flags & BCH_INODE_unlinked),\n+\tif (fsck_err_on(bch2_inode_has_backpointer(&u) &&\n+\t\t\t(u.bi_flags & BCH_INODE_unlinked),\n \t\t\ttrans, inode_unlinked_but_has_dirent,\n \t\t\t\"inode unlinked but has dirent\\n%s\",\n \t\t\t(printbuf_reset(&buf),\n@@ -1438,6 +1461,7 @@ static int check_key_has_inode(struct btree_trans *trans,\n {\n \tstruct bch_fs *c = trans->c;\n \tstruct printbuf buf = PRINTBUF;\n+\tstruct btree_iter iter2 = {};\n \tint ret = PTR_ERR_OR_ZERO(i);\n \tif (ret)\n \t\treturn ret;\n@@ -1447,40 +1471,105 @@ static int check_key_has_inode(struct btree_trans *trans,\n \n \tbool have_inode = i && !i->whiteout;\n \n-\tif (!have_inode && (c->sb.btrees_lost_data & BIT_ULL(BTREE_ID_inodes))) {\n-\t\tret =   reconstruct_inode(trans, iter->btree_id, k.k->p.snapshot, k.k->p.inode) ?:\n-\t\t\tbch2_trans_commit(trans, NULL, NULL, BCH_TRANS_COMMIT_no_enospc);\n-\t\tif (ret)\n-\t\t\tgoto err;\n+\tif (!have_inode && (c->sb.btrees_lost_data & BIT_ULL(BTREE_ID_inodes)))\n+\t\tgoto reconstruct;\n \n-\t\tinode->last_pos.inode--;\n-\t\tret = bch_err_throw(c, transaction_restart_nested);\n-\t\tgoto err;\n+\tif (have_inode && btree_matches_i_mode(iter->btree_id, i->inode.bi_mode))\n+\t\tgoto out;\n+\n+\tprt_printf(&buf, \", \");\n+\n+\tbool have_old_inode = false;\n+\tdarray_for_each(inode->inodes, i2)\n+\t\tif (!i2->whiteout &&\n+\t\t    bch2_snapshot_is_ancestor(c, k.k->p.snapshot, i2->inode.bi_snapshot) &&\n+\t\t    btree_matches_i_mode(iter->btree_id, i2->inode.bi_mode)) {\n+\t\t\tprt_printf(&buf, \"but found good inode in older snapshot\\n\");\n+\t\t\tbch2_inode_unpacked_to_text(&buf, &i2->inode);\n+\t\t\tprt_newline(&buf);\n+\t\t\thave_old_inode = true;\n+\t\t\tbreak;\n+\t\t}\n+\n+\tstruct bkey_s_c k2;\n+\tunsigned nr_keys = 0;\n+\n+\tprt_printf(&buf, \"found keys:\\n\");\n+\n+\tfor_each_btree_key_max_norestart(trans, iter2, iter->btree_id,\n+\t\t\t\t\t SPOS(k.k->p.inode, 0, k.k->p.snapshot),\n+\t\t\t\t\t POS(k.k->p.inode, U64_MAX),\n+\t\t\t\t\t 0, k2, ret) {\n+\t\tnr_keys++;\n+\t\tif (nr_keys <= 10) {\n+\t\t\tbch2_bkey_val_to_text(&buf, c, k2);\n+\t\t\tprt_newline(&buf);\n+\t\t}\n+\t\tif (nr_keys >= 100)\n+\t\t\tbreak;\n \t}\n \n-\tif (fsck_err_on(!have_inode,\n-\t\t\ttrans, key_in_missing_inode,\n-\t\t\t\"key in missing inode:\\n%s\",\n-\t\t\t(printbuf_reset(&buf),\n-\t\t\t bch2_bkey_val_to_text(&buf, c, k), buf.buf)))\n-\t\tgoto delete;\n+\tif (ret)\n+\t\tgoto err;\n \n-\tif (fsck_err_on(have_inode && !btree_matches_i_mode(iter->btree_id, i->inode.bi_mode),\n-\t\t\ttrans, key_in_wrong_inode_type,\n-\t\t\t\"key for wrong inode mode %o:\\n%s\",\n-\t\t\ti->inode.bi_mode,\n-\t\t\t(printbuf_reset(&buf),\n-\t\t\t bch2_bkey_val_to_text(&buf, c, k), buf.buf)))\n-\t\tgoto delete;\n+\tif (nr_keys > 100)\n+\t\tprt_printf(&buf, \"found > %u keys for this missing inode\\n\", nr_keys);\n+\telse if (nr_keys > 10)\n+\t\tprt_printf(&buf, \"found %u keys for this missing inode\\n\", nr_keys);\n+\n+\tif (!have_inode) {\n+\t\tif (fsck_err_on(!have_inode,\n+\t\t\t\ttrans, key_in_missing_inode,\n+\t\t\t\t\"key in missing inode%s\", buf.buf)) {\n+\t\t\t/*\n+\t\t\t * Maybe a deletion that raced with data move, or something\n+\t\t\t * weird like that? But if we know the inode was deleted, or\n+\t\t\t * it's just a few keys, we can safely delete them.\n+\t\t\t *\n+\t\t\t * If it's many keys, we should probably recreate the inode\n+\t\t\t */\n+\t\t\tif (have_old_inode || nr_keys <= 2)\n+\t\t\t\tgoto delete;\n+\t\t\telse\n+\t\t\t\tgoto reconstruct;\n+\t\t}\n+\t} else {\n+\t\t/*\n+\t\t * not autofix, this one would be a giant wtf - bit error in the\n+\t\t * inode corrupting i_mode?\n+\t\t *\n+\t\t * may want to try repairing inode instead of deleting\n+\t\t */\n+\t\tif (fsck_err_on(!btree_matches_i_mode(iter->btree_id, i->inode.bi_mode),\n+\t\t\t\ttrans, key_in_wrong_inode_type,\n+\t\t\t\t\"key for wrong inode mode %o%s\",\n+\t\t\t\ti->inode.bi_mode, buf.buf))\n+\t\t\tgoto delete;\n+\t}\n out:\n err:\n fsck_err:\n+\tbch2_trans_iter_exit(trans, &iter2);\n \tprintbuf_exit(&buf);\n \tbch_err_fn(c, ret);\n \treturn ret;\n delete:\n+\t/*\n+\t * XXX: print out more info\n+\t * count up extents for this inode, check if we have different inode in\n+\t * an older snapshot version, perhaps decide if we want to reconstitute\n+\t */\n \tret = bch2_btree_delete_at(trans, iter, BTREE_UPDATE_internal_snapshot_node);\n \tgoto out;\n+reconstruct:\n+\tret =   reconstruct_inode(trans, iter->btree_id, k.k->p.snapshot, k.k->p.inode) ?:\n+\t\tbch2_trans_commit(trans, NULL, NULL, BCH_TRANS_COMMIT_no_enospc);\n+\tif (ret)\n+\t\tgoto err;\n+\n+\tinode->last_pos.inode--;\n+\tret = bch_err_throw(c, transaction_restart_nested);\n+\tgoto out;\n }\n \n static int check_i_sectors_notnested(struct btree_trans *trans, struct inode_walker *w)\n@@ -1822,18 +1911,39 @@ static int check_extent(struct btree_trans *trans, struct btree_iter *iter,\n \t\t\t    !key_visible_in_snapshot(c, s, i->inode.bi_snapshot, k.k->p.snapshot))\n \t\t\t\tcontinue;\n \n-\t\t\tif (fsck_err_on(k.k->p.offset > round_up(i->inode.bi_size, block_bytes(c)) >> 9 &&\n+\t\t\tu64 last_block = round_up(i->inode.bi_size, block_bytes(c)) >> 9;\n+\n+\t\t\tif (fsck_err_on(k.k->p.offset > last_block &&\n \t\t\t\t\t!bkey_extent_is_reservation(k),\n \t\t\t\t\ttrans, extent_past_end_of_inode,\n \t\t\t\t\t\"extent type past end of inode %llu:%u, i_size %llu\\n%s\",\n \t\t\t\t\ti->inode.bi_inum, i->inode.bi_snapshot, i->inode.bi_size,\n \t\t\t\t\t(bch2_bkey_val_to_text(&buf, c, k), buf.buf))) {\n-\t\t\t\tstruct btree_iter iter2;\n+\t\t\t\tstruct bkey_i *whiteout = bch2_trans_kmalloc(trans, sizeof(*whiteout));\n+\t\t\t\tret = PTR_ERR_OR_ZERO(whiteout);\n+\t\t\t\tif (ret)\n+\t\t\t\t\tgoto err;\n+\n+\t\t\t\tbkey_init(&whiteout->k);\n+\t\t\t\twhiteout->k.p = SPOS(k.k->p.inode,\n+\t\t\t\t\t\t     last_block,\n+\t\t\t\t\t\t     i->inode.bi_snapshot);\n+\t\t\t\tbch2_key_resize(&whiteout->k,\n+\t\t\t\t\t\tmin(KEY_SIZE_MAX & (~0 << c->block_bits),\n+\t\t\t\t\t\t    U64_MAX - whiteout->k.p.offset));\n+\n \n-\t\t\t\tbch2_trans_copy_iter(trans, &iter2, iter);\n-\t\t\t\tbch2_btree_iter_set_snapshot(trans, &iter2, i->inode.bi_snapshot);\n+\t\t\t\t/*\n+\t\t\t\t * Need a normal (not BTREE_ITER_all_snapshots)\n+\t\t\t\t * iterator, if we're deleting in a different\n+\t\t\t\t * snapshot and need to emit a whiteout\n+\t\t\t\t */\n+\t\t\t\tstruct btree_iter iter2;\n+\t\t\t\tbch2_trans_iter_init(trans, &iter2, BTREE_ID_extents,\n+\t\t\t\t\t\t     bkey_start_pos(&whiteout->k),\n+\t\t\t\t\t\t     BTREE_ITER_intent);\n \t\t\t\tret =   bch2_btree_iter_traverse(trans, &iter2) ?:\n-\t\t\t\t\tbch2_btree_delete_at(trans, &iter2,\n+\t\t\t\t\tbch2_trans_update(trans, &iter2, whiteout,\n \t\t\t\t\t\tBTREE_UPDATE_internal_snapshot_node);\n \t\t\t\tbch2_trans_iter_exit(trans, &iter2);\n \t\t\t\tif (ret)\n@@ -1949,14 +2059,22 @@ static int check_subdir_count_notnested(struct btree_trans *trans, struct inode_\n \t\t\t\tcontinue;\n \t\t}\n \n-\t\tif (fsck_err_on(i->inode.bi_nlink != i->count,\n-\t\t\t\ttrans, inode_dir_wrong_nlink,\n-\t\t\t\t\"directory %llu:%u with wrong i_nlink: got %u, should be %llu\",\n-\t\t\t\tw->last_pos.inode, i->inode.bi_snapshot, i->inode.bi_nlink, i->count)) {\n-\t\t\ti->inode.bi_nlink = i->count;\n-\t\t\tret = bch2_fsck_write_inode(trans, &i->inode);\n-\t\t\tif (ret)\n-\t\t\t\tbreak;\n+\t\tif (i->inode.bi_nlink != i->count) {\n+\t\t\tCLASS(printbuf, buf)();\n+\n+\t\t\tlockrestart_do(trans,\n+\t\t\t\t       bch2_inum_snapshot_to_path(trans, w->last_pos.inode,\n+\t\t\t\t\t\t\t\t  i->inode.bi_snapshot, NULL, &buf));\n+\n+\t\t\tif (fsck_err_on(i->inode.bi_nlink != i->count,\n+\t\t\t\t\ttrans, inode_dir_wrong_nlink,\n+\t\t\t\t\t\"directory with wrong i_nlink: got %u, should be %llu\\n%s\",\n+\t\t\t\t\ti->inode.bi_nlink, i->count, buf.buf)) {\n+\t\t\t\ti->inode.bi_nlink = i->count;\n+\t\t\t\tret = bch2_fsck_write_inode(trans, &i->inode);\n+\t\t\t\tif (ret)\n+\t\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t}\n fsck_err:\n@@ -2493,6 +2611,11 @@ static int check_subvol_path(struct btree_trans *trans, struct btree_iter *iter,\n \tif (k.k->type != KEY_TYPE_subvolume)\n \t\treturn 0;\n \n+\tsubvol_inum start = {\n+\t\t.subvol = k.k->p.offset,\n+\t\t.inum\t= le64_to_cpu(bkey_s_c_to_subvolume(k).v->inode),\n+\t};\n+\n \twhile (k.k->p.offset != BCACHEFS_ROOT_SUBVOL) {\n \t\tret = darray_push(&subvol_path, k.k->p.offset);\n \t\tif (ret)\n@@ -2511,11 +2634,11 @@ static int check_subvol_path(struct btree_trans *trans, struct btree_iter *iter,\n \n \t\tif (darray_u32_has(&subvol_path, parent)) {\n \t\t\tprintbuf_reset(&buf);\n-\t\t\tprt_printf(&buf, \"subvolume loop:\\n\");\n+\t\t\tprt_printf(&buf, \"subvolume loop: \");\n \n-\t\t\tdarray_for_each_reverse(subvol_path, i)\n-\t\t\t\tprt_printf(&buf, \"%u \", *i);\n-\t\t\tprt_printf(&buf, \"%u\", parent);\n+\t\t\tret = bch2_inum_to_path(trans, start, &buf);\n+\t\t\tif (ret)\n+\t\t\t\tgoto err;\n \n \t\t\tif (fsck_err(trans, subvol_loop, \"%s\", buf.buf))\n \t\t\t\tret = reattach_subvol(trans, s);\n@@ -2559,19 +2682,13 @@ int bch2_check_subvolume_structure(struct bch_fs *c)\n \treturn ret;\n }\n \n-struct pathbuf_entry {\n-\tu64\tinum;\n-\tu32\tsnapshot;\n-};\n-\n-typedef DARRAY(struct pathbuf_entry) pathbuf;\n-\n-static int bch2_bi_depth_renumber_one(struct btree_trans *trans, struct pathbuf_entry *p,\n+static int bch2_bi_depth_renumber_one(struct btree_trans *trans,\n+\t\t\t\t      u64 inum, u32 snapshot,\n \t\t\t\t      u32 new_depth)\n {\n \tstruct btree_iter iter;\n \tstruct bkey_s_c k = bch2_bkey_get_iter(trans, &iter, BTREE_ID_inodes,\n-\t\t\t\t\t       SPOS(0, p->inum, p->snapshot), 0);\n+\t\t\t\t\t       SPOS(0, inum, snapshot), 0);\n \n \tstruct bch_inode_unpacked inode;\n \tint ret = bkey_err(k) ?:\n@@ -2590,14 +2707,15 @@ static int bch2_bi_depth_renumber_one(struct btree_trans *trans, struct pathbuf_\n \treturn ret;\n }\n \n-static int bch2_bi_depth_renumber(struct btree_trans *trans, pathbuf *path, u32 new_bi_depth)\n+static int bch2_bi_depth_renumber(struct btree_trans *trans, darray_u64 *path,\n+\t\t\t\t  u32 snapshot, u32 new_bi_depth)\n {\n \tu32 restart_count = trans->restart_count;\n \tint ret = 0;\n \n \tdarray_for_each_reverse(*path, i) {\n \t\tret = nested_lockrestart_do(trans,\n-\t\t\t\tbch2_bi_depth_renumber_one(trans, i, new_bi_depth));\n+\t\t\t\tbch2_bi_depth_renumber_one(trans, *i, snapshot, new_bi_depth));\n \t\tbch_err_fn(trans->c, ret);\n \t\tif (ret)\n \t\t\tbreak;\n@@ -2608,37 +2726,36 @@ static int bch2_bi_depth_renumber(struct btree_trans *trans, pathbuf *path, u32\n \treturn ret ?: trans_was_restarted(trans, restart_count);\n }\n \n-static bool path_is_dup(pathbuf *p, u64 inum, u32 snapshot)\n-{\n-\tdarray_for_each(*p, i)\n-\t\tif (i->inum\t== inum &&\n-\t\t    i->snapshot\t== snapshot)\n-\t\t\treturn true;\n-\treturn false;\n-}\n-\n static int check_path_loop(struct btree_trans *trans, struct bkey_s_c inode_k)\n {\n \tstruct bch_fs *c = trans->c;\n \tstruct btree_iter inode_iter = {};\n-\tpathbuf path = {};\n+\tdarray_u64 path = {};\n \tstruct printbuf buf = PRINTBUF;\n \tu32 snapshot = inode_k.k->p.snapshot;\n \tbool redo_bi_depth = false;\n \tu32 min_bi_depth = U32_MAX;\n \tint ret = 0;\n \n+\tstruct bpos start = inode_k.k->p;\n+\n \tstruct bch_inode_unpacked inode;\n \tret = bch2_inode_unpack(inode_k, &inode);\n \tif (ret)\n \t\treturn ret;\n \n-\twhile (!inode.bi_subvol) {\n+\t/*\n+\t * If we're running full fsck, check_dirents() will have already ran,\n+\t * and we shouldn't see any missing backpointers here - otherwise that's\n+\t * handled separately, by check_unreachable_inodes\n+\t */\n+\twhile (!inode.bi_subvol &&\n+\t       bch2_inode_has_backpointer(&inode)) {\n \t\tstruct btree_iter dirent_iter;\n \t\tstruct bkey_s_c_dirent d;\n-\t\tu32 parent_snapshot = snapshot;\n \n-\t\td = inode_get_dirent(trans, &dirent_iter, &inode, &parent_snapshot);\n+\t\td = dirent_get_by_pos(trans, &dirent_iter,\n+\t\t\t\t      SPOS(inode.bi_dir, inode.bi_dir_offset, snapshot));\n \t\tret = bkey_err(d.s_c);\n \t\tif (ret && !bch2_err_matches(ret, ENOENT))\n \t\t\tgoto out;\n@@ -2656,15 +2773,10 @@ static int check_path_loop(struct btree_trans *trans, struct bkey_s_c inode_k)\n \n \t\tbch2_trans_iter_exit(trans, &dirent_iter);\n \n-\t\tret = darray_push(&path, ((struct pathbuf_entry) {\n-\t\t\t.inum\t\t= inode.bi_inum,\n-\t\t\t.snapshot\t= snapshot,\n-\t\t}));\n+\t\tret = darray_push(&path, inode.bi_inum);\n \t\tif (ret)\n \t\t\treturn ret;\n \n-\t\tsnapshot = parent_snapshot;\n-\n \t\tbch2_trans_iter_exit(trans, &inode_iter);\n \t\tinode_k = bch2_bkey_get_iter(trans, &inode_iter, BTREE_ID_inodes,\n \t\t\t\t\t     SPOS(0, inode.bi_dir, snapshot), 0);\n@@ -2686,15 +2798,22 @@ static int check_path_loop(struct btree_trans *trans, struct bkey_s_c inode_k)\n \t\t\tbreak;\n \n \t\tinode = parent_inode;\n-\t\tsnapshot = inode_k.k->p.snapshot;\n \t\tredo_bi_depth = true;\n \n-\t\tif (path_is_dup(&path, inode.bi_inum, snapshot)) {\n+\t\tif (darray_find(path, inode.bi_inum)) {\n \t\t\tprintbuf_reset(&buf);\n-\t\t\tprt_printf(&buf, \"directory structure loop:\\n\");\n-\t\t\tdarray_for_each_reverse(path, i)\n-\t\t\t\tprt_printf(&buf, \"%llu:%u \", i->inum, i->snapshot);\n-\t\t\tprt_printf(&buf, \"%llu:%u\", inode.bi_inum, snapshot);\n+\t\t\tprt_printf(&buf, \"directory structure loop in snapshot %u: \",\n+\t\t\t\t   snapshot);\n+\n+\t\t\tret = bch2_inum_snapshot_to_path(trans, start.offset, start.snapshot, NULL, &buf);\n+\t\t\tif (ret)\n+\t\t\t\tgoto out;\n+\n+\t\t\tif (c->opts.verbose) {\n+\t\t\t\tprt_newline(&buf);\n+\t\t\t\tdarray_for_each(path, i)\n+\t\t\t\t\tprt_printf(&buf, \"%llu \", *i);\n+\t\t\t}\n \n \t\t\tif (fsck_err(trans, dir_loop, \"%s\", buf.buf)) {\n \t\t\t\tret = remove_backpointer(trans, &inode);\n@@ -2714,7 +2833,7 @@ static int check_path_loop(struct btree_trans *trans, struct bkey_s_c inode_k)\n \t\tmin_bi_depth = 0;\n \n \tif (redo_bi_depth)\n-\t\tret = bch2_bi_depth_renumber(trans, &path, min_bi_depth);\n+\t\tret = bch2_bi_depth_renumber(trans, &path, snapshot, min_bi_depth);\n out:\n fsck_err:\n \tbch2_trans_iter_exit(trans, &inode_iter);\n@@ -2731,7 +2850,7 @@ static int check_path_loop(struct btree_trans *trans, struct bkey_s_c inode_k)\n int bch2_check_directory_structure(struct bch_fs *c)\n {\n \tint ret = bch2_trans_run(c,\n-\t\tfor_each_btree_key_commit(trans, iter, BTREE_ID_inodes, POS_MIN,\n+\t\tfor_each_btree_key_reverse_commit(trans, iter, BTREE_ID_inodes, POS_MIN,\n \t\t\t\t\t  BTREE_ITER_intent|\n \t\t\t\t\t  BTREE_ITER_prefetch|\n \t\t\t\t\t  BTREE_ITER_all_snapshots, k,\ndiff --git a/fs/bcachefs/inode.h b/fs/bcachefs/inode.h\nindex 82cec2836cbd..b8ec3e628d90 100644\n--- a/fs/bcachefs/inode.h\n+++ b/fs/bcachefs/inode.h\n@@ -254,6 +254,11 @@ static inline bool bch2_inode_casefold(struct bch_fs *c, const struct bch_inode_\n \t\t: c->opts.casefold;\n }\n \n+static inline bool bch2_inode_has_backpointer(const struct bch_inode_unpacked *bi)\n+{\n+\treturn bi->bi_dir || bi->bi_dir_offset;\n+}\n+\n /* i_nlink: */\n \n static inline unsigned nlink_bias(umode_t mode)\ndiff --git a/fs/bcachefs/io_read.c b/fs/bcachefs/io_read.c\nindex 04bbdcf58e40..cd184b219a65 100644\n--- a/fs/bcachefs/io_read.c\n+++ b/fs/bcachefs/io_read.c\n@@ -1491,7 +1491,12 @@ void bch2_read_bio_to_text(struct printbuf *out, struct bch_read_bio *rbio)\n \tprt_printf(out, \"have_ioref:\\t%u\\n\",\trbio->have_ioref);\n \tprt_printf(out, \"narrow_crcs:\\t%u\\n\",\trbio->narrow_crcs);\n \tprt_printf(out, \"context:\\t%u\\n\",\trbio->context);\n-\tprt_printf(out, \"ret:\\t%s\\n\",\t\tbch2_err_str(rbio->ret));\n+\n+\tint ret = READ_ONCE(rbio->ret);\n+\tif (ret < 0)\n+\t\tprt_printf(out, \"ret:\\t%s\\n\",\t\tbch2_err_str(ret));\n+\telse\n+\t\tprt_printf(out, \"ret:\\t%i\\n\",\t\tret);\n \n \tprt_printf(out, \"flags:\\t\");\n \tbch2_prt_bitflags(out, bch2_read_bio_flags, rbio->flags);\ndiff --git a/fs/bcachefs/journal.c b/fs/bcachefs/journal.c\nindex dda802a656cf..f22b05e02c1e 100644\n--- a/fs/bcachefs/journal.c\n+++ b/fs/bcachefs/journal.c\n@@ -1283,7 +1283,7 @@ static int bch2_set_nr_journal_buckets_loop(struct bch_fs *c, struct bch_dev *ca\n \t\t\tret = 0; /* wait and retry */\n \n \t\tbch2_disk_reservation_put(c, &disk_res);\n-\t\tclosure_sync(&cl);\n+\t\tbch2_wait_on_allocator(c, &cl);\n \t}\n \n \treturn ret;\n@@ -1474,14 +1474,13 @@ void bch2_fs_journal_stop(struct journal *j)\n \t\tclear_bit(JOURNAL_running, &j->flags);\n }\n \n-int bch2_fs_journal_start(struct journal *j, u64 cur_seq)\n+int bch2_fs_journal_start(struct journal *j, u64 last_seq, u64 cur_seq)\n {\n \tstruct bch_fs *c = container_of(j, struct bch_fs, journal);\n \tstruct journal_entry_pin_list *p;\n \tstruct journal_replay *i, **_i;\n \tstruct genradix_iter iter;\n \tbool had_entries = false;\n-\tu64 last_seq = cur_seq, nr, seq;\n \n \t/*\n \t *\n@@ -1495,17 +1494,11 @@ int bch2_fs_journal_start(struct journal *j, u64 cur_seq)\n \t\treturn -EINVAL;\n \t}\n \n-\tgenradix_for_each_reverse(&c->journal_entries, iter, _i) {\n-\t\ti = *_i;\n-\n-\t\tif (journal_replay_ignore(i))\n-\t\t\tcontinue;\n+\t/* Clean filesystem? */\n+\tif (!last_seq)\n+\t\tlast_seq = cur_seq;\n \n-\t\tlast_seq = le64_to_cpu(i->j.last_seq);\n-\t\tbreak;\n-\t}\n-\n-\tnr = cur_seq - last_seq;\n+\tu64 nr = cur_seq - last_seq;\n \n \t/*\n \t * Extra fudge factor, in case we crashed when the journal pin fifo was\n@@ -1532,6 +1525,7 @@ int bch2_fs_journal_start(struct journal *j, u64 cur_seq)\n \tj->pin.back\t\t= cur_seq;\n \tatomic64_set(&j->seq, cur_seq - 1);\n \n+\tu64 seq;\n \tfifo_for_each_entry_ptr(p, &j->pin, seq)\n \t\tjournal_pin_list_init(p, 1);\n \ndiff --git a/fs/bcachefs/journal.h b/fs/bcachefs/journal.h\nindex 83734fe4331f..977907038d98 100644\n--- a/fs/bcachefs/journal.h\n+++ b/fs/bcachefs/journal.h\n@@ -453,7 +453,7 @@ int bch2_fs_journal_alloc(struct bch_fs *);\n void bch2_dev_journal_stop(struct journal *, struct bch_dev *);\n \n void bch2_fs_journal_stop(struct journal *);\n-int bch2_fs_journal_start(struct journal *, u64);\n+int bch2_fs_journal_start(struct journal *, u64, u64);\n void bch2_journal_set_replay_done(struct journal *);\n \n void bch2_dev_journal_exit(struct bch_dev *);\ndiff --git a/fs/bcachefs/journal_io.c b/fs/bcachefs/journal_io.c\nindex 0b15d71a8d2d..dd3f3434c1b0 100644\n--- a/fs/bcachefs/journal_io.c\n+++ b/fs/bcachefs/journal_io.c\n@@ -160,6 +160,9 @@ static int journal_entry_add(struct bch_fs *c, struct bch_dev *ca,\n \tstruct printbuf buf = PRINTBUF;\n \tint ret = JOURNAL_ENTRY_ADD_OK;\n \n+\tif (last_seq && c->opts.journal_rewind)\n+\t\tlast_seq = min(last_seq, c->opts.journal_rewind);\n+\n \tif (!c->journal.oldest_seq_found_ondisk ||\n \t    le64_to_cpu(j->seq) < c->journal.oldest_seq_found_ondisk)\n \t\tc->journal.oldest_seq_found_ondisk = le64_to_cpu(j->seq);\n@@ -1430,11 +1433,21 @@ int bch2_journal_read(struct bch_fs *c,\n \tprintbuf_reset(&buf);\n \tprt_printf(&buf, \"journal read done, replaying entries %llu-%llu\",\n \t\t   *last_seq, *blacklist_seq - 1);\n+\n+\t/*\n+\t * Drop blacklisted entries and entries older than last_seq (or start of\n+\t * journal rewind:\n+\t */\n+\tu64 drop_before = *last_seq;\n+\tif (c->opts.journal_rewind) {\n+\t\tdrop_before = min(drop_before, c->opts.journal_rewind);\n+\t\tprt_printf(&buf, \" (rewinding from %llu)\", c->opts.journal_rewind);\n+\t}\n+\n+\t*last_seq = drop_before;\n \tif (*start_seq != *blacklist_seq)\n \t\tprt_printf(&buf, \" (unflushed %llu-%llu)\", *blacklist_seq, *start_seq - 1);\n \tbch_info(c, \"%s\", buf.buf);\n-\n-\t/* Drop blacklisted entries and entries older than last_seq: */\n \tgenradix_for_each(&c->journal_entries, radix_iter, _i) {\n \t\ti = *_i;\n \n@@ -1442,7 +1455,7 @@ int bch2_journal_read(struct bch_fs *c,\n \t\t\tcontinue;\n \n \t\tseq = le64_to_cpu(i->j.seq);\n-\t\tif (seq < *last_seq) {\n+\t\tif (seq < drop_before) {\n \t\t\tjournal_replay_free(c, i, false);\n \t\t\tcontinue;\n \t\t}\n@@ -1455,7 +1468,7 @@ int bch2_journal_read(struct bch_fs *c,\n \t\t}\n \t}\n \n-\tret = bch2_journal_check_for_missing(c, *last_seq, *blacklist_seq - 1);\n+\tret = bch2_journal_check_for_missing(c, drop_before, *blacklist_seq - 1);\n \tif (ret)\n \t\tgoto err;\n \n@@ -1703,9 +1716,10 @@ static CLOSURE_CALLBACK(journal_write_done)\n \t\tbch2_log_msg_start(c, &buf);\n \n \t\tif (err == -BCH_ERR_journal_write_err)\n-\t\t\tprt_printf(&buf, \"unable to write journal to sufficient devices\");\n+\t\t\tprt_printf(&buf, \"unable to write journal to sufficient devices\\n\");\n \t\telse\n-\t\t\tprt_printf(&buf, \"journal write error marking replicas: %s\", bch2_err_str(err));\n+\t\t\tprt_printf(&buf, \"journal write error marking replicas: %s\\n\",\n+\t\t\t\t   bch2_err_str(err));\n \n \t\tbch2_fs_emergency_read_only2(c, &buf);\n \ndiff --git a/fs/bcachefs/namei.c b/fs/bcachefs/namei.c\nindex 779c22eb3979..c3f87c59922d 100644\n--- a/fs/bcachefs/namei.c\n+++ b/fs/bcachefs/namei.c\n@@ -625,14 +625,26 @@ static int __bch2_inum_to_path(struct btree_trans *trans,\n {\n \tunsigned orig_pos = path->pos;\n \tint ret = 0;\n+\tDARRAY(subvol_inum) inums = {};\n+\n+\tif (!snapshot) {\n+\t\tret = bch2_subvolume_get_snapshot(trans, subvol, &snapshot);\n+\t\tif (ret)\n+\t\t\tgoto disconnected;\n+\t}\n \n \twhile (true) {\n-\t\tif (!snapshot) {\n-\t\t\tret = bch2_subvolume_get_snapshot(trans, subvol, &snapshot);\n-\t\t\tif (ret)\n-\t\t\t\tgoto disconnected;\n+\t\tsubvol_inum n = (subvol_inum) { subvol ?: snapshot, inum };\n+\n+\t\tif (darray_find_p(inums, i, i->subvol == n.subvol && i->inum == n.inum)) {\n+\t\t\tprt_str_reversed(path, \"(loop)\");\n+\t\t\tbreak;\n \t\t}\n \n+\t\tret = darray_push(&inums, n);\n+\t\tif (ret)\n+\t\t\tgoto err;\n+\n \t\tstruct bch_inode_unpacked inode;\n \t\tret = bch2_inode_find_by_inum_snapshot(trans, inum, snapshot, &inode, 0);\n \t\tif (ret)\n@@ -650,7 +662,9 @@ static int __bch2_inum_to_path(struct btree_trans *trans,\n \t\tinum = inode.bi_dir;\n \t\tif (inode.bi_parent_subvol) {\n \t\t\tsubvol = inode.bi_parent_subvol;\n-\t\t\tsnapshot = 0;\n+\t\t\tret = bch2_subvolume_get_snapshot(trans, inode.bi_parent_subvol, &snapshot);\n+\t\t\tif (ret)\n+\t\t\t\tgoto disconnected;\n \t\t}\n \n \t\tstruct btree_iter d_iter;\n@@ -662,6 +676,7 @@ static int __bch2_inum_to_path(struct btree_trans *trans,\n \t\t\tgoto disconnected;\n \n \t\tstruct qstr dirent_name = bch2_dirent_get_name(d);\n+\n \t\tprt_bytes_reversed(path, dirent_name.name, dirent_name.len);\n \n \t\tprt_char(path, '/');\n@@ -677,8 +692,10 @@ static int __bch2_inum_to_path(struct btree_trans *trans,\n \t\tgoto err;\n \n \treverse_bytes(path->buf + orig_pos, path->pos - orig_pos);\n+\tdarray_exit(&inums);\n \treturn 0;\n err:\n+\tdarray_exit(&inums);\n \treturn ret;\n disconnected:\n \tif (bch2_err_matches(ret, BCH_ERR_transaction_restart))\n@@ -717,8 +734,7 @@ static int bch2_check_dirent_inode_dirent(struct btree_trans *trans,\n \tif (inode_points_to_dirent(target, d))\n \t\treturn 0;\n \n-\tif (!target->bi_dir &&\n-\t    !target->bi_dir_offset) {\n+\tif (!bch2_inode_has_backpointer(target)) {\n \t\tfsck_err_on(S_ISDIR(target->bi_mode),\n \t\t\t    trans, inode_dir_missing_backpointer,\n \t\t\t    \"directory with missing backpointer\\n%s\",\ndiff --git a/fs/bcachefs/opts.h b/fs/bcachefs/opts.h\nindex 2a02606254b3..b0a76bd6d6f5 100644\n--- a/fs/bcachefs/opts.h\n+++ b/fs/bcachefs/opts.h\n@@ -379,6 +379,11 @@ enum fsck_err_opts {\n \t  OPT_BOOL(),\t\t\t\t\t\t\t\\\n \t  BCH2_NO_SB_OPT,\t\tfalse,\t\t\t\t\\\n \t  NULL,\t\t\"Exit recovery immediately prior to journal replay\")\\\n+\tx(journal_rewind,\t\tu64,\t\t\t\t\\\n+\t  OPT_FS|OPT_MOUNT,\t\t\t\t\t\t\\\n+\t  OPT_UINT(0, U64_MAX),\t\t\t\t\t\t\\\n+\t  BCH2_NO_SB_OPT,\t\t0,\t\t\t\t\\\n+\t  NULL,\t\t\"Rewind journal\")\t\t\t\t\\\n \tx(recovery_passes,\t\tu64,\t\t\t\t\\\n \t  OPT_FS|OPT_MOUNT,\t\t\t\t\t\t\\\n \t  OPT_BITFIELD(bch2_recovery_passes),\t\t\t\t\\\ndiff --git a/fs/bcachefs/recovery.c b/fs/bcachefs/recovery.c\nindex 0b21fa6ff062..d0b7e3a36a54 100644\n--- a/fs/bcachefs/recovery.c\n+++ b/fs/bcachefs/recovery.c\n@@ -607,6 +607,7 @@ static int read_btree_roots(struct bch_fs *c)\n \t\t\t\t\tbuf.buf, bch2_err_str(ret))) {\n \t\t\tif (btree_id_is_alloc(i))\n \t\t\t\tr->error = 0;\n+\t\t\tret = 0;\n \t\t}\n \t}\n \n@@ -692,7 +693,7 @@ static bool check_version_upgrade(struct bch_fs *c)\n \t\tret = true;\n \t}\n \n-\tif (new_version > c->sb.version_incompat &&\n+\tif (new_version > c->sb.version_incompat_allowed &&\n \t    c->opts.version_upgrade == BCH_VERSION_UPGRADE_incompatible) {\n \t\tstruct printbuf buf = PRINTBUF;\n \n@@ -757,6 +758,21 @@ int bch2_fs_recovery(struct bch_fs *c)\n \tif (c->opts.nochanges)\n \t\tc->opts.read_only = true;\n \n+\tif (c->opts.journal_rewind) {\n+\t\tbch_info(c, \"rewinding journal, fsck required\");\n+\t\tc->opts.fsck = true;\n+\t}\n+\n+\tif (go_rw_in_recovery(c)) {\n+\t\t/*\n+\t\t * start workqueues/kworkers early - kthread creation checks for\n+\t\t * pending signals, which is _very_ annoying\n+\t\t */\n+\t\tret = bch2_fs_init_rw(c);\n+\t\tif (ret)\n+\t\t\tgoto err;\n+\t}\n+\n \tmutex_lock(&c->sb_lock);\n \tstruct bch_sb_field_ext *ext = bch2_sb_field_get(c->disk_sb.sb, ext);\n \tbool write_sb = false;\n@@ -965,7 +981,7 @@ int bch2_fs_recovery(struct bch_fs *c)\n \n \tret =   bch2_journal_log_msg(c, \"starting journal at entry %llu, replaying %llu-%llu\",\n \t\t\t\t     journal_seq, last_seq, blacklist_seq - 1) ?:\n-\t\tbch2_fs_journal_start(&c->journal, journal_seq);\n+\t\tbch2_fs_journal_start(&c->journal, last_seq, journal_seq);\n \tif (ret)\n \t\tgoto err;\n \n@@ -1126,7 +1142,7 @@ int bch2_fs_recovery(struct bch_fs *c)\n \t\tstruct printbuf buf = PRINTBUF;\n \t\tbch2_log_msg_start(c, &buf);\n \n-\t\tprt_printf(&buf, \"error in recovery: %s\", bch2_err_str(ret));\n+\t\tprt_printf(&buf, \"error in recovery: %s\\n\", bch2_err_str(ret));\n \t\tbch2_fs_emergency_read_only2(c, &buf);\n \n \t\tbch2_print_str(c, KERN_ERR, buf.buf);\n@@ -1181,7 +1197,7 @@ int bch2_fs_initialize(struct bch_fs *c)\n \t * journal_res_get() will crash if called before this has\n \t * set up the journal.pin FIFO and journal.cur pointer:\n \t */\n-\tret = bch2_fs_journal_start(&c->journal, 1);\n+\tret = bch2_fs_journal_start(&c->journal, 1, 1);\n \tif (ret)\n \t\tgoto err;\n \ndiff --git a/fs/bcachefs/recovery_passes.c b/fs/bcachefs/recovery_passes.c\nindex 35ac0d64d73a..c09ed2dd4639 100644\n--- a/fs/bcachefs/recovery_passes.c\n+++ b/fs/bcachefs/recovery_passes.c\n@@ -217,11 +217,7 @@ static int bch2_set_may_go_rw(struct bch_fs *c)\n \n \tset_bit(BCH_FS_may_go_rw, &c->flags);\n \n-\tif (keys->nr ||\n-\t    !c->opts.read_only ||\n-\t    !c->sb.clean ||\n-\t    c->opts.recovery_passes ||\n-\t    (c->opts.fsck && !(c->sb.features & BIT_ULL(BCH_FEATURE_no_alloc_info)))) {\n+\tif (go_rw_in_recovery(c)) {\n \t\tif (c->sb.features & BIT_ULL(BCH_FEATURE_no_alloc_info)) {\n \t\t\tbch_info(c, \"mounting a filesystem with no alloc info read-write; will recreate\");\n \t\t\tbch2_reconstruct_alloc(c);\n@@ -317,6 +313,9 @@ static bool recovery_pass_needs_set(struct bch_fs *c,\n \t */\n \tbool in_recovery = test_bit(BCH_FS_in_recovery, &c->flags);\n \tbool persistent = !in_recovery || !(*flags & RUN_RECOVERY_PASS_nopersistent);\n+\tbool rewind = in_recovery &&\n+\t\tr->curr_pass > pass &&\n+\t\t!(r->passes_complete & BIT_ULL(pass));\n \n \tif (persistent\n \t    ? !(c->sb.recovery_passes_required & BIT_ULL(pass))\n@@ -327,6 +326,9 @@ static bool recovery_pass_needs_set(struct bch_fs *c,\n \t    (r->passes_ratelimiting & BIT_ULL(pass)))\n \t\treturn true;\n \n+\tif (rewind)\n+\t\treturn true;\n+\n \treturn false;\n }\n \n@@ -341,7 +343,6 @@ int __bch2_run_explicit_recovery_pass(struct bch_fs *c,\n \tstruct bch_fs_recovery *r = &c->recovery;\n \tint ret = 0;\n \n-\n \tlockdep_assert_held(&c->sb_lock);\n \n \tbch2_printbuf_make_room(out, 1024);\n@@ -412,10 +413,8 @@ int bch2_run_explicit_recovery_pass(struct bch_fs *c,\n {\n \tint ret = 0;\n \n-\tscoped_guard(mutex, &c->sb_lock) {\n-\t\tif (!recovery_pass_needs_set(c, pass, &flags))\n-\t\t\treturn 0;\n-\n+\tif (recovery_pass_needs_set(c, pass, &flags)) {\n+\t\tguard(mutex)(&c->sb_lock);\n \t\tret = __bch2_run_explicit_recovery_pass(c, out, pass, flags);\n \t\tbch2_write_super(c);\n \t}\ndiff --git a/fs/bcachefs/recovery_passes.h b/fs/bcachefs/recovery_passes.h\nindex 260571c7105e..2117f0ce1922 100644\n--- a/fs/bcachefs/recovery_passes.h\n+++ b/fs/bcachefs/recovery_passes.h\n@@ -17,6 +17,15 @@ enum bch_run_recovery_pass_flags {\n \tRUN_RECOVERY_PASS_ratelimit\t= BIT(1),\n };\n \n+static inline bool go_rw_in_recovery(struct bch_fs *c)\n+{\n+\treturn (c->journal_keys.nr ||\n+\t\t!c->opts.read_only ||\n+\t\t!c->sb.clean ||\n+\t\tc->opts.recovery_passes ||\n+\t\t(c->opts.fsck && !(c->sb.features & BIT_ULL(BCH_FEATURE_no_alloc_info))));\n+}\n+\n int bch2_run_print_explicit_recovery_pass(struct bch_fs *, enum bch_recovery_pass);\n \n int __bch2_run_explicit_recovery_pass(struct bch_fs *, struct printbuf *,\ndiff --git a/fs/bcachefs/reflink.c b/fs/bcachefs/reflink.c\nindex a535abd44df3..92b90cfe622b 100644\n--- a/fs/bcachefs/reflink.c\n+++ b/fs/bcachefs/reflink.c\n@@ -64,6 +64,9 @@ void bch2_reflink_p_to_text(struct printbuf *out, struct bch_fs *c,\n \t       REFLINK_P_IDX(p.v),\n \t       le32_to_cpu(p.v->front_pad),\n \t       le32_to_cpu(p.v->back_pad));\n+\n+\tif (REFLINK_P_ERROR(p.v))\n+\t\tprt_str(out, \" error\");\n }\n \n bool bch2_reflink_p_merge(struct bch_fs *c, struct bkey_s _l, struct bkey_s_c _r)\n@@ -269,13 +272,12 @@ struct bkey_s_c bch2_lookup_indirect_extent(struct btree_trans *trans,\n \t\treturn k;\n \n \tif (unlikely(!bkey_extent_is_reflink_data(k.k))) {\n-\t\tunsigned size = min((u64) k.k->size,\n-\t\t\t\t    REFLINK_P_IDX(p.v) + p.k->size + le32_to_cpu(p.v->back_pad) -\n-\t\t\t\t    reflink_offset);\n-\t\tbch2_key_resize(&iter->k, size);\n+\t\tu64 missing_end = min(k.k->p.offset,\n+\t\t\t\t      REFLINK_P_IDX(p.v) + p.k->size + le32_to_cpu(p.v->back_pad));\n+\t\tBUG_ON(reflink_offset == missing_end);\n \n \t\tint ret = bch2_indirect_extent_missing_error(trans, p, reflink_offset,\n-\t\t\t\t\t\t\t     k.k->p.offset, should_commit);\n+\t\t\t\t\t\t\t     missing_end, should_commit);\n \t\tif (ret) {\n \t\t\tbch2_trans_iter_exit(trans, iter);\n \t\t\treturn bkey_s_c_err(ret);\ndiff --git a/fs/bcachefs/sb-errors_format.h b/fs/bcachefs/sb-errors_format.h\nindex d06e73884871..0641fb634bd4 100644\n--- a/fs/bcachefs/sb-errors_format.h\n+++ b/fs/bcachefs/sb-errors_format.h\n@@ -3,9 +3,10 @@\n #define _BCACHEFS_SB_ERRORS_FORMAT_H\n \n enum bch_fsck_flags {\n-\tFSCK_CAN_FIX\t\t= 1 << 0,\n-\tFSCK_CAN_IGNORE\t\t= 1 << 1,\n-\tFSCK_AUTOFIX\t\t= 1 << 2,\n+\tFSCK_CAN_FIX\t\t= BIT(0),\n+\tFSCK_CAN_IGNORE\t\t= BIT(1),\n+\tFSCK_AUTOFIX\t\t= BIT(2),\n+\tFSCK_ERR_NO_LOG\t\t= BIT(3),\n };\n \n #define BCH_SB_ERRS()\t\t\t\t\t\t\t\t\t\\\n@@ -217,7 +218,7 @@ enum bch_fsck_flags {\n \tx(inode_str_hash_invalid,\t\t\t\t194,\t0)\t\t\\\n \tx(inode_v3_fields_start_bad,\t\t\t\t195,\t0)\t\t\\\n \tx(inode_snapshot_mismatch,\t\t\t\t196,\t0)\t\t\\\n-\tx(snapshot_key_missing_inode_snapshot,\t\t\t314,\t0)\t\t\\\n+\tx(snapshot_key_missing_inode_snapshot,\t\t\t314,\tFSCK_AUTOFIX)\t\\\n \tx(inode_unlinked_but_clean,\t\t\t\t197,\t0)\t\t\\\n \tx(inode_unlinked_but_nlink_nonzero,\t\t\t198,\t0)\t\t\\\n \tx(inode_unlinked_and_not_open,\t\t\t\t281,\t0)\t\t\\\n@@ -251,20 +252,20 @@ enum bch_fsck_flags {\n \tx(deleted_inode_not_unlinked,\t\t\t\t214,\tFSCK_AUTOFIX)\t\\\n \tx(deleted_inode_has_child_snapshots,\t\t\t288,\tFSCK_AUTOFIX)\t\\\n \tx(extent_overlapping,\t\t\t\t\t215,\t0)\t\t\\\n-\tx(key_in_missing_inode,\t\t\t\t\t216,\t0)\t\t\\\n+\tx(key_in_missing_inode,\t\t\t\t\t216,\tFSCK_AUTOFIX)\t\\\n \tx(key_in_wrong_inode_type,\t\t\t\t217,\t0)\t\t\\\n-\tx(extent_past_end_of_inode,\t\t\t\t218,\t0)\t\t\\\n+\tx(extent_past_end_of_inode,\t\t\t\t218,\tFSCK_AUTOFIX)\t\\\n \tx(dirent_empty_name,\t\t\t\t\t219,\t0)\t\t\\\n \tx(dirent_val_too_big,\t\t\t\t\t220,\t0)\t\t\\\n \tx(dirent_name_too_long,\t\t\t\t\t221,\t0)\t\t\\\n \tx(dirent_name_embedded_nul,\t\t\t\t222,\t0)\t\t\\\n \tx(dirent_name_dot_or_dotdot,\t\t\t\t223,\t0)\t\t\\\n \tx(dirent_name_has_slash,\t\t\t\t224,\t0)\t\t\\\n-\tx(dirent_d_type_wrong,\t\t\t\t\t225,\t0)\t\t\\\n+\tx(dirent_d_type_wrong,\t\t\t\t\t225,\tFSCK_AUTOFIX)\t\\\n \tx(inode_bi_parent_wrong,\t\t\t\t226,\t0)\t\t\\\n \tx(dirent_in_missing_dir_inode,\t\t\t\t227,\t0)\t\t\\\n \tx(dirent_in_non_dir_inode,\t\t\t\t228,\t0)\t\t\\\n-\tx(dirent_to_missing_inode,\t\t\t\t229,\t0)\t\t\\\n+\tx(dirent_to_missing_inode,\t\t\t\t229,\tFSCK_AUTOFIX)\t\\\n \tx(dirent_to_overwritten_inode,\t\t\t\t302,\t0)\t\t\\\n \tx(dirent_to_missing_subvol,\t\t\t\t230,\t0)\t\t\\\n \tx(dirent_to_itself,\t\t\t\t\t231,\t0)\t\t\\\n@@ -300,7 +301,7 @@ enum bch_fsck_flags {\n \tx(btree_node_bkey_bad_u64s,\t\t\t\t260,\t0)\t\t\\\n \tx(btree_node_topology_empty_interior_node,\t\t261,\t0)\t\t\\\n \tx(btree_ptr_v2_min_key_bad,\t\t\t\t262,\t0)\t\t\\\n-\tx(btree_root_unreadable_and_scan_found_nothing,\t\t263,\tFSCK_AUTOFIX)\t\\\n+\tx(btree_root_unreadable_and_scan_found_nothing,\t\t263,\t0)\t\t\\\n \tx(snapshot_node_missing,\t\t\t\t264,\tFSCK_AUTOFIX)\t\\\n \tx(dup_backpointer_to_bad_csum_extent,\t\t\t265,\t0)\t\t\\\n \tx(btree_bitmap_not_marked,\t\t\t\t266,\tFSCK_AUTOFIX)\t\\\ndiff --git a/fs/bcachefs/snapshot.c b/fs/bcachefs/snapshot.c\nindex 23a332d76b32..4c43d2a2c1f5 100644\n--- a/fs/bcachefs/snapshot.c\n+++ b/fs/bcachefs/snapshot.c\n@@ -135,7 +135,9 @@ static bool test_ancestor_bitmap(struct snapshot_table *t, u32 id, u32 ancestor)\n \n bool __bch2_snapshot_is_ancestor(struct bch_fs *c, u32 id, u32 ancestor)\n {\n-\tbool ret;\n+#ifdef CONFIG_BCACHEFS_DEBUG\n+\tu32 orig_id = id;\n+#endif\n \n \tguard(rcu)();\n \tstruct snapshot_table *t = rcu_dereference(c->snapshots);\n@@ -147,11 +149,11 @@ bool __bch2_snapshot_is_ancestor(struct bch_fs *c, u32 id, u32 ancestor)\n \t\twhile (id && id < ancestor - IS_ANCESTOR_BITMAP)\n \t\t\tid = get_ancestor_below(t, id, ancestor);\n \n-\tret = id && id < ancestor\n+\tbool ret = id && id < ancestor\n \t\t? test_ancestor_bitmap(t, id, ancestor)\n \t\t: id == ancestor;\n \n-\tEBUG_ON(ret != __bch2_snapshot_is_ancestor_early(t, id, ancestor));\n+\tEBUG_ON(ret != __bch2_snapshot_is_ancestor_early(t, orig_id, ancestor));\n \treturn ret;\n }\n \n@@ -869,7 +871,8 @@ static int check_snapshot_exists(struct btree_trans *trans, u32 id)\n \n \tfor_each_btree_key_norestart(trans, iter, BTREE_ID_snapshot_trees, POS_MIN,\n \t\t\t\t     0, k, ret) {\n-\t\tif (le32_to_cpu(bkey_s_c_to_snapshot_tree(k).v->root_snapshot) == id) {\n+\t\tif (k.k->type == KEY_TYPE_snapshot_tree &&\n+\t\t    le32_to_cpu(bkey_s_c_to_snapshot_tree(k).v->root_snapshot) == id) {\n \t\t\ttree_id = k.k->p.offset;\n \t\t\tbreak;\n \t\t}\n@@ -897,7 +900,8 @@ static int check_snapshot_exists(struct btree_trans *trans, u32 id)\n \n \tfor_each_btree_key_norestart(trans, iter, BTREE_ID_subvolumes, POS_MIN,\n \t\t\t\t     0, k, ret) {\n-\t\tif (le32_to_cpu(bkey_s_c_to_subvolume(k).v->snapshot) == id) {\n+\t\tif (k.k->type == KEY_TYPE_subvolume &&\n+\t\t    le32_to_cpu(bkey_s_c_to_subvolume(k).v->snapshot) == id) {\n \t\t\tsnapshot->v.subvol = cpu_to_le32(k.k->p.offset);\n \t\t\tSET_BCH_SNAPSHOT_SUBVOL(&snapshot->v, true);\n \t\t\tbreak;\ndiff --git a/fs/bcachefs/super.c b/fs/bcachefs/super.c\nindex a5b97c9c5163..69c097ff54e7 100644\n--- a/fs/bcachefs/super.c\n+++ b/fs/bcachefs/super.c\n@@ -210,7 +210,6 @@ static int bch2_dev_alloc(struct bch_fs *, unsigned);\n static int bch2_dev_sysfs_online(struct bch_fs *, struct bch_dev *);\n static void bch2_dev_io_ref_stop(struct bch_dev *, int);\n static void __bch2_dev_read_only(struct bch_fs *, struct bch_dev *);\n-static int bch2_fs_init_rw(struct bch_fs *);\n \n struct bch_fs *bch2_dev_to_fs(dev_t dev)\n {\n@@ -794,7 +793,7 @@ static int bch2_fs_online(struct bch_fs *c)\n \treturn ret;\n }\n \n-static int bch2_fs_init_rw(struct bch_fs *c)\n+int bch2_fs_init_rw(struct bch_fs *c)\n {\n \tif (test_bit(BCH_FS_rw_init_done, &c->flags))\n \t\treturn 0;\n@@ -1015,6 +1014,16 @@ static struct bch_fs *bch2_fs_alloc(struct bch_sb *sb, struct bch_opts *opts,\n \tif (ret)\n \t\tgoto err;\n \n+\tif (go_rw_in_recovery(c)) {\n+\t\t/*\n+\t\t * start workqueues/kworkers early - kthread creation checks for\n+\t\t * pending signals, which is _very_ annoying\n+\t\t */\n+\t\tret = bch2_fs_init_rw(c);\n+\t\tif (ret)\n+\t\t\tgoto err;\n+\t}\n+\n #ifdef CONFIG_UNICODE\n \t/* Default encoding until we can potentially have more as an option. */\n \tc->cf_encoding = utf8_load(BCH_FS_DEFAULT_UTF8_ENCODING);\ndiff --git a/fs/bcachefs/super.h b/fs/bcachefs/super.h\nindex dc52f06cb2b9..e90bab9afe78 100644\n--- a/fs/bcachefs/super.h\n+++ b/fs/bcachefs/super.h\n@@ -46,6 +46,7 @@ void __bch2_fs_stop(struct bch_fs *);\n void bch2_fs_free(struct bch_fs *);\n void bch2_fs_stop(struct bch_fs *);\n \n+int bch2_fs_init_rw(struct bch_fs *);\n int bch2_fs_start(struct bch_fs *);\n struct bch_fs *bch2_fs_open(darray_const_str *, struct bch_opts *);\n \ndiff --git a/fs/bcachefs/trace.h b/fs/bcachefs/trace.h\nindex dc09532796af..9c5a9c551f03 100644\n--- a/fs/bcachefs/trace.h\n+++ b/fs/bcachefs/trace.h\n@@ -1080,34 +1080,14 @@ TRACE_EVENT(trans_blocked_journal_reclaim,\n \t\t  __entry->must_wait)\n );\n \n-TRACE_EVENT(trans_restart_journal_preres_get,\n-\tTP_PROTO(struct btree_trans *trans,\n-\t\t unsigned long caller_ip,\n-\t\t unsigned flags),\n-\tTP_ARGS(trans, caller_ip, flags),\n-\n-\tTP_STRUCT__entry(\n-\t\t__array(char,\t\t\ttrans_fn, 32\t)\n-\t\t__field(unsigned long,\t\tcaller_ip\t)\n-\t\t__field(unsigned,\t\tflags\t\t)\n-\t),\n-\n-\tTP_fast_assign(\n-\t\tstrscpy(__entry->trans_fn, trans->fn, sizeof(__entry->trans_fn));\n-\t\t__entry->caller_ip\t\t= caller_ip;\n-\t\t__entry->flags\t\t\t= flags;\n-\t),\n-\n-\tTP_printk(\"%s %pS %x\", __entry->trans_fn,\n-\t\t  (void *) __entry->caller_ip,\n-\t\t  __entry->flags)\n-);\n-\n+#if 0\n+/* todo: bring back dynamic fault injection */\n DEFINE_EVENT(transaction_event,\ttrans_restart_fault_inject,\n \tTP_PROTO(struct btree_trans *trans,\n \t\t unsigned long caller_ip),\n \tTP_ARGS(trans, caller_ip)\n );\n+#endif\n \n DEFINE_EVENT(transaction_event,\ttrans_traverse_all,\n \tTP_PROTO(struct btree_trans *trans,\n@@ -1195,19 +1175,6 @@ DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_relock_parent_for_fill,\n \tTP_ARGS(trans, caller_ip, path)\n );\n \n-DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_relock_after_fill,\n-\tTP_PROTO(struct btree_trans *trans,\n-\t\t unsigned long caller_ip,\n-\t\t struct btree_path *path),\n-\tTP_ARGS(trans, caller_ip, path)\n-);\n-\n-DEFINE_EVENT(transaction_event,\ttrans_restart_key_cache_upgrade,\n-\tTP_PROTO(struct btree_trans *trans,\n-\t\t unsigned long caller_ip),\n-\tTP_ARGS(trans, caller_ip)\n-);\n-\n DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_relock_key_cache_fill,\n \tTP_PROTO(struct btree_trans *trans,\n \t\t unsigned long caller_ip,\n@@ -1229,13 +1196,6 @@ DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_relock_path_intent,\n \tTP_ARGS(trans, caller_ip, path)\n );\n \n-DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_traverse,\n-\tTP_PROTO(struct btree_trans *trans,\n-\t\t unsigned long caller_ip,\n-\t\t struct btree_path *path),\n-\tTP_ARGS(trans, caller_ip, path)\n-);\n-\n DEFINE_EVENT(transaction_restart_iter,\ttrans_restart_memory_allocation_failure,\n \tTP_PROTO(struct btree_trans *trans,\n \t\t unsigned long caller_ip,\n@@ -1294,44 +1254,6 @@ TRACE_EVENT(trans_restart_mem_realloced,\n \t\t  __entry->bytes)\n );\n \n-TRACE_EVENT(trans_restart_key_cache_key_realloced,\n-\tTP_PROTO(struct btree_trans *trans,\n-\t\t unsigned long caller_ip,\n-\t\t struct btree_path *path,\n-\t\t unsigned old_u64s,\n-\t\t unsigned new_u64s),\n-\tTP_ARGS(trans, caller_ip, path, old_u64s, new_u64s),\n-\n-\tTP_STRUCT__entry(\n-\t\t__array(char,\t\t\ttrans_fn, 32\t)\n-\t\t__field(unsigned long,\t\tcaller_ip\t)\n-\t\t__field(enum btree_id,\t\tbtree_id\t)\n-\t\tTRACE_BPOS_entries(pos)\n-\t\t__field(u32,\t\t\told_u64s\t)\n-\t\t__field(u32,\t\t\tnew_u64s\t)\n-\t),\n-\n-\tTP_fast_assign(\n-\t\tstrscpy(__entry->trans_fn, trans->fn, sizeof(__entry->trans_fn));\n-\t\t__entry->caller_ip\t\t= caller_ip;\n-\n-\t\t__entry->btree_id\t= path->btree_id;\n-\t\tTRACE_BPOS_assign(pos, path->pos);\n-\t\t__entry->old_u64s\t= old_u64s;\n-\t\t__entry->new_u64s\t= new_u64s;\n-\t),\n-\n-\tTP_printk(\"%s %pS btree %s pos %llu:%llu:%u old_u64s %u new_u64s %u\",\n-\t\t  __entry->trans_fn,\n-\t\t  (void *) __entry->caller_ip,\n-\t\t  bch2_btree_id_str(__entry->btree_id),\n-\t\t  __entry->pos_inode,\n-\t\t  __entry->pos_offset,\n-\t\t  __entry->pos_snapshot,\n-\t\t  __entry->old_u64s,\n-\t\t  __entry->new_u64s)\n-);\n-\n DEFINE_EVENT(transaction_event,\ttrans_restart_write_buffer_flush,\n \tTP_PROTO(struct btree_trans *trans,\n \t\t unsigned long caller_ip),\n@@ -1490,6 +1412,31 @@ DEFINE_EVENT(fs_str, io_move_evacuate_bucket,\n \tTP_ARGS(c, str)\n );\n \n+DEFINE_EVENT(fs_str, extent_trim_atomic,\n+\tTP_PROTO(struct bch_fs *c, const char *str),\n+\tTP_ARGS(c, str)\n+);\n+\n+DEFINE_EVENT(fs_str, btree_iter_peek_slot,\n+\tTP_PROTO(struct bch_fs *c, const char *str),\n+\tTP_ARGS(c, str)\n+);\n+\n+DEFINE_EVENT(fs_str, __btree_iter_peek,\n+\tTP_PROTO(struct bch_fs *c, const char *str),\n+\tTP_ARGS(c, str)\n+);\n+\n+DEFINE_EVENT(fs_str, btree_iter_peek_max,\n+\tTP_PROTO(struct bch_fs *c, const char *str),\n+\tTP_ARGS(c, str)\n+);\n+\n+DEFINE_EVENT(fs_str, btree_iter_peek_prev_min,\n+\tTP_PROTO(struct bch_fs *c, const char *str),\n+\tTP_ARGS(c, str)\n+);\n+\n #ifdef CONFIG_BCACHEFS_PATH_TRACEPOINTS\n \n TRACE_EVENT(update_by_path,\n@@ -1902,21 +1849,6 @@ TRACE_EVENT(btree_path_free,\n \t\t  __entry->dup_locked)\n );\n \n-TRACE_EVENT(btree_path_free_trans_begin,\n-\tTP_PROTO(btree_path_idx_t path),\n-\tTP_ARGS(path),\n-\n-\tTP_STRUCT__entry(\n-\t\t__field(btree_path_idx_t,\tidx\t\t)\n-\t),\n-\n-\tTP_fast_assign(\n-\t\t__entry->idx\t\t\t= path;\n-\t),\n-\n-\tTP_printk(\"   path %3u\", __entry->idx)\n-);\n-\n #else /* CONFIG_BCACHEFS_PATH_TRACEPOINTS */\n #ifndef _TRACE_BCACHEFS_H\n \n@@ -1934,7 +1866,6 @@ static inline void trace_btree_path_traverse_start(struct btree_trans *trans, st\n static inline void trace_btree_path_traverse_end(struct btree_trans *trans, struct btree_path *path) {}\n static inline void trace_btree_path_set_pos(struct btree_trans *trans, struct btree_path *path, struct bpos *new_pos) {}\n static inline void trace_btree_path_free(struct btree_trans *trans, btree_path_idx_t path, struct btree_path *dup) {}\n-static inline void trace_btree_path_free_trans_begin(btree_path_idx_t path) {}\n \n #endif\n #endif /* CONFIG_BCACHEFS_PATH_TRACEPOINTS */",
    "stats": {
      "insertions": 734,
      "deletions": 451,
      "files": 42
    }
  },
  {
    "sha": "8a20830f2dd180064f25254d9c55beb243fe9223",
    "message": "Merge tag 'hid-for-linus-2025062701' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid\n\nPull HID fixes from Jiri Kosina:\n\n - fix for stalls during suspend/resume cycles with hid-nintendo (Daniel\n   J. Ogorchock)\n\n - memory leak and reference count fixes in hid-wacom and in-appletb-kdb\n   (Qasim Ijaz)\n\n - race condition (leading to kernel crash) fix during device removal in\n   hid-wacom (Thomas Zeitlhofer)\n\n - fix for missed interrupt in intel-thc-hid (Intel-thc-hid:)\n\n - support for a bunch of new device IDs\n\n* tag 'hid-for-linus-2025062701' of git://git.kernel.org/pub/scm/linux/kernel/git/hid/hid:\n  HID: lenovo: Add support for ThinkPad X1 Tablet Thin Keyboard Gen2\n  HID: appletb-kbd: fix \"appletb_backlight\" backlight device reference counting\n  HID: wacom: fix crash in wacom_aes_battery_handler()\n  HID: intel-ish-hid: ipc: Add Wildcat Lake PCI device ID\n  hid: intel-ish-hid: Use PCI_DEVICE_DATA() macro for ISH device table\n  HID: lenovo: Restrict F7/9/11 mode to compact keyboards only\n  HID: Add IGNORE quirk for SMARTLINKTECHNOLOGY\n  HID: input: lower message severity of 'No inputs registered, leaving' to debug\n  HID: quirks: Add quirk for 2 Chicony Electronics HP 5MP Cameras\n  HID: Intel-thc-hid: Intel-quicki2c: Enhance QuickI2C reset flow\n  HID: nintendo: avoid bluetooth suspend/resume stalls\n  HID: wacom: fix kobject reference count leak\n  HID: wacom: fix memory leak on sysfs attribute creation failure\n  HID: wacom: fix memory leak on kobject creation failure",
    "author": "Linus Torvalds",
    "date": "2025-06-26T17:06:01-07:00",
    "files_changed": [
      "drivers/hid/hid-appletb-kbd.c",
      "drivers/hid/hid-ids.h",
      "drivers/hid/hid-input.c",
      "drivers/hid/hid-lenovo.c",
      "drivers/hid/hid-multitouch.c",
      "drivers/hid/hid-nintendo.c",
      "drivers/hid/hid-quirks.c",
      "drivers/hid/intel-ish-hid/ipc/hw-ish.h",
      "drivers/hid/intel-ish-hid/ipc/pci-ish.c",
      "drivers/hid/intel-thc-hid/intel-quicki2c/quicki2c-protocol.c",
      "drivers/hid/wacom_sys.c"
    ],
    "diff": "diff --git a/drivers/hid/hid-appletb-kbd.c b/drivers/hid/hid-appletb-kbd.c\nindex 6f251b284018..2e0caf52af13 100644\n--- a/drivers/hid/hid-appletb-kbd.c\n+++ b/drivers/hid/hid-appletb-kbd.c\n@@ -438,6 +438,8 @@ static int appletb_kbd_probe(struct hid_device *hdev, const struct hid_device_id\n \treturn 0;\n \n close_hw:\n+\tif (kbd->backlight_dev)\n+\t\tput_device(&kbd->backlight_dev->dev);\n \thid_hw_close(hdev);\n stop_hw:\n \thid_hw_stop(hdev);\n@@ -453,6 +455,9 @@ static void appletb_kbd_remove(struct hid_device *hdev)\n \tinput_unregister_handler(&kbd->inp_handler);\n \ttimer_delete_sync(&kbd->inactivity_timer);\n \n+\tif (kbd->backlight_dev)\n+\t\tput_device(&kbd->backlight_dev->dev);\n+\n \thid_hw_close(hdev);\n \thid_hw_stop(hdev);\n }\ndiff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h\nindex e3fb4e2fe911..c6468568aea1 100644\n--- a/drivers/hid/hid-ids.h\n+++ b/drivers/hid/hid-ids.h\n@@ -312,6 +312,8 @@\n #define USB_DEVICE_ID_ASUS_AK1D\t\t0x1125\n #define USB_DEVICE_ID_CHICONY_TOSHIBA_WT10A\t0x1408\n #define USB_DEVICE_ID_CHICONY_ACER_SWITCH12\t0x1421\n+#define USB_DEVICE_ID_CHICONY_HP_5MP_CAMERA\t0xb824\n+#define USB_DEVICE_ID_CHICONY_HP_5MP_CAMERA2\t0xb82c\n \n #define USB_VENDOR_ID_CHUNGHWAT\t\t0x2247\n #define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH\t0x0001\n@@ -819,6 +821,7 @@\n #define USB_DEVICE_ID_LENOVO_TPPRODOCK\t0x6067\n #define USB_DEVICE_ID_LENOVO_X1_COVER\t0x6085\n #define USB_DEVICE_ID_LENOVO_X1_TAB\t0x60a3\n+#define USB_DEVICE_ID_LENOVO_X1_TAB2\t0x60a4\n #define USB_DEVICE_ID_LENOVO_X1_TAB3\t0x60b5\n #define USB_DEVICE_ID_LENOVO_X12_TAB\t0x60fe\n #define USB_DEVICE_ID_LENOVO_X12_TAB2\t0x61ae\n@@ -1525,4 +1528,7 @@\n #define USB_VENDOR_ID_SIGNOTEC\t\t\t0x2133\n #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011\t0x0018\n \n+#define USB_VENDOR_ID_SMARTLINKTECHNOLOGY              0x4c4a\n+#define USB_DEVICE_ID_SMARTLINKTECHNOLOGY_4155         0x4155\n+\n #endif\ndiff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c\nindex 9d80635a91eb..ff1784b5c2a4 100644\n--- a/drivers/hid/hid-input.c\n+++ b/drivers/hid/hid-input.c\n@@ -2343,7 +2343,7 @@ int hidinput_connect(struct hid_device *hid, unsigned int force)\n \t}\n \n \tif (list_empty(&hid->inputs)) {\n-\t\thid_err(hid, \"No inputs registered, leaving\\n\");\n+\t\thid_dbg(hid, \"No inputs registered, leaving\\n\");\n \t\tgoto out_unwind;\n \t}\n \ndiff --git a/drivers/hid/hid-lenovo.c b/drivers/hid/hid-lenovo.c\nindex af29ba840522..b3121fa7a72d 100644\n--- a/drivers/hid/hid-lenovo.c\n+++ b/drivers/hid/hid-lenovo.c\n@@ -492,6 +492,7 @@ static int lenovo_input_mapping(struct hid_device *hdev,\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB:\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\treturn lenovo_input_mapping_x1_tab_kbd(hdev, hi, field, usage, bit, max);\n \tdefault:\n@@ -548,11 +549,14 @@ static void lenovo_features_set_cptkbd(struct hid_device *hdev)\n \n \t/*\n \t * Tell the keyboard a driver understands it, and turn F7, F9, F11 into\n-\t * regular keys\n+\t * regular keys (Compact only)\n \t */\n-\tret = lenovo_send_cmd_cptkbd(hdev, 0x01, 0x03);\n-\tif (ret)\n-\t\thid_warn(hdev, \"Failed to switch F7/9/11 mode: %d\\n\", ret);\n+\tif (hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD ||\n+\t    hdev->product == USB_DEVICE_ID_LENOVO_CBTKBD) {\n+\t\tret = lenovo_send_cmd_cptkbd(hdev, 0x01, 0x03);\n+\t\tif (ret)\n+\t\t\thid_warn(hdev, \"Failed to switch F7/9/11 mode: %d\\n\", ret);\n+\t}\n \n \t/* Switch middle button to native mode */\n \tret = lenovo_send_cmd_cptkbd(hdev, 0x09, 0x01);\n@@ -605,6 +609,7 @@ static ssize_t attr_fn_lock_store(struct device *dev,\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\tret = lenovo_led_set_tp10ubkbd(hdev, TP10UBKBD_FN_LOCK_LED, value);\n \t\tif (ret)\n@@ -861,6 +866,7 @@ static int lenovo_event(struct hid_device *hdev, struct hid_field *field,\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\treturn lenovo_event_tp10ubkbd(hdev, field, usage, value);\n \tdefault:\n@@ -1144,6 +1150,7 @@ static int lenovo_led_brightness_set(struct led_classdev *led_cdev,\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\tret = lenovo_led_set_tp10ubkbd(hdev, tp10ubkbd_led[led_nr], value);\n \t\tbreak;\n@@ -1384,6 +1391,7 @@ static int lenovo_probe(struct hid_device *hdev,\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\tret = lenovo_probe_tp10ubkbd(hdev);\n \t\tbreak;\n@@ -1473,6 +1481,7 @@ static void lenovo_remove(struct hid_device *hdev)\n \tcase USB_DEVICE_ID_LENOVO_X12_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_TP10UBKBD:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB:\n+\tcase USB_DEVICE_ID_LENOVO_X1_TAB2:\n \tcase USB_DEVICE_ID_LENOVO_X1_TAB3:\n \t\tlenovo_remove_tp10ubkbd(hdev);\n \t\tbreak;\n@@ -1523,6 +1532,8 @@ static const struct hid_device_id lenovo_devices[] = {\n \t */\n \t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n \t\t     USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_TAB) },\n+\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n+\t\t     USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_TAB2) },\n \t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n \t\t     USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_X1_TAB3) },\n \t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\ndiff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c\nindex b41001e02da7..a1c54ffe02b4 100644\n--- a/drivers/hid/hid-multitouch.c\n+++ b/drivers/hid/hid-multitouch.c\n@@ -2132,12 +2132,18 @@ static const struct hid_device_id mt_devices[] = {\n \t\tHID_DEVICE(BUS_I2C, HID_GROUP_GENERIC,\n \t\t\tUSB_VENDOR_ID_LG, I2C_DEVICE_ID_LG_7010) },\n \n-\t/* Lenovo X1 TAB Gen 2 */\n+\t/* Lenovo X1 TAB Gen 1 */\n \t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n \t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n \t\t\t   USB_VENDOR_ID_LENOVO,\n \t\t\t   USB_DEVICE_ID_LENOVO_X1_TAB) },\n \n+\t/* Lenovo X1 TAB Gen 2 */\n+\t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n+\t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\n+\t\t\t   USB_VENDOR_ID_LENOVO,\n+\t\t\t   USB_DEVICE_ID_LENOVO_X1_TAB2) },\n+\n \t/* Lenovo X1 TAB Gen 3 */\n \t{ .driver_data = MT_CLS_WIN_8_FORCE_MULTI_INPUT,\n \t\tHID_DEVICE(BUS_USB, HID_GROUP_MULTITOUCH_WIN_8,\ndiff --git a/drivers/hid/hid-nintendo.c b/drivers/hid/hid-nintendo.c\nindex 839d5bcd72b1..fb4985988615 100644\n--- a/drivers/hid/hid-nintendo.c\n+++ b/drivers/hid/hid-nintendo.c\n@@ -308,6 +308,7 @@ enum joycon_ctlr_state {\n \tJOYCON_CTLR_STATE_INIT,\n \tJOYCON_CTLR_STATE_READ,\n \tJOYCON_CTLR_STATE_REMOVED,\n+\tJOYCON_CTLR_STATE_SUSPENDED,\n };\n \n /* Controller type received as part of device info */\n@@ -2750,14 +2751,46 @@ static void nintendo_hid_remove(struct hid_device *hdev)\n \n static int nintendo_hid_resume(struct hid_device *hdev)\n {\n-\tint ret = joycon_init(hdev);\n+\tstruct joycon_ctlr *ctlr = hid_get_drvdata(hdev);\n+\tint ret;\n+\n+\thid_dbg(hdev, \"resume\\n\");\n+\tif (!joycon_using_usb(ctlr)) {\n+\t\thid_dbg(hdev, \"no-op resume for bt ctlr\\n\");\n+\t\tctlr->ctlr_state = JOYCON_CTLR_STATE_READ;\n+\t\treturn 0;\n+\t}\n \n+\tret = joycon_init(hdev);\n \tif (ret)\n-\t\thid_err(hdev, \"Failed to restore controller after resume\");\n+\t\thid_err(hdev,\n+\t\t\t\"Failed to restore controller after resume: %d\\n\",\n+\t\t\tret);\n+\telse\n+\t\tctlr->ctlr_state = JOYCON_CTLR_STATE_READ;\n \n \treturn ret;\n }\n \n+static int nintendo_hid_suspend(struct hid_device *hdev, pm_message_t message)\n+{\n+\tstruct joycon_ctlr *ctlr = hid_get_drvdata(hdev);\n+\n+\thid_dbg(hdev, \"suspend: %d\\n\", message.event);\n+\t/*\n+\t * Avoid any blocking loops in suspend/resume transitions.\n+\t *\n+\t * joycon_enforce_subcmd_rate() can result in repeated retries if for\n+\t * whatever reason the controller stops providing input reports.\n+\t *\n+\t * This has been observed with bluetooth controllers which lose\n+\t * connectivity prior to suspend (but not long enough to result in\n+\t * complete disconnection).\n+\t */\n+\tctlr->ctlr_state = JOYCON_CTLR_STATE_SUSPENDED;\n+\treturn 0;\n+}\n+\n #endif\n \n static const struct hid_device_id nintendo_hid_devices[] = {\n@@ -2796,6 +2829,7 @@ static struct hid_driver nintendo_hid_driver = {\n \n #ifdef CONFIG_PM\n \t.resume\t\t= nintendo_hid_resume,\n+\t.suspend\t= nintendo_hid_suspend,\n #endif\n };\n static int __init nintendo_init(void)\ndiff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c\nindex 7fefeb413ec3..31508da93ba2 100644\n--- a/drivers/hid/hid-quirks.c\n+++ b/drivers/hid/hid-quirks.c\n@@ -757,6 +757,8 @@ static const struct hid_device_id hid_ignore_list[] = {\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_AVERMEDIA, USB_DEVICE_ID_AVER_FM_MR800) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_AXENTIA, USB_DEVICE_ID_AXENTIA_FM_RADIO) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_BERKSHIRE, USB_DEVICE_ID_BERKSHIRE_PCWD) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_HP_5MP_CAMERA) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_HP_5MP_CAMERA2) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_CIDC, 0x0103) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI470X) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI4713) },\n@@ -904,6 +906,7 @@ static const struct hid_device_id hid_ignore_list[] = {\n #endif\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },\n \t{ HID_USB_DEVICE(USB_VENDOR_ID_QUANTA, USB_DEVICE_ID_QUANTA_HP_5MP_CAMERA_5473) },\n+\t{ HID_USB_DEVICE(USB_VENDOR_ID_SMARTLINKTECHNOLOGY, USB_DEVICE_ID_SMARTLINKTECHNOLOGY_4155) },\n \t{ }\n };\n \ndiff --git a/drivers/hid/intel-ish-hid/ipc/hw-ish.h b/drivers/hid/intel-ish-hid/ipc/hw-ish.h\nindex 07e90d51f073..fa5d68c36313 100644\n--- a/drivers/hid/intel-ish-hid/ipc/hw-ish.h\n+++ b/drivers/hid/intel-ish-hid/ipc/hw-ish.h\n@@ -38,6 +38,7 @@\n #define PCI_DEVICE_ID_INTEL_ISH_LNL_M\t\t0xA845\n #define PCI_DEVICE_ID_INTEL_ISH_PTL_H\t\t0xE345\n #define PCI_DEVICE_ID_INTEL_ISH_PTL_P\t\t0xE445\n+#define PCI_DEVICE_ID_INTEL_ISH_WCL\t\t0x4D45\n \n #define\tREVISION_ID_CHT_A0\t0x6\n #define\tREVISION_ID_CHT_Ax_SI\t0x0\ndiff --git a/drivers/hid/intel-ish-hid/ipc/pci-ish.c b/drivers/hid/intel-ish-hid/ipc/pci-ish.c\nindex ff0fc8010072..c57483224db6 100644\n--- a/drivers/hid/intel-ish-hid/ipc/pci-ish.c\n+++ b/drivers/hid/intel-ish-hid/ipc/pci-ish.c\n@@ -27,10 +27,12 @@ enum ishtp_driver_data_index {\n \tISHTP_DRIVER_DATA_NONE,\n \tISHTP_DRIVER_DATA_LNL_M,\n \tISHTP_DRIVER_DATA_PTL,\n+\tISHTP_DRIVER_DATA_WCL,\n };\n \n #define ISH_FW_GEN_LNL_M \"lnlm\"\n #define ISH_FW_GEN_PTL \"ptl\"\n+#define ISH_FW_GEN_WCL \"wcl\"\n \n #define ISH_FIRMWARE_PATH(gen) \"intel/ish/ish_\" gen \".bin\"\n #define ISH_FIRMWARE_PATH_ALL \"intel/ish/ish_*.bin\"\n@@ -42,6 +44,9 @@ static struct ishtp_driver_data ishtp_driver_data[] = {\n \t[ISHTP_DRIVER_DATA_PTL] = {\n \t\t.fw_generation = ISH_FW_GEN_PTL,\n \t},\n+\t[ISHTP_DRIVER_DATA_WCL] = {\n+\t\t.fw_generation = ISH_FW_GEN_WCL,\n+\t},\n };\n \n static const struct pci_device_id ish_pci_tbl[] = {\n@@ -67,9 +72,10 @@ static const struct pci_device_id ish_pci_tbl[] = {\n \t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_MTL_P)},\n \t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_ARL_H)},\n \t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_ARL_S)},\n-\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_LNL_M), .driver_data = ISHTP_DRIVER_DATA_LNL_M},\n-\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_PTL_H), .driver_data = ISHTP_DRIVER_DATA_PTL},\n-\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ISH_PTL_P), .driver_data = ISHTP_DRIVER_DATA_PTL},\n+\t{PCI_DEVICE_DATA(INTEL, ISH_LNL_M, ISHTP_DRIVER_DATA_LNL_M)},\n+\t{PCI_DEVICE_DATA(INTEL, ISH_PTL_H, ISHTP_DRIVER_DATA_PTL)},\n+\t{PCI_DEVICE_DATA(INTEL, ISH_PTL_P, ISHTP_DRIVER_DATA_PTL)},\n+\t{PCI_DEVICE_DATA(INTEL, ISH_WCL, ISHTP_DRIVER_DATA_WCL)},\n \t{}\n };\n MODULE_DEVICE_TABLE(pci, ish_pci_tbl);\ndiff --git a/drivers/hid/intel-thc-hid/intel-quicki2c/quicki2c-protocol.c b/drivers/hid/intel-thc-hid/intel-quicki2c/quicki2c-protocol.c\nindex f493df0d5dc4..a63f8c833252 100644\n--- a/drivers/hid/intel-thc-hid/intel-quicki2c/quicki2c-protocol.c\n+++ b/drivers/hid/intel-thc-hid/intel-quicki2c/quicki2c-protocol.c\n@@ -4,6 +4,7 @@\n #include <linux/bitfield.h>\n #include <linux/hid.h>\n #include <linux/hid-over-i2c.h>\n+#include <linux/unaligned.h>\n \n #include \"intel-thc-dev.h\"\n #include \"intel-thc-dma.h\"\n@@ -200,6 +201,9 @@ int quicki2c_set_report(struct quicki2c_device *qcdev, u8 report_type,\n \n int quicki2c_reset(struct quicki2c_device *qcdev)\n {\n+\tu16 input_reg = le16_to_cpu(qcdev->dev_desc.input_reg);\n+\tsize_t read_len = HIDI2C_LENGTH_LEN;\n+\tu32 prd_len = read_len;\n \tint ret;\n \n \tqcdev->reset_ack = false;\n@@ -213,12 +217,32 @@ int quicki2c_reset(struct quicki2c_device *qcdev)\n \n \tret = wait_event_interruptible_timeout(qcdev->reset_ack_wq, qcdev->reset_ack,\n \t\t\t\t\t       HIDI2C_RESET_TIMEOUT * HZ);\n-\tif (ret <= 0 || !qcdev->reset_ack) {\n+\tif (qcdev->reset_ack)\n+\t\treturn 0;\n+\n+\t/*\n+\t * Manually read reset response if it wasn't received, in case reset interrupt\n+\t * was missed by touch device or THC hardware.\n+\t */\n+\tret = thc_tic_pio_read(qcdev->thc_hw, input_reg, read_len, &prd_len,\n+\t\t\t       (u32 *)qcdev->input_buf);\n+\tif (ret) {\n+\t\tdev_err_once(qcdev->dev, \"Read Reset Response failed, ret %d\\n\", ret);\n+\t\treturn ret;\n+\t}\n+\n+\t/*\n+\t * Check response packet length, it's first 16 bits of packet.\n+\t * If response packet length is zero, it's reset response, otherwise not.\n+\t */\n+\tif (get_unaligned_le16(qcdev->input_buf)) {\n \t\tdev_err_once(qcdev->dev,\n \t\t\t     \"Wait reset response timed out ret:%d timeout:%ds\\n\",\n \t\t\t     ret, HIDI2C_RESET_TIMEOUT);\n \t\treturn -ETIMEDOUT;\n \t}\n \n+\tqcdev->reset_ack = true;\n+\n \treturn 0;\n }\ndiff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c\nindex eaf099b2efdb..9a57504e51a1 100644\n--- a/drivers/hid/wacom_sys.c\n+++ b/drivers/hid/wacom_sys.c\n@@ -2048,14 +2048,18 @@ static int wacom_initialize_remotes(struct wacom *wacom)\n \n \tremote->remote_dir = kobject_create_and_add(\"wacom_remote\",\n \t\t\t\t\t\t    &wacom->hdev->dev.kobj);\n-\tif (!remote->remote_dir)\n+\tif (!remote->remote_dir) {\n+\t\tkfifo_free(&remote->remote_fifo);\n \t\treturn -ENOMEM;\n+\t}\n \n \terror = sysfs_create_files(remote->remote_dir, remote_unpair_attrs);\n \n \tif (error) {\n \t\thid_err(wacom->hdev,\n \t\t\t\"cannot create sysfs group err: %d\\n\", error);\n+\t\tkfifo_free(&remote->remote_fifo);\n+\t\tkobject_put(remote->remote_dir);\n \t\treturn error;\n \t}\n \n@@ -2901,6 +2905,7 @@ static void wacom_remove(struct hid_device *hdev)\n \thid_hw_stop(hdev);\n \n \tcancel_delayed_work_sync(&wacom->init_work);\n+\tcancel_delayed_work_sync(&wacom->aes_battery_work);\n \tcancel_work_sync(&wacom->wireless_work);\n \tcancel_work_sync(&wacom->battery_work);\n \tcancel_work_sync(&wacom->remote_work);",
    "stats": {
      "insertions": 114,
      "deletions": 13,
      "files": 11
    }
  }
]
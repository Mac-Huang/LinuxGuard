[
  {
    "sha": "c4dce0c094a89b1bc8fde1163342bd6fe29c0370",
    "message": "Merge tag 'spi-fix-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi\n\nPull spi fix from Mark Brown:\n \"One fix for a runtime PM underflow when removing the Cadence QuadSPI\n  driver\"\n\n* tag 'spi-fix-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi:\n  spi: spi-cadence-quadspi: Fix pm runtime unbalance",
    "author": "Linus Torvalds",
    "date": "2025-06-25T11:54:04-07:00",
    "files_changed": [
      "drivers/spi/spi-cadence-quadspi.c"
    ],
    "diff": "diff --git a/drivers/spi/spi-cadence-quadspi.c b/drivers/spi/spi-cadence-quadspi.c\nindex fe0f122f07b0..aa1932ba17cb 100644\n--- a/drivers/spi/spi-cadence-quadspi.c\n+++ b/drivers/spi/spi-cadence-quadspi.c\n@@ -1958,10 +1958,10 @@ static int cqspi_probe(struct platform_device *pdev)\n \t\t\tgoto probe_setup_failed;\n \t}\n \n-\tret = devm_pm_runtime_enable(dev);\n-\tif (ret) {\n-\t\tif (cqspi->rx_chan)\n-\t\t\tdma_release_channel(cqspi->rx_chan);\n+\tpm_runtime_enable(dev);\n+\n+\tif (cqspi->rx_chan) {\n+\t\tdma_release_channel(cqspi->rx_chan);\n \t\tgoto probe_setup_failed;\n \t}\n \n@@ -1981,6 +1981,7 @@ static int cqspi_probe(struct platform_device *pdev)\n \treturn 0;\n probe_setup_failed:\n \tcqspi_controller_enable(cqspi, 0);\n+\tpm_runtime_disable(dev);\n probe_reset_failed:\n \tif (cqspi->is_jh7110)\n \t\tcqspi_jh7110_disable_clk(pdev, cqspi);\n@@ -1999,7 +2000,8 @@ static void cqspi_remove(struct platform_device *pdev)\n \tif (cqspi->rx_chan)\n \t\tdma_release_channel(cqspi->rx_chan);\n \n-\tclk_disable_unprepare(cqspi->clk);\n+\tif (pm_runtime_get_sync(&pdev->dev) >= 0)\n+\t\tclk_disable(cqspi->clk);\n \n \tif (cqspi->is_jh7110)\n \t\tcqspi_jh7110_disable_clk(pdev, cqspi);",
    "stats": {
      "insertions": 7,
      "deletions": 5,
      "files": 1
    }
  },
  {
    "sha": "92ca6c498a5e6e2083b520b82d318e7e525f3e7c",
    "message": "Merge tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi\n\nPull SCSI fixes from James Bottomley:\n \"Fixes all in drivers.\n\n  ufs and megaraid_sas are small and obvious.\n\n  The large diffstat in fnic comes from two pieces: the addition of\n  quite a bit of logging (no change to function) and the reworking of\n  the timeout allocation path for the two conditions that can occur\n  simultaneously to prevent reusing the same abort frame and then both\n  trying to free it\"\n\n* tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi:\n  scsi: fnic: Fix missing DMA mapping error in fnic_send_frame()\n  scsi: fnic: Set appropriate logging level for log message\n  scsi: fnic: Add and improve logs in FDMI and FDMI ABTS paths\n  scsi: fnic: Turn off FDMI ACTIVE flags on link down\n  scsi: fnic: Fix crash in fnic_wq_cmpl_handler when FDMI times out\n  scsi: ufs: core: Fix clk scaling to be conditional in reset and restore\n  scsi: megaraid_sas: Fix invalid node index",
    "author": "Linus Torvalds",
    "date": "2025-06-25T11:20:14-07:00",
    "files_changed": [
      "drivers/scsi/fnic/fdls_disc.c",
      "drivers/scsi/fnic/fnic.h",
      "drivers/scsi/fnic/fnic_fcs.c",
      "drivers/scsi/fnic/fnic_fdls.h",
      "drivers/scsi/fnic/fnic_scsi.c",
      "drivers/scsi/megaraid/megaraid_sas_base.c",
      "drivers/ufs/core/ufshcd.c"
    ],
    "diff": "diff --git a/drivers/scsi/fnic/fdls_disc.c b/drivers/scsi/fnic/fdls_disc.c\nindex f8ab69c51dab..ae37f85f618b 100644\n--- a/drivers/scsi/fnic/fdls_disc.c\n+++ b/drivers/scsi/fnic/fdls_disc.c\n@@ -763,50 +763,86 @@ static void fdls_send_fabric_abts(struct fnic_iport_s *iport)\n \tiport->fabric.timer_pending = 1;\n }\n \n-static void fdls_send_fdmi_abts(struct fnic_iport_s *iport)\n+static uint8_t *fdls_alloc_init_fdmi_abts_frame(struct fnic_iport_s *iport,\n+\t\tuint16_t oxid)\n {\n-\tuint8_t *frame;\n+\tstruct fc_frame_header *pfdmi_abts;\n \tuint8_t d_id[3];\n+\tuint8_t *frame;\n \tstruct fnic *fnic = iport->fnic;\n-\tstruct fc_frame_header *pfabric_abts;\n-\tunsigned long fdmi_tov;\n-\tuint16_t oxid;\n-\tuint16_t frame_size = FNIC_ETH_FCOE_HDRS_OFFSET +\n-\t\t\tsizeof(struct fc_frame_header);\n \n \tframe = fdls_alloc_frame(iport);\n \tif (frame == NULL) {\n \t\tFNIC_FCS_DBG(KERN_ERR, fnic->host, fnic->fnic_num,\n \t\t\t\t\"Failed to allocate frame to send FDMI ABTS\");\n-\t\treturn;\n+\t\treturn NULL;\n \t}\n \n-\tpfabric_abts = (struct fc_frame_header *) (frame + FNIC_ETH_FCOE_HDRS_OFFSET);\n+\tpfdmi_abts = (struct fc_frame_header *) (frame + FNIC_ETH_FCOE_HDRS_OFFSET);\n \tfdls_init_fabric_abts_frame(frame, iport);\n \n \thton24(d_id, FC_FID_MGMT_SERV);\n-\tFNIC_STD_SET_D_ID(*pfabric_abts, d_id);\n+\tFNIC_STD_SET_D_ID(*pfdmi_abts, d_id);\n+\tFNIC_STD_SET_OX_ID(*pfdmi_abts, oxid);\n+\n+\treturn frame;\n+}\n+\n+static void fdls_send_fdmi_abts(struct fnic_iport_s *iport)\n+{\n+\tuint8_t *frame;\n+\tstruct fnic *fnic = iport->fnic;\n+\tunsigned long fdmi_tov;\n+\tuint16_t frame_size = FNIC_ETH_FCOE_HDRS_OFFSET +\n+\t\t\tsizeof(struct fc_frame_header);\n \n \tif (iport->fabric.fdmi_pending & FDLS_FDMI_PLOGI_PENDING) {\n-\t\toxid = iport->active_oxid_fdmi_plogi;\n-\t\tFNIC_STD_SET_OX_ID(*pfabric_abts, oxid);\n+\t\tframe = fdls_alloc_init_fdmi_abts_frame(iport,\n+\t\t\t\t\t\tiport->active_oxid_fdmi_plogi);\n+\t\tif (frame == NULL)\n+\t\t\treturn;\n+\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: FDLS send FDMI PLOGI abts. iport->fabric.state: %d oxid: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_plogi);\n \t\tfnic_send_fcoe_frame(iport, frame, frame_size);\n \t} else {\n \t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING) {\n-\t\t\toxid = iport->active_oxid_fdmi_rhba;\n-\t\t\tFNIC_STD_SET_OX_ID(*pfabric_abts, oxid);\n+\t\t\tframe = fdls_alloc_init_fdmi_abts_frame(iport,\n+\t\t\t\t\t\tiport->active_oxid_fdmi_rhba);\n+\t\t\tif (frame == NULL)\n+\t\t\t\treturn;\n+\n+\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\t \"0x%x: FDLS send FDMI RHBA abts. iport->fabric.state: %d oxid: 0x%x\",\n+\t\t\t\t iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_rhba);\n \t\t\tfnic_send_fcoe_frame(iport, frame, frame_size);\n \t\t}\n \t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING) {\n-\t\t\toxid = iport->active_oxid_fdmi_rpa;\n-\t\t\tFNIC_STD_SET_OX_ID(*pfabric_abts, oxid);\n+\t\t\tframe = fdls_alloc_init_fdmi_abts_frame(iport,\n+\t\t\t\t\t\tiport->active_oxid_fdmi_rpa);\n+\t\t\tif (frame == NULL) {\n+\t\t\t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING)\n+\t\t\t\t\tgoto arm_timer;\n+\t\t\t\telse\n+\t\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\t \"0x%x: FDLS send FDMI RPA abts. iport->fabric.state: %d oxid: 0x%x\",\n+\t\t\t\t iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_rpa);\n \t\t\tfnic_send_fcoe_frame(iport, frame, frame_size);\n \t\t}\n \t}\n \n+arm_timer:\n \tfdmi_tov = jiffies + msecs_to_jiffies(2 * iport->e_d_tov);\n \tmod_timer(&iport->fabric.fdmi_timer, round_jiffies(fdmi_tov));\n \tiport->fabric.fdmi_pending |= FDLS_FDMI_ABORT_PENDING;\n+\n+\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t iport->fcid, iport->fabric.fdmi_pending);\n }\n \n static void fdls_send_fabric_flogi(struct fnic_iport_s *iport)\n@@ -2245,6 +2281,21 @@ void fdls_fabric_timer_callback(struct timer_list *t)\n \tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n }\n \n+void fdls_fdmi_retry_plogi(struct fnic_iport_s *iport)\n+{\n+\tstruct fnic *fnic = iport->fnic;\n+\n+\tiport->fabric.fdmi_pending = 0;\n+\t/* If max retries not exhausted, start over from fdmi plogi */\n+\tif (iport->fabric.fdmi_retry < FDLS_FDMI_MAX_RETRY) {\n+\t\tiport->fabric.fdmi_retry++;\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\t\t \"Retry FDMI PLOGI. FDMI retry: %d\",\n+\t\t\t\t\t iport->fabric.fdmi_retry);\n+\t\tfdls_send_fdmi_plogi(iport);\n+\t}\n+}\n+\n void fdls_fdmi_timer_callback(struct timer_list *t)\n {\n \tstruct fnic_fdls_fabric_s *fabric = timer_container_of(fabric, t,\n@@ -2257,7 +2308,7 @@ void fdls_fdmi_timer_callback(struct timer_list *t)\n \tspin_lock_irqsave(&fnic->fnic_lock, flags);\n \n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\"fdmi timer callback : 0x%x\\n\", iport->fabric.fdmi_pending);\n+\t\t\"iport->fabric.fdmi_pending: 0x%x\\n\", iport->fabric.fdmi_pending);\n \n \tif (!iport->fabric.fdmi_pending) {\n \t\t/* timer expired after fdmi responses received. */\n@@ -2265,7 +2316,7 @@ void fdls_fdmi_timer_callback(struct timer_list *t)\n \t\treturn;\n \t}\n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\"fdmi timer callback : 0x%x\\n\", iport->fabric.fdmi_pending);\n+\t\t\"iport->fabric.fdmi_pending: 0x%x\\n\", iport->fabric.fdmi_pending);\n \n \t/* if not abort pending, send an abort */\n \tif (!(iport->fabric.fdmi_pending & FDLS_FDMI_ABORT_PENDING)) {\n@@ -2274,33 +2325,37 @@ void fdls_fdmi_timer_callback(struct timer_list *t)\n \t\treturn;\n \t}\n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\"fdmi timer callback : 0x%x\\n\", iport->fabric.fdmi_pending);\n+\t\t\"iport->fabric.fdmi_pending: 0x%x\\n\", iport->fabric.fdmi_pending);\n \n \t/* ABTS pending for an active fdmi request that is pending.\n \t * That means FDMI ABTS timed out\n \t * Schedule to free the OXID after 2*r_a_tov and proceed\n \t */\n \tif (iport->fabric.fdmi_pending & FDLS_FDMI_PLOGI_PENDING) {\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\"FDMI PLOGI ABTS timed out. Schedule oxid free: 0x%x\\n\",\n+\t\t\tiport->active_oxid_fdmi_plogi);\n \t\tfdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_plogi);\n \t} else {\n-\t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING)\n+\t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING) {\n+\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\t\t\t\"FDMI RHBA ABTS timed out. Schedule oxid free: 0x%x\\n\",\n+\t\t\t\t\t\tiport->active_oxid_fdmi_rhba);\n \t\t\tfdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_rhba);\n-\t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING)\n+\t\t}\n+\t\tif (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING) {\n+\t\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\t\t\t\"FDMI RPA ABTS timed out. Schedule oxid free: 0x%x\\n\",\n+\t\t\t\t\t\tiport->active_oxid_fdmi_rpa);\n \t\t\tfdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_rpa);\n+\t\t}\n \t}\n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\"fdmi timer callback : 0x%x\\n\", iport->fabric.fdmi_pending);\n+\t\t\"iport->fabric.fdmi_pending: 0x%x\\n\", iport->fabric.fdmi_pending);\n \n-\tiport->fabric.fdmi_pending = 0;\n-\t/* If max retries not exhaused, start over from fdmi plogi */\n-\tif (iport->fabric.fdmi_retry < FDLS_FDMI_MAX_RETRY) {\n-\t\tiport->fabric.fdmi_retry++;\n-\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\t\t\t \"retry fdmi timer %d\", iport->fabric.fdmi_retry);\n-\t\tfdls_send_fdmi_plogi(iport);\n-\t}\n+\tfdls_fdmi_retry_plogi(iport);\n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n-\t\t\"fdmi timer callback : 0x%x\\n\", iport->fabric.fdmi_pending);\n+\t\t\"iport->fabric.fdmi_pending: 0x%x\\n\", iport->fabric.fdmi_pending);\n \tspin_unlock_irqrestore(&fnic->fnic_lock, flags);\n }\n \n@@ -3715,13 +3770,60 @@ static void fdls_process_fdmi_abts_rsp(struct fnic_iport_s *iport,\n \n \tswitch (FNIC_FRAME_TYPE(oxid)) {\n \tcase FNIC_FRAME_TYPE_FDMI_PLOGI:\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\"Received FDMI PLOGI ABTS rsp with oxid: 0x%x\", oxid);\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n \t\tfdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_plogi);\n+\n+\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_PLOGI_PENDING;\n+\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n \t\tbreak;\n \tcase FNIC_FRAME_TYPE_FDMI_RHBA:\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\"Received FDMI RHBA ABTS rsp with oxid: 0x%x\", oxid);\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n+\n+\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_REG_HBA_PENDING;\n+\n+\t\t/* If RPA is still pending, don't turn off ABORT PENDING.\n+\t\t * We count on the timer to detect the ABTS timeout and take\n+\t\t * corrective action.\n+\t\t */\n+\t\tif (!(iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING))\n+\t\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;\n+\n \t\tfdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_rhba);\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n \t\tbreak;\n \tcase FNIC_FRAME_TYPE_FDMI_RPA:\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t\"Received FDMI RPA ABTS rsp with oxid: 0x%x\", oxid);\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n+\n+\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_RPA_PENDING;\n+\n+\t\t/* If RHBA is still pending, don't turn off ABORT PENDING.\n+\t\t * We count on the timer to detect the ABTS timeout and take\n+\t\t * corrective action.\n+\t\t */\n+\t\tif (!(iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING))\n+\t\t\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;\n+\n \t\tfdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_rpa);\n+\t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\t\t \"0x%x: iport->fabric.fdmi_pending: 0x%x\",\n+\t\t\t iport->fcid, iport->fabric.fdmi_pending);\n \t\tbreak;\n \tdefault:\n \t\tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n@@ -3730,10 +3832,16 @@ static void fdls_process_fdmi_abts_rsp(struct fnic_iport_s *iport,\n \t\tbreak;\n \t}\n \n-\ttimer_delete_sync(&iport->fabric.fdmi_timer);\n-\tiport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;\n-\n-\tfdls_send_fdmi_plogi(iport);\n+\t/*\n+\t * Only if ABORT PENDING is off, delete the timer, and if no other\n+\t * operations are pending, retry FDMI.\n+\t * Otherwise, let the timer pop and take the appropriate action.\n+\t */\n+\tif (!(iport->fabric.fdmi_pending & FDLS_FDMI_ABORT_PENDING)) {\n+\t\ttimer_delete_sync(&iport->fabric.fdmi_timer);\n+\t\tif (!iport->fabric.fdmi_pending)\n+\t\t\tfdls_fdmi_retry_plogi(iport);\n+\t}\n }\n \n static void\n@@ -4972,9 +5080,12 @@ void fnic_fdls_link_down(struct fnic_iport_s *iport)\n \t\tfdls_delete_tport(iport, tport);\n \t}\n \n-\tif ((fnic_fdmi_support == 1) && (iport->fabric.fdmi_pending > 0)) {\n-\t\ttimer_delete_sync(&iport->fabric.fdmi_timer);\n-\t\tiport->fabric.fdmi_pending = 0;\n+\tif (fnic_fdmi_support == 1) {\n+\t\tif (iport->fabric.fdmi_pending > 0) {\n+\t\t\ttimer_delete_sync(&iport->fabric.fdmi_timer);\n+\t\t\tiport->fabric.fdmi_pending = 0;\n+\t\t}\n+\t\tiport->flags &= ~FNIC_FDMI_ACTIVE;\n \t}\n \n \tFNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\ndiff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h\nindex 6c5f6046b1f5..c2fdc6553e62 100644\n--- a/drivers/scsi/fnic/fnic.h\n+++ b/drivers/scsi/fnic/fnic.h\n@@ -30,7 +30,7 @@\n \n #define DRV_NAME\t\t\"fnic\"\n #define DRV_DESCRIPTION\t\t\"Cisco FCoE HBA Driver\"\n-#define DRV_VERSION\t\t\"1.8.0.0\"\n+#define DRV_VERSION\t\t\"1.8.0.2\"\n #define PFX\t\t\tDRV_NAME \": \"\n #define DFX                     DRV_NAME \"%d: \"\n \ndiff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c\nindex 1e8cd64f9a5c..103ab6f1f7cd 100644\n--- a/drivers/scsi/fnic/fnic_fcs.c\n+++ b/drivers/scsi/fnic/fnic_fcs.c\n@@ -636,6 +636,8 @@ static int fnic_send_frame(struct fnic *fnic, void *frame, int frame_len)\n \tunsigned long flags;\n \n \tpa = dma_map_single(&fnic->pdev->dev, frame, frame_len, DMA_TO_DEVICE);\n+\tif (dma_mapping_error(&fnic->pdev->dev, pa))\n+\t\treturn -ENOMEM;\n \n \tif ((fnic_fc_trace_set_data(fnic->fnic_num,\n \t\t\t\tFNIC_FC_SEND | 0x80, (char *) frame,\ndiff --git a/drivers/scsi/fnic/fnic_fdls.h b/drivers/scsi/fnic/fnic_fdls.h\nindex 8e610b65ad57..531d0b37e450 100644\n--- a/drivers/scsi/fnic/fnic_fdls.h\n+++ b/drivers/scsi/fnic/fnic_fdls.h\n@@ -394,6 +394,7 @@ void fdls_send_tport_abts(struct fnic_iport_s *iport,\n bool fdls_delete_tport(struct fnic_iport_s *iport,\n \t\t       struct fnic_tport_s *tport);\n void fdls_fdmi_timer_callback(struct timer_list *t);\n+void fdls_fdmi_retry_plogi(struct fnic_iport_s *iport);\n \n /* fnic_fcs.c */\n void fnic_fdls_init(struct fnic *fnic, int usefip);\ndiff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c\nindex 7133b254cbe4..75b29a018d1f 100644\n--- a/drivers/scsi/fnic/fnic_scsi.c\n+++ b/drivers/scsi/fnic/fnic_scsi.c\n@@ -1046,7 +1046,7 @@ static void fnic_fcpio_icmnd_cmpl_handler(struct fnic *fnic, unsigned int cq_ind\n \t\tif (icmnd_cmpl->scsi_status == SAM_STAT_TASK_SET_FULL)\n \t\t\tatomic64_inc(&fnic_stats->misc_stats.queue_fulls);\n \n-\t\tFNIC_SCSI_DBG(KERN_INFO, fnic->host, fnic->fnic_num,\n+\t\tFNIC_SCSI_DBG(KERN_DEBUG, fnic->host, fnic->fnic_num,\n \t\t\t\t\"xfer_len: %llu\", xfer_len);\n \t\tbreak;\n \ndiff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c\nindex 3aac0e17cb00..9179f8aee964 100644\n--- a/drivers/scsi/megaraid/megaraid_sas_base.c\n+++ b/drivers/scsi/megaraid/megaraid_sas_base.c\n@@ -5910,7 +5910,11 @@ megasas_set_high_iops_queue_affinity_and_hint(struct megasas_instance *instance)\n \tconst struct cpumask *mask;\n \n \tif (instance->perf_mode == MR_BALANCED_PERF_MODE) {\n-\t\tmask = cpumask_of_node(dev_to_node(&instance->pdev->dev));\n+\t\tint nid = dev_to_node(&instance->pdev->dev);\n+\n+\t\tif (nid == NUMA_NO_NODE)\n+\t\t\tnid = 0;\n+\t\tmask = cpumask_of_node(nid);\n \n \t\tfor (i = 0; i < instance->low_latency_index_start; i++) {\n \t\t\tirq = pci_irq_vector(instance->pdev, i);\ndiff --git a/drivers/ufs/core/ufshcd.c b/drivers/ufs/core/ufshcd.c\nindex f62d89c8e580..50adfb8b335b 100644\n--- a/drivers/ufs/core/ufshcd.c\n+++ b/drivers/ufs/core/ufshcd.c\n@@ -7807,7 +7807,8 @@ static int ufshcd_host_reset_and_restore(struct ufs_hba *hba)\n \thba->silence_err_logs = false;\n \n \t/* scale up clocks to max frequency before full reinitialization */\n-\tufshcd_scale_clks(hba, ULONG_MAX, true);\n+\tif (ufshcd_is_clkscaling_supported(hba))\n+\t\tufshcd_scale_clks(hba, ULONG_MAX, true);\n \n \terr = ufshcd_hba_enable(hba);\n ",
    "stats": {
      "insertions": 161,
      "deletions": 42,
      "files": 7
    }
  },
  {
    "sha": "010c40c1f50eecab3cdeaa895808294ad0c4f000",
    "message": "Merge tag 'wireless-2025-06-25' of https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless\n\nJohannes Berg says:\n\n====================\nJust a few fixes:\n - iwlegacy: work around large stack with clang/kasan\n - mac80211: fix integer overflow\n - mac80211: fix link struct init vs. RCU publish\n - iwlwifi: fix warning on IFF_UP\n\n* tag 'wireless-2025-06-25' of https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless:\n  wifi: mac80211: finish link init before RCU publish\n  wifi: iwlwifi: mvm: assume '1' as the default mac_config_cmd version\n  wifi: mac80211: fix beacon interval calculation overflow\n  wifi: iwlegacy: work around excessive stack usage on clang/kasan\n====================\n\nLink: https://patch.msgid.link/20250625115433.41381-3-johannes@sipsolutions.net\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-06-25T10:26:16-07:00",
    "files_changed": [
      "drivers/net/wireless/intel/iwlegacy/4965-rs.c",
      "drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c",
      "net/mac80211/link.c",
      "net/mac80211/util.c"
    ],
    "diff": "diff --git a/drivers/net/wireless/intel/iwlegacy/4965-rs.c b/drivers/net/wireless/intel/iwlegacy/4965-rs.c\nindex 0e5130d1fccd..031d88bf6393 100644\n--- a/drivers/net/wireless/intel/iwlegacy/4965-rs.c\n+++ b/drivers/net/wireless/intel/iwlegacy/4965-rs.c\n@@ -203,7 +203,8 @@ il4965_rs_extract_rate(u32 rate_n_flags)\n \treturn (u8) (rate_n_flags & 0xFF);\n }\n \n-static void\n+/* noinline works around https://github.com/llvm/llvm-project/issues/143908 */\n+static noinline_for_stack void\n il4965_rs_rate_scale_clear_win(struct il_rate_scale_data *win)\n {\n \twin->data = 0;\ndiff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c b/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\nindex 3c255ae916c8..3f8b840871d3 100644\n--- a/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\n+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\n@@ -32,9 +32,9 @@ static void iwl_mvm_mld_mac_ctxt_cmd_common(struct iwl_mvm *mvm,\n \tunsigned int link_id;\n \tint cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n \t\t\t\t\t    WIDE_ID(MAC_CONF_GROUP,\n-\t\t\t\t\t\t    MAC_CONFIG_CMD), 0);\n+\t\t\t\t\t\t    MAC_CONFIG_CMD), 1);\n \n-\tif (WARN_ON(cmd_ver < 1 || cmd_ver > 3))\n+\tif (WARN_ON(cmd_ver > 3))\n \t\treturn;\n \n \tcmd->id_and_color = cpu_to_le32(mvmvif->id);\ndiff --git a/net/mac80211/link.c b/net/mac80211/link.c\nindex d40c2bd3b50b..4f7b7d0f64f2 100644\n--- a/net/mac80211/link.c\n+++ b/net/mac80211/link.c\n@@ -93,9 +93,6 @@ void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,\n \tif (link_id < 0)\n \t\tlink_id = 0;\n \n-\trcu_assign_pointer(sdata->vif.link_conf[link_id], link_conf);\n-\trcu_assign_pointer(sdata->link[link_id], link);\n-\n \tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n \t\tstruct ieee80211_sub_if_data *ap_bss;\n \t\tstruct ieee80211_bss_conf *ap_bss_conf;\n@@ -145,6 +142,9 @@ void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,\n \n \t\tieee80211_link_debugfs_add(link);\n \t}\n+\n+\trcu_assign_pointer(sdata->vif.link_conf[link_id], link_conf);\n+\trcu_assign_pointer(sdata->link[link_id], link);\n }\n \n void ieee80211_link_stop(struct ieee80211_link_data *link)\ndiff --git a/net/mac80211/util.c b/net/mac80211/util.c\nindex 27d414efa3fd..a125995ed252 100644\n--- a/net/mac80211/util.c\n+++ b/net/mac80211/util.c\n@@ -3884,7 +3884,7 @@ void ieee80211_recalc_dtim(struct ieee80211_local *local,\n {\n \tu64 tsf = drv_get_tsf(local, sdata);\n \tu64 dtim_count = 0;\n-\tu16 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;\n+\tu32 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;\n \tu8 dtim_period = sdata->vif.bss_conf.dtim_period;\n \tstruct ps_data *ps;\n \tu8 bcns_from_dtim;",
    "stats": {
      "insertions": 8,
      "deletions": 7,
      "files": 4
    }
  },
  {
    "sha": "fa787ac07b3ceb56dd88a62d1866038498e96230",
    "message": "KVM: x86/hyper-v: Skip non-canonical addresses during PV TLB flush\n\nIn KVM guests with Hyper-V hypercalls enabled, the hypercalls\nHVCALL_FLUSH_VIRTUAL_ADDRESS_LIST and HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX\nallow a guest to request invalidation of portions of a virtual TLB.\nFor this, the hypercall parameter includes a list of GVAs that are supposed\nto be invalidated.\n\nHowever, when non-canonical GVAs are passed, there is currently no\nfiltering in place and they are eventually passed to checked invocations of\nINVVPID on Intel / INVLPGA on AMD.  While AMD's INVLPGA silently ignores\nnon-canonical addresses (effectively a no-op), Intel's INVVPID explicitly\nsignals VM-Fail and ultimately triggers the WARN_ONCE in invvpid_error():\n\n  invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000\n  WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482\n  invvpid_error+0x91/0xa0 [kvm_intel]\n  Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse\n  CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary)\n  RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel]\n  Call Trace:\n    vmx_flush_tlb_gva+0x320/0x490 [kvm_intel]\n    kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm]\n    kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm]\n\nHyper-V documents that invalid GVAs (those that are beyond a partition's\nGVA space) are to be ignored.  While not completely clear whether this\nruling also applies to non-canonical GVAs, it is likely fine to make that\nassumption, and manual testing on Azure confirms \"real\" Hyper-V interprets\nthe specification in the same way.\n\nSkip non-canonical GVAs when processing the list of address to avoid\ntripping the INVVPID failure.  Alternatively, KVM could filter out \"bad\"\nGVAs before inserting into the FIFO, but practically speaking the only\ndownside of pushing validation to the final processing is that doing so\nis suboptimal for the guest, and no well-behaved guest will request TLB\nflushes for non-canonical addresses.\n\nFixes: 260970862c88 (\"KVM: x86: hyper-v: Handle HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST{,EX} calls gently\")\nCc: stable@vger.kernel.org\nSigned-off-by: Manuel Andreas <manuel.andreas@tum.de>\nSuggested-by: Vitaly Kuznetsov <vkuznets@redhat.com>\nLink: https://lore.kernel.org/r/c090efb3-ef82-499f-a5e0-360fc8420fb7@tum.de\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
    "author": "Manuel Andreas",
    "date": "2025-06-25T09:15:24-07:00",
    "files_changed": [
      "arch/x86/kvm/hyperv.c"
    ],
    "diff": "diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c\nindex 75221a11e15e..ee27064dd72f 100644\n--- a/arch/x86/kvm/hyperv.c\n+++ b/arch/x86/kvm/hyperv.c\n@@ -1979,6 +1979,9 @@ int kvm_hv_vcpu_flush_tlb(struct kvm_vcpu *vcpu)\n \t\tif (entries[i] == KVM_HV_TLB_FLUSHALL_ENTRY)\n \t\t\tgoto out_flush_all;\n \n+\t\tif (is_noncanonical_invlpg_address(entries[i], vcpu))\n+\t\t\tcontinue;\n+\n \t\t/*\n \t\t * Lower 12 bits of 'address' encode the number of additional\n \t\t * pages to flush.",
    "stats": {
      "insertions": 3,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "7cac633a42a7b3c8146eb1db76fb80dc652998de",
    "message": "io_uring: fix resource leak in io_import_dmabuf()\n\nReplace the return statement with setting ret = -EINVAL and jumping to\nthe err label to ensure resources are released via io_release_dmabuf.\n\nFixes: a5c98e942457 (\"io_uring/zcrx: dmabuf backed zerocopy receive\")\nSigned-off-by: Penglei Jiang <superman.xpt@gmail.com>\nLink: https://lore.kernel.org/r/20250625102703.68336-1-superman.xpt@gmail.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "author": "Penglei Jiang",
    "date": "2025-06-25T08:14:14-06:00",
    "files_changed": [
      "io_uring/zcrx.c"
    ],
    "diff": "diff --git a/io_uring/zcrx.c b/io_uring/zcrx.c\nindex 21c816c3bfe0..ade4da9c4e31 100644\n--- a/io_uring/zcrx.c\n+++ b/io_uring/zcrx.c\n@@ -106,8 +106,10 @@ static int io_import_dmabuf(struct io_zcrx_ifq *ifq,\n \tfor_each_sgtable_dma_sg(mem->sgt, sg, i)\n \t\ttotal_size += sg_dma_len(sg);\n \n-\tif (total_size < off + len)\n-\t\treturn -EINVAL;\n+\tif (total_size < off + len) {\n+\t\tret = -EINVAL;\n+\t\tgoto err;\n+\t}\n \n \tmem->dmabuf_offset = off;\n \tmem->size = len;",
    "stats": {
      "insertions": 4,
      "deletions": 2,
      "files": 1
    }
  }
]
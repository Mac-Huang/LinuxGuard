[
  {
    "sha": "51df97f90002cb055e966189bd46d831af69e155",
    "message": "Merge tag 's390-6.16-3' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux\n\nPull s390 fixes from Alexander Gordeev:\n\n - Fix incorrectly dropped dereferencing of the stack nth entry\n   introduced with a previous KASAN false positive fix\n\n - Use a proper memdup_array_user() helper to prevent overflow in a\n   protected key size calculation\n\n* tag 's390-6.16-3' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux:\n  s390/ptrace: Fix pointer dereferencing in regs_get_kernel_stack_nth()\n  s390/pkey: Prevent overflow in size calculation for memdup_user()",
    "author": "Linus Torvalds",
    "date": "2025-06-27T08:26:25-07:00",
    "files_changed": [
      "arch/s390/include/asm/ptrace.h",
      "drivers/s390/crypto/pkey_api.c"
    ],
    "diff": "diff --git a/arch/s390/include/asm/ptrace.h b/arch/s390/include/asm/ptrace.h\nindex 62c0ab4a4b9d..0905fa99a31e 100644\n--- a/arch/s390/include/asm/ptrace.h\n+++ b/arch/s390/include/asm/ptrace.h\n@@ -265,7 +265,7 @@ static __always_inline unsigned long regs_get_kernel_stack_nth(struct pt_regs *r\n \taddr = kernel_stack_pointer(regs) + n * sizeof(long);\n \tif (!regs_within_kernel_stack(regs, addr))\n \t\treturn 0;\n-\treturn READ_ONCE_NOCHECK(addr);\n+\treturn READ_ONCE_NOCHECK(*(unsigned long *)addr);\n }\n \n /**\ndiff --git a/drivers/s390/crypto/pkey_api.c b/drivers/s390/crypto/pkey_api.c\nindex cef60770f68b..b3fcdcae379e 100644\n--- a/drivers/s390/crypto/pkey_api.c\n+++ b/drivers/s390/crypto/pkey_api.c\n@@ -86,7 +86,7 @@ static void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)\n \tif (!uapqns || nr_apqns == 0)\n \t\treturn NULL;\n \n-\treturn memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));\n+\treturn memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));\n }\n \n static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)",
    "stats": {
      "insertions": 2,
      "deletions": 2,
      "files": 2
    }
  },
  {
    "sha": "9c2f970518c900821acdac47bbd681b99a325e3d",
    "message": "Merge tag 'sound-6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound\n\nPull sound fixes from Takashi Iwai:\n \"A collection of small fixes again:\n\n   - A regression fix for hibernation bug in ASoC SoundWire\n\n   - Fixes for the new Qualcomm USB offload stuff\n\n   - A potential OOB access fix in USB-audio\n\n   - A potential memleadk fix in ASoC Intel\n\n   - Quirks for HD-audio and ASoC AMD ACP\"\n\n* tag 'sound-6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:\n  ALSA: hda/realtek: Fix built-in mic on ASUS VivoBook X507UAR\n  ALSA: usb: qcom: fix NULL pointer dereference in qmi_stop_session\n  ASoC: SOF: Intel: hda: Use devm_kstrdup() to avoid memleak.\n  ASoC: rt721-sdca: fix boost gain calculation error\n  ALSA: qc_audio_offload: Fix missing error code in prepare_qmi_response()\n  ALSA: hda/realtek: Add mic-mute LED setup for ASUS UM5606\n  ALSA: usb-audio: Fix out-of-bounds read in snd_usb_get_audioformat_uac3()\n  ALSA: hda/realtek: fix mute/micmute LEDs for HP EliteBook 6 G1a\n  ASoC: amd: ps: fix for soundwire failures during hibernation exit sequence\n  ASoC: amd: yc: Add DMI quirk for Lenovo IdeaPad Slim 5 15\n  ASoC: amd: yc: add quirk for Acer Nitro ANV15-41 internal mic\n  ASoC: qcom: sm8250: Fix possibly undefined reference\n  ALSA: hda/realtek - Enable mute LED on HP Pavilion Laptop 15-eg100\n  ALSA: hda/realtek: Add quirks for some Clevo laptops",
    "author": "Linus Torvalds",
    "date": "2025-06-27T08:21:05-07:00",
    "files_changed": [
      "sound/pci/hda/patch_realtek.c",
      "sound/soc/amd/ps/acp63.h",
      "sound/soc/amd/ps/ps-common.c",
      "sound/soc/amd/yc/acp6x-mach.c",
      "sound/soc/codecs/rt721-sdca.c",
      "sound/soc/sof/intel/hda.c",
      "sound/usb/qcom/qc_audio_offload.c",
      "sound/usb/stream.c"
    ],
    "diff": "diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c\nindex 2e1618494c20..5d6d01ecfee2 100644\n--- a/sound/pci/hda/patch_realtek.c\n+++ b/sound/pci/hda/patch_realtek.c\n@@ -2656,6 +2656,7 @@ static const struct hda_quirk alc882_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x147b, 0x107a, \"Abit AW9D-MAX\", ALC882_FIXUP_ABIT_AW9D_MAX),\n \tSND_PCI_QUIRK(0x1558, 0x3702, \"Clevo X370SN[VW]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n \tSND_PCI_QUIRK(0x1558, 0x50d3, \"Clevo PC50[ER][CDF]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n+\tSND_PCI_QUIRK(0x1558, 0x5802, \"Clevo X58[05]WN[RST]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n \tSND_PCI_QUIRK(0x1558, 0x65d1, \"Clevo PB51[ER][CDF]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n \tSND_PCI_QUIRK(0x1558, 0x65d2, \"Clevo PB51R[CDF]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n \tSND_PCI_QUIRK(0x1558, 0x65e1, \"Clevo PB51[ED][DF]\", ALC1220_FIXUP_CLEVO_PB51ED_PINS),\n@@ -6609,6 +6610,7 @@ static void alc294_fixup_bass_speaker_15(struct hda_codec *codec,\n \tif (action == HDA_FIXUP_ACT_PRE_PROBE) {\n \t\tstatic const hda_nid_t conn[] = { 0x02, 0x03 };\n \t\tsnd_hda_override_conn_list(codec, 0x15, ARRAY_SIZE(conn), conn);\n+\t\tsnd_hda_gen_add_micmute_led_cdev(codec, NULL);\n \t}\n }\n \n@@ -10737,6 +10739,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8975, \"HP EliteBook x360 840 Aero G9\", ALC245_FIXUP_CS35L41_SPI_2_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x897d, \"HP mt440 Mobile Thin Client U74\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8981, \"HP Elite Dragonfly G3\", ALC245_FIXUP_CS35L41_SPI_4),\n+\tSND_PCI_QUIRK(0x103c, 0x898a, \"HP Pavilion 15-eg100\", ALC287_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x898e, \"HP EliteBook 835 G9\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x898f, \"HP EliteBook 835 G9\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8991, \"HP EliteBook 845 G9\", ALC287_FIXUP_CS35L41_I2C_2_HP_GPIO_LED),\n@@ -10907,7 +10910,9 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x103c, 0x8def, \"HP EliteBook 660 G12\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8df0, \"HP EliteBook 630 G12\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8df1, \"HP EliteBook 630 G12\", ALC236_FIXUP_HP_GPIO_LED),\n+\tSND_PCI_QUIRK(0x103c, 0x8dfb, \"HP EliteBook 6 G1a 14\", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),\n \tSND_PCI_QUIRK(0x103c, 0x8dfc, \"HP EliteBook 645 G12\", ALC236_FIXUP_HP_GPIO_LED),\n+\tSND_PCI_QUIRK(0x103c, 0x8dfd, \"HP EliteBook 6 G1a 16\", ALC236_FIXUP_HP_MUTE_LED_MICMUTE_VREF),\n \tSND_PCI_QUIRK(0x103c, 0x8dfe, \"HP EliteBook 665 G12\", ALC236_FIXUP_HP_GPIO_LED),\n \tSND_PCI_QUIRK(0x103c, 0x8e11, \"HP Trekker\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x103c, 0x8e12, \"HP Trekker\", ALC287_FIXUP_CS35L41_I2C_2),\n@@ -11026,6 +11031,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1043, 0x1df3, \"ASUS UM5606WA\", ALC294_FIXUP_BASS_SPEAKER_15),\n \tSND_PCI_QUIRK(0x1043, 0x1264, \"ASUS UM5606KA\", ALC294_FIXUP_BASS_SPEAKER_15),\n \tSND_PCI_QUIRK(0x1043, 0x1e02, \"ASUS UX3402ZA\", ALC245_FIXUP_CS35L41_SPI_2),\n+\tSND_PCI_QUIRK(0x1043, 0x1e10, \"ASUS VivoBook X507UAR\", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1043, 0x1e11, \"ASUS Zephyrus G15\", ALC289_FIXUP_ASUS_GA502),\n \tSND_PCI_QUIRK(0x1043, 0x1e12, \"ASUS UM3402\", ALC287_FIXUP_CS35L41_I2C_2),\n \tSND_PCI_QUIRK(0x1043, 0x1e1f, \"ASUS Vivobook 15 X1504VAP\", ALC2XX_FIXUP_HEADSET_MIC),\n@@ -11135,6 +11141,8 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1558, 0x14a1, \"Clevo L141MU\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x2624, \"Clevo L240TU\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x28c1, \"Clevo V370VND\", ALC2XX_FIXUP_HEADSET_MIC),\n+\tSND_PCI_QUIRK(0x1558, 0x35a1, \"Clevo V3[56]0EN[CDE]\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n+\tSND_PCI_QUIRK(0x1558, 0x35b1, \"Clevo V3[57]0WN[MNP]Q\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x4018, \"Clevo NV40M[BE]\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x4019, \"Clevo NV40MZ\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x4020, \"Clevo NV40MB\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n@@ -11162,6 +11170,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1558, 0x51b1, \"Clevo NS50AU\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x51b3, \"Clevo NS70AU\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x5630, \"Clevo NP50RNJS\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n+\tSND_PCI_QUIRK(0x1558, 0x5700, \"Clevo X560WN[RST]\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x70a1, \"Clevo NB70T[HJK]\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x70b3, \"Clevo NK70SB\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0x70f2, \"Clevo NH79EPY\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n@@ -11201,6 +11210,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {\n \tSND_PCI_QUIRK(0x1558, 0xa650, \"Clevo NP[567]0SN[CD]\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0xa671, \"Clevo NP70SN[CDE]\", ALC256_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0xa741, \"Clevo V54x_6x_TNE\", ALC245_FIXUP_CLEVO_NOISY_MIC),\n+\tSND_PCI_QUIRK(0x1558, 0xa743, \"Clevo V54x_6x_TU\", ALC245_FIXUP_CLEVO_NOISY_MIC),\n \tSND_PCI_QUIRK(0x1558, 0xa763, \"Clevo V54x_6x_TU\", ALC245_FIXUP_CLEVO_NOISY_MIC),\n \tSND_PCI_QUIRK(0x1558, 0xb018, \"Clevo NP50D[BE]\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\n \tSND_PCI_QUIRK(0x1558, 0xb019, \"Clevo NH77D[BE]Q\", ALC293_FIXUP_SYSTEM76_MIC_NO_PRESENCE),\ndiff --git a/sound/soc/amd/ps/acp63.h b/sound/soc/amd/ps/acp63.h\nindex 85feae45c44c..d7c994e26e4d 100644\n--- a/sound/soc/amd/ps/acp63.h\n+++ b/sound/soc/amd/ps/acp63.h\n@@ -334,6 +334,8 @@ struct acp_hw_ops {\n  * @addr: pci ioremap address\n  * @reg_range: ACP reigister range\n  * @acp_rev: ACP PCI revision id\n+ * @acp_sw_pad_keeper_en: store acp SoundWire pad keeper enable register value\n+ * @acp_pad_pulldown_ctrl: store acp pad pulldown control register value\n  * @acp63_sdw0-dma_intr_stat: DMA interrupt status array for ACP6.3 platform SoundWire\n  * manager-SW0 instance\n  * @acp63_sdw_dma_intr_stat: DMA interrupt status array for ACP6.3 platform SoundWire\n@@ -367,6 +369,8 @@ struct acp63_dev_data {\n \tu32 addr;\n \tu32 reg_range;\n \tu32 acp_rev;\n+\tu32 acp_sw_pad_keeper_en;\n+\tu32 acp_pad_pulldown_ctrl;\n \tu16 acp63_sdw0_dma_intr_stat[ACP63_SDW0_DMA_MAX_STREAMS];\n \tu16 acp63_sdw1_dma_intr_stat[ACP63_SDW1_DMA_MAX_STREAMS];\n \tu16 acp70_sdw0_dma_intr_stat[ACP70_SDW0_DMA_MAX_STREAMS];\ndiff --git a/sound/soc/amd/ps/ps-common.c b/sound/soc/amd/ps/ps-common.c\nindex 1c89fb5fe1da..7b4966b75dc6 100644\n--- a/sound/soc/amd/ps/ps-common.c\n+++ b/sound/soc/amd/ps/ps-common.c\n@@ -160,6 +160,8 @@ static int __maybe_unused snd_acp63_suspend(struct device *dev)\n \n \tadata = dev_get_drvdata(dev);\n \tif (adata->is_sdw_dev) {\n+\t\tadata->acp_sw_pad_keeper_en = readl(adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\t\tadata->acp_pad_pulldown_ctrl = readl(adata->acp63_base + ACP_PAD_PULLDOWN_CTRL);\n \t\tadata->sdw_en_stat = check_acp_sdw_enable_status(adata);\n \t\tif (adata->sdw_en_stat) {\n \t\t\twritel(1, adata->acp63_base + ACP_ZSC_DSP_CTRL);\n@@ -197,6 +199,7 @@ static int __maybe_unused snd_acp63_runtime_resume(struct device *dev)\n static int __maybe_unused snd_acp63_resume(struct device *dev)\n {\n \tstruct acp63_dev_data *adata;\n+\tu32 acp_sw_pad_keeper_en;\n \tint ret;\n \n \tadata = dev_get_drvdata(dev);\n@@ -209,6 +212,12 @@ static int __maybe_unused snd_acp63_resume(struct device *dev)\n \tif (ret)\n \t\tdev_err(dev, \"ACP init failed\\n\");\n \n+\tacp_sw_pad_keeper_en = readl(adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\tdev_dbg(dev, \"ACP_SW0_PAD_KEEPER_EN:0x%x\\n\", acp_sw_pad_keeper_en);\n+\tif (!acp_sw_pad_keeper_en) {\n+\t\twritel(adata->acp_sw_pad_keeper_en, adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\t\twritel(adata->acp_pad_pulldown_ctrl, adata->acp63_base + ACP_PAD_PULLDOWN_CTRL);\n+\t}\n \treturn ret;\n }\n \n@@ -408,6 +417,8 @@ static int __maybe_unused snd_acp70_suspend(struct device *dev)\n \n \tadata = dev_get_drvdata(dev);\n \tif (adata->is_sdw_dev) {\n+\t\tadata->acp_sw_pad_keeper_en = readl(adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\t\tadata->acp_pad_pulldown_ctrl = readl(adata->acp63_base + ACP_PAD_PULLDOWN_CTRL);\n \t\tadata->sdw_en_stat = check_acp_sdw_enable_status(adata);\n \t\tif (adata->sdw_en_stat) {\n \t\t\twritel(1, adata->acp63_base + ACP_ZSC_DSP_CTRL);\n@@ -445,6 +456,7 @@ static int __maybe_unused snd_acp70_runtime_resume(struct device *dev)\n static int __maybe_unused snd_acp70_resume(struct device *dev)\n {\n \tstruct acp63_dev_data *adata;\n+\tu32 acp_sw_pad_keeper_en;\n \tint ret;\n \n \tadata = dev_get_drvdata(dev);\n@@ -459,6 +471,12 @@ static int __maybe_unused snd_acp70_resume(struct device *dev)\n \tif (ret)\n \t\tdev_err(dev, \"ACP init failed\\n\");\n \n+\tacp_sw_pad_keeper_en = readl(adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\tdev_dbg(dev, \"ACP_SW0_PAD_KEEPER_EN:0x%x\\n\", acp_sw_pad_keeper_en);\n+\tif (!acp_sw_pad_keeper_en) {\n+\t\twritel(adata->acp_sw_pad_keeper_en, adata->acp63_base + ACP_SW0_PAD_KEEPER_EN);\n+\t\twritel(adata->acp_pad_pulldown_ctrl, adata->acp63_base + ACP_PAD_PULLDOWN_CTRL);\n+\t}\n \treturn ret;\n }\n \ndiff --git a/sound/soc/amd/yc/acp6x-mach.c b/sound/soc/amd/yc/acp6x-mach.c\nindex 98022e5fd428..97e340140d0c 100644\n--- a/sound/soc/amd/yc/acp6x-mach.c\n+++ b/sound/soc/amd/yc/acp6x-mach.c\n@@ -353,6 +353,13 @@ static const struct dmi_system_id yc_acp_quirk_table[] = {\n \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"83Q3\"),\n \t\t}\n \t},\n+\t{\n+\t\t.driver_data = &acp6x_card,\n+\t\t.matches = {\n+\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"RB\"),\n+\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Nitro ANV15-41\"),\n+\t\t}\n+\t},\n \t{\n \t\t.driver_data = &acp6x_card,\n \t\t.matches = {\n@@ -360,6 +367,13 @@ static const struct dmi_system_id yc_acp_quirk_table[] = {\n \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"83J2\"),\n \t\t}\n \t},\n+\t{\n+\t\t.driver_data = &acp6x_card,\n+\t\t.matches = {\n+\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"LENOVO\"),\n+\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"83J3\"),\n+\t\t}\n+\t},\n \t{\n \t\t.driver_data = &acp6x_card,\n \t\t.matches = {\ndiff --git a/sound/soc/codecs/rt721-sdca.c b/sound/soc/codecs/rt721-sdca.c\nindex 1c9f32e405cf..ba080957e933 100644\n--- a/sound/soc/codecs/rt721-sdca.c\n+++ b/sound/soc/codecs/rt721-sdca.c\n@@ -430,6 +430,7 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \tunsigned int read_l, read_r, ctl_l = 0, ctl_r = 0;\n \tunsigned int adc_vol_flag = 0;\n \tconst unsigned int interval_offset = 0xc0;\n+\tconst unsigned int tendA = 0x200;\n \tconst unsigned int tendB = 0xa00;\n \n \tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\") ||\n@@ -439,9 +440,16 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \tregmap_read(rt721->mbq_regmap, mc->reg, &read_l);\n \tregmap_read(rt721->mbq_regmap, mc->rreg, &read_r);\n \n-\tif (mc->shift == 8) /* boost gain */\n+\tif (mc->shift == 8) {\n+\t\t/* boost gain */\n \t\tctl_l = read_l / tendB;\n-\telse {\n+\t} else if (mc->shift == 1) {\n+\t\t/* FU33 boost gain */\n+\t\tif (read_l == 0x8000 || read_l == 0xfe00)\n+\t\t\tctl_l = 0;\n+\t\telse\n+\t\t\tctl_l = read_l / tendA + 1;\n+\t} else {\n \t\tif (adc_vol_flag)\n \t\t\tctl_l = mc->max - (((0x1e00 - read_l) & 0xffff) / interval_offset);\n \t\telse\n@@ -449,9 +457,16 @@ static int rt721_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n \t}\n \n \tif (read_l != read_r) {\n-\t\tif (mc->shift == 8) /* boost gain */\n+\t\tif (mc->shift == 8) {\n+\t\t\t/* boost gain */\n \t\t\tctl_r = read_r / tendB;\n-\t\telse { /* ADC/DAC gain */\n+\t\t} else if (mc->shift == 1) {\n+\t\t\t/* FU33 boost gain */\n+\t\t\tif (read_r == 0x8000 || read_r == 0xfe00)\n+\t\t\t\tctl_r = 0;\n+\t\t\telse\n+\t\t\t\tctl_r = read_r / tendA + 1;\n+\t\t} else { /* ADC/DAC gain */\n \t\t\tif (adc_vol_flag)\n \t\t\t\tctl_r = mc->max - (((0x1e00 - read_r) & 0xffff) / interval_offset);\n \t\t\telse\ndiff --git a/sound/soc/qcom/Kconfig b/sound/soc/qcom/Kconfig\nindex e86b4a03dd61..3d9ba13ee1e5 100644\n--- a/sound/soc/qcom/Kconfig\n+++ b/sound/soc/qcom/Kconfig\n@@ -186,6 +186,7 @@ config SND_SOC_SM8250\n \ttristate \"SoC Machine driver for SM8250 boards\"\n \tdepends on QCOM_APR && SOUNDWIRE\n \tdepends on COMMON_CLK\n+\tdepends on SND_SOC_QCOM_OFFLOAD_UTILS || !SND_SOC_QCOM_OFFLOAD_UTILS\n \tselect SND_SOC_QDSP6\n \tselect SND_SOC_QCOM_COMMON\n \tselect SND_SOC_QCOM_SDW\ndiff --git a/sound/soc/sof/intel/hda.c b/sound/soc/sof/intel/hda.c\nindex bdfe388da198..3b47191ea7a5 100644\n--- a/sound/soc/sof/intel/hda.c\n+++ b/sound/soc/sof/intel/hda.c\n@@ -1257,11 +1257,11 @@ static int check_tplg_quirk_mask(struct snd_soc_acpi_mach *mach)\n \treturn 0;\n }\n \n-static char *remove_file_ext(const char *tplg_filename)\n+static char *remove_file_ext(struct device *dev, const char *tplg_filename)\n {\n \tchar *filename, *tmp;\n \n-\tfilename = kstrdup(tplg_filename, GFP_KERNEL);\n+\tfilename = devm_kstrdup(dev, tplg_filename, GFP_KERNEL);\n \tif (!filename)\n \t\treturn NULL;\n \n@@ -1345,7 +1345,7 @@ struct snd_soc_acpi_mach *hda_machine_select(struct snd_sof_dev *sdev)\n \t\t */\n \t\tif (!sof_pdata->tplg_filename) {\n \t\t\t/* remove file extension if it exists */\n-\t\t\ttplg_filename = remove_file_ext(mach->sof_tplg_filename);\n+\t\t\ttplg_filename = remove_file_ext(sdev->dev, mach->sof_tplg_filename);\n \t\t\tif (!tplg_filename)\n \t\t\t\treturn NULL;\n \ndiff --git a/sound/usb/qcom/qc_audio_offload.c b/sound/usb/qcom/qc_audio_offload.c\nindex 5bc27c82e0af..3543b5a53592 100644\n--- a/sound/usb/qcom/qc_audio_offload.c\n+++ b/sound/usb/qcom/qc_audio_offload.c\n@@ -759,7 +759,7 @@ static void qmi_stop_session(void)\n \t\t\tsubs = find_substream(pcm_card_num, info->pcm_dev_num,\n \t\t\t\t\t      info->direction);\n \t\t\tif (!subs || !chip || atomic_read(&chip->shutdown)) {\n-\t\t\t\tdev_err(&subs->dev->dev,\n+\t\t\t\tdev_err(&uadev[idx].udev->dev,\n \t\t\t\t\t\"no sub for c#%u dev#%u dir%u\\n\",\n \t\t\t\t\tinfo->pcm_card_num,\n \t\t\t\t\tinfo->pcm_dev_num,\n@@ -1360,20 +1360,21 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \n \tif (!uadev[card_num].ctrl_intf) {\n \t\tdev_err(&subs->dev->dev, \"audio ctrl intf info not cached\\n\");\n-\t\tret = -ENODEV;\n-\t\tgoto err;\n+\t\treturn -ENODEV;\n \t}\n \n \tret = uaudio_populate_uac_desc(subs, resp);\n \tif (ret < 0)\n-\t\tgoto err;\n+\t\treturn ret;\n \n \tresp->slot_id = subs->dev->slot_id;\n \tresp->slot_id_valid = 1;\n \n \tdata = snd_soc_usb_find_priv_data(uaudio_qdev->auxdev->dev.parent);\n-\tif (!data)\n-\t\tgoto err;\n+\tif (!data) {\n+\t\tdev_err(&subs->dev->dev, \"No private data found\\n\");\n+\t\treturn -ENODEV;\n+\t}\n \n \tuaudio_qdev->data = data;\n \n@@ -1382,7 +1383,7 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \t\t\t\t    &resp->xhci_mem_info.tr_data,\n \t\t\t\t    &resp->std_as_data_ep_desc);\n \tif (ret < 0)\n-\t\tgoto err;\n+\t\treturn ret;\n \n \tresp->std_as_data_ep_desc_valid = 1;\n \n@@ -1500,7 +1501,6 @@ static int prepare_qmi_response(struct snd_usb_substream *subs,\n \txhci_sideband_remove_endpoint(uadev[card_num].sb,\n \t\t\tusb_pipe_endpoint(subs->dev, subs->data_endpoint->pipe));\n \n-err:\n \treturn ret;\n }\n \ndiff --git a/sound/usb/stream.c b/sound/usb/stream.c\nindex c1ea8844a46f..aa91d63749f2 100644\n--- a/sound/usb/stream.c\n+++ b/sound/usb/stream.c\n@@ -987,6 +987,8 @@ snd_usb_get_audioformat_uac3(struct snd_usb_audio *chip,\n \t * and request Cluster Descriptor\n \t */\n \twLength = le16_to_cpu(hc_header.wLength);\n+\tif (wLength < sizeof(cluster))\n+\t\treturn NULL;\n \tcluster = kzalloc(wLength, GFP_KERNEL);\n \tif (!cluster)\n \t\treturn ERR_PTR(-ENOMEM);",
    "stats": {
      "insertions": 79,
      "deletions": 15,
      "files": 9
    }
  },
  {
    "sha": "d62016b1a2df24c8608fe83cd3ae8090412881b3",
    "message": "xfs: avoid dquot buffer pin deadlock\n\nOn shutdown when quotas are enabled, the shutdown can deadlock\ntrying to unpin the dquot buffer buf_log_item like so:\n\n[ 3319.483590] task:kworker/20:0H   state:D stack:14360 pid:1962230 tgid:1962230 ppid:2      task_flags:0x4208060 flags:0x00004000\n[ 3319.493966] Workqueue: xfs-log/dm-6 xlog_ioend_work\n[ 3319.498458] Call Trace:\n[ 3319.500800]  <TASK>\n[ 3319.502809]  __schedule+0x699/0xb70\n[ 3319.512672]  schedule+0x64/0xd0\n[ 3319.515573]  schedule_timeout+0x30/0xf0\n[ 3319.528125]  __down_common+0xc3/0x200\n[ 3319.531488]  __down+0x1d/0x30\n[ 3319.534186]  down+0x48/0x50\n[ 3319.540501]  xfs_buf_lock+0x3d/0xe0\n[ 3319.543609]  xfs_buf_item_unpin+0x85/0x1b0\n[ 3319.547248]  xlog_cil_committed+0x289/0x570\n[ 3319.571411]  xlog_cil_process_committed+0x6d/0x90\n[ 3319.575590]  xlog_state_shutdown_callbacks+0x52/0x110\n[ 3319.580017]  xlog_force_shutdown+0x169/0x1a0\n[ 3319.583780]  xlog_ioend_work+0x7c/0xb0\n[ 3319.587049]  process_scheduled_works+0x1d6/0x400\n[ 3319.591127]  worker_thread+0x202/0x2e0\n[ 3319.594452]  kthread+0x20c/0x240\n\nThe CIL push has seen the deadlock, so it has aborted the push and\nis running CIL checkpoint completion to abort all the items in the\ncheckpoint. This calls ->iop_unpin(remove = true) to clean up the\nlog items in the checkpoint.\n\nWhen a buffer log item is unpined like this, it needs to lock the\nbuffer to run io completion to correctly fail the buffer and run all\nthe required completions to fail attached log items as well. In this\ncase, the attempt to lock the buffer on unpin is hanging because the\nbuffer is already locked.\n\nI suspected a leaked XFS_BLI_HOLD state because of XFS_BLI_STALE\nhandling changes I was testing, so I went looking for\npin events on HOLD buffers and unpin events on locked buffer. That\nisolated this one buffer with these two events:\n\nxfs_buf_item_pin:     dev 251:6 daddr 0xa910 bbcount 0x2 hold 2 pincount 0 lock 0 flags DONE|KMEM recur 0 refcount 1 bliflags HOLD|DIRTY|LOGGED liflags DIRTY\n....\nxfs_buf_item_unpin:   dev 251:6 daddr 0xa910 bbcount 0x2 hold 4 pincount 1 lock 0 flags DONE|KMEM recur 0 refcount 1 bliflags DIRTY liflags ABORTED\n\nFirstly, bbcount = 0x2, which means it is not a single sector\nstructure. That rules out every xfs_trans_bhold() case except one:\ndquot buffers.\n\nThen hung task dumping gave this trace:\n\n[ 3197.312078] task:fsync-tester    state:D stack:12080 pid:2051125 tgid:2051125 ppid:1643233 task_flags:0x400000 flags:0x00004002\n[ 3197.323007] Call Trace:\n[ 3197.325581]  <TASK>\n[ 3197.327727]  __schedule+0x699/0xb70\n[ 3197.334582]  schedule+0x64/0xd0\n[ 3197.337672]  schedule_timeout+0x30/0xf0\n[ 3197.350139]  wait_for_completion+0xbd/0x180\n[ 3197.354235]  __flush_workqueue+0xef/0x4e0\n[ 3197.362229]  xlog_cil_force_seq+0xa0/0x300\n[ 3197.374447]  xfs_log_force+0x77/0x230\n[ 3197.378015]  xfs_qm_dqunpin_wait+0x49/0xf0\n[ 3197.382010]  xfs_qm_dqflush+0x55/0x460\n[ 3197.385663]  xfs_qm_dquot_isolate+0x29e/0x4d0\n[ 3197.389977]  __list_lru_walk_one+0x141/0x220\n[ 3197.398867]  list_lru_walk_one+0x10/0x20\n[ 3197.402713]  xfs_qm_shrink_scan+0x6a/0x100\n[ 3197.406699]  do_shrink_slab+0x18a/0x350\n[ 3197.410512]  shrink_slab+0xf7/0x430\n[ 3197.413967]  drop_slab+0x97/0xf0\n[ 3197.417121]  drop_caches_sysctl_handler+0x59/0xc0\n[ 3197.421654]  proc_sys_call_handler+0x18b/0x280\n[ 3197.426050]  proc_sys_write+0x13/0x20\n[ 3197.429750]  vfs_write+0x2b8/0x3e0\n[ 3197.438532]  ksys_write+0x7e/0xf0\n[ 3197.441742]  __x64_sys_write+0x1b/0x30\n[ 3197.445363]  x64_sys_call+0x2c72/0x2f60\n[ 3197.449044]  do_syscall_64+0x6c/0x140\n[ 3197.456341]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nYup, another test run by check-parallel is running drop_caches\nconcurrently and the dquot shrinker for the hung filesystem is\nrunning. That's trying to flush a dirty dquot from reclaim context,\nand it waiting on a log force to complete. xfs_qm_dqflush is called\nwith the dquot buffer held locked, and so we've called\nxfs_log_force() with that buffer locked.\n\nNow the log force is waiting for a workqueue flush to complete, and\nthat workqueue flush is waiting of CIL checkpoint processing to\nfinish.\n\nThe CIL checkpoint processing is aborting all the log items it has,\nand that requires locking aborted buffers to cancel them.\n\nNow, normally this isn't a problem if we are issuing a log force\nto unpin an object, because the ->iop_unpin() method wakes pin\nwaiters first. That results in the pin waiter finishing off whatever\nit was doing, dropping the lock and then xfs_buf_item_unpin() can\nlock the buffer and fail it.\n\nHowever, xfs_qm_dqflush() is waiting on the -dquot- unpin event, not\nthe dquot buffer unpin event, and so it never gets woken and so does\nnot drop the buffer lock.\n\nInodes do not have this problem, as they can only be written from\none spot (->iop_push) whilst dquots can be written from multiple\nplaces (memory reclaim, ->iop_push, xfs_dq_dqpurge, and quotacheck).\n\nThe reason that the dquot buffer has an attached buffer log item is\nthat it has been recently allocated. Initialisation of the dquot\nbuffer logs the buffer directly, thereby pinning it in memory. We\nthen modify the dquot in a separate operation, and have memory\nreclaim racing with a shutdown and we trigger this deadlock.\n\ncheck-parallel reproduces this reliably on 1kB FSB filesystems with\nquota enabled because it does all of these things concurrently\nwithout having to explicitly write tests to exercise these corner\ncase conditions.\n\nxfs_qm_dquot_logitem_push() doesn't have this deadlock because it\nchecks if the dquot is pinned before locking the dquot buffer and\nskipping it if it is pinned. This means the xfs_qm_dqunpin_wait()\nlog force in xfs_qm_dqflush() never triggers and we unlock the\nbuffer safely allowing a concurrent shutdown to fail the buffer\nappropriately.\n\nxfs_qm_dqpurge() could have this problem as it is called from\nquotacheck and we might have allocated dquot buffers when recording\nthe quota updates. This can be fixed by calling\nxfs_qm_dqunpin_wait() before we lock the dquot buffer. Because we\nhold the dquot locked, nothing will be able to add to the pin count\nbetween the unpin_wait and the dqflush callout, so this now makes\nxfs_qm_dqpurge() safe against this race.\n\nxfs_qm_dquot_isolate() can also be fixed this same way but, quite\nfrankly, we shouldn't be doing IO in memory reclaim context. If the\ndquot is pinned or dirty, simply rotate it and let memory reclaim\ncome back to it later, same as we do for inodes.\n\nThis then gets rid of the nasty issue in xfs_qm_flush_one() where\nquotacheck writeback races with memory reclaim flushing the dquots.\nWe can lift xfs_qm_dqunpin_wait() up into this code, then get rid of\nthe \"can't get the dqflush lock\" buffer write to cycle the dqlfush\nlock and enable it to be flushed again.  checking if the dquot is\npinned and returning -EAGAIN so that the dquot walk will revisit the\ndquot again later.\n\nFinally, with xfs_qm_dqunpin_wait() lifted into all the callers,\nwe can remove it from the xfs_qm_dqflush() code.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Carlos Maiolino <cmaiolino@redhat.com>\nSigned-off-by: Carlos Maiolino <cem@kernel.org>",
    "author": "Dave Chinner",
    "date": "2025-06-27T14:14:37+02:00",
    "files_changed": [
      "fs/xfs/xfs_buf.c",
      "fs/xfs/xfs_buf.h",
      "fs/xfs/xfs_dquot.c",
      "fs/xfs/xfs_qm.c",
      "fs/xfs/xfs_trace.h"
    ],
    "diff": "diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c\nindex 8af83bd161f9..ba5bd6031ece 100644\n--- a/fs/xfs/xfs_buf.c\n+++ b/fs/xfs/xfs_buf.c\n@@ -2082,44 +2082,6 @@ xfs_buf_delwri_submit(\n \treturn error;\n }\n \n-/*\n- * Push a single buffer on a delwri queue.\n- *\n- * The purpose of this function is to submit a single buffer of a delwri queue\n- * and return with the buffer still on the original queue.\n- *\n- * The buffer locking and queue management logic between _delwri_pushbuf() and\n- * _delwri_queue() guarantee that the buffer cannot be queued to another list\n- * before returning.\n- */\n-int\n-xfs_buf_delwri_pushbuf(\n-\tstruct xfs_buf\t\t*bp,\n-\tstruct list_head\t*buffer_list)\n-{\n-\tint\t\t\terror;\n-\n-\tASSERT(bp->b_flags & _XBF_DELWRI_Q);\n-\n-\ttrace_xfs_buf_delwri_pushbuf(bp, _RET_IP_);\n-\n-\txfs_buf_lock(bp);\n-\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC);\n-\tbp->b_flags |= XBF_WRITE;\n-\txfs_buf_submit(bp);\n-\n-\t/*\n-\t * The buffer is now locked, under I/O but still on the original delwri\n-\t * queue. Wait for I/O completion, restore the DELWRI_Q flag and\n-\t * return with the buffer unlocked and still on the original queue.\n-\t */\n-\terror = xfs_buf_iowait(bp);\n-\tbp->b_flags |= _XBF_DELWRI_Q;\n-\txfs_buf_unlock(bp);\n-\n-\treturn error;\n-}\n-\n void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n {\n \t/*\ndiff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h\nindex 9d2ab567cf81..15fc56948346 100644\n--- a/fs/xfs/xfs_buf.h\n+++ b/fs/xfs/xfs_buf.h\n@@ -326,7 +326,6 @@ extern bool xfs_buf_delwri_queue(struct xfs_buf *, struct list_head *);\n void xfs_buf_delwri_queue_here(struct xfs_buf *bp, struct list_head *bl);\n extern int xfs_buf_delwri_submit(struct list_head *);\n extern int xfs_buf_delwri_submit_nowait(struct list_head *);\n-extern int xfs_buf_delwri_pushbuf(struct xfs_buf *, struct list_head *);\n \n static inline xfs_daddr_t xfs_buf_daddr(struct xfs_buf *bp)\n {\ndiff --git a/fs/xfs/xfs_dquot.c b/fs/xfs/xfs_dquot.c\nindex b4e32f0860b7..0bd8022e47b4 100644\n--- a/fs/xfs/xfs_dquot.c\n+++ b/fs/xfs/xfs_dquot.c\n@@ -1398,11 +1398,9 @@ xfs_qm_dqflush(\n \n \tASSERT(XFS_DQ_IS_LOCKED(dqp));\n \tASSERT(!completion_done(&dqp->q_flush));\n+\tASSERT(atomic_read(&dqp->q_pincount) == 0);\n \n \ttrace_xfs_dqflush(dqp);\n-\n-\txfs_qm_dqunpin_wait(dqp);\n-\n \tfa = xfs_qm_dqflush_check(dqp);\n \tif (fa) {\n \t\txfs_alert(mp, \"corrupt dquot ID 0x%x in memory at %pS\",\ndiff --git a/fs/xfs/xfs_qm.c b/fs/xfs/xfs_qm.c\nindex 417439b58785..fa135ac26471 100644\n--- a/fs/xfs/xfs_qm.c\n+++ b/fs/xfs/xfs_qm.c\n@@ -134,6 +134,7 @@ xfs_qm_dqpurge(\n \n \tdqp->q_flags |= XFS_DQFLAG_FREEING;\n \n+\txfs_qm_dqunpin_wait(dqp);\n \txfs_dqflock(dqp);\n \n \t/*\n@@ -465,6 +466,7 @@ xfs_qm_dquot_isolate(\n \tstruct xfs_dquot\t*dqp = container_of(item,\n \t\t\t\t\t\tstruct xfs_dquot, q_lru);\n \tstruct xfs_qm_isolate\t*isol = arg;\n+\tenum lru_status\t\tret = LRU_SKIP;\n \n \tif (!xfs_dqlock_nowait(dqp))\n \t\tgoto out_miss_busy;\n@@ -477,6 +479,16 @@ xfs_qm_dquot_isolate(\n \tif (dqp->q_flags & XFS_DQFLAG_FREEING)\n \t\tgoto out_miss_unlock;\n \n+\t/*\n+\t * If the dquot is pinned or dirty, rotate it to the end of the LRU to\n+\t * give some time for it to be cleaned before we try to isolate it\n+\t * again.\n+\t */\n+\tret = LRU_ROTATE;\n+\tif (XFS_DQ_IS_DIRTY(dqp) || atomic_read(&dqp->q_pincount) > 0) {\n+\t\tgoto out_miss_unlock;\n+\t}\n+\n \t/*\n \t * This dquot has acquired a reference in the meantime remove it from\n \t * the freelist and try again.\n@@ -492,41 +504,14 @@ xfs_qm_dquot_isolate(\n \t}\n \n \t/*\n-\t * If the dquot is dirty, flush it. If it's already being flushed, just\n-\t * skip it so there is time for the IO to complete before we try to\n-\t * reclaim it again on the next LRU pass.\n+\t * The dquot may still be under IO, in which case the flush lock will be\n+\t * held. If we can't get the flush lock now, just skip over the dquot as\n+\t * if it was dirty.\n \t */\n \tif (!xfs_dqflock_nowait(dqp))\n \t\tgoto out_miss_unlock;\n \n-\tif (XFS_DQ_IS_DIRTY(dqp)) {\n-\t\tstruct xfs_buf\t*bp = NULL;\n-\t\tint\t\terror;\n-\n-\t\ttrace_xfs_dqreclaim_dirty(dqp);\n-\n-\t\t/* we have to drop the LRU lock to flush the dquot */\n-\t\tspin_unlock(&lru->lock);\n-\n-\t\terror = xfs_dquot_use_attached_buf(dqp, &bp);\n-\t\tif (!bp || error == -EAGAIN) {\n-\t\t\txfs_dqfunlock(dqp);\n-\t\t\tgoto out_unlock_dirty;\n-\t\t}\n-\n-\t\t/*\n-\t\t * dqflush completes dqflock on error, and the delwri ioend\n-\t\t * does it on success.\n-\t\t */\n-\t\terror = xfs_qm_dqflush(dqp, bp);\n-\t\tif (error)\n-\t\t\tgoto out_unlock_dirty;\n-\n-\t\txfs_buf_delwri_queue(bp, &isol->buffers);\n-\t\txfs_buf_relse(bp);\n-\t\tgoto out_unlock_dirty;\n-\t}\n-\n+\tASSERT(!XFS_DQ_IS_DIRTY(dqp));\n \txfs_dquot_detach_buf(dqp);\n \txfs_dqfunlock(dqp);\n \n@@ -548,13 +533,7 @@ xfs_qm_dquot_isolate(\n out_miss_busy:\n \ttrace_xfs_dqreclaim_busy(dqp);\n \tXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\n-\treturn LRU_SKIP;\n-\n-out_unlock_dirty:\n-\ttrace_xfs_dqreclaim_busy(dqp);\n-\tXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\n-\txfs_dqunlock(dqp);\n-\treturn LRU_RETRY;\n+\treturn ret;\n }\n \n static unsigned long\n@@ -1486,7 +1465,6 @@ xfs_qm_flush_one(\n \tstruct xfs_dquot\t*dqp,\n \tvoid\t\t\t*data)\n {\n-\tstruct xfs_mount\t*mp = dqp->q_mount;\n \tstruct list_head\t*buffer_list = data;\n \tstruct xfs_buf\t\t*bp = NULL;\n \tint\t\t\terror = 0;\n@@ -1497,34 +1475,8 @@ xfs_qm_flush_one(\n \tif (!XFS_DQ_IS_DIRTY(dqp))\n \t\tgoto out_unlock;\n \n-\t/*\n-\t * The only way the dquot is already flush locked by the time quotacheck\n-\t * gets here is if reclaim flushed it before the dqadjust walk dirtied\n-\t * it for the final time. Quotacheck collects all dquot bufs in the\n-\t * local delwri queue before dquots are dirtied, so reclaim can't have\n-\t * possibly queued it for I/O. The only way out is to push the buffer to\n-\t * cycle the flush lock.\n-\t */\n-\tif (!xfs_dqflock_nowait(dqp)) {\n-\t\t/* buf is pinned in-core by delwri list */\n-\t\terror = xfs_buf_incore(mp->m_ddev_targp, dqp->q_blkno,\n-\t\t\t\tmp->m_quotainfo->qi_dqchunklen, 0, &bp);\n-\t\tif (error)\n-\t\t\tgoto out_unlock;\n-\n-\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n-\t\t\terror = -EAGAIN;\n-\t\t\txfs_buf_relse(bp);\n-\t\t\tgoto out_unlock;\n-\t\t}\n-\t\txfs_buf_unlock(bp);\n-\n-\t\txfs_buf_delwri_pushbuf(bp, buffer_list);\n-\t\txfs_buf_rele(bp);\n-\n-\t\terror = -EAGAIN;\n-\t\tgoto out_unlock;\n-\t}\n+\txfs_qm_dqunpin_wait(dqp);\n+\txfs_dqflock(dqp);\n \n \terror = xfs_dquot_use_attached_buf(dqp, &bp);\n \tif (error)\ndiff --git a/fs/xfs/xfs_trace.h b/fs/xfs/xfs_trace.h\nindex 01d284a1c759..9f0d6bc966b7 100644\n--- a/fs/xfs/xfs_trace.h\n+++ b/fs/xfs/xfs_trace.h\n@@ -778,7 +778,6 @@ DEFINE_BUF_EVENT(xfs_buf_iowait_done);\n DEFINE_BUF_EVENT(xfs_buf_delwri_queue);\n DEFINE_BUF_EVENT(xfs_buf_delwri_queued);\n DEFINE_BUF_EVENT(xfs_buf_delwri_split);\n-DEFINE_BUF_EVENT(xfs_buf_delwri_pushbuf);\n DEFINE_BUF_EVENT(xfs_buf_get_uncached);\n DEFINE_BUF_EVENT(xfs_buf_item_relse);\n DEFINE_BUF_EVENT(xfs_buf_iodone_async);",
    "stats": {
      "insertions": 20,
      "deletions": 110,
      "files": 5
    }
  },
  {
    "sha": "db6a2274162de615ff74b927d38942fe3134d298",
    "message": "xfs: catch stale AGF/AGF metadata\n\nThere is a race condition that can trigger in dmflakey fstests that\ncan result in asserts in xfs_ialloc_read_agi() and\nxfs_alloc_read_agf() firing. The asserts look like this:\n\n XFS: Assertion failed: pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks), file: fs/xfs/libxfs/xfs_alloc.c, line: 3440\n.....\n Call Trace:\n  <TASK>\n  xfs_alloc_read_agf+0x2ad/0x3a0\n  xfs_alloc_fix_freelist+0x280/0x720\n  xfs_alloc_vextent_prepare_ag+0x42/0x120\n  xfs_alloc_vextent_iterate_ags+0x67/0x260\n  xfs_alloc_vextent_start_ag+0xe4/0x1c0\n  xfs_bmapi_allocate+0x6fe/0xc90\n  xfs_bmapi_convert_delalloc+0x338/0x560\n  xfs_map_blocks+0x354/0x580\n  iomap_writepages+0x52b/0xa70\n  xfs_vm_writepages+0xd7/0x100\n  do_writepages+0xe1/0x2c0\n  __writeback_single_inode+0x44/0x340\n  writeback_sb_inodes+0x2d0/0x570\n  __writeback_inodes_wb+0x9c/0xf0\n  wb_writeback+0x139/0x2d0\n  wb_workfn+0x23e/0x4c0\n  process_scheduled_works+0x1d4/0x400\n  worker_thread+0x234/0x2e0\n  kthread+0x147/0x170\n  ret_from_fork+0x3e/0x50\n  ret_from_fork_asm+0x1a/0x30\n\nI've seen the AGI variant from scrub running on the filesysetm\nafter unmount failed due to systemd interference:\n\n XFS: Assertion failed: pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) || xfs_is_shutdown(pag->pag_mount), file: fs/xfs/libxfs/xfs_ialloc.c, line: 2804\n.....\n Call Trace:\n  <TASK>\n  xfs_ialloc_read_agi+0xee/0x150\n  xchk_perag_drain_and_lock+0x7d/0x240\n  xchk_ag_init+0x34/0x90\n  xchk_inode_xref+0x7b/0x220\n  xchk_inode+0x14d/0x180\n  xfs_scrub_metadata+0x2e2/0x510\n  xfs_ioc_scrub_metadata+0x62/0xb0\n  xfs_file_ioctl+0x446/0xbf0\n  __se_sys_ioctl+0x6f/0xc0\n  __x64_sys_ioctl+0x1d/0x30\n  x64_sys_call+0x1879/0x2ee0\n  do_syscall_64+0x68/0x130\n  ? exc_page_fault+0x62/0xc0\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nEssentially, it is the same problem. When _flakey_drop_and_remount()\nloads the drop-writes table, it makes all writes silently fail. Writes\nare reported to the fs as completed successfully, but they are not\nissued to the backing store. The filesystem sees the successful\nwrite completion and marks the metadata buffer clean and removes it\nfrom the AIL.\n\nIf this happens at the same time as memory pressure is occuring,\nthe now-clean AGF and/or AGI buffers can be reclaimed from memory.\n\nShortly afterwards, but before _flakey_drop_and_remount() runs\nunmount, background writeback is kicked and it tries to allocate\nblocks for the dirty pages in memory. This then tries to access the\nAGF buffer we just turfed out of memory. It's not found, so it gets\nread in from disk.\n\nThis is all fine, except for the fact that the last writeback of the\nAGF did not actually reach disk. The AGF on disk is stale compared\nto the in-memory state held by the perag, and so they don't match\nand the assert fires.\n\nThen other operations on that inode hang because the task was killed\nwhilst holding inode locks. e.g:\n\n Workqueue: xfs-conv/dm-12 xfs_end_io\n Call Trace:\n  <TASK>\n  __schedule+0x650/0xb10\n  schedule+0x6d/0xf0\n  schedule_preempt_disabled+0x15/0x30\n  rwsem_down_write_slowpath+0x31a/0x5f0\n  down_write+0x43/0x60\n  xfs_ilock+0x1a8/0x210\n  xfs_trans_alloc_inode+0x9c/0x240\n  xfs_iomap_write_unwritten+0xe3/0x300\n  xfs_end_ioend+0x90/0x130\n  xfs_end_io+0xce/0x100\n  process_scheduled_works+0x1d4/0x400\n  worker_thread+0x234/0x2e0\n  kthread+0x147/0x170\n  ret_from_fork+0x3e/0x50\n  ret_from_fork_asm+0x1a/0x30\n  </TASK>\n\nand it's all down hill from there.\n\nMemory pressure is one way to trigger this, another is to run \"echo\n3 > /proc/sys/vm/drop_caches\" randomly while tests are running.\n\nRegardless of how it is triggered, this effectively takes down the\nsystem once umount hangs because it's holding a sb->s_umount lock\nexclusive and now every sync(1) call gets stuck on it.\n\nFix this by replacing the asserts with a corruption detection check\nand a shutdown.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Carlos Maiolino <cmaiolino@redhat.com>\nSigned-off-by: Carlos Maiolino <cem@kernel.org>",
    "author": "Dave Chinner",
    "date": "2025-06-27T14:13:34+02:00",
    "files_changed": [
      "fs/xfs/libxfs/xfs_alloc.c",
      "fs/xfs/libxfs/xfs_ialloc.c"
    ],
    "diff": "diff --git a/fs/xfs/libxfs/xfs_alloc.c b/fs/xfs/libxfs/xfs_alloc.c\nindex 7839efe050bf..000cc7f4a3ce 100644\n--- a/fs/xfs/libxfs/xfs_alloc.c\n+++ b/fs/xfs/libxfs/xfs_alloc.c\n@@ -3444,16 +3444,41 @@ xfs_alloc_read_agf(\n \n \t\tset_bit(XFS_AGSTATE_AGF_INIT, &pag->pag_opstate);\n \t}\n+\n #ifdef DEBUG\n-\telse if (!xfs_is_shutdown(mp)) {\n-\t\tASSERT(pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks));\n-\t\tASSERT(pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks));\n-\t\tASSERT(pag->pagf_flcount == be32_to_cpu(agf->agf_flcount));\n-\t\tASSERT(pag->pagf_longest == be32_to_cpu(agf->agf_longest));\n-\t\tASSERT(pag->pagf_bno_level == be32_to_cpu(agf->agf_bno_level));\n-\t\tASSERT(pag->pagf_cnt_level == be32_to_cpu(agf->agf_cnt_level));\n+\t/*\n+\t * It's possible for the AGF to be out of sync if the block device is\n+\t * silently dropping writes. This can happen in fstests with dmflakey\n+\t * enabled, which allows the buffer to be cleaned and reclaimed by\n+\t * memory pressure and then re-read from disk here. We will get a\n+\t * stale version of the AGF from disk, and nothing good can happen from\n+\t * here. Hence if we detect this situation, immediately shut down the\n+\t * filesystem.\n+\t *\n+\t * This can also happen if we are already in the middle of a forced\n+\t * shutdown, so don't bother checking if we are already shut down.\n+\t */\n+\tif (!xfs_is_shutdown(pag_mount(pag))) {\n+\t\tbool\tok = true;\n+\n+\t\tok &= pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks);\n+\t\tok &= pag->pagf_freeblks == be32_to_cpu(agf->agf_freeblks);\n+\t\tok &= pag->pagf_btreeblks == be32_to_cpu(agf->agf_btreeblks);\n+\t\tok &= pag->pagf_flcount == be32_to_cpu(agf->agf_flcount);\n+\t\tok &= pag->pagf_longest == be32_to_cpu(agf->agf_longest);\n+\t\tok &= pag->pagf_bno_level == be32_to_cpu(agf->agf_bno_level);\n+\t\tok &= pag->pagf_cnt_level == be32_to_cpu(agf->agf_cnt_level);\n+\n+\t\tif (XFS_IS_CORRUPT(pag_mount(pag), !ok)) {\n+\t\t\txfs_ag_mark_sick(pag, XFS_SICK_AG_AGF);\n+\t\t\txfs_trans_brelse(tp, agfbp);\n+\t\t\txfs_force_shutdown(pag_mount(pag),\n+\t\t\t\t\tSHUTDOWN_CORRUPT_ONDISK);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n \t}\n-#endif\n+#endif /* DEBUG */\n+\n \tif (agfbpp)\n \t\t*agfbpp = agfbp;\n \telse\ndiff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c\nindex 0c47b5c6ca7d..750111634d9f 100644\n--- a/fs/xfs/libxfs/xfs_ialloc.c\n+++ b/fs/xfs/libxfs/xfs_ialloc.c\n@@ -2801,12 +2801,35 @@ xfs_ialloc_read_agi(\n \t\tset_bit(XFS_AGSTATE_AGI_INIT, &pag->pag_opstate);\n \t}\n \n+#ifdef DEBUG\n \t/*\n-\t * It's possible for these to be out of sync if\n-\t * we are in the middle of a forced shutdown.\n+\t * It's possible for the AGF to be out of sync if the block device is\n+\t * silently dropping writes. This can happen in fstests with dmflakey\n+\t * enabled, which allows the buffer to be cleaned and reclaimed by\n+\t * memory pressure and then re-read from disk here. We will get a\n+\t * stale version of the AGF from disk, and nothing good can happen from\n+\t * here. Hence if we detect this situation, immediately shut down the\n+\t * filesystem.\n+\t *\n+\t * This can also happen if we are already in the middle of a forced\n+\t * shutdown, so don't bother checking if we are already shut down.\n \t */\n-\tASSERT(pag->pagi_freecount == be32_to_cpu(agi->agi_freecount) ||\n-\t\txfs_is_shutdown(pag_mount(pag)));\n+\tif (!xfs_is_shutdown(pag_mount(pag))) {\n+\t\tbool\tok = true;\n+\n+\t\tok &= pag->pagi_freecount == be32_to_cpu(agi->agi_freecount);\n+\t\tok &= pag->pagi_count == be32_to_cpu(agi->agi_count);\n+\n+\t\tif (XFS_IS_CORRUPT(pag_mount(pag), !ok)) {\n+\t\t\txfs_ag_mark_sick(pag, XFS_SICK_AG_AGI);\n+\t\t\txfs_trans_brelse(tp, agibp);\n+\t\t\txfs_force_shutdown(pag_mount(pag),\n+\t\t\t\t\tSHUTDOWN_CORRUPT_ONDISK);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\t}\n+#endif /* DEBUG */\n+\n \tif (agibpp)\n \t\t*agibpp = agibp;\n \telse",
    "stats": {
      "insertions": 60,
      "deletions": 12,
      "files": 2
    }
  },
  {
    "sha": "09234a632be42573d9743ac5ff6773622d233ad0",
    "message": "xfs: xfs_ifree_cluster vs xfs_iflush_shutdown_abort deadlock\n\nLock order of xfs_ifree_cluster() is cluster buffer -> try ILOCK\n-> IFLUSHING, except for the last inode in the cluster that is\ntriggering the free. In that case, the lock order is ILOCK ->\ncluster buffer -> IFLUSHING.\n\nxfs_iflush_cluster() uses cluster buffer -> try ILOCK -> IFLUSHING,\nso this can safely run concurrently with xfs_ifree_cluster().\n\nxfs_inode_item_precommit() uses ILOCK -> cluster buffer, but this\ncannot race with xfs_ifree_cluster() so being in a different order\nwill not trigger a deadlock.\n\nxfs_reclaim_inode() during a filesystem shutdown uses ILOCK ->\nIFLUSHING -> cluster buffer via xfs_iflush_shutdown_abort(), and\nthis deadlocks against xfs_ifree_cluster() like so:\n\n sysrq: Show Blocked State\n task:kworker/10:37   state:D stack:12560 pid:276182 tgid:276182 ppid:2      flags:0x00004000\n Workqueue: xfs-inodegc/dm-3 xfs_inodegc_worker\n Call Trace:\n  <TASK>\n  __schedule+0x650/0xb10\n  schedule+0x6d/0xf0\n  schedule_timeout+0x8b/0x180\n  schedule_timeout_uninterruptible+0x1e/0x30\n  xfs_ifree+0x326/0x730\n  xfs_inactive_ifree+0xcb/0x230\n  xfs_inactive+0x2c8/0x380\n  xfs_inodegc_worker+0xaa/0x180\n  process_scheduled_works+0x1d4/0x400\n  worker_thread+0x234/0x2e0\n  kthread+0x147/0x170\n  ret_from_fork+0x3e/0x50\n  ret_from_fork_asm+0x1a/0x30\n  </TASK>\n task:fsync-tester    state:D stack:12160 pid:2255943 tgid:2255943 ppid:3988702 flags:0x00004006\n Call Trace:\n  <TASK>\n  __schedule+0x650/0xb10\n  schedule+0x6d/0xf0\n  schedule_timeout+0x31/0x180\n  __down_common+0xbe/0x1f0\n  __down+0x1d/0x30\n  down+0x48/0x50\n  xfs_buf_lock+0x3d/0xe0\n  xfs_iflush_shutdown_abort+0x51/0x1e0\n  xfs_icwalk_ag+0x386/0x690\n  xfs_reclaim_inodes_nr+0x114/0x160\n  xfs_fs_free_cached_objects+0x19/0x20\n  super_cache_scan+0x17b/0x1a0\n  do_shrink_slab+0x180/0x350\n  shrink_slab+0xf8/0x430\n  drop_slab+0x97/0xf0\n  drop_caches_sysctl_handler+0x59/0xc0\n  proc_sys_call_handler+0x189/0x280\n  proc_sys_write+0x13/0x20\n  vfs_write+0x33d/0x3f0\n  ksys_write+0x7c/0xf0\n  __x64_sys_write+0x1b/0x30\n  x64_sys_call+0x271d/0x2ee0\n  do_syscall_64+0x68/0x130\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nWe can't change the lock order of xfs_ifree_cluster() - XFS_ISTALE\nand XFS_IFLUSHING are serialised through to journal IO completion\nby the cluster buffer lock being held.\n\nThere's quite a few asserts in the code that check that XFS_ISTALE\ndoes not occur out of sync with buffer locking (e.g. in\nxfs_iflush_cluster). There's also a dependency on the inode log item\nbeing removed from the buffer before XFS_IFLUSHING is cleared, also\nwith asserts that trigger on this.\n\nFurther, we don't have a requirement for the inode to be locked when\ncompleting or aborting inode flushing because all the inode state\nupdates are serialised by holding the cluster buffer lock across the\nIO to completion.\n\nWe can't check for XFS_IRECLAIM in xfs_ifree_mark_inode_stale() and\nskip the inode, because there is no guarantee that the inode will be\nreclaimed. Hence it *must* be marked XFS_ISTALE regardless of\nwhether reclaim is preparing to free that inode. Similarly, we can't\ncheck for IFLUSHING before locking the inode because that would\nresult in dirty inodes not being marked with ISTALE in the event of\nracing with XFS_IRECLAIM.\n\nHence we have to address this issue from the xfs_reclaim_inode()\nside. It is clear that we cannot hold the inode locked here when\ncalling xfs_iflush_shutdown_abort() because it is the inode->buffer\nlock order that causes the deadlock against xfs_ifree_cluster().\n\nHence we need to drop the ILOCK before aborting the inode in the\nshutdown case. Once we've aborted the inode, we can grab the ILOCK\nagain and then immediately reclaim it as it is now guaranteed to be\nclean.\n\nNote that dropping the ILOCK in xfs_reclaim_inode() means that it\ncan now be locked by xfs_ifree_mark_inode_stale() and seen whilst in\nthis state. This is safe because we have left the XFS_IFLUSHING flag\non the inode and so xfs_ifree_mark_inode_stale() will simply set\nXFS_ISTALE and move to the next inode. An ASSERT check in this path\nneeds to be tweaked to take into account this new shutdown\ninteraction.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Carlos Maiolino <cmaiolino@redhat.com>\nSigned-off-by: Carlos Maiolino <cem@kernel.org>",
    "author": "Dave Chinner",
    "date": "2025-06-27T14:08:39+02:00",
    "files_changed": [
      "fs/xfs/xfs_icache.c",
      "fs/xfs/xfs_inode.c"
    ],
    "diff": "diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c\nindex 726e29b837e6..bbc2f2973dcc 100644\n--- a/fs/xfs/xfs_icache.c\n+++ b/fs/xfs/xfs_icache.c\n@@ -979,7 +979,15 @@ xfs_reclaim_inode(\n \t */\n \tif (xlog_is_shutdown(ip->i_mount->m_log)) {\n \t\txfs_iunpin_wait(ip);\n+\t\t/*\n+\t\t * Avoid a ABBA deadlock on the inode cluster buffer vs\n+\t\t * concurrent xfs_ifree_cluster() trying to mark the inode\n+\t\t * stale. We don't need the inode locked to run the flush abort\n+\t\t * code, but the flush abort needs to lock the cluster buffer.\n+\t\t */\n+\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n \t\txfs_iflush_shutdown_abort(ip);\n+\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n \t\tgoto reclaim;\n \t}\n \tif (xfs_ipincount(ip))\ndiff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c\nindex ee3e0f284287..761a996a857c 100644\n--- a/fs/xfs/xfs_inode.c\n+++ b/fs/xfs/xfs_inode.c\n@@ -1635,7 +1635,7 @@ xfs_ifree_mark_inode_stale(\n \tiip = ip->i_itemp;\n \tif (__xfs_iflags_test(ip, XFS_IFLUSHING)) {\n \t\tASSERT(!list_empty(&iip->ili_item.li_bio_list));\n-\t\tASSERT(iip->ili_last_fields);\n+\t\tASSERT(iip->ili_last_fields || xlog_is_shutdown(mp->m_log));\n \t\tgoto out_iunlock;\n \t}\n ",
    "stats": {
      "insertions": 9,
      "deletions": 1,
      "files": 2
    }
  }
]
[
  {
    "sha": "97aadc161d623b4b86ee5deaeb8e9165422ecb9e",
    "message": "Merge tag 'drm-misc-fixes-2025-06-19' of https://gitlab.freedesktop.org/drm/misc/kernel into drm-fixes\n\ndrm-misc-fixes for v6.16-rc3:\n- vivante scheduler fix.\n- v3d null pointer crash fix.\n- fix backlight, booting GSP-RM, and potential integer shift overflow in nouveau.\n- fix compiler warnings about unused linux/export.h\n- fix malidp unknown modifier spam.\n- fix for ssd130x.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\nFrom: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nLink: https://lore.kernel.org/r/d44bab7b-01f8-45a8-a7f4-5d3d563d2f9d@linux.intel.com",
    "author": "Dave Airlie",
    "date": "2025-06-20T08:57:11+10:00",
    "files_changed": [
      "drivers/gpu/drm/arm/malidp_planes.c",
      "drivers/gpu/drm/ast/ast_mode.c",
      "drivers/gpu/drm/etnaviv/etnaviv_sched.c",
      "drivers/gpu/drm/mgag200/mgag200_ddc.c",
      "drivers/gpu/drm/nouveau/nouveau_backlight.c",
      "drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c",
      "drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/vmm.c",
      "drivers/gpu/drm/solomon/ssd130x.c",
      "drivers/gpu/drm/v3d/v3d_sched.c"
    ],
    "diff": "diff --git a/Documentation/gpu/nouveau.rst b/Documentation/gpu/nouveau.rst\nindex b8c801e0068c..cab2e81013bc 100644\n--- a/Documentation/gpu/nouveau.rst\n+++ b/Documentation/gpu/nouveau.rst\n@@ -25,7 +25,7 @@ providing a consistent API to upper layers of the driver stack.\n GSP Support\n ------------------------\n \n-.. kernel-doc:: drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c\n+.. kernel-doc:: drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c\n    :doc: GSP message queue element\n \n .. kernel-doc:: drivers/gpu/drm/nouveau/include/nvkm/subdev/gsp.h\ndiff --git a/drivers/gpu/drm/arm/malidp_planes.c b/drivers/gpu/drm/arm/malidp_planes.c\nindex 34547edf1ee3..87f2e5ee8790 100644\n--- a/drivers/gpu/drm/arm/malidp_planes.c\n+++ b/drivers/gpu/drm/arm/malidp_planes.c\n@@ -159,7 +159,7 @@ bool malidp_format_mod_supported(struct drm_device *drm,\n \t}\n \n \tif (!fourcc_mod_is_vendor(modifier, ARM)) {\n-\t\tDRM_ERROR(\"Unknown modifier (not Arm)\\n\");\n+\t\tDRM_DEBUG_KMS(\"Unknown modifier (not Arm)\\n\");\n \t\treturn false;\n \t}\n \ndiff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c\nindex 1de832964e92..031980d8f3ab 100644\n--- a/drivers/gpu/drm/ast/ast_mode.c\n+++ b/drivers/gpu/drm/ast/ast_mode.c\n@@ -29,7 +29,6 @@\n  */\n \n #include <linux/delay.h>\n-#include <linux/export.h>\n #include <linux/pci.h>\n \n #include <drm/drm_atomic.h>\ndiff --git a/drivers/gpu/drm/etnaviv/etnaviv_sched.c b/drivers/gpu/drm/etnaviv/etnaviv_sched.c\nindex 76a3a3e517d8..71e2e6b9d713 100644\n--- a/drivers/gpu/drm/etnaviv/etnaviv_sched.c\n+++ b/drivers/gpu/drm/etnaviv/etnaviv_sched.c\n@@ -35,6 +35,7 @@ static enum drm_gpu_sched_stat etnaviv_sched_timedout_job(struct drm_sched_job\n \t\t\t\t\t\t\t  *sched_job)\n {\n \tstruct etnaviv_gem_submit *submit = to_etnaviv_submit(sched_job);\n+\tstruct drm_gpu_scheduler *sched = sched_job->sched;\n \tstruct etnaviv_gpu *gpu = submit->gpu;\n \tu32 dma_addr, primid = 0;\n \tint change;\n@@ -89,7 +90,9 @@ static enum drm_gpu_sched_stat etnaviv_sched_timedout_job(struct drm_sched_job\n \treturn DRM_GPU_SCHED_STAT_NOMINAL;\n \n out_no_timeout:\n-\tlist_add(&sched_job->list, &sched_job->sched->pending_list);\n+\tspin_lock(&sched->job_list_lock);\n+\tlist_add(&sched_job->list, &sched->pending_list);\n+\tspin_unlock(&sched->job_list_lock);\n \treturn DRM_GPU_SCHED_STAT_NOMINAL;\n }\n \ndiff --git a/drivers/gpu/drm/mgag200/mgag200_ddc.c b/drivers/gpu/drm/mgag200/mgag200_ddc.c\nindex 6d81ea8931e8..c31673eaa554 100644\n--- a/drivers/gpu/drm/mgag200/mgag200_ddc.c\n+++ b/drivers/gpu/drm/mgag200/mgag200_ddc.c\n@@ -26,7 +26,6 @@\n  * Authors: Dave Airlie <airlied@redhat.com>\n  */\n \n-#include <linux/export.h>\n #include <linux/i2c-algo-bit.h>\n #include <linux/i2c.h>\n #include <linux/pci.h>\ndiff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c\nindex d47442125fa1..9aae26eb7d8f 100644\n--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c\n+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c\n@@ -42,7 +42,7 @@\n #include \"nouveau_acpi.h\"\n \n static struct ida bl_ida;\n-#define BL_NAME_SIZE 15 // 12 for name + 2 for digits + 1 for '\\0'\n+#define BL_NAME_SIZE 24 // 12 for name + 11 for digits + 1 for '\\0'\n \n static bool\n nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE],\ndiff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c\nindex 5acb98d137bd..9d06ff722fea 100644\n--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/rpc.c\n@@ -637,12 +637,18 @@ r535_gsp_rpc_push(struct nvkm_gsp *gsp, void *payload,\n \tif (payload_size > max_payload_size) {\n \t\tconst u32 fn = rpc->function;\n \t\tu32 remain_payload_size = payload_size;\n+\t\tvoid *next;\n \n-\t\t/* Adjust length, and send initial RPC. */\n-\t\trpc->length = sizeof(*rpc) + max_payload_size;\n-\t\tmsg->checksum = rpc->length;\n+\t\t/* Send initial RPC. */\n+\t\tnext = r535_gsp_rpc_get(gsp, fn, max_payload_size);\n+\t\tif (IS_ERR(next)) {\n+\t\t\trepv = next;\n+\t\t\tgoto done;\n+\t\t}\n \n-\t\trepv = r535_gsp_rpc_send(gsp, payload, NVKM_GSP_RPC_REPLY_NOWAIT, 0);\n+\t\tmemcpy(next, payload, max_payload_size);\n+\n+\t\trepv = r535_gsp_rpc_send(gsp, next, NVKM_GSP_RPC_REPLY_NOWAIT, 0);\n \t\tif (IS_ERR(repv))\n \t\t\tgoto done;\n \n@@ -653,7 +659,6 @@ r535_gsp_rpc_push(struct nvkm_gsp *gsp, void *payload,\n \t\twhile (remain_payload_size) {\n \t\t\tu32 size = min(remain_payload_size,\n \t\t\t\t       max_payload_size);\n-\t\t\tvoid *next;\n \n \t\t\tnext = r535_gsp_rpc_get(gsp, NV_VGPU_MSG_FUNCTION_CONTINUATION_RECORD, size);\n \t\t\tif (IS_ERR(next)) {\n@@ -674,6 +679,8 @@ r535_gsp_rpc_push(struct nvkm_gsp *gsp, void *payload,\n \t\t/* Wait for reply. */\n \t\trepv = r535_gsp_rpc_handle_reply(gsp, fn, policy, payload_size +\n \t\t\t\t\t\t sizeof(*rpc));\n+\t\tif (!IS_ERR(repv))\n+\t\t\tkvfree(msg);\n \t} else {\n \t\trepv = r535_gsp_rpc_send(gsp, payload, policy, gsp_rpc_len);\n \t}\ndiff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/vmm.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/vmm.c\nindex 52f2e5f14517..f25ea610cd99 100644\n--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/vmm.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/vmm.c\n@@ -121,7 +121,7 @@ r535_mmu_vaspace_new(struct nvkm_vmm *vmm, u32 handle, bool external)\n \t\t\tpage_shift -= desc->bits;\n \n \t\t\tctrl->levels[i].physAddress = pd->pt[0]->addr;\n-\t\t\tctrl->levels[i].size = (1 << desc->bits) * desc->size;\n+\t\t\tctrl->levels[i].size = BIT_ULL(desc->bits) * desc->size;\n \t\t\tctrl->levels[i].aperture = 1;\n \t\t\tctrl->levels[i].pageShift = page_shift;\n \ndiff --git a/drivers/gpu/drm/solomon/ssd130x.c b/drivers/gpu/drm/solomon/ssd130x.c\nindex dd2006d51c7a..eec43d1a5595 100644\n--- a/drivers/gpu/drm/solomon/ssd130x.c\n+++ b/drivers/gpu/drm/solomon/ssd130x.c\n@@ -974,7 +974,7 @@ static void ssd130x_clear_screen(struct ssd130x_device *ssd130x, u8 *data_array)\n \n static void ssd132x_clear_screen(struct ssd130x_device *ssd130x, u8 *data_array)\n {\n-\tunsigned int columns = DIV_ROUND_UP(ssd130x->height, SSD132X_SEGMENT_WIDTH);\n+\tunsigned int columns = DIV_ROUND_UP(ssd130x->width, SSD132X_SEGMENT_WIDTH);\n \tunsigned int height = ssd130x->height;\n \n \tmemset(data_array, 0, columns * height);\ndiff --git a/drivers/gpu/drm/v3d/v3d_sched.c b/drivers/gpu/drm/v3d/v3d_sched.c\nindex 35f131a46d07..42df9d3567e7 100644\n--- a/drivers/gpu/drm/v3d/v3d_sched.c\n+++ b/drivers/gpu/drm/v3d/v3d_sched.c\n@@ -199,7 +199,6 @@ v3d_job_update_stats(struct v3d_job *job, enum v3d_queue queue)\n \tstruct v3d_dev *v3d = job->v3d;\n \tstruct v3d_file_priv *file = job->file->driver_priv;\n \tstruct v3d_stats *global_stats = &v3d->queue[queue].stats;\n-\tstruct v3d_stats *local_stats = &file->stats[queue];\n \tu64 now = local_clock();\n \tunsigned long flags;\n \n@@ -209,7 +208,12 @@ v3d_job_update_stats(struct v3d_job *job, enum v3d_queue queue)\n \telse\n \t\tpreempt_disable();\n \n-\tv3d_stats_update(local_stats, now);\n+\t/* Don't update the local stats if the file context has already closed */\n+\tif (file)\n+\t\tv3d_stats_update(&file->stats[queue], now);\n+\telse\n+\t\tdrm_dbg(&v3d->drm, \"The file descriptor was closed before job completion\\n\");\n+\n \tv3d_stats_update(global_stats, now);\n \n \tif (IS_ENABLED(CONFIG_LOCKDEP))",
    "stats": {
      "insertions": 27,
      "deletions": 15,
      "files": 10
    }
  },
  {
    "sha": "fde46f60f6c5138ee422087addbc5bf5b4968bf1",
    "message": "selinux: change security_compute_sid to return the ssid or tsid on match\n\nIf the end result of a security_compute_sid() computation matches the\nssid or tsid, return that SID rather than looking it up again. This\navoids the problem of multiple initial SIDs that map to the same\ncontext.\n\nCc: stable@vger.kernel.org\nReported-by: Guido Trentalancia <guido@trentalancia.com>\nFixes: ae254858ce07 (\"selinux: introduce an initial SID for early boot processes\")\nSigned-off-by: Stephen Smalley <stephen.smalley.work@gmail.com>\nTested-by: Guido Trentalancia <guido@trentalancia.com>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
    "author": "Stephen Smalley",
    "date": "2025-06-19T16:13:16-04:00",
    "files_changed": [
      "security/selinux/ss/services.c"
    ],
    "diff": "diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c\nindex 7becf3808818..d185754c2786 100644\n--- a/security/selinux/ss/services.c\n+++ b/security/selinux/ss/services.c\n@@ -1909,11 +1909,17 @@ static int security_compute_sid(u32 ssid,\n \t\t\tgoto out_unlock;\n \t}\n \t/* Obtain the sid for the context. */\n-\trc = sidtab_context_to_sid(sidtab, &newcontext, out_sid);\n-\tif (rc == -ESTALE) {\n-\t\trcu_read_unlock();\n-\t\tcontext_destroy(&newcontext);\n-\t\tgoto retry;\n+\tif (context_equal(scontext, &newcontext))\n+\t\t*out_sid = ssid;\n+\telse if (context_equal(tcontext, &newcontext))\n+\t\t*out_sid = tsid;\n+\telse {\n+\t\trc = sidtab_context_to_sid(sidtab, &newcontext, out_sid);\n+\t\tif (rc == -ESTALE) {\n+\t\t\trcu_read_unlock();\n+\t\t\tcontext_destroy(&newcontext);\n+\t\t\tgoto retry;\n+\t\t}\n \t}\n out_unlock:\n \trcu_read_unlock();",
    "stats": {
      "insertions": 11,
      "deletions": 5,
      "files": 1
    }
  },
  {
    "sha": "5c8013ae2e86ec36b07500ba4cacb14ab4d6f728",
    "message": "Merge tag 'net-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net\n\nPull networking fixes from Jakub Kicinski:\n \"Including fixes from wireless.\n\n  The ath12k fix to avoid FW crashes requires adding support for a\n  number of new FW commands so it's quite large in terms of LoC. The\n  rest is relatively small.\n\n  Current release - fix to a fix:\n\n   - ptp: fix breakage after ptp_vclock_in_use() rework\n\n  Current release - regressions:\n\n   - openvswitch: allocate struct ovs_pcpu_storage dynamically, static\n     allocation may exhaust module loader limit on smaller systems\n\n  Previous releases - regressions:\n\n   - tcp: fix tcp_packet_delayed() for peers with no selective ACK\n     support\n\n  Previous releases - always broken:\n\n   - wifi: ath12k: don't activate more links than firmware supports\n\n   - tcp: make sure sockets open via passive TFO have valid NAPI ID\n\n   - eth: bnxt_en: update MRU and RSS table of RSS contexts on queue\n     reset, prevent Rx queues from silently hanging after queue reset\n\n   - NFC: uart: set tty->disc_data only in success path\"\n\n* tag 'net-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net: (59 commits)\n  net: airoha: Differentiate hwfd buffer size for QDMA0 and QDMA1\n  net: airoha: Compute number of descriptors according to reserved memory size\n  tools: ynl: fix mixing ops and notifications on one socket\n  net: atm: fix /proc/net/atm/lec handling\n  net: atm: add lec_mutex\n  mlxbf_gige: return EPROBE_DEFER if PHY IRQ is not available\n  net: airoha: Always check return value from airoha_ppe_foe_get_entry()\n  NFC: nci: uart: Set tty->disc_data only in success path\n  calipso: Fix null-ptr-deref in calipso_req_{set,del}attr().\n  MAINTAINERS: Remove Shannon Nelson from MAINTAINERS file\n  net: lan743x: fix potential out-of-bounds write in lan743x_ptp_io_event_clock_get()\n  eth: fbnic: avoid double free when failing to DMA-map FW msg\n  tcp: fix passive TFO socket having invalid NAPI ID\n  selftests: net: add test for passive TFO socket NAPI ID\n  selftests: net: add passive TFO test binary\n  selftests: netdevsim: improve lib.sh include in peer.sh\n  tipc: fix null-ptr-deref when acquiring remote ip of ethernet bearer\n  Octeontx2-pf: Fix Backpresure configuration\n  net: ftgmac100: select FIXED_PHY\n  net: ethtool: remove duplicate defines for family info\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-06-19T10:21:32-07:00",
    "files_changed": [
      "drivers/atm/atmtcp.c",
      "drivers/net/can/m_can/tcan4x5x-core.c",
      "drivers/net/ethernet/airoha/airoha_eth.c",
      "drivers/net/ethernet/airoha/airoha_ppe.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c",
      "drivers/net/ethernet/intel/e1000e/netdev.c",
      "drivers/net/ethernet/intel/e1000e/ptp.c",
      "drivers/net/ethernet/intel/ice/ice_arfs.c",
      "drivers/net/ethernet/intel/ice/ice_eswitch.c",
      "drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c",
      "drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c",
      "drivers/net/ethernet/meta/fbnic/fbnic_fw.c",
      "drivers/net/ethernet/microchip/lan743x_ptp.h",
      "drivers/net/ethernet/pensando/ionic/ionic_main.c",
      "drivers/net/ethernet/ti/icssg/icssg_common.c",
      "drivers/net/wireless/ath/ath12k/core.c",
      "drivers/net/wireless/ath/ath12k/core.h",
      "drivers/net/wireless/ath/ath12k/debugfs.c",
      "drivers/net/wireless/ath/ath12k/debugfs.h",
      "drivers/net/wireless/ath/ath12k/mac.c",
      "drivers/net/wireless/ath/ath12k/mac.h",
      "drivers/net/wireless/ath/ath12k/wmi.c",
      "drivers/net/wireless/ath/ath12k/wmi.h",
      "drivers/net/wireless/ath/ath6kl/bmi.c",
      "drivers/net/wireless/ath/carl9170/usb.c",
      "drivers/net/wireless/intel/iwlwifi/dvm/main.c",
      "drivers/net/wireless/intel/iwlwifi/mld/mld.c",
      "drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c",
      "drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info.c",
      "drivers/ptp/ptp_clock.c",
      "drivers/ptp/ptp_private.h",
      "include/linux/atmdev.h",
      "include/linux/ieee80211.h",
      "include/uapi/linux/ethtool_netlink.h",
      "include/uapi/linux/ethtool_netlink_generated.h",
      "net/atm/common.c",
      "net/atm/lec.c",
      "net/atm/raw.c",
      "net/core/skbuff.c",
      "net/ipv4/tcp_fastopen.c",
      "net/ipv4/tcp_input.c",
      "net/ipv6/calipso.c",
      "net/mac80211/debug.h",
      "net/mac80211/rx.c",
      "net/mac80211/tx.c",
      "net/mpls/af_mpls.c",
      "net/nfc/nci/uart.c",
      "net/openvswitch/actions.c",
      "net/openvswitch/datapath.c",
      "net/openvswitch/datapath.h",
      "net/sched/sch_taprio.c",
      "net/tipc/udp_media.c",
      "tools/testing/selftests/net/tfo.c"
    ],
    "diff": "diff --git a/.mailmap b/.mailmap\nindex fee7681100a8..d57531dab08b 100644\n--- a/.mailmap\n+++ b/.mailmap\n@@ -693,9 +693,10 @@ Serge Hallyn <sergeh@kernel.org> <serge.hallyn@canonical.com>\n Serge Hallyn <sergeh@kernel.org> <serue@us.ibm.com>\n Seth Forshee <sforshee@kernel.org> <seth.forshee@canonical.com>\n Shakeel Butt <shakeel.butt@linux.dev> <shakeelb@google.com>\n-Shannon Nelson <shannon.nelson@amd.com> <snelson@pensando.io>\n-Shannon Nelson <shannon.nelson@amd.com> <shannon.nelson@intel.com>\n-Shannon Nelson <shannon.nelson@amd.com> <shannon.nelson@oracle.com>\n+Shannon Nelson <sln@onemain.com> <shannon.nelson@amd.com>\n+Shannon Nelson <sln@onemain.com> <snelson@pensando.io>\n+Shannon Nelson <sln@onemain.com> <shannon.nelson@intel.com>\n+Shannon Nelson <sln@onemain.com> <shannon.nelson@oracle.com>\n Sharath Chandra Vurukala <quic_sharathv@quicinc.com> <sharathv@codeaurora.org>\n Shiraz Hashim <shiraz.linux.kernel@gmail.com> <shiraz.hashim@st.com>\n Shuah Khan <shuah@kernel.org> <shuahkhan@gmail.com>\ndiff --git a/Documentation/netlink/specs/ethtool.yaml b/Documentation/netlink/specs/ethtool.yaml\nindex 9f98715a6512..72a076b0e1b5 100644\n--- a/Documentation/netlink/specs/ethtool.yaml\n+++ b/Documentation/netlink/specs/ethtool.yaml\n@@ -7,6 +7,9 @@ protocol: genetlink-legacy\n doc: Partial family for Ethtool Netlink.\n uapi-header: linux/ethtool_netlink_generated.h\n \n+c-family-name: ethtool-genl-name\n+c-version-name: ethtool-genl-version\n+\n definitions:\n   -\n     name: udp-tunnel-type\ndiff --git a/MAINTAINERS b/MAINTAINERS\nindex bf73c90a957a..f584e170cfc3 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -1157,7 +1157,6 @@ F:\tarch/x86/include/asm/amd/node.h\n F:\tarch/x86/kernel/amd_node.c\n \n AMD PDS CORE DRIVER\n-M:\tShannon Nelson <shannon.nelson@amd.com>\n M:\tBrett Creeley <brett.creeley@amd.com>\n L:\tnetdev@vger.kernel.org\n S:\tMaintained\n@@ -9942,7 +9941,6 @@ F:\tdrivers/fwctl/mlx5/\n \n FWCTL PDS DRIVER\n M:\tBrett Creeley <brett.creeley@amd.com>\n-R:\tShannon Nelson <shannon.nelson@amd.com>\n L:\tlinux-kernel@vger.kernel.org\n S:\tMaintained\n F:\tdrivers/fwctl/pds/\n@@ -19379,7 +19377,7 @@ F:\tcrypto/pcrypt.c\n F:\tinclude/crypto/pcrypt.h\n \n PDS DSC VIRTIO DATA PATH ACCELERATOR\n-R:\tShannon Nelson <shannon.nelson@amd.com>\n+R:\tBrett Creeley <brett.creeley@amd.com>\n F:\tdrivers/vdpa/pds/\n \n PECI HARDWARE MONITORING DRIVERS\n@@ -19401,7 +19399,6 @@ F:\tinclude/linux/peci-cpu.h\n F:\tinclude/linux/peci.h\n \n PENSANDO ETHERNET DRIVERS\n-M:\tShannon Nelson <shannon.nelson@amd.com>\n M:\tBrett Creeley <brett.creeley@amd.com>\n L:\tnetdev@vger.kernel.org\n S:\tMaintained\ndiff --git a/drivers/atm/atmtcp.c b/drivers/atm/atmtcp.c\nindex d4aa0f353b6c..eeae160c898d 100644\n--- a/drivers/atm/atmtcp.c\n+++ b/drivers/atm/atmtcp.c\n@@ -288,7 +288,9 @@ static int atmtcp_c_send(struct atm_vcc *vcc,struct sk_buff *skb)\n \tstruct sk_buff *new_skb;\n \tint result = 0;\n \n-\tif (!skb->len) return 0;\n+\tif (skb->len < sizeof(struct atmtcp_hdr))\n+\t\tgoto done;\n+\n \tdev = vcc->dev_data;\n \thdr = (struct atmtcp_hdr *) skb->data;\n \tif (hdr->length == ATMTCP_HDR_MAGIC) {\ndiff --git a/drivers/net/can/m_can/tcan4x5x-core.c b/drivers/net/can/m_can/tcan4x5x-core.c\nindex e5c162f8c589..8edaa339d590 100644\n--- a/drivers/net/can/m_can/tcan4x5x-core.c\n+++ b/drivers/net/can/m_can/tcan4x5x-core.c\n@@ -411,10 +411,11 @@ static int tcan4x5x_can_probe(struct spi_device *spi)\n \tpriv = cdev_to_priv(mcan_class);\n \n \tpriv->power = devm_regulator_get_optional(&spi->dev, \"vsup\");\n-\tif (PTR_ERR(priv->power) == -EPROBE_DEFER) {\n-\t\tret = -EPROBE_DEFER;\n-\t\tgoto out_m_can_class_free_dev;\n-\t} else {\n+\tif (IS_ERR(priv->power)) {\n+\t\tif (PTR_ERR(priv->power) == -EPROBE_DEFER) {\n+\t\t\tret = -EPROBE_DEFER;\n+\t\t\tgoto out_m_can_class_free_dev;\n+\t\t}\n \t\tpriv->power = NULL;\n \t}\n \ndiff --git a/drivers/net/ethernet/airoha/airoha_eth.c b/drivers/net/ethernet/airoha/airoha_eth.c\nindex a7ec609d64de..06dea3a13e77 100644\n--- a/drivers/net/ethernet/airoha/airoha_eth.c\n+++ b/drivers/net/ethernet/airoha/airoha_eth.c\n@@ -1065,23 +1065,18 @@ static void airoha_qdma_cleanup_tx_queue(struct airoha_queue *q)\n \n static int airoha_qdma_init_hfwd_queues(struct airoha_qdma *qdma)\n {\n+\tint size, index, num_desc = HW_DSCP_NUM;\n \tstruct airoha_eth *eth = qdma->eth;\n \tint id = qdma - &eth->qdma[0];\n+\tu32 status, buf_size;\n \tdma_addr_t dma_addr;\n \tconst char *name;\n-\tint size, index;\n-\tu32 status;\n-\n-\tsize = HW_DSCP_NUM * sizeof(struct airoha_qdma_fwd_desc);\n-\tif (!dmam_alloc_coherent(eth->dev, size, &dma_addr, GFP_KERNEL))\n-\t\treturn -ENOMEM;\n-\n-\tairoha_qdma_wr(qdma, REG_FWD_DSCP_BASE, dma_addr);\n \n \tname = devm_kasprintf(eth->dev, GFP_KERNEL, \"qdma%d-buf\", id);\n \tif (!name)\n \t\treturn -ENOMEM;\n \n+\tbuf_size = id ? AIROHA_MAX_PACKET_SIZE / 2 : AIROHA_MAX_PACKET_SIZE;\n \tindex = of_property_match_string(eth->dev->of_node,\n \t\t\t\t\t \"memory-region-names\", name);\n \tif (index >= 0) {\n@@ -1099,8 +1094,12 @@ static int airoha_qdma_init_hfwd_queues(struct airoha_qdma *qdma)\n \t\trmem = of_reserved_mem_lookup(np);\n \t\tof_node_put(np);\n \t\tdma_addr = rmem->base;\n+\t\t/* Compute the number of hw descriptors according to the\n+\t\t * reserved memory size and the payload buffer size\n+\t\t */\n+\t\tnum_desc = div_u64(rmem->size, buf_size);\n \t} else {\n-\t\tsize = AIROHA_MAX_PACKET_SIZE * HW_DSCP_NUM;\n+\t\tsize = buf_size * num_desc;\n \t\tif (!dmam_alloc_coherent(eth->dev, size, &dma_addr,\n \t\t\t\t\t GFP_KERNEL))\n \t\t\treturn -ENOMEM;\n@@ -1108,15 +1107,21 @@ static int airoha_qdma_init_hfwd_queues(struct airoha_qdma *qdma)\n \n \tairoha_qdma_wr(qdma, REG_FWD_BUF_BASE, dma_addr);\n \n+\tsize = num_desc * sizeof(struct airoha_qdma_fwd_desc);\n+\tif (!dmam_alloc_coherent(eth->dev, size, &dma_addr, GFP_KERNEL))\n+\t\treturn -ENOMEM;\n+\n+\tairoha_qdma_wr(qdma, REG_FWD_DSCP_BASE, dma_addr);\n+\t/* QDMA0: 2KB. QDMA1: 1KB */\n \tairoha_qdma_rmw(qdma, REG_HW_FWD_DSCP_CFG,\n \t\t\tHW_FWD_DSCP_PAYLOAD_SIZE_MASK,\n-\t\t\tFIELD_PREP(HW_FWD_DSCP_PAYLOAD_SIZE_MASK, 0));\n+\t\t\tFIELD_PREP(HW_FWD_DSCP_PAYLOAD_SIZE_MASK, !!id));\n \tairoha_qdma_rmw(qdma, REG_FWD_DSCP_LOW_THR, FWD_DSCP_LOW_THR_MASK,\n \t\t\tFIELD_PREP(FWD_DSCP_LOW_THR_MASK, 128));\n \tairoha_qdma_rmw(qdma, REG_LMGR_INIT_CFG,\n \t\t\tLMGR_INIT_START | LMGR_SRAM_MODE_MASK |\n \t\t\tHW_FWD_DESC_NUM_MASK,\n-\t\t\tFIELD_PREP(HW_FWD_DESC_NUM_MASK, HW_DSCP_NUM) |\n+\t\t\tFIELD_PREP(HW_FWD_DESC_NUM_MASK, num_desc) |\n \t\t\tLMGR_INIT_START | LMGR_SRAM_MODE_MASK);\n \n \treturn read_poll_timeout(airoha_qdma_rr, status,\ndiff --git a/drivers/net/ethernet/airoha/airoha_ppe.c b/drivers/net/ethernet/airoha/airoha_ppe.c\nindex 9067d2fc7706..0e217acfc5ef 100644\n--- a/drivers/net/ethernet/airoha/airoha_ppe.c\n+++ b/drivers/net/ethernet/airoha/airoha_ppe.c\n@@ -809,8 +809,10 @@ airoha_ppe_foe_flow_l2_entry_update(struct airoha_ppe *ppe,\n \t\tint idle;\n \n \t\thwe = airoha_ppe_foe_get_entry(ppe, iter->hash);\n-\t\tib1 = READ_ONCE(hwe->ib1);\n+\t\tif (!hwe)\n+\t\t\tcontinue;\n \n+\t\tib1 = READ_ONCE(hwe->ib1);\n \t\tstate = FIELD_GET(AIROHA_FOE_IB1_BIND_STATE, ib1);\n \t\tif (state != AIROHA_FOE_STATE_BIND) {\n \t\t\titer->hash = 0xffff;\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c\nindex 869580b6f70d..2cb3185c442c 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n@@ -10780,6 +10780,72 @@ void bnxt_del_one_rss_ctx(struct bnxt *bp, struct bnxt_rss_ctx *rss_ctx,\n \tbp->num_rss_ctx--;\n }\n \n+static bool bnxt_vnic_has_rx_ring(struct bnxt *bp, struct bnxt_vnic_info *vnic,\n+\t\t\t\t  int rxr_id)\n+{\n+\tu16 tbl_size = bnxt_get_rxfh_indir_size(bp->dev);\n+\tint i, vnic_rx;\n+\n+\t/* Ntuple VNIC always has all the rx rings. Any change of ring id\n+\t * must be updated because a future filter may use it.\n+\t */\n+\tif (vnic->flags & BNXT_VNIC_NTUPLE_FLAG)\n+\t\treturn true;\n+\n+\tfor (i = 0; i < tbl_size; i++) {\n+\t\tif (vnic->flags & BNXT_VNIC_RSSCTX_FLAG)\n+\t\t\tvnic_rx = ethtool_rxfh_context_indir(vnic->rss_ctx)[i];\n+\t\telse\n+\t\t\tvnic_rx = bp->rss_indir_tbl[i];\n+\n+\t\tif (rxr_id == vnic_rx)\n+\t\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+static int bnxt_set_vnic_mru_p5(struct bnxt *bp, struct bnxt_vnic_info *vnic,\n+\t\t\t\tu16 mru, int rxr_id)\n+{\n+\tint rc;\n+\n+\tif (!bnxt_vnic_has_rx_ring(bp, vnic, rxr_id))\n+\t\treturn 0;\n+\n+\tif (mru) {\n+\t\trc = bnxt_hwrm_vnic_set_rss_p5(bp, vnic, true);\n+\t\tif (rc) {\n+\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d set rss failure rc: %d\\n\",\n+\t\t\t\t   vnic->vnic_id, rc);\n+\t\t\treturn rc;\n+\t\t}\n+\t}\n+\tvnic->mru = mru;\n+\tbnxt_hwrm_vnic_update(bp, vnic,\n+\t\t\t      VNIC_UPDATE_REQ_ENABLES_MRU_VALID);\n+\n+\treturn 0;\n+}\n+\n+static int bnxt_set_rss_ctx_vnic_mru(struct bnxt *bp, u16 mru, int rxr_id)\n+{\n+\tstruct ethtool_rxfh_context *ctx;\n+\tunsigned long context;\n+\tint rc;\n+\n+\txa_for_each(&bp->dev->ethtool->rss_ctx, context, ctx) {\n+\t\tstruct bnxt_rss_ctx *rss_ctx = ethtool_rxfh_context_priv(ctx);\n+\t\tstruct bnxt_vnic_info *vnic = &rss_ctx->vnic;\n+\n+\t\trc = bnxt_set_vnic_mru_p5(bp, vnic, mru, rxr_id);\n+\t\tif (rc)\n+\t\t\treturn rc;\n+\t}\n+\n+\treturn 0;\n+}\n+\n static void bnxt_hwrm_realloc_rss_ctx_vnic(struct bnxt *bp)\n {\n \tbool set_tpa = !!(bp->flags & BNXT_FLAG_TPA);\n@@ -15927,6 +15993,7 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)\n \tstruct bnxt_vnic_info *vnic;\n \tstruct bnxt_napi *bnapi;\n \tint i, rc;\n+\tu16 mru;\n \n \trxr = &bp->rx_ring[idx];\n \tclone = qmem;\n@@ -15977,21 +16044,15 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)\n \tnapi_enable_locked(&bnapi->napi);\n \tbnxt_db_nq_arm(bp, &cpr->cp_db, cpr->cp_raw_cons);\n \n+\tmru = bp->dev->mtu + ETH_HLEN + VLAN_HLEN;\n \tfor (i = 0; i < bp->nr_vnics; i++) {\n \t\tvnic = &bp->vnic_info[i];\n \n-\t\trc = bnxt_hwrm_vnic_set_rss_p5(bp, vnic, true);\n-\t\tif (rc) {\n-\t\t\tnetdev_err(bp->dev, \"hwrm vnic %d set rss failure rc: %d\\n\",\n-\t\t\t\t   vnic->vnic_id, rc);\n+\t\trc = bnxt_set_vnic_mru_p5(bp, vnic, mru, idx);\n+\t\tif (rc)\n \t\t\treturn rc;\n-\t\t}\n-\t\tvnic->mru = bp->dev->mtu + ETH_HLEN + VLAN_HLEN;\n-\t\tbnxt_hwrm_vnic_update(bp, vnic,\n-\t\t\t\t      VNIC_UPDATE_REQ_ENABLES_MRU_VALID);\n \t}\n-\n-\treturn 0;\n+\treturn bnxt_set_rss_ctx_vnic_mru(bp, mru, idx);\n \n err_reset:\n \tnetdev_err(bp->dev, \"Unexpected HWRM error during queue start rc: %d\\n\",\n@@ -16013,10 +16074,10 @@ static int bnxt_queue_stop(struct net_device *dev, void *qmem, int idx)\n \n \tfor (i = 0; i < bp->nr_vnics; i++) {\n \t\tvnic = &bp->vnic_info[i];\n-\t\tvnic->mru = 0;\n-\t\tbnxt_hwrm_vnic_update(bp, vnic,\n-\t\t\t\t      VNIC_UPDATE_REQ_ENABLES_MRU_VALID);\n+\n+\t\tbnxt_set_vnic_mru_p5(bp, vnic, 0, idx);\n \t}\n+\tbnxt_set_rss_ctx_vnic_mru(bp, 0, idx);\n \t/* Make sure NAPI sees that the VNIC is disabled */\n \tsynchronize_net();\n \trxr = &bp->rx_ring[idx];\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\nindex 84c4812414fd..2450a369b792 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c\n@@ -231,10 +231,9 @@ void bnxt_ulp_stop(struct bnxt *bp)\n \t\treturn;\n \n \tmutex_lock(&edev->en_dev_lock);\n-\tif (!bnxt_ulp_registered(edev)) {\n-\t\tmutex_unlock(&edev->en_dev_lock);\n-\t\treturn;\n-\t}\n+\tif (!bnxt_ulp_registered(edev) ||\n+\t    (edev->flags & BNXT_EN_FLAG_ULP_STOPPED))\n+\t\tgoto ulp_stop_exit;\n \n \tedev->flags |= BNXT_EN_FLAG_ULP_STOPPED;\n \tif (aux_priv) {\n@@ -250,6 +249,7 @@ void bnxt_ulp_stop(struct bnxt *bp)\n \t\t\tadrv->suspend(adev, pm);\n \t\t}\n \t}\n+ulp_stop_exit:\n \tmutex_unlock(&edev->en_dev_lock);\n }\n \n@@ -258,19 +258,13 @@ void bnxt_ulp_start(struct bnxt *bp, int err)\n \tstruct bnxt_aux_priv *aux_priv = bp->aux_priv;\n \tstruct bnxt_en_dev *edev = bp->edev;\n \n-\tif (!edev)\n-\t\treturn;\n-\n-\tedev->flags &= ~BNXT_EN_FLAG_ULP_STOPPED;\n-\n-\tif (err)\n+\tif (!edev || err)\n \t\treturn;\n \n \tmutex_lock(&edev->en_dev_lock);\n-\tif (!bnxt_ulp_registered(edev)) {\n-\t\tmutex_unlock(&edev->en_dev_lock);\n-\t\treturn;\n-\t}\n+\tif (!bnxt_ulp_registered(edev) ||\n+\t    !(edev->flags & BNXT_EN_FLAG_ULP_STOPPED))\n+\t\tgoto ulp_start_exit;\n \n \tif (edev->ulp_tbl->msix_requested)\n \t\tbnxt_fill_msix_vecs(bp, edev->msix_entries);\n@@ -287,6 +281,8 @@ void bnxt_ulp_start(struct bnxt *bp, int err)\n \t\t\tadrv->resume(adev);\n \t\t}\n \t}\n+ulp_start_exit:\n+\tedev->flags &= ~BNXT_EN_FLAG_ULP_STOPPED;\n \tmutex_unlock(&edev->en_dev_lock);\n }\n \ndiff --git a/drivers/net/ethernet/faraday/Kconfig b/drivers/net/ethernet/faraday/Kconfig\nindex c699bd6bcbb9..474073c7f94d 100644\n--- a/drivers/net/ethernet/faraday/Kconfig\n+++ b/drivers/net/ethernet/faraday/Kconfig\n@@ -31,6 +31,7 @@ config FTGMAC100\n \tdepends on ARM || COMPILE_TEST\n \tdepends on !64BIT || BROKEN\n \tselect PHYLIB\n+\tselect FIXED_PHY\n \tselect MDIO_ASPEED if MACH_ASPEED_G6\n \tselect CRC32\n \thelp\ndiff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c\nindex a96f4cfa6e17..7719e15813ee 100644\n--- a/drivers/net/ethernet/intel/e1000e/netdev.c\n+++ b/drivers/net/ethernet/intel/e1000e/netdev.c\n@@ -3534,9 +3534,6 @@ s32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n \tcase e1000_pch_cnp:\n \tcase e1000_pch_tgp:\n \tcase e1000_pch_adp:\n-\tcase e1000_pch_mtp:\n-\tcase e1000_pch_lnp:\n-\tcase e1000_pch_ptp:\n \tcase e1000_pch_nvp:\n \t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n \t\t\t/* Stable 24MHz frequency */\n@@ -3552,6 +3549,17 @@ s32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n \t\t\tadapter->cc.shift = shift;\n \t\t}\n \t\tbreak;\n+\tcase e1000_pch_mtp:\n+\tcase e1000_pch_lnp:\n+\tcase e1000_pch_ptp:\n+\t\t/* System firmware can misreport this value, so set it to a\n+\t\t * stable 38400KHz frequency.\n+\t\t */\n+\t\tincperiod = INCPERIOD_38400KHZ;\n+\t\tincvalue = INCVALUE_38400KHZ;\n+\t\tshift = INCVALUE_SHIFT_38400KHZ;\n+\t\tadapter->cc.shift = shift;\n+\t\tbreak;\n \tcase e1000_82574:\n \tcase e1000_82583:\n \t\t/* Stable 25MHz frequency */\ndiff --git a/drivers/net/ethernet/intel/e1000e/ptp.c b/drivers/net/ethernet/intel/e1000e/ptp.c\nindex 89d57dd911dc..ea3c3eb2ef20 100644\n--- a/drivers/net/ethernet/intel/e1000e/ptp.c\n+++ b/drivers/net/ethernet/intel/e1000e/ptp.c\n@@ -295,15 +295,17 @@ void e1000e_ptp_init(struct e1000_adapter *adapter)\n \tcase e1000_pch_cnp:\n \tcase e1000_pch_tgp:\n \tcase e1000_pch_adp:\n-\tcase e1000_pch_mtp:\n-\tcase e1000_pch_lnp:\n-\tcase e1000_pch_ptp:\n \tcase e1000_pch_nvp:\n \t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI)\n \t\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_24MHZ;\n \t\telse\n \t\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_38400KHZ;\n \t\tbreak;\n+\tcase e1000_pch_mtp:\n+\tcase e1000_pch_lnp:\n+\tcase e1000_pch_ptp:\n+\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_38400KHZ;\n+\t\tbreak;\n \tcase e1000_82574:\n \tcase e1000_82583:\n \t\tadapter->ptp_clock_info.max_adj = MAX_PPB_25MHZ;\ndiff --git a/drivers/net/ethernet/intel/ice/ice_arfs.c b/drivers/net/ethernet/intel/ice/ice_arfs.c\nindex 2bc5c7f59844..1f7834c03550 100644\n--- a/drivers/net/ethernet/intel/ice/ice_arfs.c\n+++ b/drivers/net/ethernet/intel/ice/ice_arfs.c\n@@ -377,6 +377,50 @@ ice_arfs_is_perfect_flow_set(struct ice_hw *hw, __be16 l3_proto, u8 l4_proto)\n \treturn false;\n }\n \n+/**\n+ * ice_arfs_cmp - Check if aRFS filter matches this flow.\n+ * @fltr_info: filter info of the saved ARFS entry.\n+ * @fk: flow dissector keys.\n+ * @n_proto:  One of htons(ETH_P_IP) or htons(ETH_P_IPV6).\n+ * @ip_proto: One of IPPROTO_TCP or IPPROTO_UDP.\n+ *\n+ * Since this function assumes limited values for n_proto and ip_proto, it\n+ * is meant to be called only from ice_rx_flow_steer().\n+ *\n+ * Return:\n+ * * true\t- fltr_info refers to the same flow as fk.\n+ * * false\t- fltr_info and fk refer to different flows.\n+ */\n+static bool\n+ice_arfs_cmp(const struct ice_fdir_fltr *fltr_info, const struct flow_keys *fk,\n+\t     __be16 n_proto, u8 ip_proto)\n+{\n+\t/* Determine if the filter is for IPv4 or IPv6 based on flow_type,\n+\t * which is one of ICE_FLTR_PTYPE_NONF_IPV{4,6}_{TCP,UDP}.\n+\t */\n+\tbool is_v4 = fltr_info->flow_type == ICE_FLTR_PTYPE_NONF_IPV4_TCP ||\n+\t\t     fltr_info->flow_type == ICE_FLTR_PTYPE_NONF_IPV4_UDP;\n+\n+\t/* Following checks are arranged in the quickest and most discriminative\n+\t * fields first for early failure.\n+\t */\n+\tif (is_v4)\n+\t\treturn n_proto == htons(ETH_P_IP) &&\n+\t\t\tfltr_info->ip.v4.src_port == fk->ports.src &&\n+\t\t\tfltr_info->ip.v4.dst_port == fk->ports.dst &&\n+\t\t\tfltr_info->ip.v4.src_ip == fk->addrs.v4addrs.src &&\n+\t\t\tfltr_info->ip.v4.dst_ip == fk->addrs.v4addrs.dst &&\n+\t\t\tfltr_info->ip.v4.proto == ip_proto;\n+\n+\treturn fltr_info->ip.v6.src_port == fk->ports.src &&\n+\t\tfltr_info->ip.v6.dst_port == fk->ports.dst &&\n+\t\tfltr_info->ip.v6.proto == ip_proto &&\n+\t\t!memcmp(&fltr_info->ip.v6.src_ip, &fk->addrs.v6addrs.src,\n+\t\t\tsizeof(struct in6_addr)) &&\n+\t\t!memcmp(&fltr_info->ip.v6.dst_ip, &fk->addrs.v6addrs.dst,\n+\t\t\tsizeof(struct in6_addr));\n+}\n+\n /**\n  * ice_rx_flow_steer - steer the Rx flow to where application is being run\n  * @netdev: ptr to the netdev being adjusted\n@@ -448,6 +492,10 @@ ice_rx_flow_steer(struct net_device *netdev, const struct sk_buff *skb,\n \t\t\tcontinue;\n \n \t\tfltr_info = &arfs_entry->fltr_info;\n+\n+\t\tif (!ice_arfs_cmp(fltr_info, &fk, n_proto, ip_proto))\n+\t\t\tcontinue;\n+\n \t\tret = fltr_info->fltr_id;\n \n \t\tif (fltr_info->q_index == rxq_idx ||\ndiff --git a/drivers/net/ethernet/intel/ice/ice_eswitch.c b/drivers/net/ethernet/intel/ice/ice_eswitch.c\nindex 6aae03771746..2e4f0969035f 100644\n--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c\n+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c\n@@ -508,10 +508,14 @@ ice_eswitch_attach(struct ice_pf *pf, struct ice_repr *repr, unsigned long *id)\n  */\n int ice_eswitch_attach_vf(struct ice_pf *pf, struct ice_vf *vf)\n {\n-\tstruct ice_repr *repr = ice_repr_create_vf(vf);\n \tstruct devlink *devlink = priv_to_devlink(pf);\n+\tstruct ice_repr *repr;\n \tint err;\n \n+\tif (!ice_is_eswitch_mode_switchdev(pf))\n+\t\treturn 0;\n+\n+\trepr = ice_repr_create_vf(vf);\n \tif (IS_ERR(repr))\n \t\treturn PTR_ERR(repr);\n \ndiff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c\nindex 6f572589f1e5..6b5c9536d26d 100644\n--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c\n+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c\n@@ -1822,7 +1822,7 @@ int otx2_nix_config_bp(struct otx2_nic *pfvf, bool enable)\n \t\treq->chan_cnt = IEEE_8021QAZ_MAX_TCS;\n \t\treq->bpid_per_chan = 1;\n \t} else {\n-\t\treq->chan_cnt = 1;\n+\t\treq->chan_cnt = pfvf->hw.rx_chan_cnt;\n \t\treq->bpid_per_chan = 0;\n \t}\n \n@@ -1847,7 +1847,7 @@ int otx2_nix_cpt_config_bp(struct otx2_nic *pfvf, bool enable)\n \t\treq->chan_cnt = IEEE_8021QAZ_MAX_TCS;\n \t\treq->bpid_per_chan = 1;\n \t} else {\n-\t\treq->chan_cnt = 1;\n+\t\treq->chan_cnt = pfvf->hw.rx_chan_cnt;\n \t\treq->bpid_per_chan = 0;\n \t}\n \ndiff --git a/drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c b/drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c\nindex fb2e5b844c15..d76d7a945899 100644\n--- a/drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c\n+++ b/drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c\n@@ -447,8 +447,10 @@ static int mlxbf_gige_probe(struct platform_device *pdev)\n \tpriv->llu_plu_irq = platform_get_irq(pdev, MLXBF_GIGE_LLU_PLU_INTR_IDX);\n \n \tphy_irq = acpi_dev_gpio_irq_get_by(ACPI_COMPANION(&pdev->dev), \"phy\", 0);\n-\tif (phy_irq < 0) {\n-\t\tdev_err(&pdev->dev, \"Error getting PHY irq. Use polling instead\");\n+\tif (phy_irq == -EPROBE_DEFER) {\n+\t\terr = -EPROBE_DEFER;\n+\t\tgoto out;\n+\t} else if (phy_irq < 0) {\n \t\tphy_irq = PHY_POLL;\n \t}\n \ndiff --git a/drivers/net/ethernet/meta/fbnic/fbnic_fw.c b/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\nindex e2368075ab8c..4521d0483d18 100644\n--- a/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\n+++ b/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\n@@ -127,11 +127,8 @@ static int fbnic_mbx_map_msg(struct fbnic_dev *fbd, int mbx_idx,\n \t\treturn -EBUSY;\n \n \taddr = dma_map_single(fbd->dev, msg, PAGE_SIZE, direction);\n-\tif (dma_mapping_error(fbd->dev, addr)) {\n-\t\tfree_page((unsigned long)msg);\n-\n+\tif (dma_mapping_error(fbd->dev, addr))\n \t\treturn -ENOSPC;\n-\t}\n \n \tmbx->buf_info[tail].msg = msg;\n \tmbx->buf_info[tail].addr = addr;\ndiff --git a/drivers/net/ethernet/microchip/lan743x_ptp.h b/drivers/net/ethernet/microchip/lan743x_ptp.h\nindex e8d073bfa2ca..f33dc83c5700 100644\n--- a/drivers/net/ethernet/microchip/lan743x_ptp.h\n+++ b/drivers/net/ethernet/microchip/lan743x_ptp.h\n@@ -18,9 +18,9 @@\n  */\n #define LAN743X_PTP_N_EVENT_CHAN\t2\n #define LAN743X_PTP_N_PEROUT\t\tLAN743X_PTP_N_EVENT_CHAN\n-#define LAN743X_PTP_N_EXTTS\t\t4\n-#define LAN743X_PTP_N_PPS\t\t0\n #define PCI11X1X_PTP_IO_MAX_CHANNELS\t8\n+#define LAN743X_PTP_N_EXTTS\t\tPCI11X1X_PTP_IO_MAX_CHANNELS\n+#define LAN743X_PTP_N_PPS\t\t0\n #define PTP_CMD_CTL_TIMEOUT_CNT\t\t50\n \n struct lan743x_adapter;\ndiff --git a/drivers/net/ethernet/pensando/ionic/ionic_main.c b/drivers/net/ethernet/pensando/ionic/ionic_main.c\nindex daf1e82cb76b..0e60a6bef99a 100644\n--- a/drivers/net/ethernet/pensando/ionic/ionic_main.c\n+++ b/drivers/net/ethernet/pensando/ionic/ionic_main.c\n@@ -516,9 +516,9 @@ static int __ionic_dev_cmd_wait(struct ionic *ionic, unsigned long max_seconds,\n \tunsigned long start_time;\n \tunsigned long max_wait;\n \tunsigned long duration;\n-\tint done = 0;\n \tbool fw_up;\n \tint opcode;\n+\tbool done;\n \tint err;\n \n \t/* Wait for dev cmd to complete, retrying if we get EAGAIN,\n@@ -526,6 +526,7 @@ static int __ionic_dev_cmd_wait(struct ionic *ionic, unsigned long max_seconds,\n \t */\n \tmax_wait = jiffies + (max_seconds * HZ);\n try_again:\n+\tdone = false;\n \topcode = idev->opcode;\n \tstart_time = jiffies;\n \tfor (fw_up = ionic_is_fw_running(idev);\ndiff --git a/drivers/net/ethernet/ti/icssg/icssg_common.c b/drivers/net/ethernet/ti/icssg/icssg_common.c\nindex 5b8fdb882172..12f25cec6255 100644\n--- a/drivers/net/ethernet/ti/icssg/icssg_common.c\n+++ b/drivers/net/ethernet/ti/icssg/icssg_common.c\n@@ -98,20 +98,11 @@ void prueth_xmit_free(struct prueth_tx_chn *tx_chn,\n {\n \tstruct cppi5_host_desc_t *first_desc, *next_desc;\n \tdma_addr_t buf_dma, next_desc_dma;\n-\tstruct prueth_swdata *swdata;\n-\tstruct page *page;\n \tu32 buf_dma_len;\n \n \tfirst_desc = desc;\n \tnext_desc = first_desc;\n \n-\tswdata = cppi5_hdesc_get_swdata(desc);\n-\tif (swdata->type == PRUETH_SWDATA_PAGE) {\n-\t\tpage = swdata->data.page;\n-\t\tpage_pool_recycle_direct(page->pp, swdata->data.page);\n-\t\tgoto free_desc;\n-\t}\n-\n \tcppi5_hdesc_get_obuf(first_desc, &buf_dma, &buf_dma_len);\n \tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &buf_dma);\n \n@@ -135,7 +126,6 @@ void prueth_xmit_free(struct prueth_tx_chn *tx_chn,\n \t\tk3_cppi_desc_pool_free(tx_chn->desc_pool, next_desc);\n \t}\n \n-free_desc:\n \tk3_cppi_desc_pool_free(tx_chn->desc_pool, first_desc);\n }\n EXPORT_SYMBOL_GPL(prueth_xmit_free);\n@@ -612,13 +602,8 @@ u32 emac_xmit_xdp_frame(struct prueth_emac *emac,\n \tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &buf_dma);\n \tcppi5_hdesc_attach_buf(first_desc, buf_dma, xdpf->len, buf_dma, xdpf->len);\n \tswdata = cppi5_hdesc_get_swdata(first_desc);\n-\tif (page) {\n-\t\tswdata->type = PRUETH_SWDATA_PAGE;\n-\t\tswdata->data.page = page;\n-\t} else {\n-\t\tswdata->type = PRUETH_SWDATA_XDPF;\n-\t\tswdata->data.xdpf = xdpf;\n-\t}\n+\tswdata->type = PRUETH_SWDATA_XDPF;\n+\tswdata->data.xdpf = xdpf;\n \n \t/* Report BQL before sending the packet */\n \tnetif_txq = netdev_get_tx_queue(ndev, tx_chn->id);\ndiff --git a/drivers/net/wireless/ath/ath12k/core.c b/drivers/net/wireless/ath/ath12k/core.c\nindex ebc0560d40e3..89ae80934b30 100644\n--- a/drivers/net/wireless/ath/ath12k/core.c\n+++ b/drivers/net/wireless/ath/ath12k/core.c\n@@ -1216,6 +1216,7 @@ void ath12k_fw_stats_init(struct ath12k *ar)\n \tINIT_LIST_HEAD(&ar->fw_stats.pdevs);\n \tINIT_LIST_HEAD(&ar->fw_stats.bcn);\n \tinit_completion(&ar->fw_stats_complete);\n+\tinit_completion(&ar->fw_stats_done);\n }\n \n void ath12k_fw_stats_free(struct ath12k_fw_stats *stats)\n@@ -1228,8 +1229,9 @@ void ath12k_fw_stats_free(struct ath12k_fw_stats *stats)\n void ath12k_fw_stats_reset(struct ath12k *ar)\n {\n \tspin_lock_bh(&ar->data_lock);\n-\tar->fw_stats.fw_stats_done = false;\n \tath12k_fw_stats_free(&ar->fw_stats);\n+\tar->fw_stats.num_vdev_recvd = 0;\n+\tar->fw_stats.num_bcn_recvd = 0;\n \tspin_unlock_bh(&ar->data_lock);\n }\n \ndiff --git a/drivers/net/wireless/ath/ath12k/core.h b/drivers/net/wireless/ath/ath12k/core.h\nindex 941db6e49d6e..7bcd9c70309f 100644\n--- a/drivers/net/wireless/ath/ath12k/core.h\n+++ b/drivers/net/wireless/ath/ath12k/core.h\n@@ -601,6 +601,12 @@ struct ath12k_sta {\n #define ATH12K_NUM_CHANS 101\n #define ATH12K_MAX_5GHZ_CHAN 173\n \n+static inline bool ath12k_is_2ghz_channel_freq(u32 freq)\n+{\n+\treturn freq >= ATH12K_MIN_2GHZ_FREQ &&\n+\t       freq <= ATH12K_MAX_2GHZ_FREQ;\n+}\n+\n enum ath12k_hw_state {\n \tATH12K_HW_STATE_OFF,\n \tATH12K_HW_STATE_ON,\n@@ -626,7 +632,8 @@ struct ath12k_fw_stats {\n \tstruct list_head pdevs;\n \tstruct list_head vdevs;\n \tstruct list_head bcn;\n-\tbool fw_stats_done;\n+\tu32 num_vdev_recvd;\n+\tu32 num_bcn_recvd;\n };\n \n struct ath12k_dbg_htt_stats {\n@@ -806,6 +813,7 @@ struct ath12k {\n \tbool regdom_set_by_user;\n \n \tstruct completion fw_stats_complete;\n+\tstruct completion fw_stats_done;\n \n \tstruct completion mlo_setup_done;\n \tu32 mlo_setup_status;\ndiff --git a/drivers/net/wireless/ath/ath12k/debugfs.c b/drivers/net/wireless/ath/ath12k/debugfs.c\nindex dd624d73b8b2..23da93afaa5c 100644\n--- a/drivers/net/wireless/ath/ath12k/debugfs.c\n+++ b/drivers/net/wireless/ath/ath12k/debugfs.c\n@@ -1251,64 +1251,6 @@ void ath12k_debugfs_soc_destroy(struct ath12k_base *ab)\n \t */\n }\n \n-void\n-ath12k_debugfs_fw_stats_process(struct ath12k *ar,\n-\t\t\t\tstruct ath12k_fw_stats *stats)\n-{\n-\tstruct ath12k_base *ab = ar->ab;\n-\tstruct ath12k_pdev *pdev;\n-\tbool is_end;\n-\tstatic unsigned int num_vdev, num_bcn;\n-\tsize_t total_vdevs_started = 0;\n-\tint i;\n-\n-\tif (stats->stats_id == WMI_REQUEST_VDEV_STAT) {\n-\t\tif (list_empty(&stats->vdevs)) {\n-\t\t\tath12k_warn(ab, \"empty vdev stats\");\n-\t\t\treturn;\n-\t\t}\n-\t\t/* FW sends all the active VDEV stats irrespective of PDEV,\n-\t\t * hence limit until the count of all VDEVs started\n-\t\t */\n-\t\trcu_read_lock();\n-\t\tfor (i = 0; i < ab->num_radios; i++) {\n-\t\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n-\t\t\tif (pdev && pdev->ar)\n-\t\t\t\ttotal_vdevs_started += pdev->ar->num_started_vdevs;\n-\t\t}\n-\t\trcu_read_unlock();\n-\n-\t\tis_end = ((++num_vdev) == total_vdevs_started);\n-\n-\t\tlist_splice_tail_init(&stats->vdevs,\n-\t\t\t\t      &ar->fw_stats.vdevs);\n-\n-\t\tif (is_end) {\n-\t\t\tar->fw_stats.fw_stats_done = true;\n-\t\t\tnum_vdev = 0;\n-\t\t}\n-\t\treturn;\n-\t}\n-\tif (stats->stats_id == WMI_REQUEST_BCN_STAT) {\n-\t\tif (list_empty(&stats->bcn)) {\n-\t\t\tath12k_warn(ab, \"empty beacon stats\");\n-\t\t\treturn;\n-\t\t}\n-\t\t/* Mark end until we reached the count of all started VDEVs\n-\t\t * within the PDEV\n-\t\t */\n-\t\tis_end = ((++num_bcn) == ar->num_started_vdevs);\n-\n-\t\tlist_splice_tail_init(&stats->bcn,\n-\t\t\t\t      &ar->fw_stats.bcn);\n-\n-\t\tif (is_end) {\n-\t\t\tar->fw_stats.fw_stats_done = true;\n-\t\t\tnum_bcn = 0;\n-\t\t}\n-\t}\n-}\n-\n static int ath12k_open_vdev_stats(struct inode *inode, struct file *file)\n {\n \tstruct ath12k *ar = inode->i_private;\ndiff --git a/drivers/net/wireless/ath/ath12k/debugfs.h b/drivers/net/wireless/ath/ath12k/debugfs.h\nindex ebef7dace344..21641a8a0346 100644\n--- a/drivers/net/wireless/ath/ath12k/debugfs.h\n+++ b/drivers/net/wireless/ath/ath12k/debugfs.h\n@@ -12,8 +12,6 @@ void ath12k_debugfs_soc_create(struct ath12k_base *ab);\n void ath12k_debugfs_soc_destroy(struct ath12k_base *ab);\n void ath12k_debugfs_register(struct ath12k *ar);\n void ath12k_debugfs_unregister(struct ath12k *ar);\n-void ath12k_debugfs_fw_stats_process(struct ath12k *ar,\n-\t\t\t\t     struct ath12k_fw_stats *stats);\n void ath12k_debugfs_op_vif_add(struct ieee80211_hw *hw,\n \t\t\t       struct ieee80211_vif *vif);\n void ath12k_debugfs_pdev_create(struct ath12k_base *ab);\n@@ -126,11 +124,6 @@ static inline void ath12k_debugfs_unregister(struct ath12k *ar)\n {\n }\n \n-static inline void ath12k_debugfs_fw_stats_process(struct ath12k *ar,\n-\t\t\t\t\t\t   struct ath12k_fw_stats *stats)\n-{\n-}\n-\n static inline bool ath12k_debugfs_is_extd_rx_stats_enabled(struct ath12k *ar)\n {\n \treturn false;\ndiff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c\nindex 88b59f3ff87a..59ec422992d3 100644\n--- a/drivers/net/wireless/ath/ath12k/mac.c\n+++ b/drivers/net/wireless/ath/ath12k/mac.c\n@@ -4360,7 +4360,7 @@ int ath12k_mac_get_fw_stats(struct ath12k *ar,\n {\n \tstruct ath12k_base *ab = ar->ab;\n \tstruct ath12k_hw *ah = ath12k_ar_to_ah(ar);\n-\tunsigned long timeout, time_left;\n+\tunsigned long time_left;\n \tint ret;\n \n \tguard(mutex)(&ah->hw_mutex);\n@@ -4368,19 +4368,13 @@ int ath12k_mac_get_fw_stats(struct ath12k *ar,\n \tif (ah->state != ATH12K_HW_STATE_ON)\n \t\treturn -ENETDOWN;\n \n-\t/* FW stats can get split when exceeding the stats data buffer limit.\n-\t * In that case, since there is no end marking for the back-to-back\n-\t * received 'update stats' event, we keep a 3 seconds timeout in case,\n-\t * fw_stats_done is not marked yet\n-\t */\n-\ttimeout = jiffies + msecs_to_jiffies(3 * 1000);\n \tath12k_fw_stats_reset(ar);\n \n \treinit_completion(&ar->fw_stats_complete);\n+\treinit_completion(&ar->fw_stats_done);\n \n \tret = ath12k_wmi_send_stats_request_cmd(ar, param->stats_id,\n \t\t\t\t\t\tparam->vdev_id, param->pdev_id);\n-\n \tif (ret) {\n \t\tath12k_warn(ab, \"failed to request fw stats: %d\\n\", ret);\n \t\treturn ret;\n@@ -4391,7 +4385,6 @@ int ath12k_mac_get_fw_stats(struct ath12k *ar,\n \t\t   param->pdev_id, param->vdev_id, param->stats_id);\n \n \ttime_left = wait_for_completion_timeout(&ar->fw_stats_complete, 1 * HZ);\n-\n \tif (!time_left) {\n \t\tath12k_warn(ab, \"time out while waiting for get fw stats\\n\");\n \t\treturn -ETIMEDOUT;\n@@ -4400,20 +4393,15 @@ int ath12k_mac_get_fw_stats(struct ath12k *ar,\n \t/* Firmware sends WMI_UPDATE_STATS_EVENTID back-to-back\n \t * when stats data buffer limit is reached. fw_stats_complete\n \t * is completed once host receives first event from firmware, but\n-\t * still end might not be marked in the TLV.\n-\t * Below loop is to confirm that firmware completed sending all the event\n-\t * and fw_stats_done is marked true when end is marked in the TLV.\n+\t * still there could be more events following. Below is to wait\n+\t * until firmware completes sending all the events.\n \t */\n-\tfor (;;) {\n-\t\tif (time_after(jiffies, timeout))\n-\t\t\tbreak;\n-\t\tspin_lock_bh(&ar->data_lock);\n-\t\tif (ar->fw_stats.fw_stats_done) {\n-\t\t\tspin_unlock_bh(&ar->data_lock);\n-\t\t\tbreak;\n-\t\t}\n-\t\tspin_unlock_bh(&ar->data_lock);\n+\ttime_left = wait_for_completion_timeout(&ar->fw_stats_done, 3 * HZ);\n+\tif (!time_left) {\n+\t\tath12k_warn(ab, \"time out while waiting for fw stats done\\n\");\n+\t\treturn -ETIMEDOUT;\n \t}\n+\n \treturn 0;\n }\n \n@@ -5890,6 +5878,327 @@ static int ath12k_mac_handle_link_sta_state(struct ieee80211_hw *hw,\n \treturn ret;\n }\n \n+static bool ath12k_mac_is_freq_on_mac(struct ath12k_hw_mode_freq_range_arg *freq_range,\n+\t\t\t\t      u32 freq, u8 mac_id)\n+{\n+\treturn (freq >= freq_range[mac_id].low_2ghz_freq &&\n+\t\tfreq <= freq_range[mac_id].high_2ghz_freq) ||\n+\t       (freq >= freq_range[mac_id].low_5ghz_freq &&\n+\t\tfreq <= freq_range[mac_id].high_5ghz_freq);\n+}\n+\n+static bool\n+ath12k_mac_2_freq_same_mac_in_freq_range(struct ath12k_base *ab,\n+\t\t\t\t\t struct ath12k_hw_mode_freq_range_arg *freq_range,\n+\t\t\t\t\t u32 freq_link1, u32 freq_link2)\n+{\n+\tu8 i;\n+\n+\tfor (i = 0; i < MAX_RADIOS; i++) {\n+\t\tif (ath12k_mac_is_freq_on_mac(freq_range, freq_link1, i) &&\n+\t\t    ath12k_mac_is_freq_on_mac(freq_range, freq_link2, i))\n+\t\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+static bool ath12k_mac_is_hw_dbs_capable(struct ath12k_base *ab)\n+{\n+\treturn test_bit(WMI_TLV_SERVICE_DUAL_BAND_SIMULTANEOUS_SUPPORT,\n+\t\t\tab->wmi_ab.svc_map) &&\n+\t       ab->wmi_ab.hw_mode_info.support_dbs;\n+}\n+\n+static bool ath12k_mac_2_freq_same_mac_in_dbs(struct ath12k_base *ab,\n+\t\t\t\t\t      u32 freq_link1, u32 freq_link2)\n+{\n+\tstruct ath12k_hw_mode_freq_range_arg *freq_range;\n+\n+\tif (!ath12k_mac_is_hw_dbs_capable(ab))\n+\t\treturn true;\n+\n+\tfreq_range = ab->wmi_ab.hw_mode_info.freq_range_caps[ATH12K_HW_MODE_DBS];\n+\treturn ath12k_mac_2_freq_same_mac_in_freq_range(ab, freq_range,\n+\t\t\t\t\t\t\tfreq_link1, freq_link2);\n+}\n+\n+static bool ath12k_mac_is_hw_sbs_capable(struct ath12k_base *ab)\n+{\n+\treturn test_bit(WMI_TLV_SERVICE_DUAL_BAND_SIMULTANEOUS_SUPPORT,\n+\t\t\tab->wmi_ab.svc_map) &&\n+\t       ab->wmi_ab.hw_mode_info.support_sbs;\n+}\n+\n+static bool ath12k_mac_2_freq_same_mac_in_sbs(struct ath12k_base *ab,\n+\t\t\t\t\t      u32 freq_link1, u32 freq_link2)\n+{\n+\tstruct ath12k_hw_mode_info *info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *sbs_uppr_share;\n+\tstruct ath12k_hw_mode_freq_range_arg *sbs_low_share;\n+\tstruct ath12k_hw_mode_freq_range_arg *sbs_range;\n+\n+\tif (!ath12k_mac_is_hw_sbs_capable(ab))\n+\t\treturn true;\n+\n+\tif (ab->wmi_ab.sbs_lower_band_end_freq) {\n+\t\tsbs_uppr_share = info->freq_range_caps[ATH12K_HW_MODE_SBS_UPPER_SHARE];\n+\t\tsbs_low_share = info->freq_range_caps[ATH12K_HW_MODE_SBS_LOWER_SHARE];\n+\n+\t\treturn ath12k_mac_2_freq_same_mac_in_freq_range(ab, sbs_low_share,\n+\t\t\t\t\t\t\t\tfreq_link1, freq_link2) ||\n+\t\t       ath12k_mac_2_freq_same_mac_in_freq_range(ab, sbs_uppr_share,\n+\t\t\t\t\t\t\t\tfreq_link1, freq_link2);\n+\t}\n+\n+\tsbs_range = info->freq_range_caps[ATH12K_HW_MODE_SBS];\n+\treturn ath12k_mac_2_freq_same_mac_in_freq_range(ab, sbs_range,\n+\t\t\t\t\t\t\tfreq_link1, freq_link2);\n+}\n+\n+static bool ath12k_mac_freqs_on_same_mac(struct ath12k_base *ab,\n+\t\t\t\t\t u32 freq_link1, u32 freq_link2)\n+{\n+\treturn ath12k_mac_2_freq_same_mac_in_dbs(ab, freq_link1, freq_link2) &&\n+\t       ath12k_mac_2_freq_same_mac_in_sbs(ab, freq_link1, freq_link2);\n+}\n+\n+static int ath12k_mac_mlo_sta_set_link_active(struct ath12k_base *ab,\n+\t\t\t\t\t      enum wmi_mlo_link_force_reason reason,\n+\t\t\t\t\t      enum wmi_mlo_link_force_mode mode,\n+\t\t\t\t\t      u8 *mlo_vdev_id_lst,\n+\t\t\t\t\t      u8 num_mlo_vdev,\n+\t\t\t\t\t      u8 *mlo_inactive_vdev_lst,\n+\t\t\t\t\t      u8 num_mlo_inactive_vdev)\n+{\n+\tstruct wmi_mlo_link_set_active_arg param = {0};\n+\tu32 entry_idx, entry_offset, vdev_idx;\n+\tu8 vdev_id;\n+\n+\tparam.reason = reason;\n+\tparam.force_mode = mode;\n+\n+\tfor (vdev_idx = 0; vdev_idx < num_mlo_vdev; vdev_idx++) {\n+\t\tvdev_id = mlo_vdev_id_lst[vdev_idx];\n+\t\tentry_idx = vdev_id / 32;\n+\t\tentry_offset = vdev_id % 32;\n+\t\tif (entry_idx >= WMI_MLO_LINK_NUM_SZ) {\n+\t\t\tath12k_warn(ab, \"Invalid entry_idx %d num_mlo_vdev %d vdev %d\",\n+\t\t\t\t    entry_idx, num_mlo_vdev, vdev_id);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\tparam.vdev_bitmap[entry_idx] |= 1 << entry_offset;\n+\t\t/* update entry number if entry index changed */\n+\t\tif (param.num_vdev_bitmap < entry_idx + 1)\n+\t\t\tparam.num_vdev_bitmap = entry_idx + 1;\n+\t}\n+\n+\tath12k_dbg(ab, ATH12K_DBG_MAC,\n+\t\t   \"num_vdev_bitmap %d vdev_bitmap[0] = 0x%x, vdev_bitmap[1] = 0x%x\",\n+\t\t   param.num_vdev_bitmap, param.vdev_bitmap[0], param.vdev_bitmap[1]);\n+\n+\tif (mode == WMI_MLO_LINK_FORCE_MODE_ACTIVE_INACTIVE) {\n+\t\tfor (vdev_idx = 0; vdev_idx < num_mlo_inactive_vdev; vdev_idx++) {\n+\t\t\tvdev_id = mlo_inactive_vdev_lst[vdev_idx];\n+\t\t\tentry_idx = vdev_id / 32;\n+\t\t\tentry_offset = vdev_id % 32;\n+\t\t\tif (entry_idx >= WMI_MLO_LINK_NUM_SZ) {\n+\t\t\t\tath12k_warn(ab, \"Invalid entry_idx %d num_mlo_vdev %d vdev %d\",\n+\t\t\t\t\t    entry_idx, num_mlo_inactive_vdev, vdev_id);\n+\t\t\t\treturn -EINVAL;\n+\t\t\t}\n+\t\t\tparam.inactive_vdev_bitmap[entry_idx] |= 1 << entry_offset;\n+\t\t\t/* update entry number if entry index changed */\n+\t\t\tif (param.num_inactive_vdev_bitmap < entry_idx + 1)\n+\t\t\t\tparam.num_inactive_vdev_bitmap = entry_idx + 1;\n+\t\t}\n+\n+\t\tath12k_dbg(ab, ATH12K_DBG_MAC,\n+\t\t\t   \"num_vdev_bitmap %d inactive_vdev_bitmap[0] = 0x%x, inactive_vdev_bitmap[1] = 0x%x\",\n+\t\t\t   param.num_inactive_vdev_bitmap,\n+\t\t\t   param.inactive_vdev_bitmap[0],\n+\t\t\t   param.inactive_vdev_bitmap[1]);\n+\t}\n+\n+\tif (mode == WMI_MLO_LINK_FORCE_MODE_ACTIVE_LINK_NUM ||\n+\t    mode == WMI_MLO_LINK_FORCE_MODE_INACTIVE_LINK_NUM) {\n+\t\tparam.num_link_entry = 1;\n+\t\tparam.link_num[0].num_of_link = num_mlo_vdev - 1;\n+\t}\n+\n+\treturn ath12k_wmi_send_mlo_link_set_active_cmd(ab, &param);\n+}\n+\n+static int ath12k_mac_mlo_sta_update_link_active(struct ath12k_base *ab,\n+\t\t\t\t\t\t struct ieee80211_hw *hw,\n+\t\t\t\t\t\t struct ath12k_vif *ahvif)\n+{\n+\tu8 mlo_vdev_id_lst[IEEE80211_MLD_MAX_NUM_LINKS] = {0};\n+\tu32 mlo_freq_list[IEEE80211_MLD_MAX_NUM_LINKS] = {0};\n+\tunsigned long links = ahvif->links_map;\n+\tenum wmi_mlo_link_force_reason reason;\n+\tstruct ieee80211_chanctx_conf *conf;\n+\tenum wmi_mlo_link_force_mode mode;\n+\tstruct ieee80211_bss_conf *info;\n+\tstruct ath12k_link_vif *arvif;\n+\tu8 num_mlo_vdev = 0;\n+\tu8 link_id;\n+\n+\tfor_each_set_bit(link_id, &links, IEEE80211_MLD_MAX_NUM_LINKS) {\n+\t\tarvif = wiphy_dereference(hw->wiphy, ahvif->link[link_id]);\n+\t\t/* make sure vdev is created on this device */\n+\t\tif (!arvif || !arvif->is_created || arvif->ar->ab != ab)\n+\t\t\tcontinue;\n+\n+\t\tinfo = ath12k_mac_get_link_bss_conf(arvif);\n+\t\tconf = wiphy_dereference(hw->wiphy, info->chanctx_conf);\n+\t\tmlo_freq_list[num_mlo_vdev] = conf->def.chan->center_freq;\n+\n+\t\tmlo_vdev_id_lst[num_mlo_vdev] = arvif->vdev_id;\n+\t\tnum_mlo_vdev++;\n+\t}\n+\n+\t/* It is not allowed to activate more links than a single device\n+\t * supported. Something goes wrong if we reach here.\n+\t */\n+\tif (num_mlo_vdev > ATH12K_NUM_MAX_ACTIVE_LINKS_PER_DEVICE) {\n+\t\tWARN_ON_ONCE(1);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t/* if 2 links are established and both link channels fall on the\n+\t * same hardware MAC, send command to firmware to deactivate one\n+\t * of them.\n+\t */\n+\tif (num_mlo_vdev == 2 &&\n+\t    ath12k_mac_freqs_on_same_mac(ab, mlo_freq_list[0],\n+\t\t\t\t\t mlo_freq_list[1])) {\n+\t\tmode = WMI_MLO_LINK_FORCE_MODE_INACTIVE_LINK_NUM;\n+\t\treason = WMI_MLO_LINK_FORCE_REASON_NEW_CONNECT;\n+\t\treturn ath12k_mac_mlo_sta_set_link_active(ab, reason, mode,\n+\t\t\t\t\t\t\t  mlo_vdev_id_lst, num_mlo_vdev,\n+\t\t\t\t\t\t\t  NULL, 0);\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static bool ath12k_mac_are_sbs_chan(struct ath12k_base *ab, u32 freq_1, u32 freq_2)\n+{\n+\tif (!ath12k_mac_is_hw_sbs_capable(ab))\n+\t\treturn false;\n+\n+\tif (ath12k_is_2ghz_channel_freq(freq_1) ||\n+\t    ath12k_is_2ghz_channel_freq(freq_2))\n+\t\treturn false;\n+\n+\treturn !ath12k_mac_2_freq_same_mac_in_sbs(ab, freq_1, freq_2);\n+}\n+\n+static bool ath12k_mac_are_dbs_chan(struct ath12k_base *ab, u32 freq_1, u32 freq_2)\n+{\n+\tif (!ath12k_mac_is_hw_dbs_capable(ab))\n+\t\treturn false;\n+\n+\treturn !ath12k_mac_2_freq_same_mac_in_dbs(ab, freq_1, freq_2);\n+}\n+\n+static int ath12k_mac_select_links(struct ath12k_base *ab,\n+\t\t\t\t   struct ieee80211_vif *vif,\n+\t\t\t\t   struct ieee80211_hw *hw,\n+\t\t\t\t   u16 *selected_links)\n+{\n+\tunsigned long useful_links = ieee80211_vif_usable_links(vif);\n+\tstruct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);\n+\tu8 num_useful_links = hweight_long(useful_links);\n+\tstruct ieee80211_chanctx_conf *chanctx;\n+\tstruct ath12k_link_vif *assoc_arvif;\n+\tu32 assoc_link_freq, partner_freq;\n+\tu16 sbs_links = 0, dbs_links = 0;\n+\tstruct ieee80211_bss_conf *info;\n+\tstruct ieee80211_channel *chan;\n+\tstruct ieee80211_sta *sta;\n+\tstruct ath12k_sta *ahsta;\n+\tu8 link_id;\n+\n+\t/* activate all useful links if less than max supported */\n+\tif (num_useful_links <= ATH12K_NUM_MAX_ACTIVE_LINKS_PER_DEVICE) {\n+\t\t*selected_links = useful_links;\n+\t\treturn 0;\n+\t}\n+\n+\t/* only in station mode we can get here, so it's safe\n+\t * to use ap_addr\n+\t */\n+\trcu_read_lock();\n+\tsta = ieee80211_find_sta(vif, vif->cfg.ap_addr);\n+\tif (!sta) {\n+\t\trcu_read_unlock();\n+\t\tath12k_warn(ab, \"failed to find sta with addr %pM\\n\", vif->cfg.ap_addr);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tahsta = ath12k_sta_to_ahsta(sta);\n+\tassoc_arvif = wiphy_dereference(hw->wiphy, ahvif->link[ahsta->assoc_link_id]);\n+\tinfo = ath12k_mac_get_link_bss_conf(assoc_arvif);\n+\tchanctx = rcu_dereference(info->chanctx_conf);\n+\tassoc_link_freq = chanctx->def.chan->center_freq;\n+\trcu_read_unlock();\n+\tath12k_dbg(ab, ATH12K_DBG_MAC, \"assoc link %u freq %u\\n\",\n+\t\t   assoc_arvif->link_id, assoc_link_freq);\n+\n+\t/* assoc link is already activated and has to be kept active,\n+\t * only need to select a partner link from others.\n+\t */\n+\tuseful_links &= ~BIT(assoc_arvif->link_id);\n+\tfor_each_set_bit(link_id, &useful_links, IEEE80211_MLD_MAX_NUM_LINKS) {\n+\t\tinfo = wiphy_dereference(hw->wiphy, vif->link_conf[link_id]);\n+\t\tif (!info) {\n+\t\t\tath12k_warn(ab, \"failed to get link info for link: %u\\n\",\n+\t\t\t\t    link_id);\n+\t\t\treturn -ENOLINK;\n+\t\t}\n+\n+\t\tchan = info->chanreq.oper.chan;\n+\t\tif (!chan) {\n+\t\t\tath12k_warn(ab, \"failed to get chan for link: %u\\n\", link_id);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\n+\t\tpartner_freq = chan->center_freq;\n+\t\tif (ath12k_mac_are_sbs_chan(ab, assoc_link_freq, partner_freq)) {\n+\t\t\tsbs_links |= BIT(link_id);\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_MAC, \"new SBS link %u freq %u\\n\",\n+\t\t\t\t   link_id, partner_freq);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (ath12k_mac_are_dbs_chan(ab, assoc_link_freq, partner_freq)) {\n+\t\t\tdbs_links |= BIT(link_id);\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_MAC, \"new DBS link %u freq %u\\n\",\n+\t\t\t\t   link_id, partner_freq);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tath12k_dbg(ab, ATH12K_DBG_MAC, \"non DBS/SBS link %u freq %u\\n\",\n+\t\t\t   link_id, partner_freq);\n+\t}\n+\n+\t/* choose the first candidate no matter how many is in the list */\n+\tif (sbs_links)\n+\t\tlink_id = __ffs(sbs_links);\n+\telse if (dbs_links)\n+\t\tlink_id = __ffs(dbs_links);\n+\telse\n+\t\tlink_id = ffs(useful_links) - 1;\n+\n+\tath12k_dbg(ab, ATH12K_DBG_MAC, \"select partner link %u\\n\", link_id);\n+\n+\t*selected_links = BIT(assoc_arvif->link_id) | BIT(link_id);\n+\n+\treturn 0;\n+}\n+\n static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,\n \t\t\t\t   struct ieee80211_vif *vif,\n \t\t\t\t   struct ieee80211_sta *sta,\n@@ -5899,10 +6208,13 @@ static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,\n \tstruct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);\n \tstruct ath12k_sta *ahsta = ath12k_sta_to_ahsta(sta);\n \tstruct ath12k_hw *ah = ath12k_hw_to_ah(hw);\n+\tstruct ath12k_base *prev_ab = NULL, *ab;\n \tstruct ath12k_link_vif *arvif;\n \tstruct ath12k_link_sta *arsta;\n \tunsigned long valid_links;\n-\tu8 link_id = 0;\n+\tu16 selected_links = 0;\n+\tu8 link_id = 0, i;\n+\tstruct ath12k *ar;\n \tint ret;\n \n \tlockdep_assert_wiphy(hw->wiphy);\n@@ -5972,8 +6284,24 @@ static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,\n \t * about to move to the associated state.\n \t */\n \tif (ieee80211_vif_is_mld(vif) && vif->type == NL80211_IFTYPE_STATION &&\n-\t    old_state == IEEE80211_STA_AUTH && new_state == IEEE80211_STA_ASSOC)\n-\t\tieee80211_set_active_links(vif, ieee80211_vif_usable_links(vif));\n+\t    old_state == IEEE80211_STA_AUTH && new_state == IEEE80211_STA_ASSOC) {\n+\t\t/* TODO: for now only do link selection for single device\n+\t\t * MLO case. Other cases would be handled in the future.\n+\t\t */\n+\t\tab = ah->radio[0].ab;\n+\t\tif (ab->ag->num_devices == 1) {\n+\t\t\tret = ath12k_mac_select_links(ab, vif, hw, &selected_links);\n+\t\t\tif (ret) {\n+\t\t\t\tath12k_warn(ab,\n+\t\t\t\t\t    \"failed to get selected links: %d\\n\", ret);\n+\t\t\t\tgoto exit;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tselected_links = ieee80211_vif_usable_links(vif);\n+\t\t}\n+\n+\t\tieee80211_set_active_links(vif, selected_links);\n+\t}\n \n \t/* Handle all the other state transitions in generic way */\n \tvalid_links = ahsta->links_map;\n@@ -5997,6 +6325,24 @@ static int ath12k_mac_op_sta_state(struct ieee80211_hw *hw,\n \t\t}\n \t}\n \n+\tif (ieee80211_vif_is_mld(vif) && vif->type == NL80211_IFTYPE_STATION &&\n+\t    old_state == IEEE80211_STA_ASSOC && new_state == IEEE80211_STA_AUTHORIZED) {\n+\t\tfor_each_ar(ah, ar, i) {\n+\t\t\tab = ar->ab;\n+\t\t\tif (prev_ab == ab)\n+\t\t\t\tcontinue;\n+\n+\t\t\tret = ath12k_mac_mlo_sta_update_link_active(ab, hw, ahvif);\n+\t\t\tif (ret) {\n+\t\t\t\tath12k_warn(ab,\n+\t\t\t\t\t    \"failed to update link active state on connect %d\\n\",\n+\t\t\t\t\t    ret);\n+\t\t\t\tgoto exit;\n+\t\t\t}\n+\n+\t\t\tprev_ab = ab;\n+\t\t}\n+\t}\n \t/* IEEE80211_STA_NONE -> IEEE80211_STA_NOTEXIST:\n \t * Remove the station from driver (handle ML sta here since that\n \t * needs special handling. Normal sta will be handled in generic\ndiff --git a/drivers/net/wireless/ath/ath12k/mac.h b/drivers/net/wireless/ath/ath12k/mac.h\nindex e6e74b45bfa4..cc81b1f5680f 100644\n--- a/drivers/net/wireless/ath/ath12k/mac.h\n+++ b/drivers/net/wireless/ath/ath12k/mac.h\n@@ -54,6 +54,8 @@ struct ath12k_generic_iter {\n #define ATH12K_DEFAULT_SCAN_LINK\tIEEE80211_MLD_MAX_NUM_LINKS\n #define ATH12K_NUM_MAX_LINKS\t\t(IEEE80211_MLD_MAX_NUM_LINKS + 1)\n \n+#define ATH12K_NUM_MAX_ACTIVE_LINKS_PER_DEVICE\t2\n+\n enum ath12k_supported_bw {\n \tATH12K_BW_20    = 0,\n \tATH12K_BW_40    = 1,\ndiff --git a/drivers/net/wireless/ath/ath12k/wmi.c b/drivers/net/wireless/ath/ath12k/wmi.c\nindex 60e2444fe08c..465f877fc0fb 100644\n--- a/drivers/net/wireless/ath/ath12k/wmi.c\n+++ b/drivers/net/wireless/ath/ath12k/wmi.c\n@@ -91,6 +91,11 @@ struct ath12k_wmi_svc_rdy_ext2_parse {\n \tbool dma_ring_cap_done;\n \tbool spectral_bin_scaling_done;\n \tbool mac_phy_caps_ext_done;\n+\tbool hal_reg_caps_ext2_done;\n+\tbool scan_radio_caps_ext2_done;\n+\tbool twt_caps_done;\n+\tbool htt_msdu_idx_to_qtype_map_done;\n+\tbool dbs_or_sbs_cap_ext_done;\n };\n \n struct ath12k_wmi_rdy_parse {\n@@ -4395,6 +4400,7 @@ static int ath12k_wmi_hw_mode_caps_parse(struct ath12k_base *soc,\n static int ath12k_wmi_hw_mode_caps(struct ath12k_base *soc,\n \t\t\t\t   u16 len, const void *ptr, void *data)\n {\n+\tstruct ath12k_svc_ext_info *svc_ext_info = &soc->wmi_ab.svc_ext_info;\n \tstruct ath12k_wmi_svc_rdy_ext_parse *svc_rdy_ext = data;\n \tconst struct ath12k_wmi_hw_mode_cap_params *hw_mode_caps;\n \tenum wmi_host_hw_mode_config_type mode, pref;\n@@ -4427,8 +4433,11 @@ static int ath12k_wmi_hw_mode_caps(struct ath12k_base *soc,\n \t\t}\n \t}\n \n-\tath12k_dbg(soc, ATH12K_DBG_WMI, \"preferred_hw_mode:%d\\n\",\n-\t\t   soc->wmi_ab.preferred_hw_mode);\n+\tsvc_ext_info->num_hw_modes = svc_rdy_ext->n_hw_mode_caps;\n+\n+\tath12k_dbg(soc, ATH12K_DBG_WMI, \"num hw modes %u preferred_hw_mode %d\\n\",\n+\t\t   svc_ext_info->num_hw_modes, soc->wmi_ab.preferred_hw_mode);\n+\n \tif (soc->wmi_ab.preferred_hw_mode == WMI_HOST_HW_MODE_MAX)\n \t\treturn -EINVAL;\n \n@@ -4658,6 +4667,65 @@ static int ath12k_wmi_dma_ring_caps(struct ath12k_base *ab,\n \treturn ret;\n }\n \n+static void\n+ath12k_wmi_save_mac_phy_info(struct ath12k_base *ab,\n+\t\t\t     const struct ath12k_wmi_mac_phy_caps_params *mac_phy_cap,\n+\t\t\t     struct ath12k_svc_ext_mac_phy_info *mac_phy_info)\n+{\n+\tmac_phy_info->phy_id = __le32_to_cpu(mac_phy_cap->phy_id);\n+\tmac_phy_info->supported_bands = __le32_to_cpu(mac_phy_cap->supported_bands);\n+\tmac_phy_info->hw_freq_range.low_2ghz_freq =\n+\t\t\t\t\t__le32_to_cpu(mac_phy_cap->low_2ghz_chan_freq);\n+\tmac_phy_info->hw_freq_range.high_2ghz_freq =\n+\t\t\t\t\t__le32_to_cpu(mac_phy_cap->high_2ghz_chan_freq);\n+\tmac_phy_info->hw_freq_range.low_5ghz_freq =\n+\t\t\t\t\t__le32_to_cpu(mac_phy_cap->low_5ghz_chan_freq);\n+\tmac_phy_info->hw_freq_range.high_5ghz_freq =\n+\t\t\t\t\t__le32_to_cpu(mac_phy_cap->high_5ghz_chan_freq);\n+}\n+\n+static void\n+ath12k_wmi_save_all_mac_phy_info(struct ath12k_base *ab,\n+\t\t\t\t struct ath12k_wmi_svc_rdy_ext_parse *svc_rdy_ext)\n+{\n+\tstruct ath12k_svc_ext_info *svc_ext_info = &ab->wmi_ab.svc_ext_info;\n+\tconst struct ath12k_wmi_mac_phy_caps_params *mac_phy_cap;\n+\tconst struct ath12k_wmi_hw_mode_cap_params *hw_mode_cap;\n+\tstruct ath12k_svc_ext_mac_phy_info *mac_phy_info;\n+\tu32 hw_mode_id, phy_bit_map;\n+\tu8 hw_idx;\n+\n+\tmac_phy_info = &svc_ext_info->mac_phy_info[0];\n+\tmac_phy_cap = svc_rdy_ext->mac_phy_caps;\n+\n+\tfor (hw_idx = 0; hw_idx < svc_ext_info->num_hw_modes; hw_idx++) {\n+\t\thw_mode_cap = &svc_rdy_ext->hw_mode_caps[hw_idx];\n+\t\thw_mode_id = __le32_to_cpu(hw_mode_cap->hw_mode_id);\n+\t\tphy_bit_map = __le32_to_cpu(hw_mode_cap->phy_id_map);\n+\n+\t\twhile (phy_bit_map) {\n+\t\t\tath12k_wmi_save_mac_phy_info(ab, mac_phy_cap, mac_phy_info);\n+\t\t\tmac_phy_info->hw_mode_config_type =\n+\t\t\t\t\tle32_get_bits(hw_mode_cap->hw_mode_config_type,\n+\t\t\t\t\t\t      WMI_HW_MODE_CAP_CFG_TYPE);\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t\t\t   \"hw_idx %u hw_mode_id %u hw_mode_config_type %u supported_bands %u phy_id %u 2 GHz [%u - %u] 5 GHz [%u - %u]\\n\",\n+\t\t\t\t   hw_idx, hw_mode_id,\n+\t\t\t\t   mac_phy_info->hw_mode_config_type,\n+\t\t\t\t   mac_phy_info->supported_bands, mac_phy_info->phy_id,\n+\t\t\t\t   mac_phy_info->hw_freq_range.low_2ghz_freq,\n+\t\t\t\t   mac_phy_info->hw_freq_range.high_2ghz_freq,\n+\t\t\t\t   mac_phy_info->hw_freq_range.low_5ghz_freq,\n+\t\t\t\t   mac_phy_info->hw_freq_range.high_5ghz_freq);\n+\n+\t\t\tmac_phy_cap++;\n+\t\t\tmac_phy_info++;\n+\n+\t\t\tphy_bit_map >>= 1;\n+\t\t}\n+\t}\n+}\n+\n static int ath12k_wmi_svc_rdy_ext_parse(struct ath12k_base *ab,\n \t\t\t\t\tu16 tag, u16 len,\n \t\t\t\t\tconst void *ptr, void *data)\n@@ -4706,6 +4774,8 @@ static int ath12k_wmi_svc_rdy_ext_parse(struct ath12k_base *ab,\n \t\t\t\treturn ret;\n \t\t\t}\n \n+\t\t\tath12k_wmi_save_all_mac_phy_info(ab, svc_rdy_ext);\n+\n \t\t\tsvc_rdy_ext->mac_phy_done = true;\n \t\t} else if (!svc_rdy_ext->ext_hal_reg_done) {\n \t\t\tret = ath12k_wmi_ext_hal_reg_caps(ab, len, ptr, svc_rdy_ext);\n@@ -4922,10 +4992,449 @@ static int ath12k_wmi_tlv_mac_phy_caps_ext(struct ath12k_base *ab, u16 tag,\n \treturn 0;\n }\n \n+static void\n+ath12k_wmi_update_freq_info(struct ath12k_base *ab,\n+\t\t\t    struct ath12k_svc_ext_mac_phy_info *mac_cap,\n+\t\t\t    enum ath12k_hw_mode mode,\n+\t\t\t    u32 phy_id)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *mac_range;\n+\n+\tmac_range = &hw_mode_info->freq_range_caps[mode][phy_id];\n+\n+\tif (mac_cap->supported_bands & WMI_HOST_WLAN_2GHZ_CAP) {\n+\t\tmac_range->low_2ghz_freq = max_t(u32,\n+\t\t\t\t\t\t mac_cap->hw_freq_range.low_2ghz_freq,\n+\t\t\t\t\t\t ATH12K_MIN_2GHZ_FREQ);\n+\t\tmac_range->high_2ghz_freq = mac_cap->hw_freq_range.high_2ghz_freq ?\n+\t\t\t\t\t    min_t(u32,\n+\t\t\t\t\t\t  mac_cap->hw_freq_range.high_2ghz_freq,\n+\t\t\t\t\t\t  ATH12K_MAX_2GHZ_FREQ) :\n+\t\t\t\t\t    ATH12K_MAX_2GHZ_FREQ;\n+\t}\n+\n+\tif (mac_cap->supported_bands & WMI_HOST_WLAN_5GHZ_CAP) {\n+\t\tmac_range->low_5ghz_freq = max_t(u32,\n+\t\t\t\t\t\t mac_cap->hw_freq_range.low_5ghz_freq,\n+\t\t\t\t\t\t ATH12K_MIN_5GHZ_FREQ);\n+\t\tmac_range->high_5ghz_freq = mac_cap->hw_freq_range.high_5ghz_freq ?\n+\t\t\t\t\t    min_t(u32,\n+\t\t\t\t\t\t  mac_cap->hw_freq_range.high_5ghz_freq,\n+\t\t\t\t\t\t  ATH12K_MAX_6GHZ_FREQ) :\n+\t\t\t\t\t    ATH12K_MAX_6GHZ_FREQ;\n+\t}\n+}\n+\n+static bool\n+ath12k_wmi_all_phy_range_updated(struct ath12k_base *ab,\n+\t\t\t\t enum ath12k_hw_mode hwmode)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *mac_range;\n+\tu8 phy_id;\n+\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tmac_range = &hw_mode_info->freq_range_caps[hwmode][phy_id];\n+\t\t/* modify SBS/DBS range only when both phy for DBS are filled */\n+\t\tif (!mac_range->low_2ghz_freq && !mac_range->low_5ghz_freq)\n+\t\t\treturn false;\n+\t}\n+\n+\treturn true;\n+}\n+\n+static void ath12k_wmi_update_dbs_freq_info(struct ath12k_base *ab)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *mac_range;\n+\tu8 phy_id;\n+\n+\tmac_range = hw_mode_info->freq_range_caps[ATH12K_HW_MODE_DBS];\n+\t/* Reset 5 GHz range for shared mac for DBS */\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tif (mac_range[phy_id].low_2ghz_freq &&\n+\t\t    mac_range[phy_id].low_5ghz_freq) {\n+\t\t\tmac_range[phy_id].low_5ghz_freq = 0;\n+\t\t\tmac_range[phy_id].high_5ghz_freq = 0;\n+\t\t}\n+\t}\n+}\n+\n+static u32\n+ath12k_wmi_get_highest_5ghz_freq_from_range(struct ath12k_hw_mode_freq_range_arg *range)\n+{\n+\tu32 highest_freq = 0;\n+\tu8 phy_id;\n+\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tif (range[phy_id].high_5ghz_freq > highest_freq)\n+\t\t\thighest_freq = range[phy_id].high_5ghz_freq;\n+\t}\n+\n+\treturn highest_freq ? highest_freq : ATH12K_MAX_6GHZ_FREQ;\n+}\n+\n+static u32\n+ath12k_wmi_get_lowest_5ghz_freq_from_range(struct ath12k_hw_mode_freq_range_arg *range)\n+{\n+\tu32 lowest_freq = 0;\n+\tu8 phy_id;\n+\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tif ((!lowest_freq && range[phy_id].low_5ghz_freq) ||\n+\t\t    range[phy_id].low_5ghz_freq < lowest_freq)\n+\t\t\tlowest_freq = range[phy_id].low_5ghz_freq;\n+\t}\n+\n+\treturn lowest_freq ? lowest_freq : ATH12K_MIN_5GHZ_FREQ;\n+}\n+\n+static void\n+ath12k_wmi_fill_upper_share_sbs_freq(struct ath12k_base *ab,\n+\t\t\t\t     u16 sbs_range_sep,\n+\t\t\t\t     struct ath12k_hw_mode_freq_range_arg *ref_freq)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *upper_sbs_freq_range;\n+\tu8 phy_id;\n+\n+\tupper_sbs_freq_range =\n+\t\t\thw_mode_info->freq_range_caps[ATH12K_HW_MODE_SBS_UPPER_SHARE];\n+\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tupper_sbs_freq_range[phy_id].low_2ghz_freq =\n+\t\t\t\t\t\tref_freq[phy_id].low_2ghz_freq;\n+\t\tupper_sbs_freq_range[phy_id].high_2ghz_freq =\n+\t\t\t\t\t\tref_freq[phy_id].high_2ghz_freq;\n+\n+\t\t/* update for shared mac */\n+\t\tif (upper_sbs_freq_range[phy_id].low_2ghz_freq) {\n+\t\t\tupper_sbs_freq_range[phy_id].low_5ghz_freq = sbs_range_sep + 10;\n+\t\t\tupper_sbs_freq_range[phy_id].high_5ghz_freq =\n+\t\t\t\tath12k_wmi_get_highest_5ghz_freq_from_range(ref_freq);\n+\t\t} else {\n+\t\t\tupper_sbs_freq_range[phy_id].low_5ghz_freq =\n+\t\t\t\tath12k_wmi_get_lowest_5ghz_freq_from_range(ref_freq);\n+\t\t\tupper_sbs_freq_range[phy_id].high_5ghz_freq = sbs_range_sep;\n+\t\t}\n+\t}\n+}\n+\n+static void\n+ath12k_wmi_fill_lower_share_sbs_freq(struct ath12k_base *ab,\n+\t\t\t\t     u16 sbs_range_sep,\n+\t\t\t\t     struct ath12k_hw_mode_freq_range_arg *ref_freq)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *lower_sbs_freq_range;\n+\tu8 phy_id;\n+\n+\tlower_sbs_freq_range =\n+\t\t\thw_mode_info->freq_range_caps[ATH12K_HW_MODE_SBS_LOWER_SHARE];\n+\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tlower_sbs_freq_range[phy_id].low_2ghz_freq =\n+\t\t\t\t\t\tref_freq[phy_id].low_2ghz_freq;\n+\t\tlower_sbs_freq_range[phy_id].high_2ghz_freq =\n+\t\t\t\t\t\tref_freq[phy_id].high_2ghz_freq;\n+\n+\t\t/* update for shared mac */\n+\t\tif (lower_sbs_freq_range[phy_id].low_2ghz_freq) {\n+\t\t\tlower_sbs_freq_range[phy_id].low_5ghz_freq =\n+\t\t\t\tath12k_wmi_get_lowest_5ghz_freq_from_range(ref_freq);\n+\t\t\tlower_sbs_freq_range[phy_id].high_5ghz_freq = sbs_range_sep;\n+\t\t} else {\n+\t\t\tlower_sbs_freq_range[phy_id].low_5ghz_freq = sbs_range_sep + 10;\n+\t\t\tlower_sbs_freq_range[phy_id].high_5ghz_freq =\n+\t\t\t\tath12k_wmi_get_highest_5ghz_freq_from_range(ref_freq);\n+\t\t}\n+\t}\n+}\n+\n+static const char *ath12k_wmi_hw_mode_to_str(enum ath12k_hw_mode hw_mode)\n+{\n+\tstatic const char * const mode_str[] = {\n+\t\t[ATH12K_HW_MODE_SMM] = \"SMM\",\n+\t\t[ATH12K_HW_MODE_DBS] = \"DBS\",\n+\t\t[ATH12K_HW_MODE_SBS] = \"SBS\",\n+\t\t[ATH12K_HW_MODE_SBS_UPPER_SHARE] = \"SBS_UPPER_SHARE\",\n+\t\t[ATH12K_HW_MODE_SBS_LOWER_SHARE] = \"SBS_LOWER_SHARE\",\n+\t};\n+\n+\tif (hw_mode >= ARRAY_SIZE(mode_str))\n+\t\treturn \"Unknown\";\n+\n+\treturn mode_str[hw_mode];\n+}\n+\n+static void\n+ath12k_wmi_dump_freq_range_per_mac(struct ath12k_base *ab,\n+\t\t\t\t   struct ath12k_hw_mode_freq_range_arg *freq_range,\n+\t\t\t\t   enum ath12k_hw_mode hw_mode)\n+{\n+\tu8 i;\n+\n+\tfor (i = 0; i < MAX_RADIOS; i++)\n+\t\tif (freq_range[i].low_2ghz_freq || freq_range[i].low_5ghz_freq)\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t\t\t   \"frequency range: %s(%d) mac %d 2 GHz [%d - %d] 5 GHz [%d - %d]\",\n+\t\t\t\t   ath12k_wmi_hw_mode_to_str(hw_mode),\n+\t\t\t\t   hw_mode, i,\n+\t\t\t\t   freq_range[i].low_2ghz_freq,\n+\t\t\t\t   freq_range[i].high_2ghz_freq,\n+\t\t\t\t   freq_range[i].low_5ghz_freq,\n+\t\t\t\t   freq_range[i].high_5ghz_freq);\n+}\n+\n+static void ath12k_wmi_dump_freq_range(struct ath12k_base *ab)\n+{\n+\tstruct ath12k_hw_mode_freq_range_arg *freq_range;\n+\tu8 i;\n+\n+\tfor (i = ATH12K_HW_MODE_SMM; i < ATH12K_HW_MODE_MAX; i++) {\n+\t\tfreq_range = ab->wmi_ab.hw_mode_info.freq_range_caps[i];\n+\t\tath12k_wmi_dump_freq_range_per_mac(ab, freq_range, i);\n+\t}\n+}\n+\n+static int ath12k_wmi_modify_sbs_freq(struct ath12k_base *ab, u8 phy_id)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *sbs_mac_range, *shared_mac_range;\n+\tstruct ath12k_hw_mode_freq_range_arg *non_shared_range;\n+\tu8 shared_phy_id;\n+\n+\tsbs_mac_range = &hw_mode_info->freq_range_caps[ATH12K_HW_MODE_SBS][phy_id];\n+\n+\t/* if SBS mac range has both 2.4 and 5 GHz ranges, i.e. shared phy_id\n+\t * keep the range as it is in SBS\n+\t */\n+\tif (sbs_mac_range->low_2ghz_freq && sbs_mac_range->low_5ghz_freq)\n+\t\treturn 0;\n+\n+\tif (sbs_mac_range->low_2ghz_freq && !sbs_mac_range->low_5ghz_freq) {\n+\t\tath12k_err(ab, \"Invalid DBS/SBS mode with only 2.4Ghz\");\n+\t\tath12k_wmi_dump_freq_range_per_mac(ab, sbs_mac_range, ATH12K_HW_MODE_SBS);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tnon_shared_range = sbs_mac_range;\n+\t/* if SBS mac range has only 5 GHz then it's the non-shared phy, so\n+\t * modify the range as per the shared mac.\n+\t */\n+\tshared_phy_id = phy_id ? 0 : 1;\n+\tshared_mac_range =\n+\t\t&hw_mode_info->freq_range_caps[ATH12K_HW_MODE_SBS][shared_phy_id];\n+\n+\tif (shared_mac_range->low_5ghz_freq > non_shared_range->low_5ghz_freq) {\n+\t\tath12k_dbg(ab, ATH12K_DBG_WMI, \"high 5 GHz shared\");\n+\t\t/* If the shared mac lower 5 GHz frequency is greater than\n+\t\t * non-shared mac lower 5 GHz frequency then the shared mac has\n+\t\t * high 5 GHz shared with 2.4 GHz. So non-shared mac's 5 GHz high\n+\t\t * freq should be less than the shared mac's low 5 GHz freq.\n+\t\t */\n+\t\tif (non_shared_range->high_5ghz_freq >=\n+\t\t    shared_mac_range->low_5ghz_freq)\n+\t\t\tnon_shared_range->high_5ghz_freq =\n+\t\t\t\tmax_t(u32, shared_mac_range->low_5ghz_freq - 10,\n+\t\t\t\t      non_shared_range->low_5ghz_freq);\n+\t} else if (shared_mac_range->high_5ghz_freq <\n+\t\t   non_shared_range->high_5ghz_freq) {\n+\t\tath12k_dbg(ab, ATH12K_DBG_WMI, \"low 5 GHz shared\");\n+\t\t/* If the shared mac high 5 GHz frequency is less than\n+\t\t * non-shared mac high 5 GHz frequency then the shared mac has\n+\t\t * low 5 GHz shared with 2.4 GHz. So non-shared mac's 5 GHz low\n+\t\t * freq should be greater than the shared mac's high 5 GHz freq.\n+\t\t */\n+\t\tif (shared_mac_range->high_5ghz_freq >=\n+\t\t    non_shared_range->low_5ghz_freq)\n+\t\t\tnon_shared_range->low_5ghz_freq =\n+\t\t\t\tmin_t(u32, shared_mac_range->high_5ghz_freq + 10,\n+\t\t\t\t      non_shared_range->high_5ghz_freq);\n+\t} else {\n+\t\tath12k_warn(ab, \"invalid SBS range with all 5 GHz shared\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static void ath12k_wmi_update_sbs_freq_info(struct ath12k_base *ab)\n+{\n+\tstruct ath12k_hw_mode_info *hw_mode_info = &ab->wmi_ab.hw_mode_info;\n+\tstruct ath12k_hw_mode_freq_range_arg *mac_range;\n+\tu16 sbs_range_sep;\n+\tu8 phy_id;\n+\tint ret;\n+\n+\tmac_range = hw_mode_info->freq_range_caps[ATH12K_HW_MODE_SBS];\n+\n+\t/* If sbs_lower_band_end_freq has a value, then the frequency range\n+\t * will be split using that value.\n+\t */\n+\tsbs_range_sep = ab->wmi_ab.sbs_lower_band_end_freq;\n+\tif (sbs_range_sep) {\n+\t\tath12k_wmi_fill_upper_share_sbs_freq(ab, sbs_range_sep,\n+\t\t\t\t\t\t     mac_range);\n+\t\tath12k_wmi_fill_lower_share_sbs_freq(ab, sbs_range_sep,\n+\t\t\t\t\t\t     mac_range);\n+\t\t/* Hardware specifies the range boundary with sbs_range_sep,\n+\t\t * (i.e. the boundary between 5 GHz high and 5 GHz low),\n+\t\t * reset the original one to make sure it will not get used.\n+\t\t */\n+\t\tmemset(mac_range, 0, sizeof(*mac_range) * MAX_RADIOS);\n+\t\treturn;\n+\t}\n+\n+\t/* If sbs_lower_band_end_freq is not set that means firmware will send one\n+\t * shared mac range and one non-shared mac range. so update that freq.\n+\t */\n+\tfor (phy_id = 0; phy_id < MAX_RADIOS; phy_id++) {\n+\t\tret = ath12k_wmi_modify_sbs_freq(ab, phy_id);\n+\t\tif (ret) {\n+\t\t\tmemset(mac_range, 0, sizeof(*mac_range) * MAX_RADIOS);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n+static void\n+ath12k_wmi_update_mac_freq_info(struct ath12k_base *ab,\n+\t\t\t\tenum wmi_host_hw_mode_config_type hw_config_type,\n+\t\t\t\tu32 phy_id,\n+\t\t\t\tstruct ath12k_svc_ext_mac_phy_info *mac_cap)\n+{\n+\tif (phy_id >= MAX_RADIOS) {\n+\t\tath12k_err(ab, \"mac more than two not supported: %d\", phy_id);\n+\t\treturn;\n+\t}\n+\n+\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t   \"hw_mode_cfg %d mac %d band 0x%x SBS cutoff freq %d 2 GHz [%d - %d] 5 GHz [%d - %d]\",\n+\t\t   hw_config_type, phy_id, mac_cap->supported_bands,\n+\t\t   ab->wmi_ab.sbs_lower_band_end_freq,\n+\t\t   mac_cap->hw_freq_range.low_2ghz_freq,\n+\t\t   mac_cap->hw_freq_range.high_2ghz_freq,\n+\t\t   mac_cap->hw_freq_range.low_5ghz_freq,\n+\t\t   mac_cap->hw_freq_range.high_5ghz_freq);\n+\n+\tswitch (hw_config_type) {\n+\tcase WMI_HOST_HW_MODE_SINGLE:\n+\t\tif (phy_id) {\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI, \"mac phy 1 is not supported\");\n+\t\t\tbreak;\n+\t\t}\n+\t\tath12k_wmi_update_freq_info(ab, mac_cap, ATH12K_HW_MODE_SMM, phy_id);\n+\t\tbreak;\n+\n+\tcase WMI_HOST_HW_MODE_DBS:\n+\t\tif (!ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_DBS))\n+\t\t\tath12k_wmi_update_freq_info(ab, mac_cap,\n+\t\t\t\t\t\t    ATH12K_HW_MODE_DBS, phy_id);\n+\t\tbreak;\n+\tcase WMI_HOST_HW_MODE_DBS_SBS:\n+\tcase WMI_HOST_HW_MODE_DBS_OR_SBS:\n+\t\tath12k_wmi_update_freq_info(ab, mac_cap, ATH12K_HW_MODE_DBS, phy_id);\n+\t\tif (ab->wmi_ab.sbs_lower_band_end_freq ||\n+\t\t    mac_cap->hw_freq_range.low_5ghz_freq ||\n+\t\t    mac_cap->hw_freq_range.low_2ghz_freq)\n+\t\t\tath12k_wmi_update_freq_info(ab, mac_cap, ATH12K_HW_MODE_SBS,\n+\t\t\t\t\t\t    phy_id);\n+\n+\t\tif (ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_DBS))\n+\t\t\tath12k_wmi_update_dbs_freq_info(ab);\n+\t\tif (ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_SBS))\n+\t\t\tath12k_wmi_update_sbs_freq_info(ab);\n+\t\tbreak;\n+\tcase WMI_HOST_HW_MODE_SBS:\n+\tcase WMI_HOST_HW_MODE_SBS_PASSIVE:\n+\t\tath12k_wmi_update_freq_info(ab, mac_cap, ATH12K_HW_MODE_SBS, phy_id);\n+\t\tif (ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_SBS))\n+\t\t\tath12k_wmi_update_sbs_freq_info(ab);\n+\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n+static bool ath12k_wmi_sbs_range_present(struct ath12k_base *ab)\n+{\n+\tif (ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_SBS) ||\n+\t    (ab->wmi_ab.sbs_lower_band_end_freq &&\n+\t     ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_SBS_LOWER_SHARE) &&\n+\t     ath12k_wmi_all_phy_range_updated(ab, ATH12K_HW_MODE_SBS_UPPER_SHARE)))\n+\t\treturn true;\n+\n+\treturn false;\n+}\n+\n+static int ath12k_wmi_update_hw_mode_list(struct ath12k_base *ab)\n+{\n+\tstruct ath12k_svc_ext_info *svc_ext_info = &ab->wmi_ab.svc_ext_info;\n+\tstruct ath12k_hw_mode_info *info = &ab->wmi_ab.hw_mode_info;\n+\tenum wmi_host_hw_mode_config_type hw_config_type;\n+\tstruct ath12k_svc_ext_mac_phy_info *tmp;\n+\tbool dbs_mode = false, sbs_mode = false;\n+\tu32 i, j = 0;\n+\n+\tif (!svc_ext_info->num_hw_modes) {\n+\t\tath12k_err(ab, \"invalid number of hw modes\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tath12k_dbg(ab, ATH12K_DBG_WMI, \"updated HW mode list: num modes %d\",\n+\t\t   svc_ext_info->num_hw_modes);\n+\n+\tmemset(info->freq_range_caps, 0, sizeof(info->freq_range_caps));\n+\n+\tfor (i = 0; i < svc_ext_info->num_hw_modes; i++) {\n+\t\tif (j >= ATH12K_MAX_MAC_PHY_CAP)\n+\t\t\treturn -EINVAL;\n+\n+\t\t/* Update for MAC0 */\n+\t\ttmp = &svc_ext_info->mac_phy_info[j++];\n+\t\thw_config_type = tmp->hw_mode_config_type;\n+\t\tath12k_wmi_update_mac_freq_info(ab, hw_config_type, tmp->phy_id, tmp);\n+\n+\t\t/* SBS and DBS have dual MAC. Up to 2 MACs are considered. */\n+\t\tif (hw_config_type == WMI_HOST_HW_MODE_DBS ||\n+\t\t    hw_config_type == WMI_HOST_HW_MODE_SBS_PASSIVE ||\n+\t\t    hw_config_type == WMI_HOST_HW_MODE_SBS ||\n+\t\t    hw_config_type == WMI_HOST_HW_MODE_DBS_OR_SBS) {\n+\t\t\tif (j >= ATH12K_MAX_MAC_PHY_CAP)\n+\t\t\t\treturn -EINVAL;\n+\t\t\t/* Update for MAC1 */\n+\t\t\ttmp = &svc_ext_info->mac_phy_info[j++];\n+\t\t\tath12k_wmi_update_mac_freq_info(ab, hw_config_type,\n+\t\t\t\t\t\t\ttmp->phy_id, tmp);\n+\n+\t\t\tif (hw_config_type == WMI_HOST_HW_MODE_DBS ||\n+\t\t\t    hw_config_type == WMI_HOST_HW_MODE_DBS_OR_SBS)\n+\t\t\t\tdbs_mode = true;\n+\n+\t\t\tif (ath12k_wmi_sbs_range_present(ab) &&\n+\t\t\t    (hw_config_type == WMI_HOST_HW_MODE_SBS_PASSIVE ||\n+\t\t\t     hw_config_type == WMI_HOST_HW_MODE_SBS ||\n+\t\t\t     hw_config_type == WMI_HOST_HW_MODE_DBS_OR_SBS))\n+\t\t\t\tsbs_mode = true;\n+\t\t}\n+\t}\n+\n+\tinfo->support_dbs = dbs_mode;\n+\tinfo->support_sbs = sbs_mode;\n+\n+\tath12k_wmi_dump_freq_range(ab);\n+\n+\treturn 0;\n+}\n+\n static int ath12k_wmi_svc_rdy_ext2_parse(struct ath12k_base *ab,\n \t\t\t\t\t u16 tag, u16 len,\n \t\t\t\t\t const void *ptr, void *data)\n {\n+\tconst struct ath12k_wmi_dbs_or_sbs_cap_params *dbs_or_sbs_caps;\n \tstruct ath12k_wmi_pdev *wmi_handle = &ab->wmi_ab.wmi[0];\n \tstruct ath12k_wmi_svc_rdy_ext2_parse *parse = data;\n \tint ret;\n@@ -4967,7 +5476,32 @@ static int ath12k_wmi_svc_rdy_ext2_parse(struct ath12k_base *ab,\n \t\t\t}\n \n \t\t\tparse->mac_phy_caps_ext_done = true;\n+\t\t} else if (!parse->hal_reg_caps_ext2_done) {\n+\t\t\tparse->hal_reg_caps_ext2_done = true;\n+\t\t} else if (!parse->scan_radio_caps_ext2_done) {\n+\t\t\tparse->scan_radio_caps_ext2_done = true;\n+\t\t} else if (!parse->twt_caps_done) {\n+\t\t\tparse->twt_caps_done = true;\n+\t\t} else if (!parse->htt_msdu_idx_to_qtype_map_done) {\n+\t\t\tparse->htt_msdu_idx_to_qtype_map_done = true;\n+\t\t} else if (!parse->dbs_or_sbs_cap_ext_done) {\n+\t\t\tdbs_or_sbs_caps = ptr;\n+\t\t\tab->wmi_ab.sbs_lower_band_end_freq =\n+\t\t\t\t__le32_to_cpu(dbs_or_sbs_caps->sbs_lower_band_end_freq);\n+\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI, \"sbs_lower_band_end_freq %u\\n\",\n+\t\t\t\t   ab->wmi_ab.sbs_lower_band_end_freq);\n+\n+\t\t\tret = ath12k_wmi_update_hw_mode_list(ab);\n+\t\t\tif (ret) {\n+\t\t\t\tath12k_warn(ab, \"failed to update hw mode list: %d\\n\",\n+\t\t\t\t\t    ret);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\n+\t\t\tparse->dbs_or_sbs_cap_ext_done = true;\n \t\t}\n+\n \t\tbreak;\n \tdefault:\n \t\tbreak;\n@@ -7626,6 +8160,64 @@ static int ath12k_wmi_pull_fw_stats(struct ath12k_base *ab, struct sk_buff *skb,\n \t\t\t\t   &parse);\n }\n \n+static void ath12k_wmi_fw_stats_process(struct ath12k *ar,\n+\t\t\t\t\tstruct ath12k_fw_stats *stats)\n+{\n+\tstruct ath12k_base *ab = ar->ab;\n+\tstruct ath12k_pdev *pdev;\n+\tbool is_end = true;\n+\tsize_t total_vdevs_started = 0;\n+\tint i;\n+\n+\tif (stats->stats_id == WMI_REQUEST_VDEV_STAT) {\n+\t\tif (list_empty(&stats->vdevs)) {\n+\t\t\tath12k_warn(ab, \"empty vdev stats\");\n+\t\t\treturn;\n+\t\t}\n+\t\t/* FW sends all the active VDEV stats irrespective of PDEV,\n+\t\t * hence limit until the count of all VDEVs started\n+\t\t */\n+\t\trcu_read_lock();\n+\t\tfor (i = 0; i < ab->num_radios; i++) {\n+\t\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n+\t\t\tif (pdev && pdev->ar)\n+\t\t\t\ttotal_vdevs_started += pdev->ar->num_started_vdevs;\n+\t\t}\n+\t\trcu_read_unlock();\n+\n+\t\tif (total_vdevs_started)\n+\t\t\tis_end = ((++ar->fw_stats.num_vdev_recvd) ==\n+\t\t\t\t  total_vdevs_started);\n+\n+\t\tlist_splice_tail_init(&stats->vdevs,\n+\t\t\t\t      &ar->fw_stats.vdevs);\n+\n+\t\tif (is_end)\n+\t\t\tcomplete(&ar->fw_stats_done);\n+\n+\t\treturn;\n+\t}\n+\n+\tif (stats->stats_id == WMI_REQUEST_BCN_STAT) {\n+\t\tif (list_empty(&stats->bcn)) {\n+\t\t\tath12k_warn(ab, \"empty beacon stats\");\n+\t\t\treturn;\n+\t\t}\n+\t\t/* Mark end until we reached the count of all started VDEVs\n+\t\t * within the PDEV\n+\t\t */\n+\t\tif (ar->num_started_vdevs)\n+\t\t\tis_end = ((++ar->fw_stats.num_bcn_recvd) ==\n+\t\t\t\t  ar->num_started_vdevs);\n+\n+\t\tlist_splice_tail_init(&stats->bcn,\n+\t\t\t\t      &ar->fw_stats.bcn);\n+\n+\t\tif (is_end)\n+\t\t\tcomplete(&ar->fw_stats_done);\n+\t}\n+}\n+\n static void ath12k_update_stats_event(struct ath12k_base *ab, struct sk_buff *skb)\n {\n \tstruct ath12k_fw_stats stats = {};\n@@ -7655,19 +8247,15 @@ static void ath12k_update_stats_event(struct ath12k_base *ab, struct sk_buff *sk\n \n \tspin_lock_bh(&ar->data_lock);\n \n-\t/* WMI_REQUEST_PDEV_STAT can be requested via .get_txpower mac ops or via\n-\t * debugfs fw stats. Therefore, processing it separately.\n-\t */\n+\t/* Handle WMI_REQUEST_PDEV_STAT status update */\n \tif (stats.stats_id == WMI_REQUEST_PDEV_STAT) {\n \t\tlist_splice_tail_init(&stats.pdevs, &ar->fw_stats.pdevs);\n-\t\tar->fw_stats.fw_stats_done = true;\n+\t\tcomplete(&ar->fw_stats_done);\n \t\tgoto complete;\n \t}\n \n-\t/* WMI_REQUEST_VDEV_STAT and WMI_REQUEST_BCN_STAT are currently requested only\n-\t * via debugfs fw stats. Hence, processing these in debugfs context.\n-\t */\n-\tath12k_debugfs_fw_stats_process(ar, &stats);\n+\t/* Handle WMI_REQUEST_VDEV_STAT and WMI_REQUEST_BCN_STAT updates. */\n+\tath12k_wmi_fw_stats_process(ar, &stats);\n \n complete:\n \tcomplete(&ar->fw_stats_complete);\n@@ -9911,3 +10499,224 @@ int ath12k_wmi_send_vdev_set_tpc_power(struct ath12k *ar,\n \n \treturn 0;\n }\n+\n+static int\n+ath12k_wmi_fill_disallowed_bmap(struct ath12k_base *ab,\n+\t\t\t\tstruct wmi_disallowed_mlo_mode_bitmap_params *dislw_bmap,\n+\t\t\t\tstruct wmi_mlo_link_set_active_arg *arg)\n+{\n+\tstruct wmi_ml_disallow_mode_bmap_arg *dislw_bmap_arg;\n+\tu8 i;\n+\n+\tif (arg->num_disallow_mode_comb >\n+\t    ARRAY_SIZE(arg->disallow_bmap)) {\n+\t\tath12k_warn(ab, \"invalid num_disallow_mode_comb: %d\",\n+\t\t\t    arg->num_disallow_mode_comb);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tdislw_bmap_arg = &arg->disallow_bmap[0];\n+\tfor (i = 0; i < arg->num_disallow_mode_comb; i++) {\n+\t\tdislw_bmap->tlv_header =\n+\t\t\t\tath12k_wmi_tlv_cmd_hdr(0, sizeof(*dislw_bmap));\n+\t\tdislw_bmap->disallowed_mode_bitmap =\n+\t\t\t\tcpu_to_le32(dislw_bmap_arg->disallowed_mode);\n+\t\tdislw_bmap->ieee_link_id_comb =\n+\t\t\tle32_encode_bits(dislw_bmap_arg->ieee_link_id[0],\n+\t\t\t\t\t WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_1) |\n+\t\t\tle32_encode_bits(dislw_bmap_arg->ieee_link_id[1],\n+\t\t\t\t\t WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_2) |\n+\t\t\tle32_encode_bits(dislw_bmap_arg->ieee_link_id[2],\n+\t\t\t\t\t WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_3) |\n+\t\t\tle32_encode_bits(dislw_bmap_arg->ieee_link_id[3],\n+\t\t\t\t\t WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_4);\n+\n+\t\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t\t   \"entry %d disallowed_mode %d ieee_link_id_comb 0x%x\",\n+\t\t\t   i, dislw_bmap_arg->disallowed_mode,\n+\t\t\t   dislw_bmap_arg->ieee_link_id_comb);\n+\t\tdislw_bmap++;\n+\t\tdislw_bmap_arg++;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+int ath12k_wmi_send_mlo_link_set_active_cmd(struct ath12k_base *ab,\n+\t\t\t\t\t    struct wmi_mlo_link_set_active_arg *arg)\n+{\n+\tstruct wmi_disallowed_mlo_mode_bitmap_params *disallowed_mode_bmap;\n+\tstruct wmi_mlo_set_active_link_number_params *link_num_param;\n+\tu32 num_link_num_param = 0, num_vdev_bitmap = 0;\n+\tstruct ath12k_wmi_base *wmi_ab = &ab->wmi_ab;\n+\tstruct wmi_mlo_link_set_active_cmd *cmd;\n+\tu32 num_inactive_vdev_bitmap = 0;\n+\tu32 num_disallow_mode_comb = 0;\n+\tstruct wmi_tlv *tlv;\n+\tstruct sk_buff *skb;\n+\t__le32 *vdev_bitmap;\n+\tvoid *buf_ptr;\n+\tint i, ret;\n+\tu32 len;\n+\n+\tif (!arg->num_vdev_bitmap && !arg->num_link_entry) {\n+\t\tath12k_warn(ab, \"Invalid num_vdev_bitmap and num_link_entry\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tswitch (arg->force_mode) {\n+\tcase WMI_MLO_LINK_FORCE_MODE_ACTIVE_LINK_NUM:\n+\tcase WMI_MLO_LINK_FORCE_MODE_INACTIVE_LINK_NUM:\n+\t\tnum_link_num_param = arg->num_link_entry;\n+\t\tfallthrough;\n+\tcase WMI_MLO_LINK_FORCE_MODE_ACTIVE:\n+\tcase WMI_MLO_LINK_FORCE_MODE_INACTIVE:\n+\tcase WMI_MLO_LINK_FORCE_MODE_NO_FORCE:\n+\t\tnum_vdev_bitmap = arg->num_vdev_bitmap;\n+\t\tbreak;\n+\tcase WMI_MLO_LINK_FORCE_MODE_ACTIVE_INACTIVE:\n+\t\tnum_vdev_bitmap = arg->num_vdev_bitmap;\n+\t\tnum_inactive_vdev_bitmap = arg->num_inactive_vdev_bitmap;\n+\t\tbreak;\n+\tdefault:\n+\t\tath12k_warn(ab, \"Invalid force mode: %u\", arg->force_mode);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tnum_disallow_mode_comb = arg->num_disallow_mode_comb;\n+\tlen = sizeof(*cmd) +\n+\t      TLV_HDR_SIZE + sizeof(*link_num_param) * num_link_num_param +\n+\t      TLV_HDR_SIZE + sizeof(*vdev_bitmap) * num_vdev_bitmap +\n+\t      TLV_HDR_SIZE + TLV_HDR_SIZE + TLV_HDR_SIZE +\n+\t      TLV_HDR_SIZE + sizeof(*disallowed_mode_bmap) * num_disallow_mode_comb;\n+\tif (arg->force_mode == WMI_MLO_LINK_FORCE_MODE_ACTIVE_INACTIVE)\n+\t\tlen += sizeof(*vdev_bitmap) * num_inactive_vdev_bitmap;\n+\n+\tskb = ath12k_wmi_alloc_skb(wmi_ab, len);\n+\tif (!skb)\n+\t\treturn -ENOMEM;\n+\n+\tcmd = (struct wmi_mlo_link_set_active_cmd *)skb->data;\n+\tcmd->tlv_header = ath12k_wmi_tlv_cmd_hdr(WMI_TAG_MLO_LINK_SET_ACTIVE_CMD,\n+\t\t\t\t\t\t sizeof(*cmd));\n+\tcmd->force_mode = cpu_to_le32(arg->force_mode);\n+\tcmd->reason = cpu_to_le32(arg->reason);\n+\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t   \"mode %d reason %d num_link_num_param %d num_vdev_bitmap %d inactive %d num_disallow_mode_comb %d\",\n+\t\t   arg->force_mode, arg->reason, num_link_num_param,\n+\t\t   num_vdev_bitmap, num_inactive_vdev_bitmap,\n+\t\t   num_disallow_mode_comb);\n+\n+\tbuf_ptr = skb->data + sizeof(*cmd);\n+\ttlv = buf_ptr;\n+\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_STRUCT,\n+\t\t\t\t\t sizeof(*link_num_param) * num_link_num_param);\n+\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\tif (num_link_num_param) {\n+\t\tcmd->ctrl_flags =\n+\t\t\tle32_encode_bits(arg->ctrl_flags.dync_force_link_num ? 1 : 0,\n+\t\t\t\t\t CRTL_F_DYNC_FORCE_LINK_NUM);\n+\n+\t\tlink_num_param = buf_ptr;\n+\t\tfor (i = 0; i < num_link_num_param; i++) {\n+\t\t\tlink_num_param->tlv_header =\n+\t\t\t\tath12k_wmi_tlv_cmd_hdr(0, sizeof(*link_num_param));\n+\t\t\tlink_num_param->num_of_link =\n+\t\t\t\tcpu_to_le32(arg->link_num[i].num_of_link);\n+\t\t\tlink_num_param->vdev_type =\n+\t\t\t\tcpu_to_le32(arg->link_num[i].vdev_type);\n+\t\t\tlink_num_param->vdev_subtype =\n+\t\t\t\tcpu_to_le32(arg->link_num[i].vdev_subtype);\n+\t\t\tlink_num_param->home_freq =\n+\t\t\t\tcpu_to_le32(arg->link_num[i].home_freq);\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t\t\t   \"entry %d num_of_link %d vdev type %d subtype %d freq %d control_flags %d\",\n+\t\t\t\t   i, arg->link_num[i].num_of_link,\n+\t\t\t\t   arg->link_num[i].vdev_type,\n+\t\t\t\t   arg->link_num[i].vdev_subtype,\n+\t\t\t\t   arg->link_num[i].home_freq,\n+\t\t\t\t   __le32_to_cpu(cmd->ctrl_flags));\n+\t\t\tlink_num_param++;\n+\t\t}\n+\n+\t\tbuf_ptr += sizeof(*link_num_param) * num_link_num_param;\n+\t}\n+\n+\ttlv = buf_ptr;\n+\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_UINT32,\n+\t\t\t\t\t sizeof(*vdev_bitmap) * num_vdev_bitmap);\n+\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\tif (num_vdev_bitmap) {\n+\t\tvdev_bitmap = buf_ptr;\n+\t\tfor (i = 0; i < num_vdev_bitmap; i++) {\n+\t\t\tvdev_bitmap[i] = cpu_to_le32(arg->vdev_bitmap[i]);\n+\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI, \"entry %d vdev_id_bitmap 0x%x\",\n+\t\t\t\t   i, arg->vdev_bitmap[i]);\n+\t\t}\n+\n+\t\tbuf_ptr += sizeof(*vdev_bitmap) * num_vdev_bitmap;\n+\t}\n+\n+\tif (arg->force_mode == WMI_MLO_LINK_FORCE_MODE_ACTIVE_INACTIVE) {\n+\t\ttlv = buf_ptr;\n+\t\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_UINT32,\n+\t\t\t\t\t\t sizeof(*vdev_bitmap) *\n+\t\t\t\t\t\t num_inactive_vdev_bitmap);\n+\t\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\t\tif (num_inactive_vdev_bitmap) {\n+\t\t\tvdev_bitmap = buf_ptr;\n+\t\t\tfor (i = 0; i < num_inactive_vdev_bitmap; i++) {\n+\t\t\t\tvdev_bitmap[i] =\n+\t\t\t\t\tcpu_to_le32(arg->inactive_vdev_bitmap[i]);\n+\t\t\t\tath12k_dbg(ab, ATH12K_DBG_WMI,\n+\t\t\t\t\t   \"entry %d inactive_vdev_id_bitmap 0x%x\",\n+\t\t\t\t\t    i, arg->inactive_vdev_bitmap[i]);\n+\t\t\t}\n+\n+\t\t\tbuf_ptr += sizeof(*vdev_bitmap) * num_inactive_vdev_bitmap;\n+\t\t}\n+\t} else {\n+\t\t/* add empty vdev bitmap2 tlv */\n+\t\ttlv = buf_ptr;\n+\t\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_UINT32, 0);\n+\t\tbuf_ptr += TLV_HDR_SIZE;\n+\t}\n+\n+\t/* add empty ieee_link_id_bitmap tlv */\n+\ttlv = buf_ptr;\n+\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_UINT32, 0);\n+\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\t/* add empty ieee_link_id_bitmap2 tlv */\n+\ttlv = buf_ptr;\n+\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_UINT32, 0);\n+\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\ttlv = buf_ptr;\n+\ttlv->header = ath12k_wmi_tlv_hdr(WMI_TAG_ARRAY_STRUCT,\n+\t\t\t\t\t sizeof(*disallowed_mode_bmap) *\n+\t\t\t\t\t arg->num_disallow_mode_comb);\n+\tbuf_ptr += TLV_HDR_SIZE;\n+\n+\tret = ath12k_wmi_fill_disallowed_bmap(ab, buf_ptr, arg);\n+\tif (ret)\n+\t\tgoto free_skb;\n+\n+\tret = ath12k_wmi_cmd_send(&wmi_ab->wmi[0], skb, WMI_MLO_LINK_SET_ACTIVE_CMDID);\n+\tif (ret) {\n+\t\tath12k_warn(ab,\n+\t\t\t    \"failed to send WMI_MLO_LINK_SET_ACTIVE_CMDID: %d\\n\", ret);\n+\t\tgoto free_skb;\n+\t}\n+\n+\tath12k_dbg(ab, ATH12K_DBG_WMI, \"WMI mlo link set active cmd\");\n+\n+\treturn ret;\n+\n+free_skb:\n+\tdev_kfree_skb(skb);\n+\treturn ret;\n+}\ndiff --git a/drivers/net/wireless/ath/ath12k/wmi.h b/drivers/net/wireless/ath/ath12k/wmi.h\nindex ac18f75e0449..c640ffa180c8 100644\n--- a/drivers/net/wireless/ath/ath12k/wmi.h\n+++ b/drivers/net/wireless/ath/ath12k/wmi.h\n@@ -1974,6 +1974,7 @@ enum wmi_tlv_tag {\n \tWMI_TAG_TPC_STATS_CTL_PWR_TABLE_EVENT,\n \tWMI_TAG_VDEV_SET_TPC_POWER_CMD = 0x3B5,\n \tWMI_TAG_VDEV_CH_POWER_INFO,\n+\tWMI_TAG_MLO_LINK_SET_ACTIVE_CMD = 0x3BE,\n \tWMI_TAG_EHT_RATE_SET = 0x3C4,\n \tWMI_TAG_DCS_AWGN_INT_TYPE = 0x3C5,\n \tWMI_TAG_MLO_TX_SEND_PARAMS,\n@@ -2617,6 +2618,8 @@ struct ath12k_wmi_soc_mac_phy_hw_mode_caps_params {\n \t__le32 num_chainmask_tables;\n } __packed;\n \n+#define WMI_HW_MODE_CAP_CFG_TYPE\tGENMASK(27, 0)\n+\n struct ath12k_wmi_hw_mode_cap_params {\n \t__le32 tlv_header;\n \t__le32 hw_mode_id;\n@@ -2666,6 +2669,12 @@ struct ath12k_wmi_mac_phy_caps_params {\n \t__le32 he_cap_info_2g_ext;\n \t__le32 he_cap_info_5g_ext;\n \t__le32 he_cap_info_internal;\n+\t__le32 wireless_modes;\n+\t__le32 low_2ghz_chan_freq;\n+\t__le32 high_2ghz_chan_freq;\n+\t__le32 low_5ghz_chan_freq;\n+\t__le32 high_5ghz_chan_freq;\n+\t__le32 nss_ratio;\n } __packed;\n \n struct ath12k_wmi_hal_reg_caps_ext_params {\n@@ -2739,6 +2748,11 @@ struct wmi_service_ready_ext2_event {\n \t__le32 default_num_msduq_supported_per_tid;\n } __packed;\n \n+struct ath12k_wmi_dbs_or_sbs_cap_params {\n+\t__le32 hw_mode_id;\n+\t__le32 sbs_lower_band_end_freq;\n+} __packed;\n+\n struct ath12k_wmi_caps_ext_params {\n \t__le32 hw_mode_id;\n \t__le32 pdev_and_hw_link_ids;\n@@ -5049,6 +5063,53 @@ struct ath12k_wmi_pdev {\n \tu32 rx_decap_mode;\n };\n \n+struct ath12k_hw_mode_freq_range_arg {\n+\tu32 low_2ghz_freq;\n+\tu32 high_2ghz_freq;\n+\tu32 low_5ghz_freq;\n+\tu32 high_5ghz_freq;\n+};\n+\n+struct ath12k_svc_ext_mac_phy_info {\n+\tenum wmi_host_hw_mode_config_type hw_mode_config_type;\n+\tu32 phy_id;\n+\tu32 supported_bands;\n+\tstruct ath12k_hw_mode_freq_range_arg hw_freq_range;\n+};\n+\n+#define ATH12K_MAX_MAC_PHY_CAP\t8\n+\n+struct ath12k_svc_ext_info {\n+\tu32 num_hw_modes;\n+\tstruct ath12k_svc_ext_mac_phy_info mac_phy_info[ATH12K_MAX_MAC_PHY_CAP];\n+};\n+\n+/**\n+ * enum ath12k_hw_mode - enum for host mode\n+ * @ATH12K_HW_MODE_SMM: Single mac mode\n+ * @ATH12K_HW_MODE_DBS: DBS mode\n+ * @ATH12K_HW_MODE_SBS: SBS mode with either high share or low share\n+ * @ATH12K_HW_MODE_SBS_UPPER_SHARE: Higher 5 GHz shared with 2.4 GHz\n+ * @ATH12K_HW_MODE_SBS_LOWER_SHARE: Lower 5 GHz shared with 2.4 GHz\n+ * @ATH12K_HW_MODE_MAX: Max, used to indicate invalid mode\n+ */\n+enum ath12k_hw_mode {\n+\tATH12K_HW_MODE_SMM,\n+\tATH12K_HW_MODE_DBS,\n+\tATH12K_HW_MODE_SBS,\n+\tATH12K_HW_MODE_SBS_UPPER_SHARE,\n+\tATH12K_HW_MODE_SBS_LOWER_SHARE,\n+\tATH12K_HW_MODE_MAX,\n+};\n+\n+struct ath12k_hw_mode_info {\n+\tbool support_dbs:1;\n+\tbool support_sbs:1;\n+\n+\tstruct ath12k_hw_mode_freq_range_arg freq_range_caps[ATH12K_HW_MODE_MAX]\n+\t\t\t\t\t\t\t    [MAX_RADIOS];\n+};\n+\n struct ath12k_wmi_base {\n \tstruct ath12k_base *ab;\n \tstruct ath12k_wmi_pdev wmi[MAX_RADIOS];\n@@ -5066,6 +5127,10 @@ struct ath12k_wmi_base {\n \tenum wmi_host_hw_mode_config_type preferred_hw_mode;\n \n \tstruct ath12k_wmi_target_cap_arg *targ_cap;\n+\n+\tstruct ath12k_svc_ext_info svc_ext_info;\n+\tu32 sbs_lower_band_end_freq;\n+\tstruct ath12k_hw_mode_info hw_mode_info;\n };\n \n struct wmi_pdev_set_bios_interface_cmd {\n@@ -5997,6 +6062,118 @@ struct wmi_vdev_set_tpc_power_cmd {\n \t */\n } __packed;\n \n+#define CRTL_F_DYNC_FORCE_LINK_NUM GENMASK(3, 2)\n+\n+struct wmi_mlo_link_set_active_cmd {\n+\t__le32 tlv_header;\n+\t__le32 force_mode;\n+\t__le32 reason;\n+\t__le32 use_ieee_link_id_bitmap;\n+\tstruct ath12k_wmi_mac_addr_params ap_mld_mac_addr;\n+\t__le32 ctrl_flags;\n+} __packed;\n+\n+struct wmi_mlo_set_active_link_number_params {\n+\t__le32 tlv_header;\n+\t__le32 num_of_link;\n+\t__le32 vdev_type;\n+\t__le32 vdev_subtype;\n+\t__le32 home_freq;\n+} __packed;\n+\n+#define WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_1 GENMASK(7, 0)\n+#define WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_2 GENMASK(15, 8)\n+#define WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_3 GENMASK(23, 16)\n+#define WMI_DISALW_MLO_MODE_BMAP_IEEE_LINK_ID_COMB_4 GENMASK(31, 24)\n+\n+struct wmi_disallowed_mlo_mode_bitmap_params {\n+\t__le32 tlv_header;\n+\t__le32 disallowed_mode_bitmap;\n+\t__le32 ieee_link_id_comb;\n+} __packed;\n+\n+enum wmi_mlo_link_force_mode {\n+\tWMI_MLO_LINK_FORCE_MODE_ACTIVE\t\t\t= 1,\n+\tWMI_MLO_LINK_FORCE_MODE_INACTIVE\t\t= 2,\n+\tWMI_MLO_LINK_FORCE_MODE_ACTIVE_LINK_NUM\t\t= 3,\n+\tWMI_MLO_LINK_FORCE_MODE_INACTIVE_LINK_NUM\t= 4,\n+\tWMI_MLO_LINK_FORCE_MODE_NO_FORCE\t\t= 5,\n+\tWMI_MLO_LINK_FORCE_MODE_ACTIVE_INACTIVE\t\t= 6,\n+\tWMI_MLO_LINK_FORCE_MODE_NON_FORCE_UPDATE\t= 7,\n+};\n+\n+enum wmi_mlo_link_force_reason {\n+\tWMI_MLO_LINK_FORCE_REASON_NEW_CONNECT\t\t= 1,\n+\tWMI_MLO_LINK_FORCE_REASON_NEW_DISCONNECT\t= 2,\n+\tWMI_MLO_LINK_FORCE_REASON_LINK_REMOVAL\t\t= 3,\n+\tWMI_MLO_LINK_FORCE_REASON_TDLS\t\t\t= 4,\n+\tWMI_MLO_LINK_FORCE_REASON_REVERT_FAILURE\t= 5,\n+\tWMI_MLO_LINK_FORCE_REASON_LINK_DELETE\t\t= 6,\n+\tWMI_MLO_LINK_FORCE_REASON_SINGLE_LINK_EMLSR_OP\t= 7,\n+};\n+\n+struct wmi_mlo_link_num_arg {\n+\tu32 num_of_link;\n+\tu32 vdev_type;\n+\tu32 vdev_subtype;\n+\tu32 home_freq;\n+};\n+\n+struct wmi_mlo_control_flags_arg {\n+\tbool overwrite_force_active_bitmap;\n+\tbool overwrite_force_inactive_bitmap;\n+\tbool dync_force_link_num;\n+\tbool post_re_evaluate;\n+\tu8 post_re_evaluate_loops;\n+\tbool dont_reschedule_workqueue;\n+};\n+\n+struct wmi_ml_link_force_cmd_arg {\n+\tu8 ap_mld_mac_addr[ETH_ALEN];\n+\tu16 ieee_link_id_bitmap;\n+\tu16 ieee_link_id_bitmap2;\n+\tu8 link_num;\n+};\n+\n+struct wmi_ml_disallow_mode_bmap_arg {\n+\tu32 disallowed_mode;\n+\tunion {\n+\t\tu32 ieee_link_id_comb;\n+\t\tu8 ieee_link_id[4];\n+\t};\n+};\n+\n+/* maximum size of link number param array\n+ * for MLO link set active command\n+ */\n+#define WMI_MLO_LINK_NUM_SZ 2\n+\n+/* maximum size of vdev bitmap array for\n+ * MLO link set active command\n+ */\n+#define WMI_MLO_VDEV_BITMAP_SZ 2\n+\n+/* Max number of disallowed bitmap combination\n+ * sent to firmware\n+ */\n+#define WMI_ML_MAX_DISALLOW_BMAP_COMB 4\n+\n+struct wmi_mlo_link_set_active_arg {\n+\tenum wmi_mlo_link_force_mode force_mode;\n+\tenum wmi_mlo_link_force_reason reason;\n+\tu32 num_link_entry;\n+\tu32 num_vdev_bitmap;\n+\tu32 num_inactive_vdev_bitmap;\n+\tstruct wmi_mlo_link_num_arg link_num[WMI_MLO_LINK_NUM_SZ];\n+\tu32 vdev_bitmap[WMI_MLO_VDEV_BITMAP_SZ];\n+\tu32 inactive_vdev_bitmap[WMI_MLO_VDEV_BITMAP_SZ];\n+\tstruct wmi_mlo_control_flags_arg ctrl_flags;\n+\tbool use_ieee_link_id;\n+\tstruct wmi_ml_link_force_cmd_arg force_cmd;\n+\tu32 num_disallow_mode_comb;\n+\tstruct wmi_ml_disallow_mode_bmap_arg disallow_bmap[WMI_ML_MAX_DISALLOW_BMAP_COMB];\n+};\n+\n void ath12k_wmi_init_qcn9274(struct ath12k_base *ab,\n \t\t\t     struct ath12k_wmi_resource_config_arg *config);\n void ath12k_wmi_init_wcn7850(struct ath12k_base *ab,\n@@ -6195,5 +6372,6 @@ bool ath12k_wmi_supports_6ghz_cc_ext(struct ath12k *ar);\n int ath12k_wmi_send_vdev_set_tpc_power(struct ath12k *ar,\n \t\t\t\t       u32 vdev_id,\n \t\t\t\t       struct ath12k_reg_tpc_power_info *param);\n-\n+int ath12k_wmi_send_mlo_link_set_active_cmd(struct ath12k_base *ab,\n+\t\t\t\t\t    struct wmi_mlo_link_set_active_arg *param);\n #endif\ndiff --git a/drivers/net/wireless/ath/ath6kl/bmi.c b/drivers/net/wireless/ath/ath6kl/bmi.c\nindex af98e871199d..5a9e93fd1ef4 100644\n--- a/drivers/net/wireless/ath/ath6kl/bmi.c\n+++ b/drivers/net/wireless/ath/ath6kl/bmi.c\n@@ -87,7 +87,9 @@ int ath6kl_bmi_get_target_info(struct ath6kl *ar,\n \t\t * We need to do some backwards compatibility to make this work.\n \t\t */\n \t\tif (le32_to_cpu(targ_info->byte_count) != sizeof(*targ_info)) {\n-\t\t\tWARN_ON(1);\n+\t\t\tath6kl_err(\"mismatched byte count %d vs. expected %zd\\n\",\n+\t\t\t\t   le32_to_cpu(targ_info->byte_count),\n+\t\t\t\t   sizeof(*targ_info));\n \t\t\treturn -EINVAL;\n \t\t}\n \ndiff --git a/drivers/net/wireless/ath/carl9170/usb.c b/drivers/net/wireless/ath/carl9170/usb.c\nindex a3e03580cd9f..564ca6a61985 100644\n--- a/drivers/net/wireless/ath/carl9170/usb.c\n+++ b/drivers/net/wireless/ath/carl9170/usb.c\n@@ -438,14 +438,21 @@ static void carl9170_usb_rx_complete(struct urb *urb)\n \n \t\tif (atomic_read(&ar->rx_anch_urbs) == 0) {\n \t\t\t/*\n-\t\t\t * The system is too slow to cope with\n-\t\t\t * the enormous workload. We have simply\n-\t\t\t * run out of active rx urbs and this\n-\t\t\t * unfortunately leads to an unpredictable\n-\t\t\t * device.\n+\t\t\t * At this point, either the system is too slow to\n+\t\t\t * cope with the enormous workload (so we have simply\n+\t\t\t * run out of active rx urbs and this unfortunately\n+\t\t\t * leads to an unpredictable device), or the device\n+\t\t\t * is not fully functional after an unsuccessful\n+\t\t\t * firmware loading attempts (so it doesn't pass\n+\t\t\t * ieee80211_register_hw() and there is no internal\n+\t\t\t * workqueue at all).\n \t\t\t */\n \n-\t\t\tieee80211_queue_work(ar->hw, &ar->ping_work);\n+\t\t\tif (ar->registered)\n+\t\t\t\tieee80211_queue_work(ar->hw, &ar->ping_work);\n+\t\t\telse\n+\t\t\t\tpr_warn_once(\"device %s is not registered\\n\",\n+\t\t\t\t\t     dev_name(&ar->udev->dev));\n \t\t}\n \t} else {\n \t\t/*\ndiff --git a/drivers/net/wireless/intel/iwlwifi/dvm/main.c b/drivers/net/wireless/intel/iwlwifi/dvm/main.c\nindex dbfd45948e8b..66211426aa3a 100644\n--- a/drivers/net/wireless/intel/iwlwifi/dvm/main.c\n+++ b/drivers/net/wireless/intel/iwlwifi/dvm/main.c\n@@ -1316,6 +1316,7 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,\n \t\t     sizeof(trans->conf.no_reclaim_cmds));\n \tmemcpy(trans->conf.no_reclaim_cmds, no_reclaim_cmds,\n \t       sizeof(no_reclaim_cmds));\n+\ttrans->conf.n_no_reclaim_cmds = ARRAY_SIZE(no_reclaim_cmds);\n \n \tswitch (iwlwifi_mod_params.amsdu_size) {\n \tcase IWL_AMSDU_DEF:\ndiff --git a/drivers/net/wireless/intel/iwlwifi/mld/mld.c b/drivers/net/wireless/intel/iwlwifi/mld/mld.c\nindex e8820e7cf8fa..1774bb84dd3f 100644\n--- a/drivers/net/wireless/intel/iwlwifi/mld/mld.c\n+++ b/drivers/net/wireless/intel/iwlwifi/mld/mld.c\n@@ -77,6 +77,7 @@ void iwl_construct_mld(struct iwl_mld *mld, struct iwl_trans *trans,\n \n \t/* Setup async RX handling */\n \tspin_lock_init(&mld->async_handlers_lock);\n+\tINIT_LIST_HEAD(&mld->async_handlers_list);\n \twiphy_work_init(&mld->async_handlers_wk,\n \t\t\tiwl_mld_async_handlers_wk);\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c b/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\nindex 81ca9ff67be9..3c255ae916c8 100644\n--- a/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\n+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac.c\n@@ -34,7 +34,7 @@ static void iwl_mvm_mld_mac_ctxt_cmd_common(struct iwl_mvm *mvm,\n \t\t\t\t\t    WIDE_ID(MAC_CONF_GROUP,\n \t\t\t\t\t\t    MAC_CONFIG_CMD), 0);\n \n-\tif (WARN_ON(cmd_ver < 1 && cmd_ver > 3))\n+\tif (WARN_ON(cmd_ver < 1 || cmd_ver > 3))\n \t\treturn;\n \n \tcmd->id_and_color = cpu_to_le32(mvmvif->id);\ndiff --git a/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info.c b/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info.c\nindex cb36baac14da..4f2be0c1bd97 100644\n--- a/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info.c\n+++ b/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info.c\n@@ -166,7 +166,7 @@ int iwl_pcie_ctxt_info_init(struct iwl_trans *trans,\n \tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n \tstruct iwl_context_info *ctxt_info;\n \tstruct iwl_context_info_rbd_cfg *rx_cfg;\n-\tu32 control_flags = 0, rb_size;\n+\tu32 control_flags = 0, rb_size, cb_size;\n \tdma_addr_t phys;\n \tint ret;\n \n@@ -202,11 +202,12 @@ int iwl_pcie_ctxt_info_init(struct iwl_trans *trans,\n \t\trb_size = IWL_CTXT_INFO_RB_SIZE_4K;\n \t}\n \n-\tWARN_ON(RX_QUEUE_CB_SIZE(iwl_trans_get_num_rbds(trans)) > 12);\n+\tcb_size = RX_QUEUE_CB_SIZE(iwl_trans_get_num_rbds(trans));\n+\tif (WARN_ON(cb_size > 12))\n+\t\tcb_size = 12;\n+\n \tcontrol_flags = IWL_CTXT_INFO_TFD_FORMAT_LONG;\n-\tcontrol_flags |=\n-\t\tu32_encode_bits(RX_QUEUE_CB_SIZE(iwl_trans_get_num_rbds(trans)),\n-\t\t\t\tIWL_CTXT_INFO_RB_CB_SIZE);\n+\tcontrol_flags |= u32_encode_bits(cb_size, IWL_CTXT_INFO_RB_CB_SIZE);\n \tcontrol_flags |= u32_encode_bits(rb_size, IWL_CTXT_INFO_RB_SIZE);\n \tctxt_info->control.control_flags = cpu_to_le32(control_flags);\n \ndiff --git a/drivers/ptp/ptp_clock.c b/drivers/ptp/ptp_clock.c\nindex 35a5994bf64f..36f57d7b4a66 100644\n--- a/drivers/ptp/ptp_clock.c\n+++ b/drivers/ptp/ptp_clock.c\n@@ -121,7 +121,8 @@ static int ptp_clock_adjtime(struct posix_clock *pc, struct __kernel_timex *tx)\n \tstruct ptp_clock_info *ops;\n \tint err = -EOPNOTSUPP;\n \n-\tif (ptp_clock_freerun(ptp)) {\n+\tif (tx->modes & (ADJ_SETOFFSET | ADJ_FREQUENCY | ADJ_OFFSET) &&\n+\t    ptp_clock_freerun(ptp)) {\n \t\tpr_err(\"ptp: physical clock is free running\\n\");\n \t\treturn -EBUSY;\n \t}\ndiff --git a/drivers/ptp/ptp_private.h b/drivers/ptp/ptp_private.h\nindex 528d86a33f37..a6aad743c282 100644\n--- a/drivers/ptp/ptp_private.h\n+++ b/drivers/ptp/ptp_private.h\n@@ -98,7 +98,27 @@ static inline int queue_cnt(const struct timestamp_event_queue *q)\n /* Check if ptp virtual clock is in use */\n static inline bool ptp_vclock_in_use(struct ptp_clock *ptp)\n {\n-\treturn !ptp->is_virtual_clock;\n+\tbool in_use = false;\n+\n+\t/* Virtual clocks can't be stacked on top of virtual clocks.\n+\t * Avoid acquiring the n_vclocks_mux on virtual clocks, to allow this\n+\t * function to be called from code paths where the n_vclocks_mux of the\n+\t * parent physical clock is already held. Functionally that's not an\n+\t * issue, but lockdep would complain, because they have the same lock\n+\t * class.\n+\t */\n+\tif (ptp->is_virtual_clock)\n+\t\treturn false;\n+\n+\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n+\t\treturn true;\n+\n+\tif (ptp->n_vclocks)\n+\t\tin_use = true;\n+\n+\tmutex_unlock(&ptp->n_vclocks_mux);\n+\n+\treturn in_use;\n }\n \n /* Check if ptp clock shall be free running */\ndiff --git a/include/linux/atmdev.h b/include/linux/atmdev.h\nindex 9b02961d65ee..45f2f278b50a 100644\n--- a/include/linux/atmdev.h\n+++ b/include/linux/atmdev.h\n@@ -249,6 +249,12 @@ static inline void atm_account_tx(struct atm_vcc *vcc, struct sk_buff *skb)\n \tATM_SKB(skb)->atm_options = vcc->atm_options;\n }\n \n+static inline void atm_return_tx(struct atm_vcc *vcc, struct sk_buff *skb)\n+{\n+\tWARN_ON_ONCE(refcount_sub_and_test(ATM_SKB(skb)->acct_truesize,\n+\t\t\t\t\t   &sk_atm(vcc)->sk_wmem_alloc));\n+}\n+\n static inline void atm_force_charge(struct atm_vcc *vcc,int truesize)\n {\n \tatomic_add(truesize, &sk_atm(vcc)->sk_rmem_alloc);\ndiff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h\nindex ce377f7fb912..22f39e5e2ff1 100644\n--- a/include/linux/ieee80211.h\n+++ b/include/linux/ieee80211.h\n@@ -1278,7 +1278,7 @@ struct ieee80211_ext {\n \t\t\tu8 sa[ETH_ALEN];\n \t\t\t__le32 timestamp;\n \t\t\tu8 change_seq;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed s1g_beacon;\n \t} u;\n } __packed __aligned(2);\n@@ -1536,7 +1536,7 @@ struct ieee80211_mgmt {\n \t\t\t\t\tu8 action_code;\n \t\t\t\t\tu8 dialog_token;\n \t\t\t\t\t__le16 capability;\n-\t\t\t\t\tu8 variable[0];\n+\t\t\t\t\tu8 variable[];\n \t\t\t\t} __packed tdls_discover_resp;\n \t\t\t\tstruct {\n \t\t\t\t\tu8 action_code;\n@@ -1721,35 +1721,35 @@ struct ieee80211_tdls_data {\n \t\tstruct {\n \t\t\tu8 dialog_token;\n \t\t\t__le16 capability;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed setup_req;\n \t\tstruct {\n \t\t\t__le16 status_code;\n \t\t\tu8 dialog_token;\n \t\t\t__le16 capability;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed setup_resp;\n \t\tstruct {\n \t\t\t__le16 status_code;\n \t\t\tu8 dialog_token;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed setup_cfm;\n \t\tstruct {\n \t\t\t__le16 reason_code;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed teardown;\n \t\tstruct {\n \t\t\tu8 dialog_token;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed discover_req;\n \t\tstruct {\n \t\t\tu8 target_channel;\n \t\t\tu8 oper_class;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed chan_switch_req;\n \t\tstruct {\n \t\t\t__le16 status_code;\n-\t\t\tu8 variable[0];\n+\t\t\tu8 variable[];\n \t\t} __packed chan_switch_resp;\n \t} u;\n } __packed;\ndiff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h\nindex 9ff72cfb2e98..09a75bdb6560 100644\n--- a/include/uapi/linux/ethtool_netlink.h\n+++ b/include/uapi/linux/ethtool_netlink.h\n@@ -208,10 +208,6 @@ enum {\n \tETHTOOL_A_STATS_PHY_MAX = (__ETHTOOL_A_STATS_PHY_CNT - 1)\n };\n \n-/* generic netlink info */\n-#define ETHTOOL_GENL_NAME \"ethtool\"\n-#define ETHTOOL_GENL_VERSION 1\n-\n #define ETHTOOL_MCGRP_MONITOR_NAME \"monitor\"\n \n #endif /* _UAPI_LINUX_ETHTOOL_NETLINK_H_ */\ndiff --git a/include/uapi/linux/ethtool_netlink_generated.h b/include/uapi/linux/ethtool_netlink_generated.h\nindex 9a02f579de22..aa8ab5227c1e 100644\n--- a/include/uapi/linux/ethtool_netlink_generated.h\n+++ b/include/uapi/linux/ethtool_netlink_generated.h\n@@ -6,8 +6,8 @@\n #ifndef _UAPI_LINUX_ETHTOOL_NETLINK_GENERATED_H\n #define _UAPI_LINUX_ETHTOOL_NETLINK_GENERATED_H\n \n-#define ETHTOOL_FAMILY_NAME\t\"ethtool\"\n-#define ETHTOOL_FAMILY_VERSION\t1\n+#define ETHTOOL_GENL_NAME\t\"ethtool\"\n+#define ETHTOOL_GENL_VERSION\t1\n \n enum {\n \tETHTOOL_UDP_TUNNEL_TYPE_VXLAN,\ndiff --git a/lib/Kconfig b/lib/Kconfig\nindex 6c1b8f184267..37db228f70a9 100644\n--- a/lib/Kconfig\n+++ b/lib/Kconfig\n@@ -716,6 +716,7 @@ config GENERIC_LIB_DEVMEM_IS_ALLOWED\n \n config PLDMFW\n \tbool\n+\tselect CRC32\n \tdefault n\n \n config ASN1_ENCODER\ndiff --git a/net/atm/common.c b/net/atm/common.c\nindex 9b75699992ff..d7f7976ea13a 100644\n--- a/net/atm/common.c\n+++ b/net/atm/common.c\n@@ -635,6 +635,7 @@ int vcc_sendmsg(struct socket *sock, struct msghdr *m, size_t size)\n \n \tskb->dev = NULL; /* for paths shared with net_device interfaces */\n \tif (!copy_from_iter_full(skb_put(skb, size), size, &m->msg_iter)) {\n+\t\tatm_return_tx(vcc, skb);\n \t\tkfree_skb(skb);\n \t\terror = -EFAULT;\n \t\tgoto out;\ndiff --git a/net/atm/lec.c b/net/atm/lec.c\nindex acef984f3367..afb8d3eb2185 100644\n--- a/net/atm/lec.c\n+++ b/net/atm/lec.c\n@@ -124,6 +124,7 @@ static unsigned char bus_mac[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n \n /* Device structures */\n static struct net_device *dev_lec[MAX_LEC_ITF];\n+static DEFINE_MUTEX(lec_mutex);\n \n #if IS_ENABLED(CONFIG_BRIDGE)\n static void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)\n@@ -685,6 +686,7 @@ static int lec_vcc_attach(struct atm_vcc *vcc, void __user *arg)\n \tint bytes_left;\n \tstruct atmlec_ioc ioc_data;\n \n+\tlockdep_assert_held(&lec_mutex);\n \t/* Lecd must be up in this case */\n \tbytes_left = copy_from_user(&ioc_data, arg, sizeof(struct atmlec_ioc));\n \tif (bytes_left != 0)\n@@ -710,6 +712,7 @@ static int lec_vcc_attach(struct atm_vcc *vcc, void __user *arg)\n \n static int lec_mcast_attach(struct atm_vcc *vcc, int arg)\n {\n+\tlockdep_assert_held(&lec_mutex);\n \tif (arg < 0 || arg >= MAX_LEC_ITF)\n \t\treturn -EINVAL;\n \targ = array_index_nospec(arg, MAX_LEC_ITF);\n@@ -725,6 +728,7 @@ static int lecd_attach(struct atm_vcc *vcc, int arg)\n \tint i;\n \tstruct lec_priv *priv;\n \n+\tlockdep_assert_held(&lec_mutex);\n \tif (arg < 0)\n \t\targ = 0;\n \tif (arg >= MAX_LEC_ITF)\n@@ -742,6 +746,7 @@ static int lecd_attach(struct atm_vcc *vcc, int arg)\n \t\tsnprintf(dev_lec[i]->name, IFNAMSIZ, \"lec%d\", i);\n \t\tif (register_netdev(dev_lec[i])) {\n \t\t\tfree_netdev(dev_lec[i]);\n+\t\t\tdev_lec[i] = NULL;\n \t\t\treturn -EINVAL;\n \t\t}\n \n@@ -904,7 +909,6 @@ static void *lec_itf_walk(struct lec_state *state, loff_t *l)\n \tv = (dev && netdev_priv(dev)) ?\n \t\tlec_priv_walk(state, l, netdev_priv(dev)) : NULL;\n \tif (!v && dev) {\n-\t\tdev_put(dev);\n \t\t/* Partial state reset for the next time we get called */\n \t\tdev = NULL;\n \t}\n@@ -928,6 +932,7 @@ static void *lec_seq_start(struct seq_file *seq, loff_t *pos)\n {\n \tstruct lec_state *state = seq->private;\n \n+\tmutex_lock(&lec_mutex);\n \tstate->itf = 0;\n \tstate->dev = NULL;\n \tstate->locked = NULL;\n@@ -945,8 +950,9 @@ static void lec_seq_stop(struct seq_file *seq, void *v)\n \tif (state->dev) {\n \t\tspin_unlock_irqrestore(&state->locked->lec_arp_lock,\n \t\t\t\t       state->flags);\n-\t\tdev_put(state->dev);\n+\t\tstate->dev = NULL;\n \t}\n+\tmutex_unlock(&lec_mutex);\n }\n \n static void *lec_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n@@ -1003,6 +1009,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n \t\treturn -ENOIOCTLCMD;\n \t}\n \n+\tmutex_lock(&lec_mutex);\n \tswitch (cmd) {\n \tcase ATMLEC_CTRL:\n \t\terr = lecd_attach(vcc, (int)arg);\n@@ -1017,6 +1024,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n \t\tbreak;\n \t}\n \n+\tmutex_unlock(&lec_mutex);\n \treturn err;\n }\n \ndiff --git a/net/atm/raw.c b/net/atm/raw.c\nindex 2b5f78a7ec3e..1e6511ec842c 100644\n--- a/net/atm/raw.c\n+++ b/net/atm/raw.c\n@@ -36,7 +36,7 @@ static void atm_pop_raw(struct atm_vcc *vcc, struct sk_buff *skb)\n \n \tpr_debug(\"(%d) %d -= %d\\n\",\n \t\t vcc->vci, sk_wmem_alloc_get(sk), ATM_SKB(skb)->acct_truesize);\n-\tWARN_ON(refcount_sub_and_test(ATM_SKB(skb)->acct_truesize, &sk->sk_wmem_alloc));\n+\tatm_return_tx(vcc, skb);\n \tdev_kfree_skb_any(skb);\n \tsk->sk_write_space(sk);\n }\ndiff --git a/net/core/skbuff.c b/net/core/skbuff.c\nindex 85fc82f72d26..d6420b74ea9c 100644\n--- a/net/core/skbuff.c\n+++ b/net/core/skbuff.c\n@@ -6261,9 +6261,6 @@ int skb_ensure_writable(struct sk_buff *skb, unsigned int write_len)\n \tif (!pskb_may_pull(skb, write_len))\n \t\treturn -ENOMEM;\n \n-\tif (!skb_frags_readable(skb))\n-\t\treturn -EFAULT;\n-\n \tif (!skb_cloned(skb) || skb_clone_writable(skb, write_len))\n \t\treturn 0;\n \ndiff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c\nindex 9b83d639b5ac..5107121c5e37 100644\n--- a/net/ipv4/tcp_fastopen.c\n+++ b/net/ipv4/tcp_fastopen.c\n@@ -3,6 +3,7 @@\n #include <linux/tcp.h>\n #include <linux/rcupdate.h>\n #include <net/tcp.h>\n+#include <net/busy_poll.h>\n \n void tcp_fastopen_init_key_once(struct net *net)\n {\n@@ -279,6 +280,8 @@ static struct sock *tcp_fastopen_create_child(struct sock *sk,\n \n \trefcount_set(&req->rsk_refcnt, 2);\n \n+\tsk_mark_napi_id_set(child, skb);\n+\n \t/* Now finish processing the fastopen child socket. */\n \ttcp_init_transfer(child, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB, skb);\n \ndiff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c\nindex 8ec92dec321a..12c2e6fc85c6 100644\n--- a/net/ipv4/tcp_input.c\n+++ b/net/ipv4/tcp_input.c\n@@ -2479,20 +2479,33 @@ static inline bool tcp_packet_delayed(const struct tcp_sock *tp)\n {\n \tconst struct sock *sk = (const struct sock *)tp;\n \n-\tif (tp->retrans_stamp &&\n-\t    tcp_tsopt_ecr_before(tp, tp->retrans_stamp))\n-\t\treturn true;  /* got echoed TS before first retransmission */\n-\n-\t/* Check if nothing was retransmitted (retrans_stamp==0), which may\n-\t * happen in fast recovery due to TSQ. But we ignore zero retrans_stamp\n-\t * in TCP_SYN_SENT, since when we set FLAG_SYN_ACKED we also clear\n-\t * retrans_stamp even if we had retransmitted the SYN.\n+\t/* Received an echoed timestamp before the first retransmission? */\n+\tif (tp->retrans_stamp)\n+\t\treturn tcp_tsopt_ecr_before(tp, tp->retrans_stamp);\n+\n+\t/* We set tp->retrans_stamp upon the first retransmission of a loss\n+\t * recovery episode, so normally if tp->retrans_stamp is 0 then no\n+\t * retransmission has happened yet (likely due to TSQ, which can cause\n+\t * fast retransmits to be delayed). So if snd_una advanced while\n+\t * (tp->retrans_stamp is 0 then apparently a packet was merely delayed,\n+\t * not lost. But there are exceptions where we retransmit but then\n+\t * clear tp->retrans_stamp, so we check for those exceptions.\n \t */\n-\tif (!tp->retrans_stamp &&\t   /* no record of a retransmit/SYN? */\n-\t    sk->sk_state != TCP_SYN_SENT)  /* not the FLAG_SYN_ACKED case? */\n-\t\treturn true;  /* nothing was retransmitted */\n \n-\treturn false;\n+\t/* (1) For non-SACK connections, tcp_is_non_sack_preventing_reopen()\n+\t * clears tp->retrans_stamp when snd_una == high_seq.\n+\t */\n+\tif (!tcp_is_sack(tp) && !before(tp->snd_una, tp->high_seq))\n+\t\treturn false;\n+\n+\t/* (2) In TCP_SYN_SENT tcp_clean_rtx_queue() clears tp->retrans_stamp\n+\t * when setting FLAG_SYN_ACKED is set, even if the SYN was\n+\t * retransmitted.\n+\t */\n+\tif (sk->sk_state == TCP_SYN_SENT)\n+\t\treturn false;\n+\n+\treturn true;\t/* tp->retrans_stamp is zero; no retransmit yet */\n }\n \n /* Undo procedures. */\ndiff --git a/net/ipv6/calipso.c b/net/ipv6/calipso.c\nindex 62618a058b8f..a247bb93908b 100644\n--- a/net/ipv6/calipso.c\n+++ b/net/ipv6/calipso.c\n@@ -1207,6 +1207,10 @@ static int calipso_req_setattr(struct request_sock *req,\n \tstruct ipv6_opt_hdr *old, *new;\n \tstruct sock *sk = sk_to_full_sk(req_to_sk(req));\n \n+\t/* sk is NULL for SYN+ACK w/ SYN Cookie */\n+\tif (!sk)\n+\t\treturn -ENOMEM;\n+\n \tif (req_inet->ipv6_opt && req_inet->ipv6_opt->hopopt)\n \t\told = req_inet->ipv6_opt->hopopt;\n \telse\n@@ -1247,6 +1251,10 @@ static void calipso_req_delattr(struct request_sock *req)\n \tstruct ipv6_txoptions *txopts;\n \tstruct sock *sk = sk_to_full_sk(req_to_sk(req));\n \n+\t/* sk is NULL for SYN+ACK w/ SYN Cookie */\n+\tif (!sk)\n+\t\treturn;\n+\n \tif (!req_inet->ipv6_opt || !req_inet->ipv6_opt->hopopt)\n \t\treturn;\n \ndiff --git a/net/mac80211/debug.h b/net/mac80211/debug.h\nindex 5b81998cb0c9..ef7c1a68d88d 100644\n--- a/net/mac80211/debug.h\n+++ b/net/mac80211/debug.h\n@@ -1,10 +1,11 @@\n /* SPDX-License-Identifier: GPL-2.0 */\n /*\n  * Portions\n- * Copyright (C) 2022 - 2024 Intel Corporation\n+ * Copyright (C) 2022 - 2025 Intel Corporation\n  */\n #ifndef __MAC80211_DEBUG_H\n #define __MAC80211_DEBUG_H\n+#include <linux/once_lite.h>\n #include <net/cfg80211.h>\n \n #ifdef CONFIG_MAC80211_OCB_DEBUG\n@@ -152,6 +153,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\telse\t\t\t\t\t\t\t\\\n \t\t\t_sdata_err((link)->sdata, fmt, ##__VA_ARGS__);\t\\\n \t} while (0)\n+#define link_err_once(link, fmt, ...)\t\t\t\t\t\\\n+\tDO_ONCE_LITE(link_err, link, fmt, ##__VA_ARGS__)\n #define link_id_info(sdata, link_id, fmt, ...)\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n \t\tif (ieee80211_vif_is_mld(&sdata->vif))\t\t\t\\\ndiff --git a/net/mac80211/rx.c b/net/mac80211/rx.c\nindex 09beb65d6108..e73431549ce7 100644\n--- a/net/mac80211/rx.c\n+++ b/net/mac80211/rx.c\n@@ -4432,6 +4432,10 @@ static bool ieee80211_accept_frame(struct ieee80211_rx_data *rx)\n \t\tif (!multicast &&\n \t\t    !ether_addr_equal(sdata->dev->dev_addr, hdr->addr1))\n \t\t\treturn false;\n+\t\t/* reject invalid/our STA address */\n+\t\tif (!is_valid_ether_addr(hdr->addr2) ||\n+\t\t    ether_addr_equal(sdata->dev->dev_addr, hdr->addr2))\n+\t\t\treturn false;\n \t\tif (!rx->sta) {\n \t\t\tint rate_idx;\n \t\t\tif (status->encoding != RX_ENC_LEGACY)\ndiff --git a/net/mac80211/tx.c b/net/mac80211/tx.c\nindex d8d4f3d7d7f2..d58b80813bdd 100644\n--- a/net/mac80211/tx.c\n+++ b/net/mac80211/tx.c\n@@ -5,7 +5,7 @@\n  * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n  * Copyright 2007\tJohannes Berg <johannes@sipsolutions.net>\n  * Copyright 2013-2014  Intel Mobile Communications GmbH\n- * Copyright (C) 2018-2024 Intel Corporation\n+ * Copyright (C) 2018-2025 Intel Corporation\n  *\n  * Transmit and frame generation functions.\n  */\n@@ -5016,12 +5016,25 @@ static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,\n \t}\n }\n \n-static u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)\n+static u8 __ieee80211_beacon_update_cntdwn(struct ieee80211_link_data *link,\n+\t\t\t\t\t   struct beacon_data *beacon)\n {\n-\tbeacon->cntdwn_current_counter--;\n+\tif (beacon->cntdwn_current_counter == 1) {\n+\t\t/*\n+\t\t * Channel switch handling is done by a worker thread while\n+\t\t * beacons get pulled from hardware timers. It's therefore\n+\t\t * possible that software threads are slow enough to not be\n+\t\t * able to complete CSA handling in a single beacon interval,\n+\t\t * in which case we get here. There isn't much to do about\n+\t\t * it, other than letting the user know that the AP isn't\n+\t\t * behaving correctly.\n+\t\t */\n+\t\tlink_err_once(link,\n+\t\t\t      \"beacon TX faster than countdown (channel/color switch) completion\\n\");\n+\t\treturn 0;\n+\t}\n \n-\t/* the counter should never reach 0 */\n-\tWARN_ON_ONCE(!beacon->cntdwn_current_counter);\n+\tbeacon->cntdwn_current_counter--;\n \n \treturn beacon->cntdwn_current_counter;\n }\n@@ -5052,7 +5065,7 @@ u8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif, unsigned int link_i\n \tif (!beacon)\n \t\tgoto unlock;\n \n-\tcount = __ieee80211_beacon_update_cntdwn(beacon);\n+\tcount = __ieee80211_beacon_update_cntdwn(link, beacon);\n \n unlock:\n \trcu_read_unlock();\n@@ -5450,7 +5463,7 @@ __ieee80211_beacon_get(struct ieee80211_hw *hw,\n \n \t\tif (beacon->cntdwn_counter_offsets[0]) {\n \t\t\tif (!is_template)\n-\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n+\t\t\t\t__ieee80211_beacon_update_cntdwn(link, beacon);\n \n \t\t\tieee80211_set_beacon_cntdwn(sdata, beacon, link);\n \t\t}\n@@ -5482,7 +5495,7 @@ __ieee80211_beacon_get(struct ieee80211_hw *hw,\n \t\t\t\t * for now we leave it consistent with overall\n \t\t\t\t * mac80211's behavior.\n \t\t\t\t */\n-\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n+\t\t\t\t__ieee80211_beacon_update_cntdwn(link, beacon);\n \n \t\t\tieee80211_set_beacon_cntdwn(sdata, beacon, link);\n \t\t}\ndiff --git a/net/mpls/af_mpls.c b/net/mpls/af_mpls.c\nindex d536c97144e9..47d7dfd9ad09 100644\n--- a/net/mpls/af_mpls.c\n+++ b/net/mpls/af_mpls.c\n@@ -81,8 +81,8 @@ static struct mpls_route *mpls_route_input_rcu(struct net *net, unsigned index)\n \n \tif (index < net->mpls.platform_labels) {\n \t\tstruct mpls_route __rcu **platform_label =\n-\t\t\trcu_dereference(net->mpls.platform_label);\n-\t\trt = rcu_dereference(platform_label[index]);\n+\t\t\trcu_dereference_rtnl(net->mpls.platform_label);\n+\t\trt = rcu_dereference_rtnl(platform_label[index]);\n \t}\n \treturn rt;\n }\ndiff --git a/net/nfc/nci/uart.c b/net/nfc/nci/uart.c\nindex ed1508a9e093..aab107727f18 100644\n--- a/net/nfc/nci/uart.c\n+++ b/net/nfc/nci/uart.c\n@@ -119,22 +119,22 @@ static int nci_uart_set_driver(struct tty_struct *tty, unsigned int driver)\n \n \tmemcpy(nu, nci_uart_drivers[driver], sizeof(struct nci_uart));\n \tnu->tty = tty;\n-\ttty->disc_data = nu;\n \tskb_queue_head_init(&nu->tx_q);\n \tINIT_WORK(&nu->write_work, nci_uart_write_work);\n \tspin_lock_init(&nu->rx_lock);\n \n \tret = nu->ops.open(nu);\n \tif (ret) {\n-\t\ttty->disc_data = NULL;\n \t\tkfree(nu);\n+\t\treturn ret;\n \t} else if (!try_module_get(nu->owner)) {\n \t\tnu->ops.close(nu);\n-\t\ttty->disc_data = NULL;\n \t\tkfree(nu);\n \t\treturn -ENOENT;\n \t}\n-\treturn ret;\n+\ttty->disc_data = nu;\n+\n+\treturn 0;\n }\n \n /* ------ LDISC part ------ */\ndiff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c\nindex e7269a3eec79..3add108340bf 100644\n--- a/net/openvswitch/actions.c\n+++ b/net/openvswitch/actions.c\n@@ -39,16 +39,14 @@\n #include \"flow_netlink.h\"\n #include \"openvswitch_trace.h\"\n \n-DEFINE_PER_CPU(struct ovs_pcpu_storage, ovs_pcpu_storage) = {\n-\t.bh_lock = INIT_LOCAL_LOCK(bh_lock),\n-};\n+struct ovs_pcpu_storage __percpu *ovs_pcpu_storage;\n \n /* Make a clone of the 'key', using the pre-allocated percpu 'flow_keys'\n  * space. Return NULL if out of key spaces.\n  */\n static struct sw_flow_key *clone_key(const struct sw_flow_key *key_)\n {\n-\tstruct ovs_pcpu_storage *ovs_pcpu = this_cpu_ptr(&ovs_pcpu_storage);\n+\tstruct ovs_pcpu_storage *ovs_pcpu = this_cpu_ptr(ovs_pcpu_storage);\n \tstruct action_flow_keys *keys = &ovs_pcpu->flow_keys;\n \tint level = ovs_pcpu->exec_level;\n \tstruct sw_flow_key *key = NULL;\n@@ -94,7 +92,7 @@ static struct deferred_action *add_deferred_actions(struct sk_buff *skb,\n \t\t\t\t    const struct nlattr *actions,\n \t\t\t\t    const int actions_len)\n {\n-\tstruct action_fifo *fifo = this_cpu_ptr(&ovs_pcpu_storage.action_fifos);\n+\tstruct action_fifo *fifo = this_cpu_ptr(&ovs_pcpu_storage->action_fifos);\n \tstruct deferred_action *da;\n \n \tda = action_fifo_put(fifo);\n@@ -755,7 +753,7 @@ static int set_sctp(struct sk_buff *skb, struct sw_flow_key *flow_key,\n static int ovs_vport_output(struct net *net, struct sock *sk,\n \t\t\t    struct sk_buff *skb)\n {\n-\tstruct ovs_frag_data *data = this_cpu_ptr(&ovs_pcpu_storage.frag_data);\n+\tstruct ovs_frag_data *data = this_cpu_ptr(&ovs_pcpu_storage->frag_data);\n \tstruct vport *vport = data->vport;\n \n \tif (skb_cow_head(skb, data->l2_len) < 0) {\n@@ -807,7 +805,7 @@ static void prepare_frag(struct vport *vport, struct sk_buff *skb,\n \tunsigned int hlen = skb_network_offset(skb);\n \tstruct ovs_frag_data *data;\n \n-\tdata = this_cpu_ptr(&ovs_pcpu_storage.frag_data);\n+\tdata = this_cpu_ptr(&ovs_pcpu_storage->frag_data);\n \tdata->dst = skb->_skb_refdst;\n \tdata->vport = vport;\n \tdata->cb = *OVS_CB(skb);\n@@ -1566,16 +1564,15 @@ static int clone_execute(struct datapath *dp, struct sk_buff *skb,\n \tclone = clone_flow_key ? clone_key(key) : key;\n \tif (clone) {\n \t\tint err = 0;\n-\n \t\tif (actions) { /* Sample action */\n \t\t\tif (clone_flow_key)\n-\t\t\t\t__this_cpu_inc(ovs_pcpu_storage.exec_level);\n+\t\t\t\t__this_cpu_inc(ovs_pcpu_storage->exec_level);\n \n \t\t\terr = do_execute_actions(dp, skb, clone,\n \t\t\t\t\t\t actions, len);\n \n \t\t\tif (clone_flow_key)\n-\t\t\t\t__this_cpu_dec(ovs_pcpu_storage.exec_level);\n+\t\t\t\t__this_cpu_dec(ovs_pcpu_storage->exec_level);\n \t\t} else { /* Recirc action */\n \t\t\tclone->recirc_id = recirc_id;\n \t\t\tovs_dp_process_packet(skb, clone);\n@@ -1611,7 +1608,7 @@ static int clone_execute(struct datapath *dp, struct sk_buff *skb,\n \n static void process_deferred_actions(struct datapath *dp)\n {\n-\tstruct action_fifo *fifo = this_cpu_ptr(&ovs_pcpu_storage.action_fifos);\n+\tstruct action_fifo *fifo = this_cpu_ptr(&ovs_pcpu_storage->action_fifos);\n \n \t/* Do not touch the FIFO in case there is no deferred actions. */\n \tif (action_fifo_is_empty(fifo))\n@@ -1642,7 +1639,7 @@ int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\n {\n \tint err, level;\n \n-\tlevel = __this_cpu_inc_return(ovs_pcpu_storage.exec_level);\n+\tlevel = __this_cpu_inc_return(ovs_pcpu_storage->exec_level);\n \tif (unlikely(level > OVS_RECURSION_LIMIT)) {\n \t\tnet_crit_ratelimited(\"ovs: recursion limit reached on datapath %s, probable configuration error\\n\",\n \t\t\t\t     ovs_dp_name(dp));\n@@ -1659,6 +1656,6 @@ int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\n \t\tprocess_deferred_actions(dp);\n \n out:\n-\t__this_cpu_dec(ovs_pcpu_storage.exec_level);\n+\t__this_cpu_dec(ovs_pcpu_storage->exec_level);\n \treturn err;\n }\ndiff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c\nindex 6a304ae2d959..b990dc83504f 100644\n--- a/net/openvswitch/datapath.c\n+++ b/net/openvswitch/datapath.c\n@@ -244,7 +244,7 @@ void ovs_dp_detach_port(struct vport *p)\n /* Must be called with rcu_read_lock. */\n void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)\n {\n-\tstruct ovs_pcpu_storage *ovs_pcpu = this_cpu_ptr(&ovs_pcpu_storage);\n+\tstruct ovs_pcpu_storage *ovs_pcpu = this_cpu_ptr(ovs_pcpu_storage);\n \tconst struct vport *p = OVS_CB(skb)->input_vport;\n \tstruct datapath *dp = p->dp;\n \tstruct sw_flow *flow;\n@@ -299,7 +299,7 @@ void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)\n \t * avoided.\n \t */\n \tif (IS_ENABLED(CONFIG_PREEMPT_RT) && ovs_pcpu->owner != current) {\n-\t\tlocal_lock_nested_bh(&ovs_pcpu_storage.bh_lock);\n+\t\tlocal_lock_nested_bh(&ovs_pcpu_storage->bh_lock);\n \t\tovs_pcpu->owner = current;\n \t\tovs_pcpu_locked = true;\n \t}\n@@ -310,7 +310,7 @@ void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)\n \t\t\t\t    ovs_dp_name(dp), error);\n \tif (ovs_pcpu_locked) {\n \t\tovs_pcpu->owner = NULL;\n-\t\tlocal_unlock_nested_bh(&ovs_pcpu_storage.bh_lock);\n+\t\tlocal_unlock_nested_bh(&ovs_pcpu_storage->bh_lock);\n \t}\n \n \tstats_counter = &stats->n_hit;\n@@ -689,13 +689,13 @@ static int ovs_packet_cmd_execute(struct sk_buff *skb, struct genl_info *info)\n \tsf_acts = rcu_dereference(flow->sf_acts);\n \n \tlocal_bh_disable();\n-\tlocal_lock_nested_bh(&ovs_pcpu_storage.bh_lock);\n+\tlocal_lock_nested_bh(&ovs_pcpu_storage->bh_lock);\n \tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n-\t\tthis_cpu_write(ovs_pcpu_storage.owner, current);\n+\t\tthis_cpu_write(ovs_pcpu_storage->owner, current);\n \terr = ovs_execute_actions(dp, packet, sf_acts, &flow->key);\n \tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n-\t\tthis_cpu_write(ovs_pcpu_storage.owner, NULL);\n-\tlocal_unlock_nested_bh(&ovs_pcpu_storage.bh_lock);\n+\t\tthis_cpu_write(ovs_pcpu_storage->owner, NULL);\n+\tlocal_unlock_nested_bh(&ovs_pcpu_storage->bh_lock);\n \tlocal_bh_enable();\n \trcu_read_unlock();\n \n@@ -2744,6 +2744,28 @@ static struct drop_reason_list drop_reason_list_ovs = {\n \t.n_reasons = ARRAY_SIZE(ovs_drop_reasons),\n };\n \n+static int __init ovs_alloc_percpu_storage(void)\n+{\n+\tunsigned int cpu;\n+\n+\tovs_pcpu_storage = alloc_percpu(*ovs_pcpu_storage);\n+\tif (!ovs_pcpu_storage)\n+\t\treturn -ENOMEM;\n+\n+\tfor_each_possible_cpu(cpu) {\n+\t\tstruct ovs_pcpu_storage *ovs_pcpu;\n+\n+\t\tovs_pcpu = per_cpu_ptr(ovs_pcpu_storage, cpu);\n+\t\tlocal_lock_init(&ovs_pcpu->bh_lock);\n+\t}\n+\treturn 0;\n+}\n+\n+static void ovs_free_percpu_storage(void)\n+{\n+\tfree_percpu(ovs_pcpu_storage);\n+}\n+\n static int __init dp_init(void)\n {\n \tint err;\n@@ -2753,6 +2775,10 @@ static int __init dp_init(void)\n \n \tpr_info(\"Open vSwitch switching datapath\\n\");\n \n+\terr = ovs_alloc_percpu_storage();\n+\tif (err)\n+\t\tgoto error;\n+\n \terr = ovs_internal_dev_rtnl_link_register();\n \tif (err)\n \t\tgoto error;\n@@ -2799,6 +2825,7 @@ static int __init dp_init(void)\n error_unreg_rtnl_link:\n \tovs_internal_dev_rtnl_link_unregister();\n error:\n+\tovs_free_percpu_storage();\n \treturn err;\n }\n \n@@ -2813,6 +2840,7 @@ static void dp_cleanup(void)\n \tovs_vport_exit();\n \tovs_flow_exit();\n \tovs_internal_dev_rtnl_link_unregister();\n+\tovs_free_percpu_storage();\n }\n \n module_init(dp_init);\ndiff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h\nindex 1b5348b0f559..cfeb817a1889 100644\n--- a/net/openvswitch/datapath.h\n+++ b/net/openvswitch/datapath.h\n@@ -220,7 +220,8 @@ struct ovs_pcpu_storage {\n \tstruct task_struct *owner;\n \tlocal_lock_t bh_lock;\n };\n-DECLARE_PER_CPU(struct ovs_pcpu_storage, ovs_pcpu_storage);\n+\n+extern struct ovs_pcpu_storage __percpu *ovs_pcpu_storage;\n \n /**\n  * enum ovs_pkt_hash_types - hash info to include with a packet\ndiff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c\nindex 14021b812329..2b14c81a87e5 100644\n--- a/net/sched/sch_taprio.c\n+++ b/net/sched/sch_taprio.c\n@@ -1328,13 +1328,15 @@ static int taprio_dev_notifier(struct notifier_block *nb, unsigned long event,\n \n \t\tstab = rtnl_dereference(q->root->stab);\n \n-\t\toper = rtnl_dereference(q->oper_sched);\n+\t\trcu_read_lock();\n+\t\toper = rcu_dereference(q->oper_sched);\n \t\tif (oper)\n \t\t\ttaprio_update_queue_max_sdu(q, oper, stab);\n \n-\t\tadmin = rtnl_dereference(q->admin_sched);\n+\t\tadmin = rcu_dereference(q->admin_sched);\n \t\tif (admin)\n \t\t\ttaprio_update_queue_max_sdu(q, admin, stab);\n+\t\trcu_read_unlock();\n \n \t\tbreak;\n \t}\ndiff --git a/net/tipc/udp_media.c b/net/tipc/udp_media.c\nindex 108a4cc2e001..258d6aa4f21a 100644\n--- a/net/tipc/udp_media.c\n+++ b/net/tipc/udp_media.c\n@@ -489,7 +489,7 @@ int tipc_udp_nl_dump_remoteip(struct sk_buff *skb, struct netlink_callback *cb)\n \n \t\trtnl_lock();\n \t\tb = tipc_bearer_find(net, bname);\n-\t\tif (!b) {\n+\t\tif (!b || b->bcast_addr.media_id != TIPC_MEDIA_TYPE_UDP) {\n \t\t\trtnl_unlock();\n \t\t\treturn -EINVAL;\n \t\t}\n@@ -500,7 +500,7 @@ int tipc_udp_nl_dump_remoteip(struct sk_buff *skb, struct netlink_callback *cb)\n \n \t\trtnl_lock();\n \t\tb = rtnl_dereference(tn->bearer_list[bid]);\n-\t\tif (!b) {\n+\t\tif (!b || b->bcast_addr.media_id != TIPC_MEDIA_TYPE_UDP) {\n \t\t\trtnl_unlock();\n \t\t\treturn -EINVAL;\n \t\t}\ndiff --git a/tools/net/ynl/pyynl/lib/ynl.py b/tools/net/ynl/pyynl/lib/ynl.py\nindex 55b59f6c79b8..61deb5923067 100644\n--- a/tools/net/ynl/pyynl/lib/ynl.py\n+++ b/tools/net/ynl/pyynl/lib/ynl.py\n@@ -231,14 +231,7 @@ class NlMsg:\n                     self.extack['unknown'].append(extack)\n \n             if attr_space:\n-                # We don't have the ability to parse nests yet, so only do global\n-                if 'miss-type' in self.extack and 'miss-nest' not in self.extack:\n-                    miss_type = self.extack['miss-type']\n-                    if miss_type in attr_space.attrs_by_val:\n-                        spec = attr_space.attrs_by_val[miss_type]\n-                        self.extack['miss-type'] = spec['name']\n-                        if 'doc' in spec:\n-                            self.extack['miss-type-doc'] = spec['doc']\n+                self.annotate_extack(attr_space)\n \n     def _decode_policy(self, raw):\n         policy = {}\n@@ -264,6 +257,18 @@ class NlMsg:\n                 policy['mask'] = attr.as_scalar('u64')\n         return policy\n \n+    def annotate_extack(self, attr_space):\n+        \"\"\" Make extack more human friendly with attribute information \"\"\"\n+\n+        # We don't have the ability to parse nests yet, so only do global\n+        if 'miss-type' in self.extack and 'miss-nest' not in self.extack:\n+            miss_type = self.extack['miss-type']\n+            if miss_type in attr_space.attrs_by_val:\n+                spec = attr_space.attrs_by_val[miss_type]\n+                self.extack['miss-type'] = spec['name']\n+                if 'doc' in spec:\n+                    self.extack['miss-type-doc'] = spec['doc']\n+\n     def cmd(self):\n         return self.nl_type\n \n@@ -277,12 +282,12 @@ class NlMsg:\n \n \n class NlMsgs:\n-    def __init__(self, data, attr_space=None):\n+    def __init__(self, data):\n         self.msgs = []\n \n         offset = 0\n         while offset < len(data):\n-            msg = NlMsg(data, offset, attr_space=attr_space)\n+            msg = NlMsg(data, offset)\n             offset += msg.nl_len\n             self.msgs.append(msg)\n \n@@ -1034,12 +1039,13 @@ class YnlFamily(SpecFamily):\n         op_rsp = []\n         while not done:\n             reply = self.sock.recv(self._recv_size)\n-            nms = NlMsgs(reply, attr_space=op.attr_set)\n+            nms = NlMsgs(reply)\n             self._recv_dbg_print(reply, nms)\n             for nl_msg in nms:\n                 if nl_msg.nl_seq in reqs_by_seq:\n                     (op, vals, req_msg, req_flags) = reqs_by_seq[nl_msg.nl_seq]\n                     if nl_msg.extack:\n+                        nl_msg.annotate_extack(op.attr_set)\n                         self._decode_extack(req_msg, op, nl_msg.extack, vals)\n                 else:\n                     op = None\ndiff --git a/tools/testing/selftests/drivers/net/netdevsim/peer.sh b/tools/testing/selftests/drivers/net/netdevsim/peer.sh\nindex 1bb46ec435d4..7f32b5600925 100755\n--- a/tools/testing/selftests/drivers/net/netdevsim/peer.sh\n+++ b/tools/testing/selftests/drivers/net/netdevsim/peer.sh\n@@ -1,7 +1,8 @@\n #!/bin/bash\n # SPDX-License-Identifier: GPL-2.0-only\n \n-source ../../../net/lib.sh\n+lib_dir=$(dirname $0)/../../../net\n+source $lib_dir/lib.sh\n \n NSIM_DEV_1_ID=$((256 + RANDOM % 256))\n NSIM_DEV_1_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_DEV_1_ID\ndiff --git a/tools/testing/selftests/net/.gitignore b/tools/testing/selftests/net/.gitignore\nindex 532bb732bc6d..c6dd2a335cf4 100644\n--- a/tools/testing/selftests/net/.gitignore\n+++ b/tools/testing/selftests/net/.gitignore\n@@ -50,6 +50,7 @@ tap\n tcp_fastopen_backup_key\n tcp_inq\n tcp_mmap\n+tfo\n timestamping\n tls\n toeplitz\ndiff --git a/tools/testing/selftests/net/Makefile b/tools/testing/selftests/net/Makefile\nindex ab996bd22a5f..332f387615d7 100644\n--- a/tools/testing/selftests/net/Makefile\n+++ b/tools/testing/selftests/net/Makefile\n@@ -110,6 +110,8 @@ TEST_GEN_PROGS += proc_net_pktgen\n TEST_PROGS += lwt_dst_cache_ref_loop.sh\n TEST_PROGS += skf_net_off.sh\n TEST_GEN_FILES += skf_net_off\n+TEST_GEN_FILES += tfo\n+TEST_PROGS += tfo_passive.sh\n \n # YNL files, must be before \"include ..lib.mk\"\n YNL_GEN_FILES := busy_poller netlink-dumps\ndiff --git a/tools/testing/selftests/net/tfo.c b/tools/testing/selftests/net/tfo.c\nnew file mode 100644\nindex 000000000000..eb3cac5e583c\n--- /dev/null\n+++ b/tools/testing/selftests/net/tfo.c\n@@ -0,0 +1,171 @@\n+// SPDX-License-Identifier: GPL-2.0\n+#include <error.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <arpa/inet.h>\n+#include <sys/socket.h>\n+#include <netinet/tcp.h>\n+#include <errno.h>\n+\n+static int cfg_server;\n+static int cfg_client;\n+static int cfg_port = 8000;\n+static struct sockaddr_in6 cfg_addr;\n+static char *cfg_outfile;\n+\n+static int parse_address(const char *str, int port, struct sockaddr_in6 *sin6)\n+{\n+\tint ret;\n+\n+\tsin6->sin6_family = AF_INET6;\n+\tsin6->sin6_port = htons(port);\n+\n+\tret = inet_pton(sin6->sin6_family, str, &sin6->sin6_addr);\n+\tif (ret != 1) {\n+\t\t/* fallback to plain IPv4 */\n+\t\tret = inet_pton(AF_INET, str, &sin6->sin6_addr.s6_addr32[3]);\n+\t\tif (ret != 1)\n+\t\t\treturn -1;\n+\n+\t\t/* add ::ffff prefix */\n+\t\tsin6->sin6_addr.s6_addr32[0] = 0;\n+\t\tsin6->sin6_addr.s6_addr32[1] = 0;\n+\t\tsin6->sin6_addr.s6_addr16[4] = 0;\n+\t\tsin6->sin6_addr.s6_addr16[5] = 0xffff;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static void run_server(void)\n+{\n+\tunsigned long qlen = 32;\n+\tint fd, opt, connfd;\n+\tsocklen_t len;\n+\tchar buf[64];\n+\tFILE *outfile;\n+\n+\toutfile = fopen(cfg_outfile, \"w\");\n+\tif (!outfile)\n+\t\terror(1, errno, \"fopen() outfile\");\n+\n+\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n+\tif (fd == -1)\n+\t\terror(1, errno, \"socket()\");\n+\n+\topt = 1;\n+\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)\n+\t\terror(1, errno, \"setsockopt(SO_REUSEADDR)\");\n+\n+\tif (setsockopt(fd, SOL_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen)) < 0)\n+\t\terror(1, errno, \"setsockopt(TCP_FASTOPEN)\");\n+\n+\tif (bind(fd, (struct sockaddr *)&cfg_addr, sizeof(cfg_addr)) < 0)\n+\t\terror(1, errno, \"bind()\");\n+\n+\tif (listen(fd, 5) < 0)\n+\t\terror(1, errno, \"listen()\");\n+\n+\tlen = sizeof(cfg_addr);\n+\tconnfd = accept(fd, (struct sockaddr *)&cfg_addr, &len);\n+\tif (connfd < 0)\n+\t\terror(1, errno, \"accept()\");\n+\n+\tlen = sizeof(opt);\n+\tif (getsockopt(connfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &opt, &len) < 0)\n+\t\terror(1, errno, \"getsockopt(SO_INCOMING_NAPI_ID)\");\n+\n+\tread(connfd, buf, 64);\n+\tfprintf(outfile, \"%d\\n\", opt);\n+\n+\tfclose(outfile);\n+\tclose(connfd);\n+\tclose(fd);\n+}\n+\n+static void run_client(void)\n+{\n+\tint fd;\n+\tchar *msg = \"Hello, world!\";\n+\n+\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n+\tif (fd == -1)\n+\t\terror(1, errno, \"socket()\");\n+\n+\tsendto(fd, msg, strlen(msg), MSG_FASTOPEN, (struct sockaddr *)&cfg_addr, sizeof(cfg_addr));\n+\n+\tclose(fd);\n+}\n+\n+static void usage(const char *filepath)\n+{\n+\terror(1, 0, \"Usage: %s (-s|-c) -h<server_ip> -p<port> -o<outfile> \", filepath);\n+}\n+\n+static void parse_opts(int argc, char **argv)\n+{\n+\tstruct sockaddr_in6 *addr6 = (void *) &cfg_addr;\n+\tchar *addr = NULL;\n+\tint ret;\n+\tint c;\n+\n+\tif (argc <= 1)\n+\t\tusage(argv[0]);\n+\n+\twhile ((c = getopt(argc, argv, \"sch:p:o:\")) != -1) {\n+\t\tswitch (c) {\n+\t\tcase 's':\n+\t\t\tif (cfg_client)\n+\t\t\t\terror(1, 0, \"Pass one of -s or -c\");\n+\t\t\tcfg_server = 1;\n+\t\t\tbreak;\n+\t\tcase 'c':\n+\t\t\tif (cfg_server)\n+\t\t\t\terror(1, 0, \"Pass one of -s or -c\");\n+\t\t\tcfg_client = 1;\n+\t\t\tbreak;\n+\t\tcase 'h':\n+\t\t\taddr = optarg;\n+\t\t\tbreak;\n+\t\tcase 'p':\n+\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n+\t\t\tbreak;\n+\t\tcase 'o':\n+\t\t\tcfg_outfile = strdup(optarg);\n+\t\t\tif (!cfg_outfile)\n+\t\t\t\terror(1, 0, \"outfile invalid\");\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (cfg_server && addr)\n+\t\terror(1, 0, \"Server cannot have -h specified\");\n+\n+\tmemset(addr6, 0, sizeof(*addr6));\n+\taddr6->sin6_family = AF_INET6;\n+\taddr6->sin6_port = htons(cfg_port);\n+\taddr6->sin6_addr = in6addr_any;\n+\tif (addr) {\n+\t\tret = parse_address(addr, cfg_port, addr6);\n+\t\tif (ret)\n+\t\t\terror(1, 0, \"Client address parse error: %s\", addr);\n+\t}\n+}\n+\n+int main(int argc, char **argv)\n+{\n+\tparse_opts(argc, argv);\n+\n+\tif (cfg_server)\n+\t\trun_server();\n+\telse if (cfg_client)\n+\t\trun_client();\n+\n+\treturn 0;\n+}\ndiff --git a/tools/testing/selftests/net/tfo_passive.sh b/tools/testing/selftests/net/tfo_passive.sh\nnew file mode 100755\nindex 000000000000..80bf11fdc046\n--- /dev/null\n+++ b/tools/testing/selftests/net/tfo_passive.sh\n@@ -0,0 +1,112 @@\n+#!/bin/bash\n+# SPDX-License-Identifier: GPL-2.0\n+source lib.sh\n+\n+NSIM_SV_ID=$((256 + RANDOM % 256))\n+NSIM_SV_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_SV_ID\n+NSIM_CL_ID=$((512 + RANDOM % 256))\n+NSIM_CL_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_CL_ID\n+\n+NSIM_DEV_SYS_NEW=/sys/bus/netdevsim/new_device\n+NSIM_DEV_SYS_DEL=/sys/bus/netdevsim/del_device\n+NSIM_DEV_SYS_LINK=/sys/bus/netdevsim/link_device\n+NSIM_DEV_SYS_UNLINK=/sys/bus/netdevsim/unlink_device\n+\n+SERVER_IP=192.168.1.1\n+CLIENT_IP=192.168.1.2\n+SERVER_PORT=48675\n+\n+setup_ns()\n+{\n+\tset -e\n+\tip netns add nssv\n+\tip netns add nscl\n+\n+\tNSIM_SV_NAME=$(find $NSIM_SV_SYS/net -maxdepth 1 -type d ! \\\n+\t\t-path $NSIM_SV_SYS/net -exec basename {} \\;)\n+\tNSIM_CL_NAME=$(find $NSIM_CL_SYS/net -maxdepth 1 -type d ! \\\n+\t\t-path $NSIM_CL_SYS/net -exec basename {} \\;)\n+\n+\tip link set $NSIM_SV_NAME netns nssv\n+\tip link set $NSIM_CL_NAME netns nscl\n+\n+\tip netns exec nssv ip addr add \"${SERVER_IP}/24\" dev $NSIM_SV_NAME\n+\tip netns exec nscl ip addr add \"${CLIENT_IP}/24\" dev $NSIM_CL_NAME\n+\n+\tip netns exec nssv ip link set dev $NSIM_SV_NAME up\n+\tip netns exec nscl ip link set dev $NSIM_CL_NAME up\n+\n+\t# Enable passive TFO\n+\tip netns exec nssv sysctl -w net.ipv4.tcp_fastopen=519 > /dev/null\n+\n+\tset +e\n+}\n+\n+cleanup_ns()\n+{\n+\tip netns del nscl\n+\tip netns del nssv\n+}\n+\n+###\n+### Code start\n+###\n+\n+modprobe netdevsim\n+\n+# linking\n+\n+echo $NSIM_SV_ID > $NSIM_DEV_SYS_NEW\n+echo $NSIM_CL_ID > $NSIM_DEV_SYS_NEW\n+udevadm settle\n+\n+setup_ns\n+\n+NSIM_SV_FD=$((256 + RANDOM % 256))\n+exec {NSIM_SV_FD}</var/run/netns/nssv\n+NSIM_SV_IFIDX=$(ip netns exec nssv cat /sys/class/net/$NSIM_SV_NAME/ifindex)\n+\n+NSIM_CL_FD=$((256 + RANDOM % 256))\n+exec {NSIM_CL_FD}</var/run/netns/nscl\n+NSIM_CL_IFIDX=$(ip netns exec nscl cat /sys/class/net/$NSIM_CL_NAME/ifindex)\n+\n+echo \"$NSIM_SV_FD:$NSIM_SV_IFIDX $NSIM_CL_FD:$NSIM_CL_IFIDX\" > \\\n+     $NSIM_DEV_SYS_LINK\n+\n+if [ $? -ne 0 ]; then\n+\techo \"linking netdevsim1 with netdevsim2 should succeed\"\n+\tcleanup_ns\n+\texit 1\n+fi\n+\n+out_file=$(mktemp)\n+\n+timeout -k 1s 30s ip netns exec nssv ./tfo        \\\n+\t\t\t\t-s                \\\n+\t\t\t\t-p ${SERVER_PORT} \\\n+\t\t\t\t-o ${out_file}&\n+\n+wait_local_port_listen nssv ${SERVER_PORT} tcp\n+\n+ip netns exec nscl ./tfo -c -h ${SERVER_IP} -p ${SERVER_PORT}\n+\n+wait\n+\n+res=$(cat $out_file)\n+rm $out_file\n+\n+if [ $res -eq 0 ]; then\n+\techo \"got invalid NAPI ID from passive TFO socket\"\n+\tcleanup_ns\n+\texit 1\n+fi\n+\n+echo \"$NSIM_SV_FD:$NSIM_SV_IFIDX\" > $NSIM_DEV_SYS_UNLINK\n+\n+echo $NSIM_CL_ID > $NSIM_DEV_SYS_DEL\n+\n+cleanup_ns\n+\n+modprobe -r netdevsim\n+\n+exit 0",
    "stats": {
      "insertions": 2091,
      "deletions": 288,
      "files": 64
    }
  },
  {
    "sha": "6463cbe08b0cbf9bba8763306764f5fd643023e1",
    "message": "mtd: spinand: fix memory leak of ECC engine conf\n\nMemory allocated for the ECC engine conf is not released during spinand\ncleanup. Below kmemleak trace is seen for this memory leak:\n\nunreferenced object 0xffffff80064f00e0 (size 8):\n  comm \"swapper/0\", pid 1, jiffies 4294937458\n  hex dump (first 8 bytes):\n    00 00 00 00 00 00 00 00                          ........\n  backtrace (crc 0):\n    kmemleak_alloc+0x30/0x40\n    __kmalloc_cache_noprof+0x208/0x3c0\n    spinand_ondie_ecc_init_ctx+0x114/0x200\n    nand_ecc_init_ctx+0x70/0xa8\n    nanddev_ecc_engine_init+0xec/0x27c\n    spinand_probe+0xa2c/0x1620\n    spi_mem_probe+0x130/0x21c\n    spi_probe+0xf0/0x170\n    really_probe+0x17c/0x6e8\n    __driver_probe_device+0x17c/0x21c\n    driver_probe_device+0x58/0x180\n    __device_attach_driver+0x15c/0x1f8\n    bus_for_each_drv+0xec/0x150\n    __device_attach+0x188/0x24c\n    device_initial_probe+0x10/0x20\n    bus_probe_device+0x11c/0x160\n\nFix the leak by calling nanddev_ecc_engine_cleanup() inside\nspinand_cleanup().\n\nSigned-off-by: Pablo Martin-Gomez <pmartin-gomez@freebox.fr>\nSigned-off-by: Miquel Raynal <miquel.raynal@bootlin.com>",
    "author": "Pablo Martin-Gomez",
    "date": "2025-06-19T19:13:21+02:00",
    "files_changed": [
      "drivers/mtd/nand/spi/core.c"
    ],
    "diff": "diff --git a/drivers/mtd/nand/spi/core.c b/drivers/mtd/nand/spi/core.c\nindex 7099db7a62be..c411fe9be3ef 100644\n--- a/drivers/mtd/nand/spi/core.c\n+++ b/drivers/mtd/nand/spi/core.c\n@@ -1585,6 +1585,7 @@ static void spinand_cleanup(struct spinand_device *spinand)\n {\n \tstruct nand_device *nand = spinand_to_nand(spinand);\n \n+\tnanddev_ecc_engine_cleanup(nand);\n \tnanddev_cleanup(nand);\n \tspinand_manufacturer_cleanup(spinand);\n \tkfree(spinand->databuf);",
    "stats": {
      "insertions": 1,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "b2348fe6c81cc92c7d0bd8a7d9241f8de0fa72b7",
    "message": "bcachefs: Fix *__bch2_trans_subbuf_alloc() error path\n\nDon't change buf->size on error - this would usually be a transaction\nrestart, but it could also be -ENOMEM - when we've exceeded the bump\nallocator max).\n\nFixes: 247abee6ae6d (\"bcachefs: btree_trans_subbuf\")\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>",
    "author": "Kent Overstreet",
    "date": "2025-06-19T13:08:06-04:00",
    "files_changed": [
      "fs/bcachefs/btree_update.c"
    ],
    "diff": "diff --git a/fs/bcachefs/btree_update.c b/fs/bcachefs/btree_update.c\nindex e97e78c10f49..ee657b9f4b96 100644\n--- a/fs/bcachefs/btree_update.c\n+++ b/fs/bcachefs/btree_update.c\n@@ -549,20 +549,26 @@ void *__bch2_trans_subbuf_alloc(struct btree_trans *trans,\n \t\t\t\tunsigned u64s)\n {\n \tunsigned new_top = buf->u64s + u64s;\n-\tunsigned old_size = buf->size;\n+\tunsigned new_size = buf->size;\n \n-\tif (new_top > buf->size)\n-\t\tbuf->size = roundup_pow_of_two(new_top);\n+\tBUG_ON(roundup_pow_of_two(new_top) > U16_MAX);\n \n-\tvoid *n = bch2_trans_kmalloc_nomemzero(trans, buf->size * sizeof(u64));\n+\tif (new_top > new_size)\n+\t\tnew_size = roundup_pow_of_two(new_top);\n+\n+\tvoid *n = bch2_trans_kmalloc_nomemzero(trans, new_size * sizeof(u64));\n \tif (IS_ERR(n))\n \t\treturn n;\n \n+\tunsigned offset = (u64 *) n - (u64 *) trans->mem;\n+\tBUG_ON(offset > U16_MAX);\n+\n \tif (buf->u64s)\n \t\tmemcpy(n,\n \t\t       btree_trans_subbuf_base(trans, buf),\n-\t\t       old_size * sizeof(u64));\n+\t\t       buf->size * sizeof(u64));\n \tbuf->base = (u64 *) n - (u64 *) trans->mem;\n+\tbuf->size = new_size;\n \n \tvoid *p = btree_trans_subbuf_top(trans, buf);\n \tbuf->u64s = new_top;",
    "stats": {
      "insertions": 11,
      "deletions": 5,
      "files": 1
    }
  }
]
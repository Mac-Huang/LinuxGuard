[
  {
    "sha": "ca46946a482238b0cdea459fb82fc837fb36260e",
    "message": "regulator: core: fix NULL dereference on unbind due to stale coupling data\n\nFailing to reset coupling_desc.n_coupled after freeing coupled_rdevs can\nlead to NULL pointer dereference when regulators are accessed post-unbind.\n\nThis can happen during runtime PM or other regulator operations that rely\non coupling metadata.\n\nFor example, on ridesx4, unbinding the 'reg-dummy' platform device triggers\na panic in regulator_lock_recursive() due to stale coupling state.\n\nEnsure n_coupled is set to 0 to prevent access to invalid pointers.\n\nSigned-off-by: Alessandro Carminati <acarmina@redhat.com>\nLink: https://patch.msgid.link/20250626083809.314842-1-acarmina@redhat.com\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "Alessandro Carminati",
    "date": "2025-06-29T22:10:41+01:00",
    "files_changed": [
      "drivers/regulator/core.c"
    ],
    "diff": "diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c\nindex 7a248dc8d2e2..cbd6d53ebfb5 100644\n--- a/drivers/regulator/core.c\n+++ b/drivers/regulator/core.c\n@@ -5639,6 +5639,7 @@ static void regulator_remove_coupling(struct regulator_dev *rdev)\n \t\t\t\t ERR_PTR(err));\n \t}\n \n+\trdev->coupling_desc.n_coupled = 0;\n \tkfree(rdev->coupling_desc.coupled_rdevs);\n \trdev->coupling_desc.coupled_rdevs = NULL;\n }",
    "stats": {
      "insertions": 1,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "dc78f7e59169d3f0e6c3c95d23dc8e55e95741e2",
    "message": "ASoC: fsl_sai: Force a software reset when starting in consumer mode\n\nOn an imx8mm platform with an external clock provider, when running the\nreceiver (arecord) and triggering an xrun with xrun_injection, we see a\nchannel swap/offset. This happens sometimes when running only the\nreceiver, but occurs reliably if a transmitter (aplay) is also\nconcurrently running.\n\nIt seems that the SAI loses track of frame sync during the trigger stop\n-> trigger start cycle that occurs during an xrun. Doing just a FIFO\nreset in this case does not suffice, and only a software reset seems to\nget it back on track.\n\nThis looks like the same h/w bug that is already handled for the\nproducer case, so we now do the reset unconditionally on config disable.\n\nSigned-off-by: Arun Raghavan <arun@asymptotic.io>\nReported-by: Pieterjan Camerlynck <p.camerlynck@televic.com>\nFixes: 3e3f8bd56955 (\"ASoC: fsl_sai: fix no frame clk in master mode\")\nCc: stable@vger.kernel.org\nReviewed-by: Fabio Estevam <festevam@gmail.com>\nLink: https://patch.msgid.link/20250626130858.163825-1-arun@arunraghavan.net\nSigned-off-by: Mark Brown <broonie@kernel.org>",
    "author": "Arun Raghavan",
    "date": "2025-06-29T22:10:26+01:00",
    "files_changed": [
      "sound/soc/fsl/fsl_sai.c"
    ],
    "diff": "diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c\nindex af1a168d35e3..50af6b725670 100644\n--- a/sound/soc/fsl/fsl_sai.c\n+++ b/sound/soc/fsl/fsl_sai.c\n@@ -803,13 +803,15 @@ static void fsl_sai_config_disable(struct fsl_sai *sai, int dir)\n \t * anymore. Add software reset to fix this issue.\n \t * This is a hardware bug, and will be fix in the\n \t * next sai version.\n+\t *\n+\t * In consumer mode, this can happen even after a\n+\t * single open/close, especially if both tx and rx\n+\t * are running concurrently.\n \t */\n-\tif (!sai->is_consumer_mode[tx]) {\n-\t\t/* Software Reset */\n-\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), FSL_SAI_CSR_SR);\n-\t\t/* Clear SR bit to finish the reset */\n-\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), 0);\n-\t}\n+\t/* Software Reset */\n+\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), FSL_SAI_CSR_SR);\n+\t/* Clear SR bit to finish the reset */\n+\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), 0);\n }\n \n static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,",
    "stats": {
      "insertions": 8,
      "deletions": 6,
      "files": 1
    }
  },
  {
    "sha": "b846350aa272de99bf6fecfa6b08e64ebfb13173",
    "message": "drm/exynos: exynos7_drm_decon: add vblank check in IRQ handling\n\nIf there's support for another console device (such as a TTY serial),\nthe kernel occasionally panics during boot. The panic message and a\nrelevant snippet of the call stack is as follows:\n\n  Unable to handle kernel NULL pointer dereference at virtual address 000000000000000\n  Call trace:\n    drm_crtc_handle_vblank+0x10/0x30 (P)\n    decon_irq_handler+0x88/0xb4\n    [...]\n\nOtherwise, the panics don't happen. This indicates that it's some sort\nof race condition.\n\nAdd a check to validate if the drm device can handle vblanks before\ncalling drm_crtc_handle_vblank() to avoid this.\n\nCc: stable@vger.kernel.org\nFixes: 96976c3d9aff (\"drm/exynos: Add DECON driver\")\nSigned-off-by: Kaustabh Chakraborty <kauschluss@disroot.org>\nSigned-off-by: Inki Dae <inki.dae@samsung.com>",
    "author": "Kaustabh Chakraborty",
    "date": "2025-06-29T16:58:16+09:00",
    "files_changed": [
      "drivers/gpu/drm/exynos/exynos7_drm_decon.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/exynos/exynos7_drm_decon.c b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\nindex f91daefa9d2b..805aa28c1723 100644\n--- a/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n+++ b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n@@ -636,6 +636,10 @@ static irqreturn_t decon_irq_handler(int irq, void *dev_id)\n \tif (!ctx->drm_dev)\n \t\tgoto out;\n \n+\t/* check if crtc and vblank have been initialized properly */\n+\tif (!drm_dev_has_vblank(ctx->drm_dev))\n+\t\tgoto out;\n+\n \tif (!ctx->i80_if) {\n \t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n ",
    "stats": {
      "insertions": 4,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "dfba48a70cb68888efb494c9642502efe73614ed",
    "message": "Merge tag 'i2c-for-6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux\n\nPull i2c fixes from Wolfram Sang:\n\n - imx: fix SMBus protocol compliance during block read\n\n - omap: fix error handling path in probe\n\n - robotfuzz, tiny-usb: prevent zero-length reads\n\n - x86, designware, amdisp: fix build error when modules are disabled\n   (agreed to go in via i2c)\n\n - scx200_acb: fix build error because of missing HAS_IOPORT\n\n* tag 'i2c-for-6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux:\n  i2c: scx200_acb: depends on HAS_IOPORT\n  i2c: omap: Fix an error handling path in omap_i2c_probe()\n  platform/x86: Use i2c adapter name to fix build errors\n  i2c: amd-isp: Initialize unique adapter name\n  i2c: designware: Initialize adapter name only when not set\n  i2c: tiny-usb: disable zero-length read messages\n  i2c: robotfuzz-osif: disable zero-length read messages\n  i2c: imx: fix emulated smbus block read",
    "author": "Linus Torvalds",
    "date": "2025-06-28T15:23:17-07:00",
    "files_changed": [
      "drivers/i2c/busses/i2c-designware-amdisp.c",
      "drivers/i2c/busses/i2c-designware-master.c",
      "drivers/i2c/busses/i2c-imx.c",
      "drivers/i2c/busses/i2c-omap.c",
      "drivers/i2c/busses/i2c-robotfuzz-osif.c",
      "drivers/i2c/busses/i2c-tiny-usb.c",
      "drivers/platform/x86/amd/amd_isp4.c",
      "include/linux/soc/amd/isp4_misc.h"
    ],
    "diff": "diff --git a/MAINTAINERS b/MAINTAINERS\nindex 7aff9b0ead32..4bac4ea21b64 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -24099,6 +24099,7 @@ M:\tBin Du <bin.du@amd.com>\n L:\tlinux-i2c@vger.kernel.org\n S:\tMaintained\n F:\tdrivers/i2c/busses/i2c-designware-amdisp.c\n+F:\tinclude/linux/soc/amd/isp4_misc.h\n \n SYNOPSYS DESIGNWARE MMC/SD/SDIO DRIVER\n M:\tJaehoon Chung <jh80.chung@samsung.com>\ndiff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig\nindex 48c5ab832009..0a4ecccd1851 100644\n--- a/drivers/i2c/busses/Kconfig\n+++ b/drivers/i2c/busses/Kconfig\n@@ -1530,7 +1530,7 @@ config I2C_XGENE_SLIMPRO\n \n config SCx200_ACB\n \ttristate \"Geode ACCESS.bus support\"\n-\tdepends on X86_32 && PCI\n+\tdepends on X86_32 && PCI && HAS_IOPORT\n \thelp\n \t  Enable the use of the ACCESS.bus controllers on the Geode SCx200 and\n \t  SC1100 processors and the CS5535 and CS5536 Geode companion devices.\ndiff --git a/drivers/i2c/busses/i2c-designware-amdisp.c b/drivers/i2c/busses/i2c-designware-amdisp.c\nindex ad6f08338124..450793d5f839 100644\n--- a/drivers/i2c/busses/i2c-designware-amdisp.c\n+++ b/drivers/i2c/busses/i2c-designware-amdisp.c\n@@ -8,6 +8,7 @@\n #include <linux/module.h>\n #include <linux/platform_device.h>\n #include <linux/pm_runtime.h>\n+#include <linux/soc/amd/isp4_misc.h>\n \n #include \"i2c-designware-core.h\"\n \n@@ -62,6 +63,7 @@ static int amd_isp_dw_i2c_plat_probe(struct platform_device *pdev)\n \n \tadap = &isp_i2c_dev->adapter;\n \tadap->owner = THIS_MODULE;\n+\tscnprintf(adap->name, sizeof(adap->name), AMDISP_I2C_ADAP_NAME);\n \tACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));\n \tadap->dev.of_node = pdev->dev.of_node;\n \t/* use dynamically allocated adapter id */\ndiff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c\nindex c5394229b77f..9d7d9e47564a 100644\n--- a/drivers/i2c/busses/i2c-designware-master.c\n+++ b/drivers/i2c/busses/i2c-designware-master.c\n@@ -1042,8 +1042,9 @@ int i2c_dw_probe_master(struct dw_i2c_dev *dev)\n \tif (ret)\n \t\treturn ret;\n \n-\tsnprintf(adap->name, sizeof(adap->name),\n-\t\t \"Synopsys DesignWare I2C adapter\");\n+\tif (!adap->name[0])\n+\t\tscnprintf(adap->name, sizeof(adap->name),\n+\t\t\t  \"Synopsys DesignWare I2C adapter\");\n \tadap->retries = 3;\n \tadap->algo = &i2c_dw_algo;\n \tadap->quirks = &i2c_dw_quirks;\ndiff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c\nindex e5732b0557fb..205cc132fdec 100644\n--- a/drivers/i2c/busses/i2c-imx.c\n+++ b/drivers/i2c/busses/i2c-imx.c\n@@ -1008,7 +1008,7 @@ static inline int i2c_imx_isr_read(struct imx_i2c_struct *i2c_imx)\n \t/* setup bus to read data */\n \ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n \ttemp &= ~I2CR_MTX;\n-\tif (i2c_imx->msg->len - 1)\n+\tif ((i2c_imx->msg->len - 1) || (i2c_imx->msg->flags & I2C_M_RECV_LEN))\n \t\ttemp &= ~I2CR_TXAK;\n \n \timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n@@ -1063,6 +1063,7 @@ static inline void i2c_imx_isr_read_block_data_len(struct imx_i2c_struct *i2c_im\n \t\twake_up(&i2c_imx->queue);\n \t}\n \ti2c_imx->msg->len += len;\n+\ti2c_imx->msg->buf[i2c_imx->msg_buf_idx++] = len;\n }\n \n static irqreturn_t i2c_imx_master_isr(struct imx_i2c_struct *i2c_imx, unsigned int status)\ndiff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c\nindex f1cc26ac5b80..8b01df3cc8e9 100644\n--- a/drivers/i2c/busses/i2c-omap.c\n+++ b/drivers/i2c/busses/i2c-omap.c\n@@ -1461,13 +1461,13 @@ omap_i2c_probe(struct platform_device *pdev)\n \t\tif (IS_ERR(mux_state)) {\n \t\t\tr = PTR_ERR(mux_state);\n \t\t\tdev_dbg(&pdev->dev, \"failed to get I2C mux: %d\\n\", r);\n-\t\t\tgoto err_disable_pm;\n+\t\t\tgoto err_put_pm;\n \t\t}\n \t\tomap->mux_state = mux_state;\n \t\tr = mux_state_select(omap->mux_state);\n \t\tif (r) {\n \t\t\tdev_err(&pdev->dev, \"failed to select I2C mux: %d\\n\", r);\n-\t\t\tgoto err_disable_pm;\n+\t\t\tgoto err_put_pm;\n \t\t}\n \t}\n \n@@ -1515,6 +1515,9 @@ omap_i2c_probe(struct platform_device *pdev)\n \n err_unuse_clocks:\n \tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\n+\tif (omap->mux_state)\n+\t\tmux_state_deselect(omap->mux_state);\n+err_put_pm:\n \tpm_runtime_dont_use_autosuspend(omap->dev);\n \tpm_runtime_put_sync(omap->dev);\n err_disable_pm:\ndiff --git a/drivers/i2c/busses/i2c-robotfuzz-osif.c b/drivers/i2c/busses/i2c-robotfuzz-osif.c\nindex 80d45079b763..e0a76fb5bc31 100644\n--- a/drivers/i2c/busses/i2c-robotfuzz-osif.c\n+++ b/drivers/i2c/busses/i2c-robotfuzz-osif.c\n@@ -111,6 +111,11 @@ static u32 osif_func(struct i2c_adapter *adapter)\n \treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n }\n \n+/* prevent invalid 0-length usb_control_msg */\n+static const struct i2c_adapter_quirks osif_quirks = {\n+\t.flags = I2C_AQ_NO_ZERO_LEN_READ,\n+};\n+\n static const struct i2c_algorithm osif_algorithm = {\n \t.xfer = osif_xfer,\n \t.functionality = osif_func,\n@@ -143,6 +148,7 @@ static int osif_probe(struct usb_interface *interface,\n \n \tpriv->adapter.owner = THIS_MODULE;\n \tpriv->adapter.class = I2C_CLASS_HWMON;\n+\tpriv->adapter.quirks = &osif_quirks;\n \tpriv->adapter.algo = &osif_algorithm;\n \tpriv->adapter.algo_data = priv;\n \tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\ndiff --git a/drivers/i2c/busses/i2c-tiny-usb.c b/drivers/i2c/busses/i2c-tiny-usb.c\nindex a18eab0992a1..57dfe5f1a7d9 100644\n--- a/drivers/i2c/busses/i2c-tiny-usb.c\n+++ b/drivers/i2c/busses/i2c-tiny-usb.c\n@@ -139,6 +139,11 @@ static u32 usb_func(struct i2c_adapter *adapter)\n \treturn ret;\n }\n \n+/* prevent invalid 0-length usb_control_msg */\n+static const struct i2c_adapter_quirks usb_quirks = {\n+\t.flags = I2C_AQ_NO_ZERO_LEN_READ,\n+};\n+\n /* This is the actual algorithm we define */\n static const struct i2c_algorithm usb_algorithm = {\n \t.xfer = usb_xfer,\n@@ -247,6 +252,7 @@ static int i2c_tiny_usb_probe(struct usb_interface *interface,\n \t/* setup i2c adapter description */\n \tdev->adapter.owner = THIS_MODULE;\n \tdev->adapter.class = I2C_CLASS_HWMON;\n+\tdev->adapter.quirks = &usb_quirks;\n \tdev->adapter.algo = &usb_algorithm;\n \tdev->adapter.algo_data = dev;\n \tsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\ndiff --git a/drivers/platform/x86/amd/amd_isp4.c b/drivers/platform/x86/amd/amd_isp4.c\nindex 0cc01441bcbb..9f291aeb35f1 100644\n--- a/drivers/platform/x86/amd/amd_isp4.c\n+++ b/drivers/platform/x86/amd/amd_isp4.c\n@@ -11,6 +11,7 @@\n #include <linux/mutex.h>\n #include <linux/platform_device.h>\n #include <linux/property.h>\n+#include <linux/soc/amd/isp4_misc.h>\n #include <linux/string.h>\n #include <linux/types.h>\n #include <linux/units.h>\n@@ -151,7 +152,7 @@ MODULE_DEVICE_TABLE(acpi, amdisp_sensor_ids);\n \n static inline bool is_isp_i2c_adapter(struct i2c_adapter *adap)\n {\n-\treturn !strcmp(adap->owner->name, \"i2c_designware_amdisp\");\n+\treturn !strcmp(adap->name, AMDISP_I2C_ADAP_NAME);\n }\n \n static void instantiate_isp_i2c_client(struct amdisp_platform *isp4_platform,\ndiff --git a/include/linux/soc/amd/isp4_misc.h b/include/linux/soc/amd/isp4_misc.h\nnew file mode 100644\nindex 000000000000..6738796986a7\n--- /dev/null\n+++ b/include/linux/soc/amd/isp4_misc.h\n@@ -0,0 +1,12 @@\n+// SPDX-License-Identifier: GPL-2.0+\n+\n+/*\n+ * Copyright (C) 2025 Advanced Micro Devices, Inc.\n+ */\n+\n+#ifndef __SOC_ISP4_MISC_H\n+#define __SOC_ISP4_MISC_H\n+\n+#define AMDISP_I2C_ADAP_NAME \"AMDISP DesignWare I2C adapter\"\n+\n+#endif",
    "stats": {
      "insertions": 40,
      "deletions": 7,
      "files": 10
    }
  },
  {
    "sha": "ded779017ad78fc9df3e9d9ae0e39d2e73865851",
    "message": "Merge tag 'trace-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/trace/linux-trace\n\nPull tracing fix from Steven Rostedt:\n\n - Fix possible UAF on error path in filter_free_subsystem_filters()\n\n   When freeing a subsystem filter, the filter for the subsystem is\n   passed in to be freed and all the events within the subsystem will\n   have their filter freed too. In order to free without waiting for RCU\n   synchronization, list items are allocated to hold what is going to be\n   freed to free it via a call_rcu(). If the allocation of these items\n   fails, it will call the synchronization directly and free after that\n   (causing a bit of delay for the user).\n\n   The subsystem filter is first added to this list and then the filters\n   for all the events under the subsystem. The bug is if one of the\n   allocations of the list items for the event filters fail to allocate,\n   it jumps to the \"free_now\" label which will free the subsystem\n   filter, then all the items on the allocated list, and then the event\n   filters that were not added to the list yet. But because the\n   subsystem filter was added first, it gets freed twice.\n\n   The solution is to add the subsystem filter after the events, and\n   then if any of the allocations fail it will not try to free any of\n   them twice\n\n* tag 'trace-v6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/trace/linux-trace:\n  tracing: Fix filter logic error",
    "author": "Linus Torvalds",
    "date": "2025-06-28T11:39:24-07:00",
    "files_changed": [
      "kernel/trace/trace_events_filter.c"
    ],
    "diff": "diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c\nindex 08141f105c95..3885aadc434d 100644\n--- a/kernel/trace/trace_events_filter.c\n+++ b/kernel/trace/trace_events_filter.c\n@@ -1436,13 +1436,6 @@ static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n \n \tINIT_LIST_HEAD(&head->list);\n \n-\titem = kmalloc(sizeof(*item), GFP_KERNEL);\n-\tif (!item)\n-\t\tgoto free_now;\n-\n-\titem->filter = filter;\n-\tlist_add_tail(&item->list, &head->list);\n-\n \tlist_for_each_entry(file, &tr->events, list) {\n \t\tif (file->system != dir)\n \t\t\tcontinue;\n@@ -1454,6 +1447,13 @@ static void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n \t\tevent_clear_filter(file);\n \t}\n \n+\titem = kmalloc(sizeof(*item), GFP_KERNEL);\n+\tif (!item)\n+\t\tgoto free_now;\n+\n+\titem->filter = filter;\n+\tlist_add_tail(&item->list, &head->list);\n+\n \tdelay_free_filter(head);\n \treturn;\n  free_now:",
    "stats": {
      "insertions": 7,
      "deletions": 7,
      "files": 1
    }
  }
]
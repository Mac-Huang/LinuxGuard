[
  {
    "sha": "5bd1bafd4474ee26f504b41aba11f3e2a1175b88",
    "message": "eth: fbnic: avoid double free when failing to DMA-map FW msg\n\nThe semantics are that caller of fbnic_mbx_map_msg() retains\nthe ownership of the message on error. All existing callers\ndutifully free the page.\n\nFixes: da3cde08209e (\"eth: fbnic: Add FW communication mechanism\")\nReviewed-by: Alexander Duyck <alexanderduyck@fb.com>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>\nReviewed-by: Jacob Keller <jacob.e.keller@intel.com>\nLink: https://patch.msgid.link/20250616195510.225819-1-kuba@kernel.org\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
    "author": "Jakub Kicinski",
    "date": "2025-06-19T12:16:11+02:00",
    "files_changed": [
      "drivers/net/ethernet/meta/fbnic/fbnic_fw.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/meta/fbnic/fbnic_fw.c b/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\nindex e2368075ab8c..4521d0483d18 100644\n--- a/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\n+++ b/drivers/net/ethernet/meta/fbnic/fbnic_fw.c\n@@ -127,11 +127,8 @@ static int fbnic_mbx_map_msg(struct fbnic_dev *fbd, int mbx_idx,\n \t\treturn -EBUSY;\n \n \taddr = dma_map_single(fbd->dev, msg, PAGE_SIZE, direction);\n-\tif (dma_mapping_error(fbd->dev, addr)) {\n-\t\tfree_page((unsigned long)msg);\n-\n+\tif (dma_mapping_error(fbd->dev, addr))\n \t\treturn -ENOSPC;\n-\t}\n \n \tmbx->buf_info[tail].msg = msg;\n \tmbx->buf_info[tail].addr = addr;",
    "stats": {
      "insertions": 1,
      "deletions": 4,
      "files": 1
    }
  },
  {
    "sha": "9b70c362a9d4ab93e0b582dad73acb2a953ef797",
    "message": "Merge branch 'net-fix-passive-tfo-socket-having-invalid-napi-id'\n\nDavid Wei says:\n\n====================\nnet: fix passive TFO socket having invalid NAPI ID\n\nFound a bug where an accepted passive TFO socket returns an invalid NAPI\nID (i.e. 0) from SO_INCOMING_NAPI_ID. Add a selftest for this using\nnetdevsim and fix the bug.\n\nPatch 1 is a drive-by fix for the lib.sh include in an existing\ndrivers/net/netdevsim/peer.sh selftest.\n\nPatch 2 adds a test binary for a simple TFO server/client.\n\nPatch 3 adds a selftest for checking that the NAPI ID of a passive TFO\nsocket is valid. This will currently fail.\n\nPatch 4 adds a fix for the bug.\n====================\n\nLink: https://patch.msgid.link/20250617212102.175711-1-dw@davidwei.uk\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-06-18T18:30:55-07:00",
    "files_changed": [
      "net/ipv4/tcp_fastopen.c",
      "tools/testing/selftests/net/tfo.c"
    ],
    "diff": "diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c\nindex 9b83d639b5ac..5107121c5e37 100644\n--- a/net/ipv4/tcp_fastopen.c\n+++ b/net/ipv4/tcp_fastopen.c\n@@ -3,6 +3,7 @@\n #include <linux/tcp.h>\n #include <linux/rcupdate.h>\n #include <net/tcp.h>\n+#include <net/busy_poll.h>\n \n void tcp_fastopen_init_key_once(struct net *net)\n {\n@@ -279,6 +280,8 @@ static struct sock *tcp_fastopen_create_child(struct sock *sk,\n \n \trefcount_set(&req->rsk_refcnt, 2);\n \n+\tsk_mark_napi_id_set(child, skb);\n+\n \t/* Now finish processing the fastopen child socket. */\n \ttcp_init_transfer(child, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB, skb);\n \ndiff --git a/tools/testing/selftests/drivers/net/netdevsim/peer.sh b/tools/testing/selftests/drivers/net/netdevsim/peer.sh\nindex 1bb46ec435d4..7f32b5600925 100755\n--- a/tools/testing/selftests/drivers/net/netdevsim/peer.sh\n+++ b/tools/testing/selftests/drivers/net/netdevsim/peer.sh\n@@ -1,7 +1,8 @@\n #!/bin/bash\n # SPDX-License-Identifier: GPL-2.0-only\n \n-source ../../../net/lib.sh\n+lib_dir=$(dirname $0)/../../../net\n+source $lib_dir/lib.sh\n \n NSIM_DEV_1_ID=$((256 + RANDOM % 256))\n NSIM_DEV_1_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_DEV_1_ID\ndiff --git a/tools/testing/selftests/net/.gitignore b/tools/testing/selftests/net/.gitignore\nindex 532bb732bc6d..c6dd2a335cf4 100644\n--- a/tools/testing/selftests/net/.gitignore\n+++ b/tools/testing/selftests/net/.gitignore\n@@ -50,6 +50,7 @@ tap\n tcp_fastopen_backup_key\n tcp_inq\n tcp_mmap\n+tfo\n timestamping\n tls\n toeplitz\ndiff --git a/tools/testing/selftests/net/Makefile b/tools/testing/selftests/net/Makefile\nindex ab996bd22a5f..332f387615d7 100644\n--- a/tools/testing/selftests/net/Makefile\n+++ b/tools/testing/selftests/net/Makefile\n@@ -110,6 +110,8 @@ TEST_GEN_PROGS += proc_net_pktgen\n TEST_PROGS += lwt_dst_cache_ref_loop.sh\n TEST_PROGS += skf_net_off.sh\n TEST_GEN_FILES += skf_net_off\n+TEST_GEN_FILES += tfo\n+TEST_PROGS += tfo_passive.sh\n \n # YNL files, must be before \"include ..lib.mk\"\n YNL_GEN_FILES := busy_poller netlink-dumps\ndiff --git a/tools/testing/selftests/net/tfo.c b/tools/testing/selftests/net/tfo.c\nnew file mode 100644\nindex 000000000000..eb3cac5e583c\n--- /dev/null\n+++ b/tools/testing/selftests/net/tfo.c\n@@ -0,0 +1,171 @@\n+// SPDX-License-Identifier: GPL-2.0\n+#include <error.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <arpa/inet.h>\n+#include <sys/socket.h>\n+#include <netinet/tcp.h>\n+#include <errno.h>\n+\n+static int cfg_server;\n+static int cfg_client;\n+static int cfg_port = 8000;\n+static struct sockaddr_in6 cfg_addr;\n+static char *cfg_outfile;\n+\n+static int parse_address(const char *str, int port, struct sockaddr_in6 *sin6)\n+{\n+\tint ret;\n+\n+\tsin6->sin6_family = AF_INET6;\n+\tsin6->sin6_port = htons(port);\n+\n+\tret = inet_pton(sin6->sin6_family, str, &sin6->sin6_addr);\n+\tif (ret != 1) {\n+\t\t/* fallback to plain IPv4 */\n+\t\tret = inet_pton(AF_INET, str, &sin6->sin6_addr.s6_addr32[3]);\n+\t\tif (ret != 1)\n+\t\t\treturn -1;\n+\n+\t\t/* add ::ffff prefix */\n+\t\tsin6->sin6_addr.s6_addr32[0] = 0;\n+\t\tsin6->sin6_addr.s6_addr32[1] = 0;\n+\t\tsin6->sin6_addr.s6_addr16[4] = 0;\n+\t\tsin6->sin6_addr.s6_addr16[5] = 0xffff;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static void run_server(void)\n+{\n+\tunsigned long qlen = 32;\n+\tint fd, opt, connfd;\n+\tsocklen_t len;\n+\tchar buf[64];\n+\tFILE *outfile;\n+\n+\toutfile = fopen(cfg_outfile, \"w\");\n+\tif (!outfile)\n+\t\terror(1, errno, \"fopen() outfile\");\n+\n+\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n+\tif (fd == -1)\n+\t\terror(1, errno, \"socket()\");\n+\n+\topt = 1;\n+\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)\n+\t\terror(1, errno, \"setsockopt(SO_REUSEADDR)\");\n+\n+\tif (setsockopt(fd, SOL_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen)) < 0)\n+\t\terror(1, errno, \"setsockopt(TCP_FASTOPEN)\");\n+\n+\tif (bind(fd, (struct sockaddr *)&cfg_addr, sizeof(cfg_addr)) < 0)\n+\t\terror(1, errno, \"bind()\");\n+\n+\tif (listen(fd, 5) < 0)\n+\t\terror(1, errno, \"listen()\");\n+\n+\tlen = sizeof(cfg_addr);\n+\tconnfd = accept(fd, (struct sockaddr *)&cfg_addr, &len);\n+\tif (connfd < 0)\n+\t\terror(1, errno, \"accept()\");\n+\n+\tlen = sizeof(opt);\n+\tif (getsockopt(connfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &opt, &len) < 0)\n+\t\terror(1, errno, \"getsockopt(SO_INCOMING_NAPI_ID)\");\n+\n+\tread(connfd, buf, 64);\n+\tfprintf(outfile, \"%d\\n\", opt);\n+\n+\tfclose(outfile);\n+\tclose(connfd);\n+\tclose(fd);\n+}\n+\n+static void run_client(void)\n+{\n+\tint fd;\n+\tchar *msg = \"Hello, world!\";\n+\n+\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n+\tif (fd == -1)\n+\t\terror(1, errno, \"socket()\");\n+\n+\tsendto(fd, msg, strlen(msg), MSG_FASTOPEN, (struct sockaddr *)&cfg_addr, sizeof(cfg_addr));\n+\n+\tclose(fd);\n+}\n+\n+static void usage(const char *filepath)\n+{\n+\terror(1, 0, \"Usage: %s (-s|-c) -h<server_ip> -p<port> -o<outfile> \", filepath);\n+}\n+\n+static void parse_opts(int argc, char **argv)\n+{\n+\tstruct sockaddr_in6 *addr6 = (void *) &cfg_addr;\n+\tchar *addr = NULL;\n+\tint ret;\n+\tint c;\n+\n+\tif (argc <= 1)\n+\t\tusage(argv[0]);\n+\n+\twhile ((c = getopt(argc, argv, \"sch:p:o:\")) != -1) {\n+\t\tswitch (c) {\n+\t\tcase 's':\n+\t\t\tif (cfg_client)\n+\t\t\t\terror(1, 0, \"Pass one of -s or -c\");\n+\t\t\tcfg_server = 1;\n+\t\t\tbreak;\n+\t\tcase 'c':\n+\t\t\tif (cfg_server)\n+\t\t\t\terror(1, 0, \"Pass one of -s or -c\");\n+\t\t\tcfg_client = 1;\n+\t\t\tbreak;\n+\t\tcase 'h':\n+\t\t\taddr = optarg;\n+\t\t\tbreak;\n+\t\tcase 'p':\n+\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n+\t\t\tbreak;\n+\t\tcase 'o':\n+\t\t\tcfg_outfile = strdup(optarg);\n+\t\t\tif (!cfg_outfile)\n+\t\t\t\terror(1, 0, \"outfile invalid\");\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (cfg_server && addr)\n+\t\terror(1, 0, \"Server cannot have -h specified\");\n+\n+\tmemset(addr6, 0, sizeof(*addr6));\n+\taddr6->sin6_family = AF_INET6;\n+\taddr6->sin6_port = htons(cfg_port);\n+\taddr6->sin6_addr = in6addr_any;\n+\tif (addr) {\n+\t\tret = parse_address(addr, cfg_port, addr6);\n+\t\tif (ret)\n+\t\t\terror(1, 0, \"Client address parse error: %s\", addr);\n+\t}\n+}\n+\n+int main(int argc, char **argv)\n+{\n+\tparse_opts(argc, argv);\n+\n+\tif (cfg_server)\n+\t\trun_server();\n+\telse if (cfg_client)\n+\t\trun_client();\n+\n+\treturn 0;\n+}\ndiff --git a/tools/testing/selftests/net/tfo_passive.sh b/tools/testing/selftests/net/tfo_passive.sh\nnew file mode 100755\nindex 000000000000..80bf11fdc046\n--- /dev/null\n+++ b/tools/testing/selftests/net/tfo_passive.sh\n@@ -0,0 +1,112 @@\n+#!/bin/bash\n+# SPDX-License-Identifier: GPL-2.0\n+source lib.sh\n+\n+NSIM_SV_ID=$((256 + RANDOM % 256))\n+NSIM_SV_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_SV_ID\n+NSIM_CL_ID=$((512 + RANDOM % 256))\n+NSIM_CL_SYS=/sys/bus/netdevsim/devices/netdevsim$NSIM_CL_ID\n+\n+NSIM_DEV_SYS_NEW=/sys/bus/netdevsim/new_device\n+NSIM_DEV_SYS_DEL=/sys/bus/netdevsim/del_device\n+NSIM_DEV_SYS_LINK=/sys/bus/netdevsim/link_device\n+NSIM_DEV_SYS_UNLINK=/sys/bus/netdevsim/unlink_device\n+\n+SERVER_IP=192.168.1.1\n+CLIENT_IP=192.168.1.2\n+SERVER_PORT=48675\n+\n+setup_ns()\n+{\n+\tset -e\n+\tip netns add nssv\n+\tip netns add nscl\n+\n+\tNSIM_SV_NAME=$(find $NSIM_SV_SYS/net -maxdepth 1 -type d ! \\\n+\t\t-path $NSIM_SV_SYS/net -exec basename {} \\;)\n+\tNSIM_CL_NAME=$(find $NSIM_CL_SYS/net -maxdepth 1 -type d ! \\\n+\t\t-path $NSIM_CL_SYS/net -exec basename {} \\;)\n+\n+\tip link set $NSIM_SV_NAME netns nssv\n+\tip link set $NSIM_CL_NAME netns nscl\n+\n+\tip netns exec nssv ip addr add \"${SERVER_IP}/24\" dev $NSIM_SV_NAME\n+\tip netns exec nscl ip addr add \"${CLIENT_IP}/24\" dev $NSIM_CL_NAME\n+\n+\tip netns exec nssv ip link set dev $NSIM_SV_NAME up\n+\tip netns exec nscl ip link set dev $NSIM_CL_NAME up\n+\n+\t# Enable passive TFO\n+\tip netns exec nssv sysctl -w net.ipv4.tcp_fastopen=519 > /dev/null\n+\n+\tset +e\n+}\n+\n+cleanup_ns()\n+{\n+\tip netns del nscl\n+\tip netns del nssv\n+}\n+\n+###\n+### Code start\n+###\n+\n+modprobe netdevsim\n+\n+# linking\n+\n+echo $NSIM_SV_ID > $NSIM_DEV_SYS_NEW\n+echo $NSIM_CL_ID > $NSIM_DEV_SYS_NEW\n+udevadm settle\n+\n+setup_ns\n+\n+NSIM_SV_FD=$((256 + RANDOM % 256))\n+exec {NSIM_SV_FD}</var/run/netns/nssv\n+NSIM_SV_IFIDX=$(ip netns exec nssv cat /sys/class/net/$NSIM_SV_NAME/ifindex)\n+\n+NSIM_CL_FD=$((256 + RANDOM % 256))\n+exec {NSIM_CL_FD}</var/run/netns/nscl\n+NSIM_CL_IFIDX=$(ip netns exec nscl cat /sys/class/net/$NSIM_CL_NAME/ifindex)\n+\n+echo \"$NSIM_SV_FD:$NSIM_SV_IFIDX $NSIM_CL_FD:$NSIM_CL_IFIDX\" > \\\n+     $NSIM_DEV_SYS_LINK\n+\n+if [ $? -ne 0 ]; then\n+\techo \"linking netdevsim1 with netdevsim2 should succeed\"\n+\tcleanup_ns\n+\texit 1\n+fi\n+\n+out_file=$(mktemp)\n+\n+timeout -k 1s 30s ip netns exec nssv ./tfo        \\\n+\t\t\t\t-s                \\\n+\t\t\t\t-p ${SERVER_PORT} \\\n+\t\t\t\t-o ${out_file}&\n+\n+wait_local_port_listen nssv ${SERVER_PORT} tcp\n+\n+ip netns exec nscl ./tfo -c -h ${SERVER_IP} -p ${SERVER_PORT}\n+\n+wait\n+\n+res=$(cat $out_file)\n+rm $out_file\n+\n+if [ $res -eq 0 ]; then\n+\techo \"got invalid NAPI ID from passive TFO socket\"\n+\tcleanup_ns\n+\texit 1\n+fi\n+\n+echo \"$NSIM_SV_FD:$NSIM_SV_IFIDX\" > $NSIM_DEV_SYS_UNLINK\n+\n+echo $NSIM_CL_ID > $NSIM_DEV_SYS_DEL\n+\n+cleanup_ns\n+\n+modprobe -r netdevsim\n+\n+exit 0",
    "stats": {
      "insertions": 291,
      "deletions": 1,
      "files": 6
    }
  },
  {
    "sha": "fb4d33ab452ea254e2c319bac5703d1b56d895bf",
    "message": "Merge tag '6.16-rc2-ksmbd-server-fixes' of git://git.samba.org/ksmbd\n\nPull smb server fixes from Steve French:\n\n - Fix alternate data streams bug\n\n - Important fix for null pointer deref with Kerberos authentication\n\n - Fix oops in smbdirect (RDMA) in free_transport\n\n* tag '6.16-rc2-ksmbd-server-fixes' of git://git.samba.org/ksmbd:\n  ksmbd: handle set/get info file for streamed file\n  ksmbd: fix null pointer dereference in destroy_previous_session\n  ksmbd: add free_transport ops in ksmbd connection",
    "author": "Linus Torvalds",
    "date": "2025-06-18T17:47:27-07:00",
    "files_changed": [
      "fs/smb/server/connection.c",
      "fs/smb/server/connection.h",
      "fs/smb/server/smb2pdu.c",
      "fs/smb/server/transport_rdma.c",
      "fs/smb/server/transport_tcp.c",
      "fs/smb/server/vfs.c",
      "fs/smb/server/vfs_cache.h"
    ],
    "diff": "diff --git a/fs/smb/server/connection.c b/fs/smb/server/connection.c\nindex 83764c230e9d..3f04a2977ba8 100644\n--- a/fs/smb/server/connection.c\n+++ b/fs/smb/server/connection.c\n@@ -40,7 +40,7 @@ void ksmbd_conn_free(struct ksmbd_conn *conn)\n \tkvfree(conn->request_buf);\n \tkfree(conn->preauth_info);\n \tif (atomic_dec_and_test(&conn->refcnt)) {\n-\t\tksmbd_free_transport(conn->transport);\n+\t\tconn->transport->ops->free_transport(conn->transport);\n \t\tkfree(conn);\n \t}\n }\ndiff --git a/fs/smb/server/connection.h b/fs/smb/server/connection.h\nindex 6efed923bd68..dd3e0e3f7bf0 100644\n--- a/fs/smb/server/connection.h\n+++ b/fs/smb/server/connection.h\n@@ -133,6 +133,7 @@ struct ksmbd_transport_ops {\n \t\t\t  void *buf, unsigned int len,\n \t\t\t  struct smb2_buffer_desc_v1 *desc,\n \t\t\t  unsigned int desc_len);\n+\tvoid (*free_transport)(struct ksmbd_transport *kt);\n };\n \n struct ksmbd_transport {\ndiff --git a/fs/smb/server/smb2pdu.c b/fs/smb/server/smb2pdu.c\nindex 1a308171b599..fafa86273f12 100644\n--- a/fs/smb/server/smb2pdu.c\n+++ b/fs/smb/server/smb2pdu.c\n@@ -1607,17 +1607,18 @@ static int krb5_authenticate(struct ksmbd_work *work,\n \tout_len = work->response_sz -\n \t\t(le16_to_cpu(rsp->SecurityBufferOffset) + 4);\n \n-\t/* Check previous session */\n-\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n-\tif (prev_sess_id && prev_sess_id != sess->id)\n-\t\tdestroy_previous_session(conn, sess->user, prev_sess_id);\n-\n \tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n \t\t\t\t\t out_blob, &out_len);\n \tif (retval) {\n \t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n \t\treturn -EINVAL;\n \t}\n+\n+\t/* Check previous session */\n+\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n+\tif (prev_sess_id && prev_sess_id != sess->id)\n+\t\tdestroy_previous_session(conn, sess->user, prev_sess_id);\n+\n \trsp->SecurityBufferLength = cpu_to_le16(out_len);\n \n \tif ((conn->sign || server_conf.enforced_signing) ||\n@@ -4871,8 +4872,13 @@ static int get_file_standard_info(struct smb2_query_info_rsp *rsp,\n \tsinfo = (struct smb2_file_standard_info *)rsp->Buffer;\n \tdelete_pending = ksmbd_inode_pending_delete(fp);\n \n-\tsinfo->AllocationSize = cpu_to_le64(stat.blocks << 9);\n-\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\tif (ksmbd_stream_fd(fp) == false) {\n+\t\tsinfo->AllocationSize = cpu_to_le64(stat.blocks << 9);\n+\t\tsinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\t} else {\n+\t\tsinfo->AllocationSize = cpu_to_le64(fp->stream.size);\n+\t\tsinfo->EndOfFile = cpu_to_le64(fp->stream.size);\n+\t}\n \tsinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);\n \tsinfo->DeletePending = delete_pending;\n \tsinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;\n@@ -4935,9 +4941,14 @@ static int get_file_all_info(struct ksmbd_work *work,\n \tfile_info->ChangeTime = cpu_to_le64(time);\n \tfile_info->Attributes = fp->f_ci->m_fattr;\n \tfile_info->Pad1 = 0;\n-\tfile_info->AllocationSize =\n-\t\tcpu_to_le64(stat.blocks << 9);\n-\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\tif (ksmbd_stream_fd(fp) == false) {\n+\t\tfile_info->AllocationSize =\n+\t\t\tcpu_to_le64(stat.blocks << 9);\n+\t\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\t} else {\n+\t\tfile_info->AllocationSize = cpu_to_le64(fp->stream.size);\n+\t\tfile_info->EndOfFile = cpu_to_le64(fp->stream.size);\n+\t}\n \tfile_info->NumberOfLinks =\n \t\t\tcpu_to_le32(get_nlink(&stat) - delete_pending);\n \tfile_info->DeletePending = delete_pending;\n@@ -4946,7 +4957,10 @@ static int get_file_all_info(struct ksmbd_work *work,\n \tfile_info->IndexNumber = cpu_to_le64(stat.ino);\n \tfile_info->EASize = 0;\n \tfile_info->AccessFlags = fp->daccess;\n-\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n+\tif (ksmbd_stream_fd(fp) == false)\n+\t\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n+\telse\n+\t\tfile_info->CurrentByteOffset = cpu_to_le64(fp->stream.pos);\n \tfile_info->Mode = fp->coption;\n \tfile_info->AlignmentRequirement = 0;\n \tconv_len = smbConvertToUTF16((__le16 *)file_info->FileName, filename,\n@@ -5134,8 +5148,13 @@ static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,\n \ttime = ksmbd_UnixTimeToNT(stat.ctime);\n \tfile_info->ChangeTime = cpu_to_le64(time);\n \tfile_info->Attributes = fp->f_ci->m_fattr;\n-\tfile_info->AllocationSize = cpu_to_le64(stat.blocks << 9);\n-\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\tif (ksmbd_stream_fd(fp) == false) {\n+\t\tfile_info->AllocationSize = cpu_to_le64(stat.blocks << 9);\n+\t\tfile_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n+\t} else {\n+\t\tfile_info->AllocationSize = cpu_to_le64(fp->stream.size);\n+\t\tfile_info->EndOfFile = cpu_to_le64(fp->stream.size);\n+\t}\n \tfile_info->Reserved = cpu_to_le32(0);\n \trsp->OutputBufferLength =\n \t\tcpu_to_le32(sizeof(struct smb2_file_ntwrk_info));\n@@ -5158,7 +5177,11 @@ static void get_file_position_info(struct smb2_query_info_rsp *rsp,\n \tstruct smb2_file_pos_info *file_info;\n \n \tfile_info = (struct smb2_file_pos_info *)rsp->Buffer;\n-\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n+\tif (ksmbd_stream_fd(fp) == false)\n+\t\tfile_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);\n+\telse\n+\t\tfile_info->CurrentByteOffset = cpu_to_le64(fp->stream.pos);\n+\n \trsp->OutputBufferLength =\n \t\tcpu_to_le32(sizeof(struct smb2_file_pos_info));\n }\n@@ -5247,8 +5270,13 @@ static int find_file_posix_info(struct smb2_query_info_rsp *rsp,\n \tfile_info->ChangeTime = cpu_to_le64(time);\n \tfile_info->DosAttributes = fp->f_ci->m_fattr;\n \tfile_info->Inode = cpu_to_le64(stat.ino);\n-\tfile_info->EndOfFile = cpu_to_le64(stat.size);\n-\tfile_info->AllocationSize = cpu_to_le64(stat.blocks << 9);\n+\tif (ksmbd_stream_fd(fp) == false) {\n+\t\tfile_info->EndOfFile = cpu_to_le64(stat.size);\n+\t\tfile_info->AllocationSize = cpu_to_le64(stat.blocks << 9);\n+\t} else {\n+\t\tfile_info->EndOfFile = cpu_to_le64(fp->stream.size);\n+\t\tfile_info->AllocationSize = cpu_to_le64(fp->stream.size);\n+\t}\n \tfile_info->HardLinks = cpu_to_le32(stat.nlink);\n \tfile_info->Mode = cpu_to_le32(stat.mode & 0777);\n \tswitch (stat.mode & S_IFMT) {\n@@ -6190,6 +6218,9 @@ static int set_file_allocation_info(struct ksmbd_work *work,\n \tif (!(fp->daccess & FILE_WRITE_DATA_LE))\n \t\treturn -EACCES;\n \n+\tif (ksmbd_stream_fd(fp) == true)\n+\t\treturn 0;\n+\n \trc = vfs_getattr(&fp->filp->f_path, &stat, STATX_BASIC_STATS,\n \t\t\t AT_STATX_SYNC_AS_STAT);\n \tif (rc)\n@@ -6248,7 +6279,8 @@ static int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,\n \t * truncate of some filesystem like FAT32 fill zero data in\n \t * truncated range.\n \t */\n-\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC) {\n+\tif (inode->i_sb->s_magic != MSDOS_SUPER_MAGIC &&\n+\t    ksmbd_stream_fd(fp) == false) {\n \t\tksmbd_debug(SMB, \"truncated to newsize %lld\\n\", newsize);\n \t\trc = ksmbd_vfs_truncate(work, fp, newsize);\n \t\tif (rc) {\n@@ -6321,7 +6353,13 @@ static int set_file_position_info(struct ksmbd_file *fp,\n \t\treturn -EINVAL;\n \t}\n \n-\tfp->filp->f_pos = current_byte_offset;\n+\tif (ksmbd_stream_fd(fp) == false)\n+\t\tfp->filp->f_pos = current_byte_offset;\n+\telse {\n+\t\tif (current_byte_offset > XATTR_SIZE_MAX)\n+\t\t\tcurrent_byte_offset = XATTR_SIZE_MAX;\n+\t\tfp->stream.pos = current_byte_offset;\n+\t}\n \treturn 0;\n }\n \ndiff --git a/fs/smb/server/transport_rdma.c b/fs/smb/server/transport_rdma.c\nindex 4998df04ab95..64a428a06ace 100644\n--- a/fs/smb/server/transport_rdma.c\n+++ b/fs/smb/server/transport_rdma.c\n@@ -159,7 +159,8 @@ struct smb_direct_transport {\n };\n \n #define KSMBD_TRANS(t) ((struct ksmbd_transport *)&((t)->transport))\n-\n+#define SMBD_TRANS(t)\t((struct smb_direct_transport *)container_of(t, \\\n+\t\t\t\tstruct smb_direct_transport, transport))\n enum {\n \tSMB_DIRECT_MSG_NEGOTIATE_REQ = 0,\n \tSMB_DIRECT_MSG_DATA_TRANSFER\n@@ -410,6 +411,11 @@ static struct smb_direct_transport *alloc_transport(struct rdma_cm_id *cm_id)\n \treturn NULL;\n }\n \n+static void smb_direct_free_transport(struct ksmbd_transport *kt)\n+{\n+\tkfree(SMBD_TRANS(kt));\n+}\n+\n static void free_transport(struct smb_direct_transport *t)\n {\n \tstruct smb_direct_recvmsg *recvmsg;\n@@ -455,7 +461,6 @@ static void free_transport(struct smb_direct_transport *t)\n \n \tsmb_direct_destroy_pools(t);\n \tksmbd_conn_free(KSMBD_TRANS(t)->conn);\n-\tkfree(t);\n }\n \n static struct smb_direct_sendmsg\n@@ -2281,4 +2286,5 @@ static const struct ksmbd_transport_ops ksmbd_smb_direct_transport_ops = {\n \t.read\t\t= smb_direct_read,\n \t.rdma_read\t= smb_direct_rdma_read,\n \t.rdma_write\t= smb_direct_rdma_write,\n+\t.free_transport = smb_direct_free_transport,\n };\ndiff --git a/fs/smb/server/transport_tcp.c b/fs/smb/server/transport_tcp.c\nindex abedf510899a..4e9f98db9ff4 100644\n--- a/fs/smb/server/transport_tcp.c\n+++ b/fs/smb/server/transport_tcp.c\n@@ -93,7 +93,7 @@ static struct tcp_transport *alloc_transport(struct socket *client_sk)\n \treturn t;\n }\n \n-void ksmbd_free_transport(struct ksmbd_transport *kt)\n+static void ksmbd_tcp_free_transport(struct ksmbd_transport *kt)\n {\n \tstruct tcp_transport *t = TCP_TRANS(kt);\n \n@@ -656,4 +656,5 @@ static const struct ksmbd_transport_ops ksmbd_tcp_transport_ops = {\n \t.read\t\t= ksmbd_tcp_read,\n \t.writev\t\t= ksmbd_tcp_writev,\n \t.disconnect\t= ksmbd_tcp_disconnect,\n+\t.free_transport = ksmbd_tcp_free_transport,\n };\ndiff --git a/fs/smb/server/vfs.c b/fs/smb/server/vfs.c\nindex ba45e809555a..0f3aad12e495 100644\n--- a/fs/smb/server/vfs.c\n+++ b/fs/smb/server/vfs.c\n@@ -293,6 +293,7 @@ static int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,\n \n \tif (v_len - *pos < count)\n \t\tcount = v_len - *pos;\n+\tfp->stream.pos = v_len;\n \n \tmemcpy(buf, &stream_buf[*pos], count);\n \n@@ -456,8 +457,8 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,\n \t\t\t\t true);\n \tif (err < 0)\n \t\tgoto out;\n-\n-\tfp->filp->f_pos = *pos;\n+\telse\n+\t\tfp->stream.pos = size;\n \terr = 0;\n out:\n \tkvfree(stream_buf);\ndiff --git a/fs/smb/server/vfs_cache.h b/fs/smb/server/vfs_cache.h\nindex 5bbb179736c2..0708155b5caf 100644\n--- a/fs/smb/server/vfs_cache.h\n+++ b/fs/smb/server/vfs_cache.h\n@@ -44,6 +44,7 @@ struct ksmbd_lock {\n struct stream {\n \tchar *name;\n \tssize_t size;\n+\tloff_t pos;\n };\n \n struct ksmbd_inode {",
    "stats": {
      "insertions": 72,
      "deletions": 24,
      "files": 7
    }
  },
  {
    "sha": "229f135e0680da3dd0bcce515c07be87858f1d12",
    "message": "Merge tag 'driver-core-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/driver-core/driver-core\n\nPull driver core fixes from Danilo Krummrich:\n\n - Fix a race condition in Devres::drop(). This depends on two other\n   patches:\n     - (Minimal) Rust abstractions for struct completion\n     - Let Revocable indicate whether its data is already being revoked\n\n - Fix Devres to avoid exposing the internal Revocable\n\n - Add .mailmap entry for Danilo Krummrich\n\n - Add Madhavan Srinivasan to embargoed-hardware-issues.rst\n\n* tag 'driver-core-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/driver-core/driver-core:\n  Documentation: embargoed-hardware-issues.rst: Add myself for Power\n  mailmap: add entry for Danilo Krummrich\n  rust: devres: do not dereference to the internal Revocable\n  rust: devres: fix race in Devres::drop()\n  rust: revocable: indicate whether `data` has been revoked already\n  rust: completion: implement initial abstraction",
    "author": "Linus Torvalds",
    "date": "2025-06-18T14:31:16-07:00",
    "files_changed": [
      "rust/bindings/bindings_helper.h",
      "rust/helpers/completion.c",
      "rust/helpers/helpers.c"
    ],
    "diff": "diff --git a/.mailmap b/.mailmap\nindex 1999905a9c7e..fee7681100a8 100644\n--- a/.mailmap\n+++ b/.mailmap\n@@ -197,6 +197,7 @@ Daniel Borkmann <daniel@iogearbox.net> <daniel.borkmann@tik.ee.ethz.ch>\n Daniel Borkmann <daniel@iogearbox.net> <dborkmann@redhat.com>\n Daniel Borkmann <daniel@iogearbox.net> <dborkman@redhat.com>\n Daniel Borkmann <daniel@iogearbox.net> <dxchgb@gmail.com>\n+Danilo Krummrich <dakr@kernel.org> <dakr@redhat.com>\n David Brownell <david-b@pacbell.net>\n David Collins <quic_collinsd@quicinc.com> <collinsd@codeaurora.org>\n David Heidelberg <david@ixit.cz> <d.okias@gmail.com>\ndiff --git a/Documentation/process/embargoed-hardware-issues.rst b/Documentation/process/embargoed-hardware-issues.rst\nindex da6bf0f6d01e..34e00848e0da 100644\n--- a/Documentation/process/embargoed-hardware-issues.rst\n+++ b/Documentation/process/embargoed-hardware-issues.rst\n@@ -290,6 +290,7 @@ an involved disclosed party. The current ambassadors list:\n   AMD\t\tTom Lendacky <thomas.lendacky@amd.com>\n   Ampere\tDarren Hart <darren@os.amperecomputing.com>\n   ARM\t\tCatalin Marinas <catalin.marinas@arm.com>\n+  IBM Power\tMadhavan Srinivasan <maddy@linux.ibm.com>\n   IBM Z\t\tChristian Borntraeger <borntraeger@de.ibm.com>\n   Intel\t\tTony Luck <tony.luck@intel.com>\n   Qualcomm\tTrilok Soni <quic_tsoni@quicinc.com>\ndiff --git a/rust/bindings/bindings_helper.h b/rust/bindings/bindings_helper.h\nindex bc494745f67b..8cbb660e2ec2 100644\n--- a/rust/bindings/bindings_helper.h\n+++ b/rust/bindings/bindings_helper.h\n@@ -39,6 +39,7 @@\n #include <linux/blk_types.h>\n #include <linux/blkdev.h>\n #include <linux/clk.h>\n+#include <linux/completion.h>\n #include <linux/configfs.h>\n #include <linux/cpu.h>\n #include <linux/cpufreq.h>\ndiff --git a/rust/helpers/completion.c b/rust/helpers/completion.c\nnew file mode 100644\nindex 000000000000..b2443262a2ae\n--- /dev/null\n+++ b/rust/helpers/completion.c\n@@ -0,0 +1,8 @@\n+// SPDX-License-Identifier: GPL-2.0\n+\n+#include <linux/completion.h>\n+\n+void rust_helper_init_completion(struct completion *x)\n+{\n+\tinit_completion(x);\n+}\ndiff --git a/rust/helpers/helpers.c b/rust/helpers/helpers.c\nindex 16fa9bca5949..b15b3cddad4e 100644\n--- a/rust/helpers/helpers.c\n+++ b/rust/helpers/helpers.c\n@@ -13,6 +13,7 @@\n #include \"build_assert.c\"\n #include \"build_bug.c\"\n #include \"clk.c\"\n+#include \"completion.c\"\n #include \"cpu.c\"\n #include \"cpufreq.c\"\n #include \"cpumask.c\"\ndiff --git a/rust/kernel/devres.rs b/rust/kernel/devres.rs\nindex 0f79a2ec9474..57502534d985 100644\n--- a/rust/kernel/devres.rs\n+++ b/rust/kernel/devres.rs\n@@ -12,26 +12,28 @@\n     error::{Error, Result},\n     ffi::c_void,\n     prelude::*,\n-    revocable::Revocable,\n-    sync::Arc,\n+    revocable::{Revocable, RevocableGuard},\n+    sync::{rcu, Arc, Completion},\n     types::ARef,\n };\n \n-use core::ops::Deref;\n-\n #[pin_data]\n struct DevresInner<T> {\n     dev: ARef<Device>,\n     callback: unsafe extern \"C\" fn(*mut c_void),\n     #[pin]\n     data: Revocable<T>,\n+    #[pin]\n+    revoke: Completion,\n }\n \n /// This abstraction is meant to be used by subsystems to containerize [`Device`] bound resources to\n /// manage their lifetime.\n ///\n /// [`Device`] bound resources should be freed when either the resource goes out of scope or the\n-/// [`Device`] is unbound respectively, depending on what happens first.\n+/// [`Device`] is unbound respectively, depending on what happens first. In any case, it is always\n+/// guaranteed that revoking the device resource is completed before the corresponding [`Device`]\n+/// is unbound.\n ///\n /// To achieve that [`Devres`] registers a devres callback on creation, which is called once the\n /// [`Device`] is unbound, revoking access to the encapsulated resource (see also [`Revocable`]).\n@@ -102,6 +104,7 @@ fn new(dev: &Device<Bound>, data: T, flags: Flags) -> Result<Arc<DevresInner<T>>\n                 dev: dev.into(),\n                 callback: Self::devres_callback,\n                 data <- Revocable::new(data),\n+                revoke <- Completion::new(),\n             }),\n             flags,\n         )?;\n@@ -130,26 +133,28 @@ fn as_ptr(&self) -> *const Self {\n         self as _\n     }\n \n-    fn remove_action(this: &Arc<Self>) {\n+    fn remove_action(this: &Arc<Self>) -> bool {\n         // SAFETY:\n         // - `self.inner.dev` is a valid `Device`,\n         // - the `action` and `data` pointers are the exact same ones as given to devm_add_action()\n         //   previously,\n         // - `self` is always valid, even if the action has been released already.\n-        let ret = unsafe {\n+        let success = unsafe {\n             bindings::devm_remove_action_nowarn(\n                 this.dev.as_raw(),\n                 Some(this.callback),\n                 this.as_ptr() as _,\n             )\n-        };\n+        } == 0;\n \n-        if ret == 0 {\n+        if success {\n             // SAFETY: We leaked an `Arc` reference to devm_add_action() in `DevresInner::new`; if\n             // devm_remove_action_nowarn() was successful we can (and have to) claim back ownership\n             // of this reference.\n             let _ = unsafe { Arc::from_raw(this.as_ptr()) };\n         }\n+\n+        success\n     }\n \n     #[allow(clippy::missing_safety_doc)]\n@@ -161,7 +166,12 @@ fn remove_action(this: &Arc<Self>) {\n         //         `DevresInner::new`.\n         let inner = unsafe { Arc::from_raw(ptr) };\n \n-        inner.data.revoke();\n+        if !inner.data.revoke() {\n+            // If `revoke()` returns false, it means that `Devres::drop` already started revoking\n+            // `inner.data` for us. Hence we have to wait until `Devres::drop()` signals that it\n+            // completed revoking `inner.data`.\n+            inner.revoke.wait_for_completion();\n+        }\n     }\n }\n \n@@ -218,20 +228,36 @@ pub fn access<'a>(&'a self, dev: &'a Device<Bound>) -> Result<&'a T> {\n         // SAFETY: `dev` being the same device as the device this `Devres` has been created for\n         // proves that `self.0.data` hasn't been revoked and is guaranteed to not be revoked as\n         // long as `dev` lives; `dev` lives at least as long as `self`.\n-        Ok(unsafe { self.deref().access() })\n+        Ok(unsafe { self.0.data.access() })\n     }\n-}\n \n-impl<T> Deref for Devres<T> {\n-    type Target = Revocable<T>;\n+    /// [`Devres`] accessor for [`Revocable::try_access`].\n+    pub fn try_access(&self) -> Option<RevocableGuard<'_, T>> {\n+        self.0.data.try_access()\n+    }\n+\n+    /// [`Devres`] accessor for [`Revocable::try_access_with`].\n+    pub fn try_access_with<R, F: FnOnce(&T) -> R>(&self, f: F) -> Option<R> {\n+        self.0.data.try_access_with(f)\n+    }\n \n-    fn deref(&self) -> &Self::Target {\n-        &self.0.data\n+    /// [`Devres`] accessor for [`Revocable::try_access_with_guard`].\n+    pub fn try_access_with_guard<'a>(&'a self, guard: &'a rcu::Guard) -> Option<&'a T> {\n+        self.0.data.try_access_with_guard(guard)\n     }\n }\n \n impl<T> Drop for Devres<T> {\n     fn drop(&mut self) {\n-        DevresInner::remove_action(&self.0);\n+        // SAFETY: When `drop` runs, it is guaranteed that nobody is accessing the revocable data\n+        // anymore, hence it is safe not to wait for the grace period to finish.\n+        if unsafe { self.0.data.revoke_nosync() } {\n+            // We revoked `self.0.data` before the devres action did, hence try to remove it.\n+            if !DevresInner::remove_action(&self.0) {\n+                // We could not remove the devres action, which means that it now runs concurrently,\n+                // hence signal that `self.0.data` has been revoked successfully.\n+                self.0.revoke.complete_all();\n+            }\n+        }\n     }\n }\ndiff --git a/rust/kernel/revocable.rs b/rust/kernel/revocable.rs\nindex db4aa46bb121..06a3cdfce344 100644\n--- a/rust/kernel/revocable.rs\n+++ b/rust/kernel/revocable.rs\n@@ -154,8 +154,10 @@ pub unsafe fn access(&self) -> &T {\n     /// # Safety\n     ///\n     /// Callers must ensure that there are no more concurrent users of the revocable object.\n-    unsafe fn revoke_internal<const SYNC: bool>(&self) {\n-        if self.is_available.swap(false, Ordering::Relaxed) {\n+    unsafe fn revoke_internal<const SYNC: bool>(&self) -> bool {\n+        let revoke = self.is_available.swap(false, Ordering::Relaxed);\n+\n+        if revoke {\n             if SYNC {\n                 // SAFETY: Just an FFI call, there are no further requirements.\n                 unsafe { bindings::synchronize_rcu() };\n@@ -165,6 +167,8 @@ unsafe fn revoke_internal<const SYNC: bool>(&self) {\n             // `compare_exchange` above that takes `is_available` from `true` to `false`.\n             unsafe { drop_in_place(self.data.get()) };\n         }\n+\n+        revoke\n     }\n \n     /// Revokes access to and drops the wrapped object.\n@@ -172,10 +176,13 @@ unsafe fn revoke_internal<const SYNC: bool>(&self) {\n     /// Access to the object is revoked immediately to new callers of [`Revocable::try_access`],\n     /// expecting that there are no concurrent users of the object.\n     ///\n+    /// Returns `true` if `&self` has been revoked with this call, `false` if it was revoked\n+    /// already.\n+    ///\n     /// # Safety\n     ///\n     /// Callers must ensure that there are no more concurrent users of the revocable object.\n-    pub unsafe fn revoke_nosync(&self) {\n+    pub unsafe fn revoke_nosync(&self) -> bool {\n         // SAFETY: By the safety requirement of this function, the caller ensures that nobody is\n         // accessing the data anymore and hence we don't have to wait for the grace period to\n         // finish.\n@@ -189,7 +196,10 @@ pub unsafe fn revoke_nosync(&self) {\n     /// If there are concurrent users of the object (i.e., ones that called\n     /// [`Revocable::try_access`] beforehand and still haven't dropped the returned guard), this\n     /// function waits for the concurrent access to complete before dropping the wrapped object.\n-    pub fn revoke(&self) {\n+    ///\n+    /// Returns `true` if `&self` has been revoked with this call, `false` if it was revoked\n+    /// already.\n+    pub fn revoke(&self) -> bool {\n         // SAFETY: By passing `true` we ask `revoke_internal` to wait for the grace period to\n         // finish.\n         unsafe { self.revoke_internal::<true>() }\ndiff --git a/rust/kernel/sync.rs b/rust/kernel/sync.rs\nindex 36a719015583..c23a12639924 100644\n--- a/rust/kernel/sync.rs\n+++ b/rust/kernel/sync.rs\n@@ -10,6 +10,7 @@\n use pin_init;\n \n mod arc;\n+pub mod completion;\n mod condvar;\n pub mod lock;\n mod locked_by;\n@@ -17,6 +18,7 @@\n pub mod rcu;\n \n pub use arc::{Arc, ArcBorrow, UniqueArc};\n+pub use completion::Completion;\n pub use condvar::{new_condvar, CondVar, CondVarTimeoutResult};\n pub use lock::global::{global_lock, GlobalGuard, GlobalLock, GlobalLockBackend, GlobalLockedBy};\n pub use lock::mutex::{new_mutex, Mutex, MutexGuard};\ndiff --git a/rust/kernel/sync/completion.rs b/rust/kernel/sync/completion.rs\nnew file mode 100644\nindex 000000000000..c50012a940a3\n--- /dev/null\n+++ b/rust/kernel/sync/completion.rs\n@@ -0,0 +1,112 @@\n+// SPDX-License-Identifier: GPL-2.0\n+\n+//! Completion support.\n+//!\n+//! Reference: <https://docs.kernel.org/scheduler/completion.html>\n+//!\n+//! C header: [`include/linux/completion.h`](srctree/include/linux/completion.h)\n+\n+use crate::{bindings, prelude::*, types::Opaque};\n+\n+/// Synchronization primitive to signal when a certain task has been completed.\n+///\n+/// The [`Completion`] synchronization primitive signals when a certain task has been completed by\n+/// waking up other tasks that have been queued up to wait for the [`Completion`] to be completed.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use kernel::sync::{Arc, Completion};\n+/// use kernel::workqueue::{self, impl_has_work, new_work, Work, WorkItem};\n+///\n+/// #[pin_data]\n+/// struct MyTask {\n+///     #[pin]\n+///     work: Work<MyTask>,\n+///     #[pin]\n+///     done: Completion,\n+/// }\n+///\n+/// impl_has_work! {\n+///     impl HasWork<Self> for MyTask { self.work }\n+/// }\n+///\n+/// impl MyTask {\n+///     fn new() -> Result<Arc<Self>> {\n+///         let this = Arc::pin_init(pin_init!(MyTask {\n+///             work <- new_work!(\"MyTask::work\"),\n+///             done <- Completion::new(),\n+///         }), GFP_KERNEL)?;\n+///\n+///         let _ = workqueue::system().enqueue(this.clone());\n+///\n+///         Ok(this)\n+///     }\n+///\n+///     fn wait_for_completion(&self) {\n+///         self.done.wait_for_completion();\n+///\n+///         pr_info!(\"Completion: task complete\\n\");\n+///     }\n+/// }\n+///\n+/// impl WorkItem for MyTask {\n+///     type Pointer = Arc<MyTask>;\n+///\n+///     fn run(this: Arc<MyTask>) {\n+///         // process this task\n+///         this.done.complete_all();\n+///     }\n+/// }\n+///\n+/// let task = MyTask::new()?;\n+/// task.wait_for_completion();\n+/// # Ok::<(), Error>(())\n+/// ```\n+#[pin_data]\n+pub struct Completion {\n+    #[pin]\n+    inner: Opaque<bindings::completion>,\n+}\n+\n+// SAFETY: `Completion` is safe to be send to any task.\n+unsafe impl Send for Completion {}\n+\n+// SAFETY: `Completion` is safe to be accessed concurrently.\n+unsafe impl Sync for Completion {}\n+\n+impl Completion {\n+    /// Create an initializer for a new [`Completion`].\n+    pub fn new() -> impl PinInit<Self> {\n+        pin_init!(Self {\n+            inner <- Opaque::ffi_init(|slot: *mut bindings::completion| {\n+                // SAFETY: `slot` is a valid pointer to an uninitialized `struct completion`.\n+                unsafe { bindings::init_completion(slot) };\n+            }),\n+        })\n+    }\n+\n+    fn as_raw(&self) -> *mut bindings::completion {\n+        self.inner.get()\n+    }\n+\n+    /// Signal all tasks waiting on this completion.\n+    ///\n+    /// This method wakes up all tasks waiting on this completion; after this operation the\n+    /// completion is permanently done, i.e. signals all current and future waiters.\n+    pub fn complete_all(&self) {\n+        // SAFETY: `self.as_raw()` is a pointer to a valid `struct completion`.\n+        unsafe { bindings::complete_all(self.as_raw()) };\n+    }\n+\n+    /// Wait for completion of a task.\n+    ///\n+    /// This method waits for the completion of a task; it is not interruptible and there is no\n+    /// timeout.\n+    ///\n+    /// See also [`Completion::complete_all`].\n+    pub fn wait_for_completion(&self) {\n+        // SAFETY: `self.as_raw()` is a pointer to a valid `struct completion`.\n+        unsafe { bindings::wait_for_completion(self.as_raw()) };\n+    }\n+}",
    "stats": {
      "insertions": 183,
      "deletions": 21,
      "files": 9
    }
  },
  {
    "sha": "28c0d7756fd9b69971073c946076e35851a7133b",
    "message": "Merge branch '100GbE' of git://git.kernel.org/pub/scm/linux/kernel/git/tnguy/net-queue\n\nTony Nguyen says:\n\n====================\nIntel Wired LAN Driver Updates 2025-06-17 (ice, e1000e)\n\nFor ice:\nKrishna Kumar modifies aRFS match criteria to correctly identify\nmatching filters.\n\nGrzegorz fixes a memory leak in eswitch legacy mode.\n\nFor e1000e:\nVitaly sets clock frequency on some Nahum systems which may misreport\ntheir value.\n\n* '100GbE' of git://git.kernel.org/pub/scm/linux/kernel/git/tnguy/net-queue:\n  e1000e: set fixed clock frequency indication for Nahum 11 and Nahum 13\n  ice: fix eswitch code memory leak in reset scenario\n  net: ice: Perform accurate aRFS flow match\n====================\n\nLink: https://patch.msgid.link/20250617172444.1419560-1-anthony.l.nguyen@intel.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-06-18T14:15:15-07:00",
    "files_changed": [
      "drivers/net/ethernet/intel/e1000e/netdev.c",
      "drivers/net/ethernet/intel/e1000e/ptp.c",
      "drivers/net/ethernet/intel/ice/ice_arfs.c",
      "drivers/net/ethernet/intel/ice/ice_eswitch.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c\nindex a96f4cfa6e17..7719e15813ee 100644\n--- a/drivers/net/ethernet/intel/e1000e/netdev.c\n+++ b/drivers/net/ethernet/intel/e1000e/netdev.c\n@@ -3534,9 +3534,6 @@ s32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n \tcase e1000_pch_cnp:\n \tcase e1000_pch_tgp:\n \tcase e1000_pch_adp:\n-\tcase e1000_pch_mtp:\n-\tcase e1000_pch_lnp:\n-\tcase e1000_pch_ptp:\n \tcase e1000_pch_nvp:\n \t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n \t\t\t/* Stable 24MHz frequency */\n@@ -3552,6 +3549,17 @@ s32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n \t\t\tadapter->cc.shift = shift;\n \t\t}\n \t\tbreak;\n+\tcase e1000_pch_mtp:\n+\tcase e1000_pch_lnp:\n+\tcase e1000_pch_ptp:\n+\t\t/* System firmware can misreport this value, so set it to a\n+\t\t * stable 38400KHz frequency.\n+\t\t */\n+\t\tincperiod = INCPERIOD_38400KHZ;\n+\t\tincvalue = INCVALUE_38400KHZ;\n+\t\tshift = INCVALUE_SHIFT_38400KHZ;\n+\t\tadapter->cc.shift = shift;\n+\t\tbreak;\n \tcase e1000_82574:\n \tcase e1000_82583:\n \t\t/* Stable 25MHz frequency */\ndiff --git a/drivers/net/ethernet/intel/e1000e/ptp.c b/drivers/net/ethernet/intel/e1000e/ptp.c\nindex 89d57dd911dc..ea3c3eb2ef20 100644\n--- a/drivers/net/ethernet/intel/e1000e/ptp.c\n+++ b/drivers/net/ethernet/intel/e1000e/ptp.c\n@@ -295,15 +295,17 @@ void e1000e_ptp_init(struct e1000_adapter *adapter)\n \tcase e1000_pch_cnp:\n \tcase e1000_pch_tgp:\n \tcase e1000_pch_adp:\n-\tcase e1000_pch_mtp:\n-\tcase e1000_pch_lnp:\n-\tcase e1000_pch_ptp:\n \tcase e1000_pch_nvp:\n \t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI)\n \t\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_24MHZ;\n \t\telse\n \t\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_38400KHZ;\n \t\tbreak;\n+\tcase e1000_pch_mtp:\n+\tcase e1000_pch_lnp:\n+\tcase e1000_pch_ptp:\n+\t\tadapter->ptp_clock_info.max_adj = MAX_PPB_38400KHZ;\n+\t\tbreak;\n \tcase e1000_82574:\n \tcase e1000_82583:\n \t\tadapter->ptp_clock_info.max_adj = MAX_PPB_25MHZ;\ndiff --git a/drivers/net/ethernet/intel/ice/ice_arfs.c b/drivers/net/ethernet/intel/ice/ice_arfs.c\nindex 2bc5c7f59844..1f7834c03550 100644\n--- a/drivers/net/ethernet/intel/ice/ice_arfs.c\n+++ b/drivers/net/ethernet/intel/ice/ice_arfs.c\n@@ -377,6 +377,50 @@ ice_arfs_is_perfect_flow_set(struct ice_hw *hw, __be16 l3_proto, u8 l4_proto)\n \treturn false;\n }\n \n+/**\n+ * ice_arfs_cmp - Check if aRFS filter matches this flow.\n+ * @fltr_info: filter info of the saved ARFS entry.\n+ * @fk: flow dissector keys.\n+ * @n_proto:  One of htons(ETH_P_IP) or htons(ETH_P_IPV6).\n+ * @ip_proto: One of IPPROTO_TCP or IPPROTO_UDP.\n+ *\n+ * Since this function assumes limited values for n_proto and ip_proto, it\n+ * is meant to be called only from ice_rx_flow_steer().\n+ *\n+ * Return:\n+ * * true\t- fltr_info refers to the same flow as fk.\n+ * * false\t- fltr_info and fk refer to different flows.\n+ */\n+static bool\n+ice_arfs_cmp(const struct ice_fdir_fltr *fltr_info, const struct flow_keys *fk,\n+\t     __be16 n_proto, u8 ip_proto)\n+{\n+\t/* Determine if the filter is for IPv4 or IPv6 based on flow_type,\n+\t * which is one of ICE_FLTR_PTYPE_NONF_IPV{4,6}_{TCP,UDP}.\n+\t */\n+\tbool is_v4 = fltr_info->flow_type == ICE_FLTR_PTYPE_NONF_IPV4_TCP ||\n+\t\t     fltr_info->flow_type == ICE_FLTR_PTYPE_NONF_IPV4_UDP;\n+\n+\t/* Following checks are arranged in the quickest and most discriminative\n+\t * fields first for early failure.\n+\t */\n+\tif (is_v4)\n+\t\treturn n_proto == htons(ETH_P_IP) &&\n+\t\t\tfltr_info->ip.v4.src_port == fk->ports.src &&\n+\t\t\tfltr_info->ip.v4.dst_port == fk->ports.dst &&\n+\t\t\tfltr_info->ip.v4.src_ip == fk->addrs.v4addrs.src &&\n+\t\t\tfltr_info->ip.v4.dst_ip == fk->addrs.v4addrs.dst &&\n+\t\t\tfltr_info->ip.v4.proto == ip_proto;\n+\n+\treturn fltr_info->ip.v6.src_port == fk->ports.src &&\n+\t\tfltr_info->ip.v6.dst_port == fk->ports.dst &&\n+\t\tfltr_info->ip.v6.proto == ip_proto &&\n+\t\t!memcmp(&fltr_info->ip.v6.src_ip, &fk->addrs.v6addrs.src,\n+\t\t\tsizeof(struct in6_addr)) &&\n+\t\t!memcmp(&fltr_info->ip.v6.dst_ip, &fk->addrs.v6addrs.dst,\n+\t\t\tsizeof(struct in6_addr));\n+}\n+\n /**\n  * ice_rx_flow_steer - steer the Rx flow to where application is being run\n  * @netdev: ptr to the netdev being adjusted\n@@ -448,6 +492,10 @@ ice_rx_flow_steer(struct net_device *netdev, const struct sk_buff *skb,\n \t\t\tcontinue;\n \n \t\tfltr_info = &arfs_entry->fltr_info;\n+\n+\t\tif (!ice_arfs_cmp(fltr_info, &fk, n_proto, ip_proto))\n+\t\t\tcontinue;\n+\n \t\tret = fltr_info->fltr_id;\n \n \t\tif (fltr_info->q_index == rxq_idx ||\ndiff --git a/drivers/net/ethernet/intel/ice/ice_eswitch.c b/drivers/net/ethernet/intel/ice/ice_eswitch.c\nindex 6aae03771746..2e4f0969035f 100644\n--- a/drivers/net/ethernet/intel/ice/ice_eswitch.c\n+++ b/drivers/net/ethernet/intel/ice/ice_eswitch.c\n@@ -508,10 +508,14 @@ ice_eswitch_attach(struct ice_pf *pf, struct ice_repr *repr, unsigned long *id)\n  */\n int ice_eswitch_attach_vf(struct ice_pf *pf, struct ice_vf *vf)\n {\n-\tstruct ice_repr *repr = ice_repr_create_vf(vf);\n \tstruct devlink *devlink = priv_to_devlink(pf);\n+\tstruct ice_repr *repr;\n \tint err;\n \n+\tif (!ice_is_eswitch_mode_switchdev(pf))\n+\t\treturn 0;\n+\n+\trepr = ice_repr_create_vf(vf);\n \tif (IS_ERR(repr))\n \t\treturn PTR_ERR(repr);\n ",
    "stats": {
      "insertions": 69,
      "deletions": 7,
      "files": 4
    }
  }
]
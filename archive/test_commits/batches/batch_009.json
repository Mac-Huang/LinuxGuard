[
  {
    "sha": "aa9552438ebf015fc5f9f890dbfe39f0c53cf37e",
    "message": "nbd: fix uaf in nbd_genl_connect() error path\n\nThere is a use-after-free issue in nbd:\n\nblock nbd6: Receive control failed (result -104)\nblock nbd6: shutting down sockets\n==================================================================\nBUG: KASAN: slab-use-after-free in recv_work+0x694/0xa80 drivers/block/nbd.c:1022\nWrite of size 4 at addr ffff8880295de478 by task kworker/u33:0/67\n\nCPU: 2 UID: 0 PID: 67 Comm: kworker/u33:0 Not tainted 6.15.0-rc5-syzkaller-00123-g2c89c1b655c0 #0 PREEMPT(full)\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nWorkqueue: nbd6-recv recv_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xc3/0x670 mm/kasan/report.c:521\n kasan_report+0xe0/0x110 mm/kasan/report.c:634\n check_region_inline mm/kasan/generic.c:183 [inline]\n kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189\n instrument_atomic_read_write include/linux/instrumented.h:96 [inline]\n atomic_dec include/linux/atomic/atomic-instrumented.h:592 [inline]\n recv_work+0x694/0xa80 drivers/block/nbd.c:1022\n process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238\n process_scheduled_works kernel/workqueue.c:3319 [inline]\n worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400\n kthread+0x3c2/0x780 kernel/kthread.c:464\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245\n </TASK>\n\nnbd_genl_connect() does not properly stop the device on certain\nerror paths after nbd_start_device() has been called. This causes\nthe error path to put nbd->config while recv_work continue to use\nthe config after putting it, leading to use-after-free in recv_work.\n\nThis patch moves nbd_start_device() after the backend file creation.\n\nReported-by: syzbot+48240bab47e705c53126@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/all/68227a04.050a0220.f2294.00b5.GAE@google.com/T/\nFixes: 6497ef8df568 (\"nbd: provide a way for userspace processes to identify device backends\")\nSigned-off-by: Zheng Qixing <zhengqixing@huawei.com>\nReviewed-by: Yu Kuai <yukuai3@huawei.com>\nLink: https://lore.kernel.org/r/20250612132405.364904-1-zhengqixing@huaweicloud.com\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "author": "Zheng Qixing",
    "date": "2025-07-07T11:58:08-06:00",
    "files_changed": [
      "drivers/block/nbd.c"
    ],
    "diff": "diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c\nindex 7bdc7eb808ea..2592bd19ebc1 100644\n--- a/drivers/block/nbd.c\n+++ b/drivers/block/nbd.c\n@@ -2198,9 +2198,7 @@ static int nbd_genl_connect(struct sk_buff *skb, struct genl_info *info)\n \t\t\t\tgoto out;\n \t\t}\n \t}\n-\tret = nbd_start_device(nbd);\n-\tif (ret)\n-\t\tgoto out;\n+\n \tif (info->attrs[NBD_ATTR_BACKEND_IDENTIFIER]) {\n \t\tnbd->backend = nla_strdup(info->attrs[NBD_ATTR_BACKEND_IDENTIFIER],\n \t\t\t\t\t  GFP_KERNEL);\n@@ -2216,6 +2214,8 @@ static int nbd_genl_connect(struct sk_buff *skb, struct genl_info *info)\n \t\tgoto out;\n \t}\n \tset_bit(NBD_RT_HAS_BACKEND_FILE, &config->runtime_flags);\n+\n+\tret = nbd_start_device(nbd);\n out:\n \tmutex_unlock(&nbd->config_lock);\n \tif (!ret) {",
    "stats": {
      "insertions": 3,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "03ee8f73801a8f46d83dfc2bf73fb9ffa5a21602",
    "message": "wifi: mt76: mt7925: Fix null-ptr-deref in mt7925_thermal_init()\n\ndevm_kasprintf() returns NULL on error. Currently, mt7925_thermal_init()\ndoes not check for this case, which results in a NULL pointer\ndereference.\n\nAdd NULL check after devm_kasprintf() to prevent this issue.\n\nFixes: 396e41a74a88 (\"wifi: mt76: mt7925: support temperature sensor\")\nSigned-off-by: Henry Martin <bsdhenryma@tencent.com>\nReviewed-by: AngeloGioacchino Del Regno <angelogioacchino.delregno@collabora.com>\nLink: https://patch.msgid.link/20250625124901.1839832-1-bsdhenryma@tencent.com\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
    "author": "Henry Martin",
    "date": "2025-07-07T18:05:52+02:00",
    "files_changed": [
      "drivers/net/wireless/mediatek/mt76/mt7925/init.c"
    ],
    "diff": "diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/init.c b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\nindex 2a83ff59a968..4249bad83c93 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n@@ -52,6 +52,8 @@ static int mt7925_thermal_init(struct mt792x_phy *phy)\n \n \tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7925_%s\",\n \t\t\t      wiphy_name(wiphy));\n+\tif (!name)\n+\t\treturn -ENOMEM;\n \n \thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,\n \t\t\t\t\t\t       mt7925_hwmon_groups);",
    "stats": {
      "insertions": 2,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "35ad47c0b3da04b00b19a8b9ed5632e2f2520472",
    "message": "wifi: mt76: mt7925: prevent NULL pointer dereference in mt7925_sta_set_decap_offload()\n\nAdd a NULL check for msta->vif before accessing its members to prevent\na kernel panic in AP mode deployment. This also fix the issue reported\nin [1].\n\nThe crash occurs when this function is triggered before the station is\nfully initialized. The call trace shows a page fault at\nmt7925_sta_set_decap_offload() due to accessing resources when msta->vif\nis NULL.\n\nFix this by adding an early return if msta->vif is NULL and also check\nwcid.sta is ready. This ensures we only proceed with decap offload\nconfiguration when the station's state is properly initialized.\n\n[14739.655703] Unable to handle kernel paging request at virtual address ffffffffffffffa0\n[14739.811820] CPU: 0 UID: 0 PID: 895854 Comm: hostapd Tainted: G\n[14739.821394] Tainted: [C]=CRAP, [O]=OOT_MODULE\n[14739.825746] Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT)\n[14739.831577] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[14739.838538] pc : mt7925_sta_set_decap_offload+0xc0/0x1b8 [mt7925_common]\n[14739.845271] lr : mt7925_sta_set_decap_offload+0x58/0x1b8 [mt7925_common]\n[14739.851985] sp : ffffffc085efb500\n[14739.855295] x29: ffffffc085efb500 x28: 0000000000000000 x27: ffffff807803a158\n[14739.862436] x26: ffffff8041ececb8 x25: 0000000000000001 x24: 0000000000000001\n[14739.869577] x23: 0000000000000001 x22: 0000000000000008 x21: ffffff8041ecea88\n[14739.876715] x20: ffffff8041c19ca0 x19: ffffff8078031fe0 x18: 0000000000000000\n[14739.883853] x17: 0000000000000000 x16: ffffffe2aeac1110 x15: 000000559da48080\n[14739.890991] x14: 0000000000000001 x13: 0000000000000000 x12: 0000000000000000\n[14739.898130] x11: 0a10020001008e88 x10: 0000000000001a50 x9 : ffffffe26457bfa0\n[14739.905269] x8 : ffffff8042013bb0 x7 : ffffff807fb6cbf8 x6 : dead000000000100\n[14739.912407] x5 : dead000000000122 x4 : ffffff80780326c8 x3 : 0000000000000000\n[14739.919546] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffffff8041ececb8\n[14739.926686] Call trace:\n[14739.929130]  mt7925_sta_set_decap_offload+0xc0/0x1b8 [mt7925_common]\n[14739.935505]  ieee80211_check_fast_rx+0x19c/0x510 [mac80211]\n[14739.941344]  _sta_info_move_state+0xe4/0x510 [mac80211]\n[14739.946860]  sta_info_move_state+0x1c/0x30 [mac80211]\n[14739.952116]  sta_apply_auth_flags.constprop.0+0x90/0x1b0 [mac80211]\n[14739.958708]  sta_apply_parameters+0x234/0x5e0 [mac80211]\n[14739.964332]  ieee80211_add_station+0xdc/0x190 [mac80211]\n[14739.969950]  nl80211_new_station+0x46c/0x670 [cfg80211]\n[14739.975516]  genl_family_rcv_msg_doit+0xdc/0x150\n[14739.980158]  genl_rcv_msg+0x218/0x298\n[14739.983830]  netlink_rcv_skb+0x64/0x138\n[14739.987670]  genl_rcv+0x40/0x60\n[14739.990816]  netlink_unicast+0x314/0x380\n[14739.994742]  netlink_sendmsg+0x198/0x3f0\n[14739.998664]  __sock_sendmsg+0x64/0xc0\n[14740.002324]  ____sys_sendmsg+0x260/0x298\n[14740.006242]  ___sys_sendmsg+0xb4/0x110\n\nCc: stable@vger.kernel.org\nLink: https://github.com/morrownr/USB-WiFi/issues/603 [1]\nFixes: b859ad65309a (\"wifi: mt76: mt7925: add link handling in mt7925_sta_set_decap_offload\")\nSigned-off-by: Deren Wu <deren.wu@mediatek.com>\nLink: https://patch.msgid.link/35aedbffa050e98939264300407a52ba4e236d52.1748149855.git.deren.wu@mediatek.com\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
    "author": "Deren Wu",
    "date": "2025-07-07T17:42:20+02:00",
    "files_changed": [
      "drivers/net/wireless/mediatek/mt76/mt7925/main.c"
    ],
    "diff": "diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/main.c b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\nindex f0f1b1e4d507..5b001548dffc 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n@@ -1603,6 +1603,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \tunsigned long valid = mvif->valid_links;\n \tu8 i;\n \n+\tif (!msta->vif)\n+\t\treturn;\n+\n \tmt792x_mutex_acquire(dev);\n \n \tvalid = ieee80211_vif_is_mld(vif) ? mvif->valid_links : BIT(0);\n@@ -1617,6 +1620,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \t\telse\n \t\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &mlink->wcid.flags);\n \n+\t\tif (!mlink->wcid.sta)\n+\t\t\tcontinue;\n+\n \t\tmt7925_mcu_wtbl_update_hdr_trans(dev, vif, sta, i);\n \t}\n ",
    "stats": {
      "insertions": 6,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "3dd6f67c669c860b93ff533f790f23ee1cb36f25",
    "message": "wifi: mt76: Move RCU section in mt7996_mcu_add_rate_ctrl()\n\nSince mt76_mcu_skb_send_msg() routine can't be executed in atomic context,\nmove RCU section in mt7996_mcu_add_rate_ctrl() and execute\nmt76_mcu_skb_send_msg() in non-atomic context. This is a preliminary\npatch to fix a 'sleep while atomic' issue in mt7996_mac_sta_rc_work().\n\nFixes: 0762bdd30279 (\"wifi: mt76: mt7996: rework mt7996_mac_sta_rc_work to support MLO\")\nSigned-off-by: Lorenzo Bianconi <lorenzo@kernel.org>\nLink: https://patch.msgid.link/20250605-mt7996-sleep-while-atomic-v1-4-d46d15f9203c@kernel.org\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
    "author": "Lorenzo Bianconi",
    "date": "2025-07-07T17:42:20+02:00",
    "files_changed": [
      "drivers/net/wireless/mediatek/mt76/mt7996/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h"
    ],
    "diff": "diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\nindex 7444bd374b50..329dc9edc80d 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n@@ -2356,7 +2356,6 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)\n \tstruct ieee80211_bss_conf *link_conf;\n \tstruct ieee80211_link_sta *link_sta;\n \tstruct mt7996_sta_link *msta_link;\n-\tstruct mt7996_vif_link *link;\n \tstruct mt76_vif_link *mlink;\n \tstruct ieee80211_sta *sta;\n \tstruct ieee80211_vif *vif;\n@@ -2398,13 +2397,10 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)\n \n \t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n \n-\t\tlink = (struct mt7996_vif_link *)mlink;\n-\n \t\tif (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |\n \t\t\t       IEEE80211_RC_NSS_CHANGED |\n \t\t\t       IEEE80211_RC_BW_CHANGED))\n-\t\t\tmt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t link_sta, link, msta_link,\n+\t\t\tmt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n \t\t\t\t\t\t link_id, true);\n \n \t\tif (changed & IEEE80211_RC_SMPS_CHANGED)\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/main.c b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\nindex a096b5bab001..07dd75ce94a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n@@ -1112,10 +1112,8 @@ mt7996_mac_sta_event(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t\tif (err)\n \t\t\t\treturn err;\n \n-\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t       link_sta, link,\n-\t\t\t\t\t\t       msta_link, link_id,\n-\t\t\t\t\t\t       false);\n+\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n+\t\t\t\t\t\t       link_id, false);\n \t\t\tif (err)\n \t\t\t\treturn err;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex 742497ba2a6b..77ab1f4854a4 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n@@ -2201,23 +2201,44 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,\n \tmemset(ra->rx_rcpi, INIT_RCPI, sizeof(ra->rx_rcpi));\n }\n \n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link,\n-\t\t\t     u8 link_id, bool changed)\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed)\n {\n-\tstruct mt7996_sta *msta = msta_link->sta;\n+\tstruct ieee80211_bss_conf *link_conf;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n+\tstruct ieee80211_sta *sta;\n \tstruct sk_buff *skb;\n-\tint ret;\n+\tint ret = -ENODEV;\n+\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n+\tif (!link_conf)\n+\t\tgoto error_unlock;\n \n \tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\tret = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \t/* firmware rc algorithm refers to sta_rec_he for HE control.\n \t * once dev->rc_work changes the settings driver should also\n@@ -2231,12 +2252,19 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t */\n \tmt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, link_conf, link_sta, link);\n \n+\trcu_read_unlock();\n+\n \tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n \tif (ret)\n \t\treturn ret;\n \n \treturn mt7996_mcu_add_rate_ctrl_fixed(dev, msta, vif, link_id);\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn ret;\n }\n \n static int\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\nindex a529c2bae7cb..33ac16b64ef1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n@@ -620,13 +620,9 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,\n int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,\n \t\t\t    struct mt7996_vif_link *link,\n \t\t\t    struct ieee80211_he_obss_pd *he_obss_pd);\n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link,\n-\t\t\t     u8 link_id, bool changed);\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed);\n int mt7996_set_channel(struct mt76_phy *mphy);\n int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);\n int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,",
    "stats": {
      "insertions": 45,
      "deletions": 27,
      "files": 4
    }
  },
  {
    "sha": "28d519d0d493a8cf3f8ca01f10d962c56cec1825",
    "message": "wifi: mt76: Move RCU section in mt7996_mcu_add_rate_ctrl_fixed()\n\nSince mt7996_mcu_set_fixed_field() can't be executed in a RCU critical\nsection, move RCU section in mt7996_mcu_add_rate_ctrl_fixed() and run\nmt7996_mcu_set_fixed_field() in non-atomic context. This is a\npreliminary patch to fix a 'sleep while atomic' issue in\nmt7996_mac_sta_rc_work().\n\nFixes: 0762bdd30279 (\"wifi: mt76: mt7996: rework mt7996_mac_sta_rc_work to support MLO\")\nSigned-off-by: Lorenzo Bianconi <lorenzo@kernel.org>\nLink: https://patch.msgid.link/20250605-mt7996-sleep-while-atomic-v1-3-d46d15f9203c@kernel.org\nSigned-off-by: Felix Fietkau <nbd@nbd.name>",
    "author": "Lorenzo Bianconi",
    "date": "2025-07-07T17:42:20+02:00",
    "files_changed": [
      "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c"
    ],
    "diff": "diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex 33c61e795b73..742497ba2a6b 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n@@ -1977,51 +1977,74 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n }\n \n static int\n-mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       u8 link_id)\n+mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       struct ieee80211_vif *vif, u8 link_id)\n {\n-\tstruct cfg80211_chan_def *chandef = &link->phy->mt76->chandef;\n-\tstruct cfg80211_bitrate_mask *mask = &link->bitrate_mask;\n-\tenum nl80211_band band = chandef->chan->band;\n-\tstruct mt7996_sta *msta = msta_link->sta;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct cfg80211_bitrate_mask mask;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n \tstruct sta_phy_uni phy = {};\n-\tint ret, nrates = 0;\n+\tstruct ieee80211_sta *sta;\n+\tint ret, nrates = 0, idx;\n+\tenum nl80211_band band;\n+\tbool has_he;\n \n #define __sta_phy_bitrate_mask_check(_mcs, _gi, _ht, _he)\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\t\\\n-\t\tu8 i, gi = mask->control[band]._gi;\t\t\t\t\\\n+\t\tu8 i, gi = mask.control[band]._gi;\t\t\t\t\\\n \t\tgi = (_he) ? gi : gi == NL80211_TXRATE_FORCE_SGI;\t\t\\\n \t\tphy.sgi = gi;\t\t\t\t\t\t\t\\\n-\t\tphy.he_ltf = mask->control[band].he_ltf;\t\t\t\\\n-\t\tfor (i = 0; i < ARRAY_SIZE(mask->control[band]._mcs); i++) {\t\\\n-\t\t\tif (!mask->control[band]._mcs[i])\t\t\t\\\n+\t\tphy.he_ltf = mask.control[band].he_ltf;\t\t\t\t\\\n+\t\tfor (i = 0; i < ARRAY_SIZE(mask.control[band]._mcs); i++) {\t\\\n+\t\t\tif (!mask.control[band]._mcs[i])\t\t\t\\\n \t\t\t\tcontinue;\t\t\t\t\t\\\n-\t\t\tnrates += hweight16(mask->control[band]._mcs[i]);\t\\\n-\t\t\tphy.mcs = ffs(mask->control[band]._mcs[i]) - 1;\t\t\\\n+\t\t\tnrates += hweight16(mask.control[band]._mcs[i]);\t\\\n+\t\t\tphy.mcs = ffs(mask.control[band]._mcs[i]) - 1;\t\t\\\n \t\t\tif (_ht)\t\t\t\t\t\t\\\n \t\t\t\tphy.mcs += 8 * i;\t\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\t\\\n \t} while (0)\n \n-\tif (link_sta->he_cap.has_he) {\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tband = link->phy->mt76->chandef.chan->band;\n+\thas_he = link_sta->he_cap.has_he;\n+\tmask = link->bitrate_mask;\n+\tidx = msta_link->wcid.idx;\n+\n+\tif (has_he) {\n \t\t__sta_phy_bitrate_mask_check(he_mcs, he_gi, 0, 1);\n \t} else if (link_sta->vht_cap.vht_supported) {\n \t\t__sta_phy_bitrate_mask_check(vht_mcs, gi, 0, 0);\n \t} else if (link_sta->ht_cap.ht_supported) {\n \t\t__sta_phy_bitrate_mask_check(ht_mcs, gi, 1, 0);\n \t} else {\n-\t\tnrates = hweight32(mask->control[band].legacy);\n-\t\tphy.mcs = ffs(mask->control[band].legacy) - 1;\n+\t\tnrates = hweight32(mask.control[band].legacy);\n+\t\tphy.mcs = ffs(mask.control[band].legacy) - 1;\n \t}\n+\n+\trcu_read_unlock();\n+\n #undef __sta_phy_bitrate_mask_check\n \n \t/* fall back to auto rate control */\n-\tif (mask->control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n-\t    mask->control[band].he_gi == GENMASK(7, 0) &&\n-\t    mask->control[band].he_ltf == GENMASK(7, 0) &&\n+\tif (mask.control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n+\t    mask.control[band].he_gi == GENMASK(7, 0) &&\n+\t    mask.control[band].he_ltf == GENMASK(7, 0) &&\n \t    nrates != 1)\n \t\treturn 0;\n \n@@ -2034,16 +2057,16 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \t}\n \n \t/* fixed GI */\n-\tif (mask->control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n-\t    mask->control[band].he_gi != GENMASK(7, 0)) {\n+\tif (mask.control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n+\t    mask.control[band].he_gi != GENMASK(7, 0)) {\n \t\tu32 addr;\n \n \t\t/* firmware updates only TXCMD but doesn't take WTBL into\n \t\t * account, so driver should update here to reflect the\n \t\t * actual txrate hardware sends out.\n \t\t */\n-\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, msta_link->wcid.idx, 7);\n-\t\tif (link_sta->he_cap.has_he)\n+\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 7);\n+\t\tif (has_he)\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(31, 24), phy.sgi);\n \t\telse\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);\n@@ -2055,7 +2078,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \t}\n \n \t/* fixed HE_LTF */\n-\tif (mask->control[band].he_ltf != GENMASK(7, 0)) {\n+\tif (mask.control[band].he_ltf != GENMASK(7, 0)) {\n \t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_HE_LTF);\n \t\tif (ret)\n@@ -2063,6 +2086,11 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n \t}\n \n \treturn 0;\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn -ENODEV;\n }\n \n static void\n@@ -2181,6 +2209,7 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t     struct mt7996_sta_link *msta_link,\n \t\t\t     u8 link_id, bool changed)\n {\n+\tstruct mt7996_sta *msta = msta_link->sta;\n \tstruct sk_buff *skb;\n \tint ret;\n \n@@ -2207,8 +2236,7 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \tif (ret)\n \t\treturn ret;\n \n-\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, link_sta, link, msta_link,\n-\t\t\t\t\t      link_id);\n+\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, msta, vif, link_id);\n }\n \n static int",
    "stats": {
      "insertions": 57,
      "deletions": 29,
      "files": 1
    }
  }
]
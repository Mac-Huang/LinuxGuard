[
  {
    "sha": "40f92e79b0aabbf3575e371f9054657a421a3e79",
    "message": "Merge tag 'block-6.16-20250710' of git://git.kernel.dk/linux\n\nPull block fixes from Jens Axboe:\n\n - MD changes via Yu:\n     - fix UAF due to stack memory used for bio mempool (Jinchao)\n     - fix raid10/raid1 nowait IO error path (Nigel and Qixing)\n     - fix kernel crash from reading bitmap sysfs entry (HÃ¥kon)\n\n - Fix for a UAF in the nbd connect error path\n\n - Fix for blocksize being bigger than pagesize, if THP isn't enabled\n\n* tag 'block-6.16-20250710' of git://git.kernel.dk/linux:\n  block: reject bs > ps block devices when THP is disabled\n  nbd: fix uaf in nbd_genl_connect() error path\n  md/md-bitmap: fix GPF in bitmap_get_stats()\n  md/raid1,raid10: strip REQ_NOWAIT from member bios\n  raid10: cleanup memleak at raid10_make_request\n  md/raid1: Fix stack memory use after return in raid1_reshape",
    "author": "Linus Torvalds",
    "date": "2025-07-11T10:35:54-07:00",
    "files_changed": [
      "drivers/block/nbd.c",
      "drivers/md/md-bitmap.c",
      "drivers/md/raid1.c",
      "drivers/md/raid10.c",
      "include/linux/blkdev.h"
    ],
    "diff": "diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c\nindex 7bdc7eb808ea..2592bd19ebc1 100644\n--- a/drivers/block/nbd.c\n+++ b/drivers/block/nbd.c\n@@ -2198,9 +2198,7 @@ static int nbd_genl_connect(struct sk_buff *skb, struct genl_info *info)\n \t\t\t\tgoto out;\n \t\t}\n \t}\n-\tret = nbd_start_device(nbd);\n-\tif (ret)\n-\t\tgoto out;\n+\n \tif (info->attrs[NBD_ATTR_BACKEND_IDENTIFIER]) {\n \t\tnbd->backend = nla_strdup(info->attrs[NBD_ATTR_BACKEND_IDENTIFIER],\n \t\t\t\t\t  GFP_KERNEL);\n@@ -2216,6 +2214,8 @@ static int nbd_genl_connect(struct sk_buff *skb, struct genl_info *info)\n \t\tgoto out;\n \t}\n \tset_bit(NBD_RT_HAS_BACKEND_FILE, &config->runtime_flags);\n+\n+\tret = nbd_start_device(nbd);\n out:\n \tmutex_unlock(&nbd->config_lock);\n \tif (!ret) {\ndiff --git a/drivers/md/md-bitmap.c b/drivers/md/md-bitmap.c\nindex bd694910b01b..7f524a26cebc 100644\n--- a/drivers/md/md-bitmap.c\n+++ b/drivers/md/md-bitmap.c\n@@ -2366,8 +2366,7 @@ static int bitmap_get_stats(void *data, struct md_bitmap_stats *stats)\n \n \tif (!bitmap)\n \t\treturn -ENOENT;\n-\tif (!bitmap->mddev->bitmap_info.external &&\n-\t    !bitmap->storage.sb_page)\n+\tif (!bitmap->storage.sb_page)\n \t\treturn -EINVAL;\n \tsb = kmap_local_page(bitmap->storage.sb_page);\n \tstats->sync_size = le64_to_cpu(sb->sync_size);\ndiff --git a/drivers/md/raid1.c b/drivers/md/raid1.c\nindex 19c5a0ce5a40..64b8176907a9 100644\n--- a/drivers/md/raid1.c\n+++ b/drivers/md/raid1.c\n@@ -1399,7 +1399,7 @@ static void raid1_read_request(struct mddev *mddev, struct bio *bio,\n \t}\n \tread_bio = bio_alloc_clone(mirror->rdev->bdev, bio, gfp,\n \t\t\t\t   &mddev->bio_set);\n-\n+\tread_bio->bi_opf &= ~REQ_NOWAIT;\n \tr1_bio->bios[rdisk] = read_bio;\n \n \tread_bio->bi_iter.bi_sector = r1_bio->sector +\n@@ -1649,6 +1649,7 @@ static void raid1_write_request(struct mddev *mddev, struct bio *bio,\n \t\t\t\twait_for_serialization(rdev, r1_bio);\n \t\t}\n \n+\t\tmbio->bi_opf &= ~REQ_NOWAIT;\n \t\tr1_bio->bios[i] = mbio;\n \n \t\tmbio->bi_iter.bi_sector\t= (r1_bio->sector + rdev->data_offset);\n@@ -3428,6 +3429,7 @@ static int raid1_reshape(struct mddev *mddev)\n \t/* ok, everything is stopped */\n \toldpool = conf->r1bio_pool;\n \tconf->r1bio_pool = newpool;\n+\tinit_waitqueue_head(&conf->r1bio_pool.wait);\n \n \tfor (d = d2 = 0; d < conf->raid_disks; d++) {\n \t\tstruct md_rdev *rdev = conf->mirrors[d].rdev;\ndiff --git a/drivers/md/raid10.c b/drivers/md/raid10.c\nindex b74780af4c22..c9bd2005bfd0 100644\n--- a/drivers/md/raid10.c\n+++ b/drivers/md/raid10.c\n@@ -1182,8 +1182,11 @@ static void raid10_read_request(struct mddev *mddev, struct bio *bio,\n \t\t}\n \t}\n \n-\tif (!regular_request_wait(mddev, conf, bio, r10_bio->sectors))\n+\tif (!regular_request_wait(mddev, conf, bio, r10_bio->sectors)) {\n+\t\traid_end_bio_io(r10_bio);\n \t\treturn;\n+\t}\n+\n \trdev = read_balance(conf, r10_bio, &max_sectors);\n \tif (!rdev) {\n \t\tif (err_rdev) {\n@@ -1221,6 +1224,7 @@ static void raid10_read_request(struct mddev *mddev, struct bio *bio,\n \t\tr10_bio->master_bio = bio;\n \t}\n \tread_bio = bio_alloc_clone(rdev->bdev, bio, gfp, &mddev->bio_set);\n+\tread_bio->bi_opf &= ~REQ_NOWAIT;\n \n \tr10_bio->devs[slot].bio = read_bio;\n \tr10_bio->devs[slot].rdev = rdev;\n@@ -1256,6 +1260,7 @@ static void raid10_write_one_disk(struct mddev *mddev, struct r10bio *r10_bio,\n \t\t\t     conf->mirrors[devnum].rdev;\n \n \tmbio = bio_alloc_clone(rdev->bdev, bio, GFP_NOIO, &mddev->bio_set);\n+\tmbio->bi_opf &= ~REQ_NOWAIT;\n \tif (replacement)\n \t\tr10_bio->devs[n_copy].repl_bio = mbio;\n \telse\n@@ -1370,8 +1375,11 @@ static void raid10_write_request(struct mddev *mddev, struct bio *bio,\n \t}\n \n \tsectors = r10_bio->sectors;\n-\tif (!regular_request_wait(mddev, conf, bio, sectors))\n+\tif (!regular_request_wait(mddev, conf, bio, sectors)) {\n+\t\traid_end_bio_io(r10_bio);\n \t\treturn;\n+\t}\n+\n \tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n \t    (mddev->reshape_backwards\n \t     ? (bio->bi_iter.bi_sector < conf->reshape_safe &&\ndiff --git a/include/linux/blkdev.h b/include/linux/blkdev.h\nindex a59880c809c7..181a0deadc9e 100644\n--- a/include/linux/blkdev.h\n+++ b/include/linux/blkdev.h\n@@ -269,11 +269,16 @@ static inline dev_t disk_devt(struct gendisk *disk)\n \treturn MKDEV(disk->major, disk->first_minor);\n }\n \n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n /*\n  * We should strive for 1 << (PAGE_SHIFT + MAX_PAGECACHE_ORDER)\n  * however we constrain this to what we can validate and test.\n  */\n #define BLK_MAX_BLOCK_SIZE      SZ_64K\n+#else\n+#define BLK_MAX_BLOCK_SIZE      PAGE_SIZE\n+#endif\n+\n \n /* blk_validate_limits() validates bsize, so drivers don't usually need to */\n static inline int blk_validate_block_size(unsigned long bsize)",
    "stats": {
      "insertions": 22,
      "deletions": 8,
      "files": 5
    }
  },
  {
    "sha": "c7979c3917fa1326dae3607e1c6a04c12057b194",
    "message": "Merge tag 'net-6.16-rc6-2' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net\n\nPull more networking fixes from Jakub Kicinski\n \"Big chunk of fixes for WiFi, Johannes says probably the last for the\n  release.\n\n  The Netlink fixes (on top of the tree) restore operation of iw (WiFi\n  CLI) which uses sillily small recv buffer, and is the reason for this\n  'emergency PR'.\n\n  The GRE multicast fix also stands out among the user-visible\n  regressions.\n\n  Current release - fix to a fix:\n\n   - netlink: make sure we always allow at least one skb to be queued,\n     even if the recvbuf is (mis)configured to be tiny\n\n  Previous releases - regressions:\n\n   - gre: fix IPv6 multicast route creation\n\n  Previous releases - always broken:\n\n   - wifi: prevent A-MSDU attacks in mesh networks\n\n   - wifi: cfg80211: fix S1G beacon head validation and detection\n\n   - wifi: mac80211:\n       - always clear frame buffer to prevent stack leak in cases which\n         hit a WARN()\n       - fix monitor interface in device restart\n\n   - wifi: mwifiex: discard erroneous disassoc frames on STA interface\n\n   - wifi: mt76:\n       - prevent null-deref in mt7925_sta_set_decap_offload()\n       - add missing RCU annotations, and fix sleep in atomic\n       - fix decapsulation offload\n       - fixes for scanning\n\n   - phy: microchip: improve link establishment and reset handling\n\n   - eth: mlx5e: fix race between DIM disable and net_dim()\n\n   - bnxt_en: correct DMA unmap len for XDP_REDIRECT\"\n\n* tag 'net-6.16-rc6-2' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net: (44 commits)\n  netlink: make sure we allow at least one dump skb\n  netlink: Fix rmem check in netlink_broadcast_deliver().\n  bnxt_en: Set DMA unmap len correctly for XDP_REDIRECT\n  bnxt_en: Flush FW trace before copying to the coredump\n  bnxt_en: Fix DCB ETS validation\n  net: ll_temac: Fix missing tx_pending check in ethtools_set_ringparam()\n  net/mlx5e: Add new prio for promiscuous mode\n  net/mlx5e: Fix race between DIM disable and net_dim()\n  net/mlx5: Reset bw_share field when changing a node's parent\n  can: m_can: m_can_handle_lost_msg(): downgrade msg lost in rx message to debug level\n  selftests: net: lib: fix shift count out of range\n  selftests: Add IPv6 multicast route generation tests for GRE devices.\n  gre: Fix IPv6 multicast route creation.\n  net: phy: microchip: limit 100M workaround to link-down events on LAN88xx\n  net: phy: microchip: Use genphy_soft_reset() to purge stale LPA bits\n  ibmvnic: Fix hardcoded NUM_RX_STATS/NUM_TX_STATS with dynamic sizeof\n  net: appletalk: Fix device refcount leak in atrtr_create()\n  netfilter: flowtable: account for Ethernet header in nf_flow_pppoe_proto()\n  wifi: mac80211: add the virtual monitor after reconfig complete\n  wifi: mac80211: always initialize sdata::key_list\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-07-11T10:18:51-07:00",
    "files_changed": [
      "drivers/net/can/m_can/m_can.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c",
      "drivers/net/ethernet/ibm/ibmvnic.h",
      "drivers/net/ethernet/mellanox/mlx5/core/en/fs.h",
      "drivers/net/ethernet/mellanox/mlx5/core/en_dim.c",
      "drivers/net/ethernet/mellanox/mlx5/core/en_fs.c",
      "drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c",
      "drivers/net/ethernet/mellanox/mlx5/core/fs_core.c",
      "drivers/net/ethernet/xilinx/ll_temac_main.c",
      "drivers/net/phy/microchip.c",
      "drivers/net/wireless/marvell/mwifiex/util.c",
      "drivers/net/wireless/mediatek/mt76/mt76.h",
      "drivers/net/wireless/mediatek/mt76/mt7603/dma.c",
      "drivers/net/wireless/mediatek/mt76/mt7603/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7615/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt76x02.h",
      "drivers/net/wireless/mediatek/mt76/mt76x02_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mmio.c",
      "drivers/net/wireless/mediatek/mt76/mt7921/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7921/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/init.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mcu.h",
      "drivers/net/wireless/mediatek/mt76/mt7925/regs.h",
      "drivers/net/wireless/mediatek/mt76/mt792x_core.c",
      "drivers/net/wireless/mediatek/mt76/mt792x_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h",
      "drivers/net/wireless/mediatek/mt76/tx.c",
      "drivers/net/wireless/mediatek/mt76/util.c",
      "drivers/net/wireless/ralink/rt2x00/rt2x00soc.c",
      "drivers/net/wireless/ralink/rt2x00/rt2x00soc.h",
      "drivers/net/wireless/zydas/zd1211rw/zd_mac.c",
      "include/linux/ieee80211.h",
      "include/net/netfilter/nf_flow_table.h",
      "net/appletalk/ddp.c",
      "net/ipv6/addrconf.c",
      "net/mac80211/cfg.c",
      "net/mac80211/iface.c",
      "net/mac80211/mlme.c",
      "net/mac80211/parse.c",
      "net/mac80211/util.c",
      "net/netlink/af_netlink.c",
      "net/wireless/nl80211.c",
      "net/wireless/util.c"
    ],
    "diff": "diff --git a/drivers/net/can/m_can/m_can.c b/drivers/net/can/m_can/m_can.c\nindex 6c656bfdb323..fe74dbd2c966 100644\n--- a/drivers/net/can/m_can/m_can.c\n+++ b/drivers/net/can/m_can/m_can.c\n@@ -665,7 +665,7 @@ static int m_can_handle_lost_msg(struct net_device *dev)\n \tstruct can_frame *frame;\n \tu32 timestamp = 0;\n \n-\tnetdev_err(dev, \"msg lost in rxf0\\n\");\n+\tnetdev_dbg(dev, \"msg lost in rxf0\\n\");\n \n \tstats->rx_errors++;\n \tstats->rx_over_errors++;\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c\nindex ce97befd3cb3..67e70d3d0980 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_coredump.c\n@@ -368,23 +368,27 @@ static u32 bnxt_get_ctx_coredump(struct bnxt *bp, void *buf, u32 offset,\n \t\tif (!ctxm->mem_valid || !seg_id)\n \t\t\tcontinue;\n \n-\t\tif (trace)\n+\t\tif (trace) {\n \t\t\textra_hlen = BNXT_SEG_RCD_LEN;\n+\t\t\tif (buf) {\n+\t\t\t\tu16 trace_type = bnxt_bstore_to_trace[type];\n+\n+\t\t\t\tbnxt_fill_drv_seg_record(bp, &record, ctxm,\n+\t\t\t\t\t\t\t trace_type);\n+\t\t\t}\n+\t\t}\n+\n \t\tif (buf)\n \t\t\tdata = buf + BNXT_SEG_HDR_LEN + extra_hlen;\n+\n \t\tseg_len = bnxt_copy_ctx_mem(bp, ctxm, data, 0) + extra_hlen;\n \t\tif (buf) {\n \t\t\tbnxt_fill_coredump_seg_hdr(bp, &seg_hdr, NULL, seg_len,\n \t\t\t\t\t\t   0, 0, 0, comp_id, seg_id);\n \t\t\tmemcpy(buf, &seg_hdr, BNXT_SEG_HDR_LEN);\n \t\t\tbuf += BNXT_SEG_HDR_LEN;\n-\t\t\tif (trace) {\n-\t\t\t\tu16 trace_type = bnxt_bstore_to_trace[type];\n-\n-\t\t\t\tbnxt_fill_drv_seg_record(bp, &record, ctxm,\n-\t\t\t\t\t\t\t trace_type);\n+\t\t\tif (trace)\n \t\t\t\tmemcpy(buf, &record, BNXT_SEG_RCD_LEN);\n-\t\t\t}\n \t\t\tbuf += seg_len;\n \t\t}\n \t\tlen += BNXT_SEG_HDR_LEN + seg_len;\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\nindex 0dbb880a7aa0..71e14be2507e 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\n@@ -487,7 +487,9 @@ static int bnxt_ets_validate(struct bnxt *bp, struct ieee_ets *ets, u8 *tc)\n \n \t\tif ((ets->tc_tx_bw[i] || ets->tc_tsa[i]) && i > bp->max_tc)\n \t\t\treturn -EINVAL;\n+\t}\n \n+\tfor (i = 0; i < max_tc; i++) {\n \t\tswitch (ets->tc_tsa[i]) {\n \t\tcase IEEE_8021QAZ_TSA_STRICT:\n \t\t\tbreak;\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c\nindex 4a6d8cb9f970..09e7e8efa6fa 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c\n@@ -115,7 +115,7 @@ static void __bnxt_xmit_xdp_redirect(struct bnxt *bp,\n \ttx_buf->action = XDP_REDIRECT;\n \ttx_buf->xdpf = xdpf;\n \tdma_unmap_addr_set(tx_buf, mapping, mapping);\n-\tdma_unmap_len_set(tx_buf, len, 0);\n+\tdma_unmap_len_set(tx_buf, len, len);\n }\n \n void bnxt_tx_int_xdp(struct bnxt *bp, struct bnxt_napi *bnapi, int budget)\ndiff --git a/drivers/net/ethernet/ibm/ibmvnic.h b/drivers/net/ethernet/ibm/ibmvnic.h\nindex a189038d88df..246ddce753f9 100644\n--- a/drivers/net/ethernet/ibm/ibmvnic.h\n+++ b/drivers/net/ethernet/ibm/ibmvnic.h\n@@ -211,7 +211,6 @@ struct ibmvnic_statistics {\n \tu8 reserved[72];\n } __packed __aligned(8);\n \n-#define NUM_TX_STATS 3\n struct ibmvnic_tx_queue_stats {\n \tu64 batched_packets;\n \tu64 direct_packets;\n@@ -219,13 +218,18 @@ struct ibmvnic_tx_queue_stats {\n \tu64 dropped_packets;\n };\n \n-#define NUM_RX_STATS 3\n+#define NUM_TX_STATS \\\n+\t(sizeof(struct ibmvnic_tx_queue_stats) / sizeof(u64))\n+\n struct ibmvnic_rx_queue_stats {\n \tu64 packets;\n \tu64 bytes;\n \tu64 interrupts;\n };\n \n+#define NUM_RX_STATS \\\n+\t(sizeof(struct ibmvnic_rx_queue_stats) / sizeof(u64))\n+\n struct ibmvnic_acl_buffer {\n \t__be32 len;\n \t__be32 version;\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h\nindex b5c3a2a9d2a5..9560fcba643f 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h\n@@ -18,7 +18,8 @@ enum {\n \n enum {\n \tMLX5E_TC_PRIO = 0,\n-\tMLX5E_NIC_PRIO\n+\tMLX5E_PROMISC_PRIO,\n+\tMLX5E_NIC_PRIO,\n };\n \n struct mlx5e_flow_table {\n@@ -68,9 +69,13 @@ struct mlx5e_l2_table {\n \t\t\t\t MLX5_HASH_FIELD_SEL_DST_IP   |\\\n \t\t\t\t MLX5_HASH_FIELD_SEL_IPSEC_SPI)\n \n-/* NIC prio FTS */\n+/* NIC promisc FT level */\n enum {\n \tMLX5E_PROMISC_FT_LEVEL,\n+};\n+\n+/* NIC prio FTS */\n+enum {\n \tMLX5E_VLAN_FT_LEVEL,\n \tMLX5E_L2_FT_LEVEL,\n \tMLX5E_TTC_FT_LEVEL,\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c b/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\nindex 298bb74ec5e9..d1d629697e28 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\n@@ -113,7 +113,7 @@ int mlx5e_dim_rx_change(struct mlx5e_rq *rq, bool enable)\n \t\t__set_bit(MLX5E_RQ_STATE_DIM, &rq->state);\n \t} else {\n \t\t__clear_bit(MLX5E_RQ_STATE_DIM, &rq->state);\n-\n+\t\tsynchronize_net();\n \t\tmlx5e_dim_disable(rq->dim);\n \t\trq->dim = NULL;\n \t}\n@@ -140,7 +140,7 @@ int mlx5e_dim_tx_change(struct mlx5e_txqsq *sq, bool enable)\n \t\t__set_bit(MLX5E_SQ_STATE_DIM, &sq->state);\n \t} else {\n \t\t__clear_bit(MLX5E_SQ_STATE_DIM, &sq->state);\n-\n+\t\tsynchronize_net();\n \t\tmlx5e_dim_disable(sq->dim);\n \t\tsq->dim = NULL;\n \t}\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c\nindex 04a969128161..265c4ca85f7d 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c\n@@ -780,7 +780,7 @@ static int mlx5e_create_promisc_table(struct mlx5e_flow_steering *fs)\n \tft_attr.max_fte = MLX5E_PROMISC_TABLE_SIZE;\n \tft_attr.autogroup.max_num_groups = 1;\n \tft_attr.level = MLX5E_PROMISC_FT_LEVEL;\n-\tft_attr.prio = MLX5E_NIC_PRIO;\n+\tft_attr.prio = MLX5E_PROMISC_PRIO;\n \n \tft->t = mlx5_create_auto_grouped_flow_table(fs->ns, &ft_attr);\n \tif (IS_ERR(ft->t)) {\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c b/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c\nindex b6ae384396b3..ad9f6fca9b6a 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/qos.c\n@@ -1076,6 +1076,7 @@ static int esw_qos_vports_node_update_parent(struct mlx5_esw_sched_node *node,\n \t\treturn err;\n \t}\n \tesw_qos_node_set_parent(node, parent);\n+\tnode->bw_share = 0;\n \n \treturn 0;\n }\ndiff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c\nindex a8046200d376..3dd9a6f40709 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c\n@@ -113,13 +113,16 @@\n #define ETHTOOL_PRIO_NUM_LEVELS 1\n #define ETHTOOL_NUM_PRIOS 11\n #define ETHTOOL_MIN_LEVEL (KERNEL_MIN_LEVEL + ETHTOOL_NUM_PRIOS)\n-/* Promiscuous, Vlan, mac, ttc, inner ttc, {UDP/ANY/aRFS/accel/{esp, esp_err}}, IPsec policy,\n+/* Vlan, mac, ttc, inner ttc, {UDP/ANY/aRFS/accel/{esp, esp_err}}, IPsec policy,\n  * {IPsec RoCE MPV,Alias table},IPsec RoCE policy\n  */\n-#define KERNEL_NIC_PRIO_NUM_LEVELS 11\n+#define KERNEL_NIC_PRIO_NUM_LEVELS 10\n #define KERNEL_NIC_NUM_PRIOS 1\n-/* One more level for tc */\n-#define KERNEL_MIN_LEVEL (KERNEL_NIC_PRIO_NUM_LEVELS + 1)\n+/* One more level for tc, and one more for promisc */\n+#define KERNEL_MIN_LEVEL (KERNEL_NIC_PRIO_NUM_LEVELS + 2)\n+\n+#define KERNEL_NIC_PROMISC_NUM_PRIOS 1\n+#define KERNEL_NIC_PROMISC_NUM_LEVELS 1\n \n #define KERNEL_NIC_TC_NUM_PRIOS  1\n #define KERNEL_NIC_TC_NUM_LEVELS 3\n@@ -187,6 +190,8 @@ static struct init_tree_node {\n \t\t\t   ADD_NS(MLX5_FLOW_TABLE_MISS_ACTION_DEF,\n \t\t\t\t  ADD_MULTIPLE_PRIO(KERNEL_NIC_TC_NUM_PRIOS,\n \t\t\t\t\t\t    KERNEL_NIC_TC_NUM_LEVELS),\n+\t\t\t\t  ADD_MULTIPLE_PRIO(KERNEL_NIC_PROMISC_NUM_PRIOS,\n+\t\t\t\t\t\t    KERNEL_NIC_PROMISC_NUM_LEVELS),\n \t\t\t\t  ADD_MULTIPLE_PRIO(KERNEL_NIC_NUM_PRIOS,\n \t\t\t\t\t\t    KERNEL_NIC_PRIO_NUM_LEVELS))),\n \t\t  ADD_PRIO(0, BY_PASS_MIN_LEVEL, 0, FS_CHAINING_CAPS,\ndiff --git a/drivers/net/ethernet/xilinx/ll_temac_main.c b/drivers/net/ethernet/xilinx/ll_temac_main.c\nindex edb36ff07a0c..6f82203a414c 100644\n--- a/drivers/net/ethernet/xilinx/ll_temac_main.c\n+++ b/drivers/net/ethernet/xilinx/ll_temac_main.c\n@@ -1309,7 +1309,7 @@ ll_temac_ethtools_set_ringparam(struct net_device *ndev,\n \tif (ering->rx_pending > RX_BD_NUM_MAX ||\n \t    ering->rx_mini_pending ||\n \t    ering->rx_jumbo_pending ||\n-\t    ering->rx_pending > TX_BD_NUM_MAX)\n+\t    ering->tx_pending > TX_BD_NUM_MAX)\n \t\treturn -EINVAL;\n \n \tif (netif_running(ndev))\ndiff --git a/drivers/net/phy/microchip.c b/drivers/net/phy/microchip.c\nindex 13570f628aa5..dc8634e7bcbe 100644\n--- a/drivers/net/phy/microchip.c\n+++ b/drivers/net/phy/microchip.c\n@@ -332,7 +332,7 @@ static void lan88xx_link_change_notify(struct phy_device *phydev)\n \t * As workaround, set to 10 before setting to 100\n \t * at forced 100 F/H mode.\n \t */\n-\tif (!phydev->autoneg && phydev->speed == 100) {\n+\tif (phydev->state == PHY_NOLINK && !phydev->autoneg && phydev->speed == 100) {\n \t\t/* disable phy interrupt */\n \t\ttemp = phy_read(phydev, LAN88XX_INT_MASK);\n \t\ttemp &= ~LAN88XX_INT_MASK_MDINTPIN_EN_;\n@@ -488,6 +488,7 @@ static struct phy_driver microchip_phy_driver[] = {\n \t.config_init\t= lan88xx_config_init,\n \t.config_aneg\t= lan88xx_config_aneg,\n \t.link_change_notify = lan88xx_link_change_notify,\n+\t.soft_reset\t= genphy_soft_reset,\n \n \t/* Interrupt handling is broken, do not define related\n \t * functions to force polling.\ndiff --git a/drivers/net/wireless/marvell/mwifiex/util.c b/drivers/net/wireless/marvell/mwifiex/util.c\nindex 4c5b1de0e936..6882e90e90b2 100644\n--- a/drivers/net/wireless/marvell/mwifiex/util.c\n+++ b/drivers/net/wireless/marvell/mwifiex/util.c\n@@ -459,7 +459,9 @@ mwifiex_process_mgmt_packet(struct mwifiex_private *priv,\n \t\t\t\t    \"auth: receive authentication from %pM\\n\",\n \t\t\t\t    ieee_hdr->addr3);\n \t\t} else {\n-\t\t\tif (!priv->wdev.connected)\n+\t\t\tif (!priv->wdev.connected ||\n+\t\t\t    !ether_addr_equal(ieee_hdr->addr3,\n+\t\t\t\t\t      priv->curr_bss_params.bss_descriptor.mac_address))\n \t\t\t\treturn 0;\n \n \t\t\tif (ieee80211_is_deauth(ieee_hdr->frame_control)) {\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h\nindex 5f8d81cda6cd..74b75035d361 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt76.h\n@@ -1224,6 +1224,16 @@ static inline int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q,\n #define mt76_dereference(p, dev) \\\n \trcu_dereference_protected(p, lockdep_is_held(&(dev)->mutex))\n \n+static inline struct mt76_wcid *\n+__mt76_wcid_ptr(struct mt76_dev *dev, u16 idx)\n+{\n+\tif (idx >= ARRAY_SIZE(dev->wcid))\n+\t\treturn NULL;\n+\treturn rcu_dereference(dev->wcid[idx]);\n+}\n+\n+#define mt76_wcid_ptr(dev, idx) __mt76_wcid_ptr(&(dev)->mt76, idx)\n+\n struct mt76_dev *mt76_alloc_device(struct device *pdev, unsigned int size,\n \t\t\t\t   const struct ieee80211_ops *ops,\n \t\t\t\t   const struct mt76_driver_ops *drv_ops);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\nindex 863e5770df51..e26cc78fff94 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\n@@ -44,7 +44,7 @@ mt7603_rx_loopback_skb(struct mt7603_dev *dev, struct sk_buff *skb)\n \tif (idx >= MT7603_WTBL_STA - 1)\n \t\tgoto free;\n \n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\tgoto free;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\nindex 413973d05b43..6387f9e61060 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\n@@ -487,10 +487,7 @@ mt7603_rx_get_wcid(struct mt7603_dev *dev, u8 idx, bool unicast)\n \tstruct mt7603_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT7603_WTBL_SIZE)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -1266,12 +1263,9 @@ void mt7603_mac_add_txs(struct mt7603_dev *dev, void *data)\n \tif (pid == MT_PACKET_ID_NO_ACK)\n \t\treturn;\n \n-\tif (wcidx >= MT7603_WTBL_SIZE)\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\nindex 3ca4fae7c4b0..f8d2cc94b742 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\n@@ -90,10 +90,7 @@ static struct mt76_wcid *mt7615_rx_get_wcid(struct mt7615_dev *dev,\n \tstruct mt7615_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT7615_WTBL_SIZE)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -1504,7 +1501,7 @@ static void mt7615_mac_add_txs(struct mt7615_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\nindex e9ac8a7317a1..0db00efe88b0 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\n@@ -1172,7 +1172,7 @@ void mt76_connac2_txwi_free(struct mt76_dev *dev, struct mt76_txwi_cache *t,\n \t\twcid_idx = wcid->idx;\n \t} else {\n \t\twcid_idx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n+\t\twcid = __mt76_wcid_ptr(dev, wcid_idx);\n \n \t\tif (wcid && wcid->sta) {\n \t\t\tsta = container_of((void *)wcid, struct ieee80211_sta,\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\nindex cb13d0a76878..16db0f2082d1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\n@@ -287,7 +287,7 @@ __mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif_link *mvif\n \n \tmt76_connac_mcu_get_wlan_idx(dev, wcid, &hdr.wlan_idx_lo,\n \t\t\t\t     &hdr.wlan_idx_hi);\n-\tskb = mt76_mcu_msg_alloc(dev, NULL, len);\n+\tskb = __mt76_mcu_msg_alloc(dev, NULL, len, len, GFP_ATOMIC);\n \tif (!skb)\n \t\treturn ERR_PTR(-ENOMEM);\n \n@@ -1740,8 +1740,8 @@ int mt76_connac_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\tif (!sreq->ssids[i].ssid_len)\n \t\t\tcontinue;\n \n-\t\treq->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n-\t\tmemcpy(req->ssids[i].ssid, sreq->ssids[i].ssid,\n+\t\treq->ssids[n_ssids].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n+\t\tmemcpy(req->ssids[n_ssids].ssid, sreq->ssids[i].ssid,\n \t\t       sreq->ssids[i].ssid_len);\n \t\tn_ssids++;\n \t}\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76x02.h b/drivers/net/wireless/mediatek/mt76/mt76x02.h\nindex 4cd63bacd742..9d7ee09b6cc9 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76x02.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt76x02.h\n@@ -262,10 +262,7 @@ mt76x02_rx_get_sta(struct mt76_dev *dev, u8 idx)\n {\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT76x02_N_WCIDS)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\treturn NULL;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\nindex d5db6ffd6d36..83488b2d6efb 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\n@@ -564,9 +564,7 @@ void mt76x02_send_tx_status(struct mt76x02_dev *dev,\n \n \trcu_read_lock();\n \n-\tif (stat->wcid < MT76x02_N_WCIDS)\n-\t\twcid = rcu_dereference(dev->mt76.wcid[stat->wcid]);\n-\n+\twcid = mt76_wcid_ptr(dev, stat->wcid);\n \tif (wcid && wcid->sta) {\n \t\tvoid *priv;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\nindex 9400e4af2a04..6639976afcee 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\n@@ -56,10 +56,7 @@ static struct mt76_wcid *mt7915_rx_get_wcid(struct mt7915_dev *dev,\n \tstruct mt7915_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -917,7 +914,7 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -1013,12 +1010,9 @@ static void mt7915_mac_add_txs(struct mt7915_dev *dev, void *data)\n \tif (pid < MT_PACKET_ID_WED)\n \t\treturn;\n \n-\tif (wcidx >= mt7915_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\nindex 427542777abc..c6584d2b7509 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\n@@ -3986,7 +3986,7 @@ int mt7915_mcu_wed_wa_tx_stats(struct mt7915_dev *dev, u16 wlan_idx)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \tif (wcid)\n \t\twcid->stats.tx_packets += le32_to_cpu(res->tx_packets);\n \telse\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c b/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\nindex 9c4d5cea0c42..4a82f8e4c118 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\n@@ -587,12 +587,9 @@ static void mt7915_mmio_wed_update_rx_stats(struct mtk_wed_device *wed,\n \n \tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n \n-\tif (idx >= mt7915_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (wcid) {\n \t\twcid->stats.rx_bytes += le32_to_cpu(stats->rx_byte_cnt);\n \t\twcid->stats.rx_packets += le32_to_cpu(stats->rx_pkt_cnt);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\nindex 5dd57de59f27..f1f76506b0a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\n@@ -465,7 +465,7 @@ void mt7921_mac_add_txs(struct mt792x_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -516,7 +516,7 @@ static void mt7921_mac_tx_free(struct mt792x_dev *dev, void *data, int len)\n \n \t\t\tcount++;\n \t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -816,7 +816,7 @@ void mt7921_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n \tu16 idx;\n \n \tidx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\twcid = rcu_dereference(mdev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(mdev, idx);\n \tsta = wcid_to_sta(wcid);\n \n \tif (sta && likely(e->skb->protocol != cpu_to_be16(ETH_P_PAE)))\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7921/main.c b/drivers/net/wireless/mediatek/mt76/mt7921/main.c\nindex 1fffa43379b2..77f73ae1d7ec 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c\n@@ -1180,6 +1180,9 @@ static void mt7921_sta_set_decap_offload(struct ieee80211_hw *hw,\n \tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n \tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n \n+\tif (!msta->deflink.wcid.sta)\n+\t\treturn;\n+\n \tmt792x_mutex_acquire(dev);\n \n \tif (enabled)\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/init.c b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\nindex 2a83ff59a968..4249bad83c93 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n@@ -52,6 +52,8 @@ static int mt7925_thermal_init(struct mt792x_phy *phy)\n \n \tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7925_%s\",\n \t\t\t      wiphy_name(wiphy));\n+\tif (!name)\n+\t\treturn -ENOMEM;\n \n \thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,\n \t\t\t\t\t\t       mt7925_hwmon_groups);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mac.c b/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\nindex c871d2f9688b..75823c9fd3a1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\n@@ -1040,7 +1040,7 @@ void mt7925_mac_add_txs(struct mt792x_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -1122,7 +1122,7 @@ mt7925_mac_tx_free(struct mt792x_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -1445,7 +1445,7 @@ void mt7925_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n \tu16 idx;\n \n \tidx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\twcid = rcu_dereference(mdev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(mdev, idx);\n \tsta = wcid_to_sta(wcid);\n \n \tif (sta && likely(e->skb->protocol != cpu_to_be16(ETH_P_PAE)))\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/main.c b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\nindex 94b0099dcd41..5b001548dffc 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n@@ -1481,7 +1481,7 @@ mt7925_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n \n \tmt792x_mutex_acquire(dev);\n \n-\terr = mt7925_mcu_sched_scan_req(mphy, vif, req);\n+\terr = mt7925_mcu_sched_scan_req(mphy, vif, req, ies);\n \tif (err < 0)\n \t\tgoto out;\n \n@@ -1603,6 +1603,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \tunsigned long valid = mvif->valid_links;\n \tu8 i;\n \n+\tif (!msta->vif)\n+\t\treturn;\n+\n \tmt792x_mutex_acquire(dev);\n \n \tvalid = ieee80211_vif_is_mld(vif) ? mvif->valid_links : BIT(0);\n@@ -1617,6 +1620,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \t\telse\n \t\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &mlink->wcid.flags);\n \n+\t\tif (!mlink->wcid.sta)\n+\t\t\tcontinue;\n+\n \t\tmt7925_mcu_wtbl_update_hdr_trans(dev, vif, sta, i);\n \t}\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\nindex b8542be0d945..8ac6fbb736ab 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\n@@ -164,6 +164,7 @@ mt7925_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\t\t       bool suspend, struct cfg80211_wowlan *wowlan)\n {\n \tstruct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;\n+\tstruct ieee80211_scan_ies ies = {};\n \tstruct mt76_dev *dev = phy->dev;\n \tstruct {\n \t\tstruct {\n@@ -194,7 +195,7 @@ mt7925_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\treq.wow_ctrl_tlv.trigger |= (UNI_WOW_DETECT_TYPE_DISCONNECT |\n \t\t\t\t\t     UNI_WOW_DETECT_TYPE_BCN_LOST);\n \tif (wowlan->nd_config) {\n-\t\tmt7925_mcu_sched_scan_req(phy, vif, wowlan->nd_config);\n+\t\tmt7925_mcu_sched_scan_req(phy, vif, wowlan->nd_config, &ies);\n \t\treq.wow_ctrl_tlv.trigger |= UNI_WOW_DETECT_TYPE_SCH_SCAN_HIT;\n \t\tmt7925_mcu_sched_scan_enable(phy, vif, suspend);\n \t}\n@@ -2818,6 +2819,54 @@ int mt7925_mcu_set_dbdc(struct mt76_phy *phy, bool enable)\n \treturn err;\n }\n \n+static void\n+mt7925_mcu_build_scan_ie_tlv(struct mt76_dev *mdev,\n+\t\t\t     struct sk_buff *skb,\n+\t\t\t     struct ieee80211_scan_ies *scan_ies)\n+{\n+\tu32 max_len = sizeof(struct scan_ie_tlv) + MT76_CONNAC_SCAN_IE_LEN;\n+\tstruct scan_ie_tlv *ie;\n+\tenum nl80211_band i;\n+\tstruct tlv *tlv;\n+\tconst u8 *ies;\n+\tu16 ies_len;\n+\n+\tfor (i = 0; i <= NL80211_BAND_6GHZ; i++) {\n+\t\tif (i == NL80211_BAND_60GHZ)\n+\t\t\tcontinue;\n+\n+\t\ties = scan_ies->ies[i];\n+\t\ties_len = scan_ies->len[i];\n+\n+\t\tif (!ies || !ies_len)\n+\t\t\tcontinue;\n+\n+\t\tif (ies_len > max_len)\n+\t\t\treturn;\n+\n+\t\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE,\n+\t\t\t\t\t      sizeof(*ie) + ies_len);\n+\t\tie = (struct scan_ie_tlv *)tlv;\n+\n+\t\tmemcpy(ie->ies, ies, ies_len);\n+\t\tie->ies_len = cpu_to_le16(ies_len);\n+\n+\t\tswitch (i) {\n+\t\tcase NL80211_BAND_2GHZ:\n+\t\t\tie->band = 1;\n+\t\t\tbreak;\n+\t\tcase NL80211_BAND_6GHZ:\n+\t\t\tie->band = 3;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tie->band = 2;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tmax_len -= (sizeof(*ie) + ies_len);\n+\t}\n+}\n+\n int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\t       struct ieee80211_scan_request *scan_req)\n {\n@@ -2843,7 +2892,8 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \n \tmax_len = sizeof(*hdr) + sizeof(*req) + sizeof(*ssid) +\n \t\t  sizeof(*bssid) * MT7925_RNR_SCAN_MAX_BSSIDS +\n-\t\t  sizeof(*chan_info) + sizeof(*misc) + sizeof(*ie);\n+\t\t  sizeof(*chan_info) + sizeof(*misc) + sizeof(*ie) +\n+\t\t  MT76_CONNAC_SCAN_IE_LEN;\n \n \tskb = mt76_mcu_msg_alloc(mdev, NULL, max_len);\n \tif (!skb)\n@@ -2869,8 +2919,8 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\tif (i > MT7925_RNR_SCAN_MAX_BSSIDS)\n \t\t\tbreak;\n \n-\t\tssid->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n-\t\tmemcpy(ssid->ssids[i].ssid, sreq->ssids[i].ssid,\n+\t\tssid->ssids[n_ssids].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n+\t\tmemcpy(ssid->ssids[n_ssids].ssid, sreq->ssids[i].ssid,\n \t\t       sreq->ssids[i].ssid_len);\n \t\tn_ssids++;\n \t}\n@@ -2925,13 +2975,6 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t}\n \tchan_info->channel_type = sreq->n_channels ? 4 : 0;\n \n-\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE, sizeof(*ie));\n-\tie = (struct scan_ie_tlv *)tlv;\n-\tif (sreq->ie_len > 0) {\n-\t\tmemcpy(ie->ies, sreq->ie, sreq->ie_len);\n-\t\tie->ies_len = cpu_to_le16(sreq->ie_len);\n-\t}\n-\n \treq->scan_func |= SCAN_FUNC_SPLIT_SCAN;\n \n \ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_MISC, sizeof(*misc));\n@@ -2942,6 +2985,9 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\treq->scan_func |= SCAN_FUNC_RANDOM_MAC;\n \t}\n \n+\t/* Append scan probe IEs as the last tlv */\n+\tmt7925_mcu_build_scan_ie_tlv(mdev, skb, &scan_req->ies);\n+\n \terr = mt76_mcu_skb_send_msg(mdev, skb, MCU_UNI_CMD(SCAN_REQ),\n \t\t\t\t    true);\n \tif (err < 0)\n@@ -2953,7 +2999,8 @@ EXPORT_SYMBOL_GPL(mt7925_mcu_hw_scan);\n \n int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif,\n-\t\t\t      struct cfg80211_sched_scan_request *sreq)\n+\t\t\t      struct cfg80211_sched_scan_request *sreq,\n+\t\t\t      struct ieee80211_scan_ies *ies)\n {\n \tstruct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;\n \tstruct ieee80211_channel **scan_list = sreq->channels;\n@@ -3041,12 +3088,8 @@ int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t}\n \tchan_info->channel_type = sreq->n_channels ? 4 : 0;\n \n-\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE, sizeof(*ie));\n-\tie = (struct scan_ie_tlv *)tlv;\n-\tif (sreq->ie_len > 0) {\n-\t\tmemcpy(ie->ies, sreq->ie, sreq->ie_len);\n-\t\tie->ies_len = cpu_to_le16(sreq->ie_len);\n-\t}\n+\t/* Append scan probe IEs as the last tlv */\n+\tmt7925_mcu_build_scan_ie_tlv(mdev, skb, ies);\n \n \treturn mt76_mcu_skb_send_msg(mdev, skb, MCU_UNI_CMD(SCAN_REQ),\n \t\t\t\t     true);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\nindex ee6fb16e83c5..a40764d89a1f 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\n@@ -269,7 +269,7 @@ struct scan_ie_tlv {\n \t__le16 ies_len;\n \tu8 band;\n \tu8 pad;\n-\tu8 ies[MT76_CONNAC_SCAN_IE_LEN];\n+\tu8 ies[];\n };\n \n struct scan_misc_tlv {\n@@ -673,7 +673,8 @@ int mt7925_mcu_cancel_hw_scan(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif);\n int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif,\n-\t\t\t      struct cfg80211_sched_scan_request *sreq);\n+\t\t\t      struct cfg80211_sched_scan_request *sreq,\n+\t\t\t      struct ieee80211_scan_ies *ies);\n int mt7925_mcu_sched_scan_enable(struct mt76_phy *phy,\n \t\t\t\t struct ieee80211_vif *vif,\n \t\t\t\t bool enable);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/regs.h b/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\nindex 547489092c29..341987e47f67 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\n@@ -58,7 +58,7 @@\n \n #define MT_INT_TX_DONE_MCU\t\t(MT_INT_TX_DONE_MCU_WM |\t\\\n \t\t\t\t\t MT_INT_TX_DONE_FWDL)\n-#define MT_INT_TX_DONE_ALL\t\t(MT_INT_TX_DONE_MCU_WM |\t\\\n+#define MT_INT_TX_DONE_ALL\t\t(MT_INT_TX_DONE_MCU |\t\\\n \t\t\t\t\t MT_INT_TX_DONE_BAND0 |\t\\\n \t\t\t\t\tGENMASK(18, 4))\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt792x_core.c b/drivers/net/wireless/mediatek/mt76/mt792x_core.c\nindex a50c1723ca29..05130ec1e5f7 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt792x_core.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt792x_core.c\n@@ -28,7 +28,7 @@ static const struct ieee80211_iface_combination if_comb[] = {\n \t},\n };\n \n-static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n+static const struct ieee80211_iface_limit if_limits_chanctx_mcc[] = {\n \t{\n \t\t.max = 2,\n \t\t.types = BIT(NL80211_IFTYPE_STATION) |\n@@ -36,8 +36,23 @@ static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n \t},\n \t{\n \t\t.max = 1,\n-\t\t.types = BIT(NL80211_IFTYPE_AP) |\n-\t\t\t BIT(NL80211_IFTYPE_P2P_GO)\n+\t\t.types = BIT(NL80211_IFTYPE_P2P_GO)\n+\t},\n+\t{\n+\t\t.max = 1,\n+\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE)\n+\t}\n+};\n+\n+static const struct ieee80211_iface_limit if_limits_chanctx_scc[] = {\n+\t{\n+\t\t.max = 2,\n+\t\t.types = BIT(NL80211_IFTYPE_STATION) |\n+\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT)\n+\t},\n+\t{\n+\t\t.max = 1,\n+\t\t.types = BIT(NL80211_IFTYPE_AP)\n \t},\n \t{\n \t\t.max = 1,\n@@ -47,11 +62,18 @@ static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n \n static const struct ieee80211_iface_combination if_comb_chanctx[] = {\n \t{\n-\t\t.limits = if_limits_chanctx,\n-\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx),\n+\t\t.limits = if_limits_chanctx_mcc,\n+\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx_mcc),\n \t\t.max_interfaces = 3,\n \t\t.num_different_channels = 2,\n \t\t.beacon_int_infra_match = false,\n+\t},\n+\t{\n+\t\t.limits = if_limits_chanctx_scc,\n+\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx_scc),\n+\t\t.max_interfaces = 3,\n+\t\t.num_different_channels = 1,\n+\t\t.beacon_int_infra_match = false,\n \t}\n };\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt792x_mac.c b/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\nindex 05978d9c7b91..3f1d9ba49076 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\n@@ -142,10 +142,7 @@ struct mt76_wcid *mt792x_rx_get_wcid(struct mt792x_dev *dev, u16 idx,\n \tstruct mt792x_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\nindex 0dbd4662bc84..92148518f6a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n@@ -61,10 +61,7 @@ static struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,\n \tstruct mt76_wcid *wcid;\n \tint i;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\treturn NULL;\n \n@@ -1249,7 +1246,7 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tgoto next;\n@@ -1471,12 +1468,9 @@ static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)\n \tif (pid < MT_PACKET_ID_NO_SKB)\n \t\treturn;\n \n-\tif (wcidx >= mt7996_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -2353,20 +2347,12 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)\n void mt7996_mac_sta_rc_work(struct work_struct *work)\n {\n \tstruct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);\n-\tstruct ieee80211_bss_conf *link_conf;\n-\tstruct ieee80211_link_sta *link_sta;\n \tstruct mt7996_sta_link *msta_link;\n-\tstruct mt7996_vif_link *link;\n-\tstruct mt76_vif_link *mlink;\n-\tstruct ieee80211_sta *sta;\n \tstruct ieee80211_vif *vif;\n-\tstruct mt7996_sta *msta;\n \tstruct mt7996_vif *mvif;\n \tLIST_HEAD(list);\n \tu32 changed;\n-\tu8 link_id;\n \n-\trcu_read_lock();\n \tspin_lock_bh(&dev->mt76.sta_poll_lock);\n \tlist_splice_init(&dev->sta_rc_list, &list);\n \n@@ -2377,46 +2363,28 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)\n \n \t\tchanged = msta_link->changed;\n \t\tmsta_link->changed = 0;\n-\n-\t\tsta = wcid_to_sta(&msta_link->wcid);\n-\t\tlink_id = msta_link->wcid.link_id;\n-\t\tmsta = msta_link->sta;\n-\t\tmvif = msta->vif;\n-\t\tvif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);\n-\n-\t\tmlink = rcu_dereference(mvif->mt76.link[link_id]);\n-\t\tif (!mlink)\n-\t\t\tcontinue;\n-\n-\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n-\t\tif (!link_sta)\n-\t\t\tcontinue;\n-\n-\t\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n-\t\tif (!link_conf)\n-\t\t\tcontinue;\n+\t\tmvif = msta_link->sta->vif;\n+\t\tvif = container_of((void *)mvif, struct ieee80211_vif,\n+\t\t\t\t   drv_priv);\n \n \t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n \n-\t\tlink = (struct mt7996_vif_link *)mlink;\n-\n \t\tif (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |\n \t\t\t       IEEE80211_RC_NSS_CHANGED |\n \t\t\t       IEEE80211_RC_BW_CHANGED))\n-\t\t\tmt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t link_sta, link, msta_link,\n+\t\t\tmt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n+\t\t\t\t\t\t msta_link->wcid.link_id,\n \t\t\t\t\t\t true);\n \n \t\tif (changed & IEEE80211_RC_SMPS_CHANGED)\n-\t\t\tmt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t   msta_link, NULL,\n+\t\t\tmt7996_mcu_set_fixed_field(dev, msta_link->sta, NULL,\n+\t\t\t\t\t\t   msta_link->wcid.link_id,\n \t\t\t\t\t\t   RATE_PARAM_MMPS_UPDATE);\n \n \t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n \t}\n \n \tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n-\trcu_read_unlock();\n }\n \n void mt7996_mac_work(struct work_struct *work)\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/main.c b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\nindex 78ae9f5cb176..07dd75ce94a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n@@ -1112,9 +1112,8 @@ mt7996_mac_sta_event(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t\tif (err)\n \t\t\t\treturn err;\n \n-\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t       link_sta, link,\n-\t\t\t\t\t\t       msta_link, false);\n+\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n+\t\t\t\t\t\t       link_id, false);\n \t\t\tif (err)\n \t\t\t\treturn err;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex f0adc0b4b8b6..994526c65bfc 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n@@ -555,7 +555,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\tswitch (le16_to_cpu(res->tag)) {\n \t\tcase UNI_ALL_STA_TXRX_RATE:\n \t\t\twlan_idx = le16_to_cpu(res->rate[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -565,7 +565,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\t\tbreak;\n \t\tcase UNI_ALL_STA_TXRX_ADM_STAT:\n \t\t\twlan_idx = le16_to_cpu(res->adm_stat[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -579,7 +579,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\t\tbreak;\n \t\tcase UNI_ALL_STA_TXRX_MSDU_COUNT:\n \t\t\twlan_idx = le16_to_cpu(res->msdu_cnt[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -676,10 +676,7 @@ mt7996_mcu_wed_rro_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \n \t\t\te = (void *)skb->data;\n \t\t\tidx = le16_to_cpu(e->wlan_id);\n-\t\t\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\t\t\tbreak;\n-\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tif (!wcid || !wcid->sta)\n \t\t\t\tbreak;\n \n@@ -1905,22 +1902,35 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t     MCU_WM_UNI_CMD(RA), true);\n }\n \n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field)\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field)\n {\n-\tstruct sta_phy_uni *phy = data;\n+\tstruct mt7996_vif *mvif = msta->vif;\n+\tstruct mt7996_sta_link *msta_link;\n \tstruct sta_rec_ra_fixed_uni *ra;\n+\tstruct sta_phy_uni *phy = data;\n+\tstruct mt76_vif_link *mlink;\n \tstruct sk_buff *skb;\n+\tint err = -ENODEV;\n \tstruct tlv *tlv;\n \n-\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n+\trcu_read_lock();\n+\n+\tmlink = rcu_dereference(mvif->mt76.link[link_id]);\n+\tif (!mlink)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, mlink,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\terr = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA_UPDATE, sizeof(*ra));\n \tra = (struct sta_rec_ra_fixed_uni *)tlv;\n@@ -1935,106 +1945,149 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n \t\tif (phy)\n \t\t\tra->phy = *phy;\n \t\tbreak;\n-\tcase RATE_PARAM_MMPS_UPDATE:\n+\tcase RATE_PARAM_MMPS_UPDATE: {\n+\t\tstruct ieee80211_sta *sta = wcid_to_sta(&msta_link->wcid);\n+\t\tstruct ieee80211_link_sta *link_sta;\n+\n+\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\t\tif (!link_sta) {\n+\t\t\tdev_kfree_skb(skb);\n+\t\t\tgoto error_unlock;\n+\t\t}\n+\n \t\tra->mmps_mode = mt7996_mcu_get_mmps_mode(link_sta->smps_mode);\n \t\tbreak;\n+\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tra->field = cpu_to_le32(field);\n \n+\trcu_read_unlock();\n+\n \treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn err;\n }\n \n static int\n-mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link)\n+mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       struct ieee80211_vif *vif, u8 link_id)\n {\n-\tstruct cfg80211_chan_def *chandef = &link->phy->mt76->chandef;\n-\tstruct cfg80211_bitrate_mask *mask = &link->bitrate_mask;\n-\tenum nl80211_band band = chandef->chan->band;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct cfg80211_bitrate_mask mask;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n \tstruct sta_phy_uni phy = {};\n-\tint ret, nrates = 0;\n+\tstruct ieee80211_sta *sta;\n+\tint ret, nrates = 0, idx;\n+\tenum nl80211_band band;\n+\tbool has_he;\n \n #define __sta_phy_bitrate_mask_check(_mcs, _gi, _ht, _he)\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\t\\\n-\t\tu8 i, gi = mask->control[band]._gi;\t\t\t\t\\\n+\t\tu8 i, gi = mask.control[band]._gi;\t\t\t\t\\\n \t\tgi = (_he) ? gi : gi == NL80211_TXRATE_FORCE_SGI;\t\t\\\n \t\tphy.sgi = gi;\t\t\t\t\t\t\t\\\n-\t\tphy.he_ltf = mask->control[band].he_ltf;\t\t\t\\\n-\t\tfor (i = 0; i < ARRAY_SIZE(mask->control[band]._mcs); i++) {\t\\\n-\t\t\tif (!mask->control[band]._mcs[i])\t\t\t\\\n+\t\tphy.he_ltf = mask.control[band].he_ltf;\t\t\t\t\\\n+\t\tfor (i = 0; i < ARRAY_SIZE(mask.control[band]._mcs); i++) {\t\\\n+\t\t\tif (!mask.control[band]._mcs[i])\t\t\t\\\n \t\t\t\tcontinue;\t\t\t\t\t\\\n-\t\t\tnrates += hweight16(mask->control[band]._mcs[i]);\t\\\n-\t\t\tphy.mcs = ffs(mask->control[band]._mcs[i]) - 1;\t\t\\\n+\t\t\tnrates += hweight16(mask.control[band]._mcs[i]);\t\\\n+\t\t\tphy.mcs = ffs(mask.control[band]._mcs[i]) - 1;\t\t\\\n \t\t\tif (_ht)\t\t\t\t\t\t\\\n \t\t\t\tphy.mcs += 8 * i;\t\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\t\\\n \t} while (0)\n \n-\tif (link_sta->he_cap.has_he) {\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tband = link->phy->mt76->chandef.chan->band;\n+\thas_he = link_sta->he_cap.has_he;\n+\tmask = link->bitrate_mask;\n+\tidx = msta_link->wcid.idx;\n+\n+\tif (has_he) {\n \t\t__sta_phy_bitrate_mask_check(he_mcs, he_gi, 0, 1);\n \t} else if (link_sta->vht_cap.vht_supported) {\n \t\t__sta_phy_bitrate_mask_check(vht_mcs, gi, 0, 0);\n \t} else if (link_sta->ht_cap.ht_supported) {\n \t\t__sta_phy_bitrate_mask_check(ht_mcs, gi, 1, 0);\n \t} else {\n-\t\tnrates = hweight32(mask->control[band].legacy);\n-\t\tphy.mcs = ffs(mask->control[band].legacy) - 1;\n+\t\tnrates = hweight32(mask.control[band].legacy);\n+\t\tphy.mcs = ffs(mask.control[band].legacy) - 1;\n \t}\n+\n+\trcu_read_unlock();\n+\n #undef __sta_phy_bitrate_mask_check\n \n \t/* fall back to auto rate control */\n-\tif (mask->control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n-\t    mask->control[band].he_gi == GENMASK(7, 0) &&\n-\t    mask->control[band].he_ltf == GENMASK(7, 0) &&\n+\tif (mask.control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n+\t    mask.control[band].he_gi == GENMASK(7, 0) &&\n+\t    mask.control[band].he_ltf == GENMASK(7, 0) &&\n \t    nrates != 1)\n \t\treturn 0;\n \n \t/* fixed single rate */\n \tif (nrates == 1) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_MCS);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \t/* fixed GI */\n-\tif (mask->control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n-\t    mask->control[band].he_gi != GENMASK(7, 0)) {\n+\tif (mask.control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n+\t    mask.control[band].he_gi != GENMASK(7, 0)) {\n \t\tu32 addr;\n \n \t\t/* firmware updates only TXCMD but doesn't take WTBL into\n \t\t * account, so driver should update here to reflect the\n \t\t * actual txrate hardware sends out.\n \t\t */\n-\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, msta_link->wcid.idx, 7);\n-\t\tif (link_sta->he_cap.has_he)\n+\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 7);\n+\t\tif (has_he)\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(31, 24), phy.sgi);\n \t\telse\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);\n \n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_GI);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \t/* fixed HE_LTF */\n-\tif (mask->control[band].he_ltf != GENMASK(7, 0)) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\tif (mask.control[band].he_ltf != GENMASK(7, 0)) {\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_HE_LTF);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \treturn 0;\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn -ENODEV;\n }\n \n static void\n@@ -2145,21 +2198,44 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,\n \tmemset(ra->rx_rcpi, INIT_RCPI, sizeof(ra->rx_rcpi));\n }\n \n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed)\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed)\n {\n+\tstruct ieee80211_bss_conf *link_conf;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n+\tstruct ieee80211_sta *sta;\n \tstruct sk_buff *skb;\n-\tint ret;\n+\tint ret = -ENODEV;\n+\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n+\tif (!link_conf)\n+\t\tgoto error_unlock;\n \n \tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\tret = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \t/* firmware rc algorithm refers to sta_rec_he for HE control.\n \t * once dev->rc_work changes the settings driver should also\n@@ -2173,12 +2249,19 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t */\n \tmt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, link_conf, link_sta, link);\n \n+\trcu_read_unlock();\n+\n \tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n \tif (ret)\n \t\treturn ret;\n \n-\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, link_sta, link, msta_link);\n+\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, msta, vif, link_id);\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn ret;\n }\n \n static int\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\nindex 1ad6bc046f7c..33ac16b64ef1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n@@ -620,23 +620,17 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,\n int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,\n \t\t\t    struct mt7996_vif_link *link,\n \t\t\t    struct ieee80211_he_obss_pd *he_obss_pd);\n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed);\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed);\n int mt7996_set_channel(struct mt76_phy *mphy);\n int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);\n int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t      struct ieee80211_bss_conf *link_conf);\n int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t   void *data, u16 version);\n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field);\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field);\n int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);\n int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len);\n int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num);\ndiff --git a/drivers/net/wireless/mediatek/mt76/tx.c b/drivers/net/wireless/mediatek/mt76/tx.c\nindex 513916469ca2..e6cf16706667 100644\n--- a/drivers/net/wireless/mediatek/mt76/tx.c\n+++ b/drivers/net/wireless/mediatek/mt76/tx.c\n@@ -64,7 +64,7 @@ mt76_tx_status_unlock(struct mt76_dev *dev, struct sk_buff_head *list)\n \t\tstruct mt76_tx_cb *cb = mt76_tx_skb_cb(skb);\n \t\tstruct mt76_wcid *wcid;\n \n-\t\twcid = rcu_dereference(dev->wcid[cb->wcid]);\n+\t\twcid = __mt76_wcid_ptr(dev, cb->wcid);\n \t\tif (wcid) {\n \t\t\tstatus.sta = wcid_to_sta(wcid);\n \t\t\tif (status.sta && (wcid->rate.flags || wcid->rate.legacy)) {\n@@ -251,9 +251,7 @@ void __mt76_tx_complete_skb(struct mt76_dev *dev, u16 wcid_idx, struct sk_buff *\n \n \trcu_read_lock();\n \n-\tif (wcid_idx < ARRAY_SIZE(dev->wcid))\n-\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n-\n+\twcid = __mt76_wcid_ptr(dev, wcid_idx);\n \tmt76_tx_check_non_aql(dev, wcid, skb);\n \n #ifdef CONFIG_NL80211_TESTMODE\n@@ -538,7 +536,7 @@ mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)\n \t\t\tbreak;\n \n \t\tmtxq = (struct mt76_txq *)txq->drv_priv;\n-\t\twcid = rcu_dereference(dev->wcid[mtxq->wcid]);\n+\t\twcid = __mt76_wcid_ptr(dev, mtxq->wcid);\n \t\tif (!wcid || test_bit(MT_WCID_FLAG_PS, &wcid->flags))\n \t\t\tcontinue;\n \n@@ -617,7 +615,8 @@ mt76_txq_schedule_pending_wcid(struct mt76_phy *phy, struct mt76_wcid *wcid,\n \t\tif ((dev->drv->drv_flags & MT_DRV_HW_MGMT_TXQ) &&\n \t\t    !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n \t\t    !ieee80211_is_data(hdr->frame_control) &&\n-\t\t    !ieee80211_is_bufferable_mmpdu(skb))\n+\t\t    (!ieee80211_is_bufferable_mmpdu(skb) ||\n+\t\t     ieee80211_is_deauth(hdr->frame_control)))\n \t\t\tqid = MT_TXQ_PSD;\n \n \t\tq = phy->q_tx[qid];\ndiff --git a/drivers/net/wireless/mediatek/mt76/util.c b/drivers/net/wireless/mediatek/mt76/util.c\nindex 95b3dc96e4c4..97249ebb4bc8 100644\n--- a/drivers/net/wireless/mediatek/mt76/util.c\n+++ b/drivers/net/wireless/mediatek/mt76/util.c\n@@ -83,7 +83,7 @@ int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx)\n \t\t\tif (!(mask & 1))\n \t\t\t\tcontinue;\n \n-\t\t\twcid = rcu_dereference(dev->wcid[j]);\n+\t\t\twcid = __mt76_wcid_ptr(dev, j);\n \t\t\tif (!wcid || wcid->phy_idx != phy_idx)\n \t\t\t\tcontinue;\n \ndiff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\nindex eface610178d..f7f3a2340c39 100644\n--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\n+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\n@@ -108,7 +108,7 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)\n }\n EXPORT_SYMBOL_GPL(rt2x00soc_probe);\n \n-int rt2x00soc_remove(struct platform_device *pdev)\n+void rt2x00soc_remove(struct platform_device *pdev)\n {\n \tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n \tstruct rt2x00_dev *rt2x00dev = hw->priv;\n@@ -119,8 +119,6 @@ int rt2x00soc_remove(struct platform_device *pdev)\n \trt2x00lib_remove_dev(rt2x00dev);\n \trt2x00soc_free_reg(rt2x00dev);\n \tieee80211_free_hw(hw);\n-\n-\treturn 0;\n }\n EXPORT_SYMBOL_GPL(rt2x00soc_remove);\n \ndiff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\nindex 021fd06b3627..d6226b8a10e0 100644\n--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\n+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\n@@ -17,7 +17,7 @@\n  * SoC driver handlers.\n  */\n int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops);\n-int rt2x00soc_remove(struct platform_device *pdev);\n+void rt2x00soc_remove(struct platform_device *pdev);\n #ifdef CONFIG_PM\n int rt2x00soc_suspend(struct platform_device *pdev, pm_message_t state);\n int rt2x00soc_resume(struct platform_device *pdev);\ndiff --git a/drivers/net/wireless/zydas/zd1211rw/zd_mac.c b/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\nindex 9653dbaac3c0..781510a3ec6d 100644\n--- a/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\n+++ b/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\n@@ -583,7 +583,11 @@ void zd_mac_tx_to_dev(struct sk_buff *skb, int error)\n \n \t\tskb_queue_tail(q, skb);\n \t\twhile (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {\n-\t\t\tzd_mac_tx_status(hw, skb_dequeue(q),\n+\t\t\tskb = skb_dequeue(q);\n+\t\t\tif (!skb)\n+\t\t\t\tbreak;\n+\n+\t\t\tzd_mac_tx_status(hw, skb,\n \t\t\t\t\t mac->ack_pending ? mac->ack_signal : 0,\n \t\t\t\t\t NULL);\n \t\t\tmac->ack_pending = 0;\ndiff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h\nindex 22f39e5e2ff1..996be3c2cff0 100644\n--- a/include/linux/ieee80211.h\n+++ b/include/linux/ieee80211.h\n@@ -662,18 +662,6 @@ static inline bool ieee80211_s1g_has_cssid(__le16 fc)\n \t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_CSSID));\n }\n \n-/**\n- * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n- * @fc: frame control bytes in little-endian byteorder\n- * Return: whether or not the frame is an S1G short beacon,\n- *\ti.e. it is an S1G beacon with 'next TBTT' flag set\n- */\n-static inline bool ieee80211_is_s1g_short_beacon(__le16 fc)\n-{\n-\treturn ieee80211_is_s1g_beacon(fc) &&\n-\t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_NEXT_TBTT));\n-}\n-\n /**\n  * ieee80211_is_atim - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ATIM\n  * @fc: frame control bytes in little-endian byteorder\n@@ -4901,6 +4889,39 @@ static inline bool ieee80211_is_ftm(struct sk_buff *skb)\n \treturn false;\n }\n \n+/**\n+ * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n+ * @fc: frame control bytes in little-endian byteorder\n+ * @variable: pointer to the beacon frame elements\n+ * @variable_len: length of the frame elements\n+ * Return: whether or not the frame is an S1G short beacon. As per\n+ *\tIEEE80211-2024 11.1.3.10.1, The S1G beacon compatibility element shall\n+ *\talways be present as the first element in beacon frames generated at a\n+ *\tTBTT (Target Beacon Transmission Time), so any frame not containing\n+ *\tthis element must have been generated at a TSBTT (Target Short Beacon\n+ *\tTransmission Time) that is not a TBTT. Additionally, short beacons are\n+ *\tprohibited from containing the S1G beacon compatibility element as per\n+ *\tIEEE80211-2024 9.3.4.3 Table 9-76, so if we have an S1G beacon with\n+ *\teither no elements or the first element is not the beacon compatibility\n+ *\telement, we have a short beacon.\n+ */\n+static inline bool ieee80211_is_s1g_short_beacon(__le16 fc, const u8 *variable,\n+\t\t\t\t\t\t size_t variable_len)\n+{\n+\tif (!ieee80211_is_s1g_beacon(fc))\n+\t\treturn false;\n+\n+\t/*\n+\t * If the frame does not contain at least 1 element (this is perfectly\n+\t * valid in a short beacon) and is an S1G beacon, we have a short\n+\t * beacon.\n+\t */\n+\tif (variable_len < 2)\n+\t\treturn true;\n+\n+\treturn variable[0] != WLAN_EID_S1G_BCN_COMPAT;\n+}\n+\n struct element {\n \tu8 id;\n \tu8 datalen;\ndiff --git a/include/net/netfilter/nf_flow_table.h b/include/net/netfilter/nf_flow_table.h\nindex d711642e78b5..c003cd194fa2 100644\n--- a/include/net/netfilter/nf_flow_table.h\n+++ b/include/net/netfilter/nf_flow_table.h\n@@ -370,7 +370,7 @@ static inline __be16 __nf_flow_pppoe_proto(const struct sk_buff *skb)\n \n static inline bool nf_flow_pppoe_proto(struct sk_buff *skb, __be16 *inner_proto)\n {\n-\tif (!pskb_may_pull(skb, PPPOE_SES_HLEN))\n+\tif (!pskb_may_pull(skb, ETH_HLEN + PPPOE_SES_HLEN))\n \t\treturn false;\n \n \t*inner_proto = __nf_flow_pppoe_proto(skb);\ndiff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c\nindex 73ea7e67f05a..30242fe10341 100644\n--- a/net/appletalk/ddp.c\n+++ b/net/appletalk/ddp.c\n@@ -576,6 +576,7 @@ static int atrtr_create(struct rtentry *r, struct net_device *devhint)\n \n \t/* Fill in the routing entry */\n \trt->target  = ta->sat_addr;\n+\tdev_put(rt->dev); /* Release old device */\n \tdev_hold(devhint);\n \trt->dev     = devhint;\n \trt->flags   = r->rt_flags;\ndiff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c\nindex ba2ec7c870cc..870a0bd6c2ba 100644\n--- a/net/ipv6/addrconf.c\n+++ b/net/ipv6/addrconf.c\n@@ -3525,11 +3525,9 @@ static void addrconf_gre_config(struct net_device *dev)\n \n \tASSERT_RTNL();\n \n-\tidev = ipv6_find_idev(dev);\n-\tif (IS_ERR(idev)) {\n-\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n+\tidev = addrconf_add_dev(dev);\n+\tif (IS_ERR(idev))\n \t\treturn;\n-\t}\n \n \t/* Generate the IPv6 link-local address using addrconf_addr_gen(),\n \t * unless we have an IPv4 GRE device not bound to an IP address and\n@@ -3543,9 +3541,6 @@ static void addrconf_gre_config(struct net_device *dev)\n \t}\n \n \tadd_v4_addrs(idev);\n-\n-\tif (dev->flags & IFF_POINTOPOINT)\n-\t\taddrconf_add_mroute(dev);\n }\n #endif\n \ndiff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c\nindex d9d88f2f2831..954795b0fe48 100644\n--- a/net/mac80211/cfg.c\n+++ b/net/mac80211/cfg.c\n@@ -1959,6 +1959,20 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,\n \tieee80211_sta_init_nss(link_sta);\n \n \tif (params->opmode_notif_used) {\n+\t\tenum nl80211_chan_width width = link->conf->chanreq.oper.width;\n+\n+\t\tswitch (width) {\n+\t\tcase NL80211_CHAN_WIDTH_20:\n+\t\tcase NL80211_CHAN_WIDTH_40:\n+\t\tcase NL80211_CHAN_WIDTH_80:\n+\t\tcase NL80211_CHAN_WIDTH_160:\n+\t\tcase NL80211_CHAN_WIDTH_80P80:\n+\t\tcase NL80211_CHAN_WIDTH_320: /* not VHT, allowed for HE/EHT */\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\n \t\t/* returned value is only needed for rc update, but the\n \t\t * rc isn't initialized here yet, so ignore it\n \t\t */\ndiff --git a/net/mac80211/iface.c b/net/mac80211/iface.c\nindex 7c27f3cd841c..c01634fdba78 100644\n--- a/net/mac80211/iface.c\n+++ b/net/mac80211/iface.c\n@@ -1150,6 +1150,8 @@ static void ieee80211_sdata_init(struct ieee80211_local *local,\n {\n \tsdata->local = local;\n \n+\tINIT_LIST_HEAD(&sdata->key_list);\n+\n \t/*\n \t * Initialize the default link, so we can use link_id 0 for non-MLD,\n \t * and that continues to work for non-MLD-aware drivers that use just\n@@ -2210,8 +2212,6 @@ int ieee80211_if_add(struct ieee80211_local *local, const char *name,\n \n \tieee80211_init_frag_cache(&sdata->frags);\n \n-\tINIT_LIST_HEAD(&sdata->key_list);\n-\n \twiphy_delayed_work_init(&sdata->dec_tailroom_needed_wk,\n \t\t\t\tieee80211_delayed_tailroom_dec);\n \ndiff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c\nindex 2d46d4af60d7..0ed68182f79b 100644\n--- a/net/mac80211/mlme.c\n+++ b/net/mac80211/mlme.c\n@@ -3934,6 +3934,9 @@ static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,\n \n \tlockdep_assert_wiphy(local->hw.wiphy);\n \n+\tif (frame_buf)\n+\t\tmemset(frame_buf, 0, IEEE80211_DEAUTH_FRAME_LEN);\n+\n \tif (WARN_ON(!ap_sta))\n \t\treturn;\n \n@@ -7195,6 +7198,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \tstruct ieee80211_bss_conf *bss_conf = link->conf;\n \tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n \tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n+\tstruct ieee80211_ext *ext = NULL;\n \tsize_t baselen;\n \tstruct ieee802_11_elems *elems;\n \tstruct ieee80211_local *local = sdata->local;\n@@ -7220,7 +7224,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t/* Process beacon from the current BSS */\n \tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n \tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n-\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n+\t\text = (void *)mgmt;\n \t\tvariable = ext->u.s1g_beacon.variable +\n \t\t\t   ieee80211_s1g_optional_len(ext->frame_control);\n \t}\n@@ -7407,7 +7411,9 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t}\n \n \tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n-\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n+\t    (ext && ieee80211_is_s1g_short_beacon(ext->frame_control,\n+\t\t\t\t\t\t  parse_params.start,\n+\t\t\t\t\t\t  parse_params.len)))\n \t\tgoto free;\n \tlink->u.mgd.beacon_crc = ncrc;\n \tlink->u.mgd.beacon_crc_valid = true;\n@@ -10699,8 +10705,8 @@ static void ieee80211_ml_epcs(struct ieee80211_sub_if_data *sdata,\n \t */\n \tfor_each_mle_subelement(sub, (const u8 *)elems->ml_epcs,\n \t\t\t\telems->ml_epcs_len) {\n+\t\tstruct ieee802_11_elems *link_elems __free(kfree) = NULL;\n \t\tstruct ieee80211_link_data *link;\n-\t\tstruct ieee802_11_elems *link_elems __free(kfree);\n \t\tu8 *pos = (void *)sub->data;\n \t\tu16 control;\n \t\tssize_t len;\ndiff --git a/net/mac80211/parse.c b/net/mac80211/parse.c\nindex 96584b39215e..c5e0f7f46004 100644\n--- a/net/mac80211/parse.c\n+++ b/net/mac80211/parse.c\n@@ -758,7 +758,6 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,\n {\n \tconst struct element *elem, *sub;\n \tsize_t profile_len = 0;\n-\tbool found = false;\n \n \tif (!bss || !bss->transmitted_bss)\n \t\treturn profile_len;\n@@ -809,15 +808,14 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,\n \t\t\t\t\t       index[2],\n \t\t\t\t\t       new_bssid);\n \t\t\tif (ether_addr_equal(new_bssid, bss->bssid)) {\n-\t\t\t\tfound = true;\n \t\t\t\telems->bssid_index_len = index[1];\n \t\t\t\telems->bssid_index = (void *)&index[2];\n-\t\t\t\tbreak;\n+\t\t\t\treturn profile_len;\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn found ? profile_len : 0;\n+\treturn 0;\n }\n \n static void\ndiff --git a/net/mac80211/util.c b/net/mac80211/util.c\nindex a125995ed252..e66da651678a 100644\n--- a/net/mac80211/util.c\n+++ b/net/mac80211/util.c\n@@ -2144,11 +2144,6 @@ int ieee80211_reconfig(struct ieee80211_local *local)\n \t\tcfg80211_sched_scan_stopped_locked(local->hw.wiphy, 0);\n \n  wake_up:\n-\n-\tif (local->virt_monitors > 0 &&\n-\t    local->virt_monitors == local->open_count)\n-\t\tieee80211_add_virtual_monitor(local);\n-\n \t/*\n \t * Clear the WLAN_STA_BLOCK_BA flag so new aggregation\n \t * sessions can be established after a resume.\n@@ -2202,6 +2197,10 @@ int ieee80211_reconfig(struct ieee80211_local *local)\n \t\t}\n \t}\n \n+\tif (local->virt_monitors > 0 &&\n+\t    local->virt_monitors == local->open_count)\n+\t\tieee80211_add_virtual_monitor(local);\n+\n \tif (!suspended)\n \t\treturn 0;\n \ndiff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c\nindex 79fbaf7333ce..6332a0e06596 100644\n--- a/net/netlink/af_netlink.c\n+++ b/net/netlink/af_netlink.c\n@@ -1395,7 +1395,7 @@ static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)\n \trmem = atomic_add_return(skb->truesize, &sk->sk_rmem_alloc);\n \trcvbuf = READ_ONCE(sk->sk_rcvbuf);\n \n-\tif ((rmem != skb->truesize || rmem <= rcvbuf) &&\n+\tif ((rmem == skb->truesize || rmem <= rcvbuf) &&\n \t    !test_bit(NETLINK_S_CONGESTED, &nlk->state)) {\n \t\tnetlink_skb_set_owner_r(skb, sk);\n \t\t__netlink_sendskb(sk, skb);\n@@ -2258,11 +2258,11 @@ static int netlink_dump(struct sock *sk, bool lock_taken)\n \tstruct netlink_ext_ack extack = {};\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n+\tunsigned int rmem, rcvbuf;\n \tsize_t max_recvmsg_len;\n \tstruct module *module;\n \tint err = -ENOBUFS;\n \tint alloc_min_size;\n-\tunsigned int rmem;\n \tint alloc_size;\n \n \tif (!lock_taken)\n@@ -2294,8 +2294,9 @@ static int netlink_dump(struct sock *sk, bool lock_taken)\n \tif (!skb)\n \t\tgoto errout_skb;\n \n+\trcvbuf = READ_ONCE(sk->sk_rcvbuf);\n \trmem = atomic_add_return(skb->truesize, &sk->sk_rmem_alloc);\n-\tif (rmem >= READ_ONCE(sk->sk_rcvbuf)) {\n+\tif (rmem != skb->truesize && rmem >= rcvbuf) {\n \t\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n \t\tgoto errout_skb;\n \t}\ndiff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c\nindex 85f139016da2..50202d170f3a 100644\n--- a/net/wireless/nl80211.c\n+++ b/net/wireless/nl80211.c\n@@ -229,6 +229,7 @@ static int validate_beacon_head(const struct nlattr *attr,\n \tunsigned int len = nla_len(attr);\n \tconst struct element *elem;\n \tconst struct ieee80211_mgmt *mgmt = (void *)data;\n+\tconst struct ieee80211_ext *ext;\n \tunsigned int fixedlen, hdrlen;\n \tbool s1g_bcn;\n \n@@ -237,8 +238,10 @@ static int validate_beacon_head(const struct nlattr *attr,\n \n \ts1g_bcn = ieee80211_is_s1g_beacon(mgmt->frame_control);\n \tif (s1g_bcn) {\n-\t\tfixedlen = offsetof(struct ieee80211_ext,\n-\t\t\t\t    u.s1g_beacon.variable);\n+\t\text = (struct ieee80211_ext *)mgmt;\n+\t\tfixedlen =\n+\t\t\toffsetof(struct ieee80211_ext, u.s1g_beacon.variable) +\n+\t\t\tieee80211_s1g_optional_len(ext->frame_control);\n \t\thdrlen = offsetof(struct ieee80211_ext, u.s1g_beacon);\n \t} else {\n \t\tfixedlen = offsetof(struct ieee80211_mgmt,\ndiff --git a/net/wireless/util.c b/net/wireless/util.c\nindex ed868c0f7ca8..1ad5a6bdfd75 100644\n--- a/net/wireless/util.c\n+++ b/net/wireless/util.c\n@@ -820,6 +820,52 @@ bool ieee80211_is_valid_amsdu(struct sk_buff *skb, u8 mesh_hdr)\n }\n EXPORT_SYMBOL(ieee80211_is_valid_amsdu);\n \n+\n+/*\n+ * Detects if an MSDU frame was maliciously converted into an A-MSDU\n+ * frame by an adversary. This is done by parsing the received frame\n+ * as if it were a regular MSDU, even though the A-MSDU flag is set.\n+ *\n+ * For non-mesh interfaces, detection involves checking whether the\n+ * payload, when interpreted as an MSDU, begins with a valid RFC1042\n+ * header. This is done by comparing the A-MSDU subheader's destination\n+ * address to the start of the RFC1042 header.\n+ *\n+ * For mesh interfaces, the MSDU includes a 6-byte Mesh Control field\n+ * and an optional variable-length Mesh Address Extension field before\n+ * the RFC1042 header. The position of the RFC1042 header must therefore\n+ * be calculated based on the mesh header length.\n+ *\n+ * Since this function intentionally parses an A-MSDU frame as an MSDU,\n+ * it only assumes that the A-MSDU subframe header is present, and\n+ * beyond this it performs its own bounds checks under the assumption\n+ * that the frame is instead parsed as a non-aggregated MSDU.\n+ */\n+static bool\n+is_amsdu_aggregation_attack(struct ethhdr *eth, struct sk_buff *skb,\n+\t\t\t    enum nl80211_iftype iftype)\n+{\n+\tint offset;\n+\n+\t/* Non-mesh case can be directly compared */\n+\tif (iftype != NL80211_IFTYPE_MESH_POINT)\n+\t\treturn ether_addr_equal(eth->h_dest, rfc1042_header);\n+\n+\toffset = __ieee80211_get_mesh_hdrlen(eth->h_dest[0]);\n+\tif (offset == 6) {\n+\t\t/* Mesh case with empty address extension field */\n+\t\treturn ether_addr_equal(eth->h_source, rfc1042_header);\n+\t} else if (offset + ETH_ALEN <= skb->len) {\n+\t\t/* Mesh case with non-empty address extension field */\n+\t\tu8 temp[ETH_ALEN];\n+\n+\t\tskb_copy_bits(skb, offset, temp, ETH_ALEN);\n+\t\treturn ether_addr_equal(temp, rfc1042_header);\n+\t}\n+\n+\treturn false;\n+}\n+\n void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n \t\t\t      const unsigned int extra_headroom,\n@@ -861,8 +907,10 @@ void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t/* the last MSDU has no padding */\n \t\tif (subframe_len > remaining)\n \t\t\tgoto purge;\n-\t\t/* mitigate A-MSDU aggregation injection attacks */\n-\t\tif (ether_addr_equal(hdr.eth.h_dest, rfc1042_header))\n+\t\t/* mitigate A-MSDU aggregation injection attacks, to be\n+\t\t * checked when processing first subframe (offset == 0).\n+\t\t */\n+\t\tif (offset == 0 && is_amsdu_aggregation_attack(&hdr.eth, skb, iftype))\n \t\t\tgoto purge;\n \n \t\toffset += sizeof(struct ethhdr);\ndiff --git a/tools/testing/selftests/net/gre_ipv6_lladdr.sh b/tools/testing/selftests/net/gre_ipv6_lladdr.sh\nindex 5b34f6e1f831..48eb999a3120 100755\n--- a/tools/testing/selftests/net/gre_ipv6_lladdr.sh\n+++ b/tools/testing/selftests/net/gre_ipv6_lladdr.sh\n@@ -24,7 +24,10 @@ setup_basenet()\n \tip -netns \"${NS0}\" address add dev lo 2001:db8::10/64 nodad\n }\n \n-# Check if network device has an IPv6 link-local address assigned.\n+# Check the IPv6 configuration of a network device.\n+#\n+# We currently check the generation of the link-local IPv6 address and the\n+# creation of the ff00::/8 multicast route.\n #\n # Parameters:\n #\n@@ -35,7 +38,7 @@ setup_basenet()\n #         a link-local address)\n #   * $4: The user visible name for the scenario being tested\n #\n-check_ipv6_ll_addr()\n+check_ipv6_device_config()\n {\n \tlocal DEV=\"$1\"\n \tlocal EXTRA_MATCH=\"$2\"\n@@ -45,7 +48,11 @@ check_ipv6_ll_addr()\n \tRET=0\n \tset +e\n \tip -netns \"${NS0}\" -6 address show dev \"${DEV}\" scope link | grep \"fe80::\" | grep -q \"${EXTRA_MATCH}\"\n-\tcheck_err_fail \"${XRET}\" $? \"\"\n+\tcheck_err_fail \"${XRET}\" $? \"IPv6 link-local address generation\"\n+\n+\tip -netns \"${NS0}\" -6 route show table local type multicast ff00::/8 proto kernel | grep -q \"${DEV}\"\n+\tcheck_err_fail 0 $? \"IPv6 multicast route creation\"\n+\n \tlog_test \"${MSG}\"\n \tset -e\n }\n@@ -102,20 +109,20 @@ test_gre_device()\n \t\t;;\n \tesac\n \n-\t# Check that IPv6 link-local address is generated when device goes up\n+\t# Check the IPv6 device configuration when it goes up\n \tip netns exec \"${NS0}\" sysctl -qw net.ipv6.conf.gretest.addr_gen_mode=\"${ADDR_GEN_MODE}\"\n \tip -netns \"${NS0}\" link set dev gretest up\n-\tcheck_ipv6_ll_addr gretest \"${MATCH_REGEXP}\" \"${XRET}\" \"config: ${MSG}\"\n+\tcheck_ipv6_device_config gretest \"${MATCH_REGEXP}\" \"${XRET}\" \"config: ${MSG}\"\n \n \t# Now disable link-local address generation\n \tip -netns \"${NS0}\" link set dev gretest down\n \tip netns exec \"${NS0}\" sysctl -qw net.ipv6.conf.gretest.addr_gen_mode=1\n \tip -netns \"${NS0}\" link set dev gretest up\n \n-\t# Check that link-local address generation works when re-enabled while\n-\t# the device is already up\n+\t# Check the IPv6 device configuration when link-local address\n+\t# generation is re-enabled while the device is already up\n \tip netns exec \"${NS0}\" sysctl -qw net.ipv6.conf.gretest.addr_gen_mode=\"${ADDR_GEN_MODE}\"\n-\tcheck_ipv6_ll_addr gretest \"${MATCH_REGEXP}\" \"${XRET}\" \"update: ${MSG}\"\n+\tcheck_ipv6_device_config gretest \"${MATCH_REGEXP}\" \"${XRET}\" \"update: ${MSG}\"\n \n \tip -netns \"${NS0}\" link del dev gretest\n }\n@@ -126,7 +133,7 @@ test_gre4()\n \tlocal MODE\n \n \tfor GRE_TYPE in \"gre\" \"gretap\"; do\n-\t\tprintf \"\\n####\\nTesting IPv6 link-local address generation on ${GRE_TYPE} devices\\n####\\n\\n\"\n+\t\tprintf \"\\n####\\nTesting IPv6 configuration of ${GRE_TYPE} devices\\n####\\n\\n\"\n \n \t\tfor MODE in \"eui64\" \"none\" \"stable-privacy\" \"random\"; do\n \t\t\ttest_gre_device \"${GRE_TYPE}\" 192.0.2.10 192.0.2.11 \"${MODE}\"\n@@ -142,7 +149,7 @@ test_gre6()\n \tlocal MODE\n \n \tfor GRE_TYPE in \"ip6gre\" \"ip6gretap\"; do\n-\t\tprintf \"\\n####\\nTesting IPv6 link-local address generation on ${GRE_TYPE} devices\\n####\\n\\n\"\n+\t\tprintf \"\\n####\\nTesting IPv6 configuration of ${GRE_TYPE} devices\\n####\\n\\n\"\n \n \t\tfor MODE in \"eui64\" \"none\" \"stable-privacy\" \"random\"; do\n \t\t\ttest_gre_device \"${GRE_TYPE}\" 2001:db8::10 2001:db8::11 \"${MODE}\"\ndiff --git a/tools/testing/selftests/net/lib.sh b/tools/testing/selftests/net/lib.sh\nindex 006fdadcc4b9..86a216e9aca8 100644\n--- a/tools/testing/selftests/net/lib.sh\n+++ b/tools/testing/selftests/net/lib.sh\n@@ -312,7 +312,7 @@ log_test_result()\n \tlocal test_name=$1; shift\n \tlocal opt_str=$1; shift\n \tlocal result=$1; shift\n-\tlocal retmsg=$1; shift\n+\tlocal retmsg=$1\n \n \tprintf \"TEST: %-60s  [%s]\\n\" \"$test_name $opt_str\" \"$result\"\n \tif [[ $retmsg ]]; then",
    "stats": {
      "insertions": 500,
      "deletions": 277,
      "files": 57
    }
  },
  {
    "sha": "b74c2a2e9cc471e847abd87e50a2354c07e02040",
    "message": "bnxt_en: Fix DCB ETS validation\n\nIn bnxt_ets_validate(), the code incorrectly loops over all possible\ntraffic classes to check and add the ETS settings.  Fix it to loop\nover the configured traffic classes only.\n\nThe unconfigured traffic classes will default to TSA_ETS with 0\nbandwidth.  Looping over these unconfigured traffic classes may\ncause the validation to fail and trigger this error message:\n\n\"rejecting ETS config starving a TC\\n\"\n\nThe .ieee_setets() will then fail.\n\nFixes: 7df4ae9fe855 (\"bnxt_en: Implement DCBNL to support host-based DCBX.\")\nReviewed-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>\nSigned-off-by: Shravya KN <shravya.k-n@broadcom.com>\nSigned-off-by: Michael Chan <michael.chan@broadcom.com>\nLink: https://patch.msgid.link/20250710213938.1959625-2-michael.chan@broadcom.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Shravya KN",
    "date": "2025-07-11T07:28:34-07:00",
    "files_changed": [
      "drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\nindex 0dbb880a7aa0..71e14be2507e 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_dcb.c\n@@ -487,7 +487,9 @@ static int bnxt_ets_validate(struct bnxt *bp, struct ieee_ets *ets, u8 *tc)\n \n \t\tif ((ets->tc_tx_bw[i] || ets->tc_tsa[i]) && i > bp->max_tc)\n \t\t\treturn -EINVAL;\n+\t}\n \n+\tfor (i = 0; i < max_tc; i++) {\n \t\tswitch (ets->tc_tsa[i]) {\n \t\tcase IEEE_8021QAZ_TSA_STRICT:\n \t\t\tbreak;",
    "stats": {
      "insertions": 2,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "e81750b4e3826fedce7362dad839cb40384d60ae",
    "message": "net: ll_temac: Fix missing tx_pending check in ethtools_set_ringparam()\n\nThe function ll_temac_ethtools_set_ringparam() incorrectly checked\nrx_pending twice, once correctly for RX and once mistakenly in place\nof tx_pending. This caused tx_pending to be left unchecked against\nTX_BD_NUM_MAX.\nAs a result, invalid TX ring sizes may have been accepted or valid\nones wrongly rejected based on the RX limit, leading to potential\nmisconfiguration or unexpected results.\n\nThis patch corrects the condition to properly validate tx_pending.\n\nFixes: f7b261bfc35e (\"net: ll_temac: Make RX/TX ring sizes configurable\")\nSigned-off-by: Alok Tiwari <alok.a.tiwari@oracle.com>\nLink: https://patch.msgid.link/20250710180621.2383000-1-alok.a.tiwari@oracle.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Alok Tiwari",
    "date": "2025-07-11T07:27:26-07:00",
    "files_changed": [
      "drivers/net/ethernet/xilinx/ll_temac_main.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/xilinx/ll_temac_main.c b/drivers/net/ethernet/xilinx/ll_temac_main.c\nindex edb36ff07a0c..6f82203a414c 100644\n--- a/drivers/net/ethernet/xilinx/ll_temac_main.c\n+++ b/drivers/net/ethernet/xilinx/ll_temac_main.c\n@@ -1309,7 +1309,7 @@ ll_temac_ethtools_set_ringparam(struct net_device *ndev,\n \tif (ering->rx_pending > RX_BD_NUM_MAX ||\n \t    ering->rx_mini_pending ||\n \t    ering->rx_jumbo_pending ||\n-\t    ering->rx_pending > TX_BD_NUM_MAX)\n+\t    ering->tx_pending > TX_BD_NUM_MAX)\n \t\treturn -EINVAL;\n \n \tif (netif_running(ndev))",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "eb41a264a3a576dc040ee37c3d9d6b7e2d9be968",
    "message": "net/mlx5e: Fix race between DIM disable and net_dim()\n\nThere's a race between disabling DIM and NAPI callbacks using the dim\npointer on the RQ or SQ.\n\nIf NAPI checks the DIM state bit and sees it still set, it assumes\n`rq->dim` or `sq->dim` is valid. But if DIM gets disabled right after\nthat check, the pointer might already be set to NULL, leading to a NULL\npointer dereference in net_dim().\n\nFix this by calling `synchronize_net()` before freeing the DIM context.\nThis ensures all in-progress NAPI callbacks are finished before the\npointer is cleared.\n\nKernel log:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000000\n...\nRIP: 0010:net_dim+0x23/0x190\n...\nCall Trace:\n <TASK>\n ? __die+0x20/0x60\n ? page_fault_oops+0x150/0x3e0\n ? common_interrupt+0xf/0xa0\n ? sysvec_call_function_single+0xb/0x90\n ? exc_page_fault+0x74/0x130\n ? asm_exc_page_fault+0x22/0x30\n ? net_dim+0x23/0x190\n ? mlx5e_poll_ico_cq+0x41/0x6f0 [mlx5_core]\n ? sysvec_apic_timer_interrupt+0xb/0x90\n mlx5e_handle_rx_dim+0x92/0xd0 [mlx5_core]\n mlx5e_napi_poll+0x2cd/0xac0 [mlx5_core]\n ? mlx5e_poll_ico_cq+0xe5/0x6f0 [mlx5_core]\n busy_poll_stop+0xa2/0x200\n ? mlx5e_napi_poll+0x1d9/0xac0 [mlx5_core]\n ? mlx5e_trigger_irq+0x130/0x130 [mlx5_core]\n __napi_busy_loop+0x345/0x3b0\n ? sysvec_call_function_single+0xb/0x90\n ? asm_sysvec_call_function_single+0x16/0x20\n ? sysvec_apic_timer_interrupt+0xb/0x90\n ? pcpu_free_area+0x1e4/0x2e0\n napi_busy_loop+0x11/0x20\n xsk_recvmsg+0x10c/0x130\n sock_recvmsg+0x44/0x70\n __sys_recvfrom+0xbc/0x130\n ? __schedule+0x398/0x890\n __x64_sys_recvfrom+0x20/0x30\n do_syscall_64+0x4c/0x100\n entry_SYSCALL_64_after_hwframe+0x4b/0x53\n...\n---[ end trace 0000000000000000 ]---\n...\n---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---\n\nFixes: 445a25f6e1a2 (\"net/mlx5e: Support updating coalescing configuration without resetting channels\")\nSigned-off-by: Carolina Jubran <cjubran@nvidia.com>\nReviewed-by: Cosmin Ratiu <cratiu@nvidia.com>\nSigned-off-by: Tariq Toukan <tariqt@nvidia.com>\nReviewed-by: Jacob Keller <jacob.e.keller@intel.com>\nLink: https://patch.msgid.link/1752155624-24095-3-git-send-email-tariqt@nvidia.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Carolina Jubran",
    "date": "2025-07-11T07:26:44-07:00",
    "files_changed": [
      "drivers/net/ethernet/mellanox/mlx5/core/en_dim.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c b/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\nindex 298bb74ec5e9..d1d629697e28 100644\n--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dim.c\n@@ -113,7 +113,7 @@ int mlx5e_dim_rx_change(struct mlx5e_rq *rq, bool enable)\n \t\t__set_bit(MLX5E_RQ_STATE_DIM, &rq->state);\n \t} else {\n \t\t__clear_bit(MLX5E_RQ_STATE_DIM, &rq->state);\n-\n+\t\tsynchronize_net();\n \t\tmlx5e_dim_disable(rq->dim);\n \t\trq->dim = NULL;\n \t}\n@@ -140,7 +140,7 @@ int mlx5e_dim_tx_change(struct mlx5e_txqsq *sq, bool enable)\n \t\t__set_bit(MLX5E_SQ_STATE_DIM, &sq->state);\n \t} else {\n \t\t__clear_bit(MLX5E_SQ_STATE_DIM, &sq->state);\n-\n+\t\tsynchronize_net();\n \t\tmlx5e_dim_disable(sq->dim);\n \t\tsq->dim = NULL;\n \t}",
    "stats": {
      "insertions": 2,
      "deletions": 2,
      "files": 1
    }
  }
]
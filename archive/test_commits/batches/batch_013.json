[
  {
    "sha": "df46426745ac58618c822ce3f93d2bb25b9a5060",
    "message": "Merge tag 'platform-drivers-x86-v6.16-3' of git://git.kernel.org/pub/scm/linux/kernel/git/pdx86/platform-drivers-x86\n\nPull x86 platform drivers fixes from Ilpo JÃ¤rvinen:\n \"Mostly a few lines fixed here and there except amd/isp4 which improves\n  swnodes relationships but that is a new driver not in any stable\n  kernels yet. The think-lmi driver changes also look relatively large\n  but there are just many fixes to it.\n\n  The i2c/piix4 change is a effectively a revert of the commit\n  7e173eb82ae9 (\"i2c: piix4: Make CONFIG_I2C_PIIX4 dependent on\n  CONFIG_X86\") but that required moving the header out from arch/x86\n  under include/linux/platform_data/\n\n  Summary:\n\n   - amd/isp4: Improve swnode graph (new driver exception)\n\n   - asus-nb-wmi: Use duo keyboard quirk for Zenbook Duo UX8406CA\n\n   - dell-lis3lv02d: Add Latitude 5500 accelerometer address\n\n   - dell-wmi-sysman: Fix WMI data block retrieval and class dev unreg\n\n   - hp-bioscfg: Fix class device unregistration\n\n   - i2c: piix4: Re-enable on non-x86 + move FCH header under platform_data/\n\n   - intel/hid: Wildcat Lake support\n\n   - mellanox:\n      - mlxbf-pmc: Fix duplicate event ID\n      - mlxbf-tmfifo: Fix vring_desc.len assignment\n      - mlxreg-lc: Fix bit-not-set logic check\n      - nvsw-sn2201: Fix bus number in error message & spelling errors\n\n   - portwell-ec: Move watchdog device under correct platform hierarchy\n\n   - think-lmi: Error handling fixes (sysfs, kset, kobject, class dev unreg)\n\n   - thinkpad_acpi: Handle HKEY 0x1402 event (2025 Thinkpads)\n\n   - wmi: Fix WMI event enablement\"\n\n* tag 'platform-drivers-x86-v6.16-3' of git://git.kernel.org/pub/scm/linux/kernel/git/pdx86/platform-drivers-x86: (22 commits)\n  platform/x86: think-lmi: Fix sysfs group cleanup\n  platform/x86: think-lmi: Fix kobject cleanup\n  platform/x86: think-lmi: Create ksets consecutively\n  platform/mellanox: mlxreg-lc: Fix logic error in power state check\n  i2c: Re-enable piix4 driver on non-x86\n  Move FCH header to a location accessible by all archs\n  platform/x86/intel/hid: Add Wildcat Lake support\n  platform/x86: dell-wmi-sysman: Fix class device unregistration\n  platform/x86: think-lmi: Fix class device unregistration\n  platform/x86: hp-bioscfg: Fix class device unregistration\n  platform/x86: Update swnode graph for amd isp4\n  platform/x86: dell-wmi-sysman: Fix WMI data block retrieval in sysfs callbacks\n  platform/x86: wmi: Update documentation of WCxx/WExx ACPI methods\n  platform/x86: wmi: Fix WMI event enablement\n  platform/mellanox: nvsw-sn2201: Fix bus number in adapter error message\n  platform/mellanox: Fix spelling and comment clarity in Mellanox drivers\n  platform/mellanox: mlxbf-pmc: Fix duplicate event ID for CACHE_DATA1\n  platform/x86: thinkpad_acpi: handle HKEY 0x1402 event\n  platform/x86: asus-nb-wmi: add DMI quirk for ASUS Zenbook Duo UX8406CA\n  platform/x86: dell-lis3lv02d: Add Latitude 5500\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-07-04T10:05:31-07:00",
    "files_changed": [
      "arch/x86/include/asm/amd/fch.h",
      "arch/x86/kernel/cpu/amd.c",
      "drivers/i2c/busses/i2c-piix4.c",
      "drivers/platform/mellanox/mlxbf-pmc.c",
      "drivers/platform/mellanox/mlxbf-tmfifo.c",
      "drivers/platform/mellanox/mlxreg-dpu.c",
      "drivers/platform/mellanox/mlxreg-lc.c",
      "drivers/platform/mellanox/nvsw-sn2201.c",
      "drivers/platform/x86/amd/amd_isp4.c",
      "drivers/platform/x86/amd/pmc/pmc-quirks.c",
      "drivers/platform/x86/asus-nb-wmi.c",
      "drivers/platform/x86/dell/dell-lis3lv02d.c",
      "drivers/platform/x86/dell/dell-wmi-sysman/dell-wmi-sysman.h",
      "drivers/platform/x86/dell/dell-wmi-sysman/enum-attributes.c",
      "drivers/platform/x86/dell/dell-wmi-sysman/int-attributes.c",
      "drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c",
      "drivers/platform/x86/dell/dell-wmi-sysman/string-attributes.c",
      "drivers/platform/x86/dell/dell-wmi-sysman/sysman.c",
      "drivers/platform/x86/hp/hp-bioscfg/bioscfg.c",
      "drivers/platform/x86/intel/hid.c",
      "drivers/platform/x86/portwell-ec.c",
      "drivers/platform/x86/think-lmi.c",
      "drivers/platform/x86/thinkpad_acpi.c",
      "drivers/platform/x86/wmi.c",
      "include/linux/platform_data/x86/amd-fch.h"
    ],
    "diff": "diff --git a/Documentation/wmi/acpi-interface.rst b/Documentation/wmi/acpi-interface.rst\nindex f1b28835d23c..1ef003b033bf 100644\n--- a/Documentation/wmi/acpi-interface.rst\n+++ b/Documentation/wmi/acpi-interface.rst\n@@ -36,7 +36,7 @@ Offset  Size (in bytes) Content\n \n The WMI object flags control whether the method or notification ID is used:\n \n-- 0x1: Data block usage is expensive and must be explicitly enabled/disabled.\n+- 0x1: Data block is expensive to collect.\n - 0x2: Data block contains WMI methods.\n - 0x4: Data block contains ASCIZ string.\n - 0x8: Data block describes a WMI event, use notification ID instead\n@@ -83,14 +83,18 @@ event as hexadecimal value. Their first parameter is an integer with a value\n of 0 if the WMI event should be disabled, other values will enable\n the WMI event.\n \n+Those ACPI methods are always called even for WMI events not registered as\n+being expensive to collect to match the behavior of the Windows driver.\n+\n WCxx ACPI methods\n -----------------\n-Similar to the ``WExx`` ACPI methods, except that it controls data collection\n-instead of events and thus the last two characters of the ACPI method name are\n-the method ID of the data block to enable/disable.\n+Similar to the ``WExx`` ACPI methods, except that instead of WMI events it controls\n+data collection of data blocks registered as being expensive to collect. Thus the\n+last two characters of the ACPI method name are the method ID of the data block\n+to enable/disable.\n \n Those ACPI methods are also called before setting data blocks to match the\n-behaviour of the Windows driver.\n+behavior of the Windows driver.\n \n _WED ACPI method\n ----------------\ndiff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c\nindex b2ad8d13211a..655f44f89ded 100644\n--- a/arch/x86/kernel/cpu/amd.c\n+++ b/arch/x86/kernel/cpu/amd.c\n@@ -9,7 +9,7 @@\n #include <linux/sched/clock.h>\n #include <linux/random.h>\n #include <linux/topology.h>\n-#include <asm/amd/fch.h>\n+#include <linux/platform_data/x86/amd-fch.h>\n #include <asm/processor.h>\n #include <asm/apic.h>\n #include <asm/cacheinfo.h>\ndiff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig\nindex 0a4ecccd1851..c8d115b58e44 100644\n--- a/drivers/i2c/busses/Kconfig\n+++ b/drivers/i2c/busses/Kconfig\n@@ -200,7 +200,7 @@ config I2C_ISMT\n \n config I2C_PIIX4\n \ttristate \"Intel PIIX4 and compatible (ATI/AMD/Serverworks/Broadcom/SMSC)\"\n-\tdepends on PCI && HAS_IOPORT && X86\n+\tdepends on PCI && HAS_IOPORT\n \tselect I2C_SMBUS\n \thelp\n \t  If you say yes to this option, support will be included for the Intel\ndiff --git a/drivers/i2c/busses/i2c-piix4.c b/drivers/i2c/busses/i2c-piix4.c\nindex 9d3a4dc2bd60..ac3bb550303f 100644\n--- a/drivers/i2c/busses/i2c-piix4.c\n+++ b/drivers/i2c/busses/i2c-piix4.c\n@@ -34,7 +34,7 @@\n #include <linux/dmi.h>\n #include <linux/acpi.h>\n #include <linux/io.h>\n-#include <asm/amd/fch.h>\n+#include <linux/platform_data/x86/amd-fch.h>\n \n #include \"i2c-piix4.h\"\n \ndiff --git a/drivers/platform/mellanox/mlxbf-pmc.c b/drivers/platform/mellanox/mlxbf-pmc.c\nindex 900069eb186e..a1c529f1ff1a 100644\n--- a/drivers/platform/mellanox/mlxbf-pmc.c\n+++ b/drivers/platform/mellanox/mlxbf-pmc.c\n@@ -715,7 +715,7 @@ static const struct mlxbf_pmc_events mlxbf_pmc_llt_events[] = {\n \t{101, \"GDC_BANK0_HIT_DCL_PARTIAL\"},\n \t{102, \"GDC_BANK0_EVICT_DCL\"},\n \t{103, \"GDC_BANK0_G_RSE_PIPE_CACHE_DATA0\"},\n-\t{103, \"GDC_BANK0_G_RSE_PIPE_CACHE_DATA1\"},\n+\t{104, \"GDC_BANK0_G_RSE_PIPE_CACHE_DATA1\"},\n \t{105, \"GDC_BANK0_ARB_STRB\"},\n \t{106, \"GDC_BANK0_ARB_WAIT\"},\n \t{107, \"GDC_BANK0_GGA_STRB\"},\ndiff --git a/drivers/platform/mellanox/mlxbf-tmfifo.c b/drivers/platform/mellanox/mlxbf-tmfifo.c\nindex aae99adb29eb..14aa87b39be5 100644\n--- a/drivers/platform/mellanox/mlxbf-tmfifo.c\n+++ b/drivers/platform/mellanox/mlxbf-tmfifo.c\n@@ -281,7 +281,8 @@ static int mlxbf_tmfifo_alloc_vrings(struct mlxbf_tmfifo *fifo,\n \t\tvring->align = SMP_CACHE_BYTES;\n \t\tvring->index = i;\n \t\tvring->vdev_id = tm_vdev->vdev.id.device;\n-\t\tvring->drop_desc.len = VRING_DROP_DESC_MAX_LEN;\n+\t\tvring->drop_desc.len = cpu_to_virtio32(&tm_vdev->vdev,\n+\t\t\t\t\t\t       VRING_DROP_DESC_MAX_LEN);\n \t\tdev = &tm_vdev->vdev.dev;\n \n \t\tsize = vring_size(vring->num, vring->align);\n@@ -1287,7 +1288,7 @@ static void mlxbf_tmfifo_get_cfg_mac(u8 *mac)\n \t\tether_addr_copy(mac, mlxbf_tmfifo_net_default_mac);\n }\n \n-/* Set TmFifo thresolds which is used to trigger interrupts. */\n+/* Set TmFifo thresholds which is used to trigger interrupts. */\n static void mlxbf_tmfifo_set_threshold(struct mlxbf_tmfifo *fifo)\n {\n \tu64 ctl;\ndiff --git a/drivers/platform/mellanox/mlxreg-dpu.c b/drivers/platform/mellanox/mlxreg-dpu.c\nindex 52260106a9f1..39f89c47144a 100644\n--- a/drivers/platform/mellanox/mlxreg-dpu.c\n+++ b/drivers/platform/mellanox/mlxreg-dpu.c\n@@ -483,7 +483,7 @@ static int mlxreg_dpu_config_init(struct mlxreg_dpu *mlxreg_dpu, void *regmap,\n \t\t\t\t\t\t\t  mlxreg_dpu->io_data,\n \t\t\t\t\t\t\t  sizeof(*mlxreg_dpu->io_data));\n \t\tif (IS_ERR(mlxreg_dpu->io_regs)) {\n-\t\t\tdev_err(dev, \"Failed to create regio for client %s at bus %d at addr 0x%02x\\n\",\n+\t\t\tdev_err(dev, \"Failed to create region for client %s at bus %d at addr 0x%02x\\n\",\n \t\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr,\n \t\t\t\tdata->hpdev.brdinfo->addr);\n \t\t\treturn PTR_ERR(mlxreg_dpu->io_regs);\ndiff --git a/drivers/platform/mellanox/mlxreg-lc.c b/drivers/platform/mellanox/mlxreg-lc.c\nindex aee395bb48ae..d1518598dfed 100644\n--- a/drivers/platform/mellanox/mlxreg-lc.c\n+++ b/drivers/platform/mellanox/mlxreg-lc.c\n@@ -57,9 +57,9 @@ enum mlxreg_lc_state {\n  * @dev: platform device;\n  * @lock: line card lock;\n  * @par_regmap: parent device regmap handle;\n- * @data: pltaform core data;\n+ * @data: platform core data;\n  * @io_data: register access platform data;\n- * @led_data: LED platform data ;\n+ * @led_data: LED platform data;\n  * @mux_data: MUX platform data;\n  * @led: LED device;\n  * @io_regs: register access device;\n@@ -171,7 +171,7 @@ static int mlxreg_lc_chan[] = {\n \t0x4e, 0x4f\n };\n \n-/* Defaul mux configuration. */\n+/* Default mux configuration. */\n static struct mlxcpld_mux_plat_data mlxreg_lc_mux_data[] = {\n \t{\n \t\t.chan_ids = mlxreg_lc_chan,\n@@ -181,7 +181,7 @@ static struct mlxcpld_mux_plat_data mlxreg_lc_mux_data[] = {\n \t},\n };\n \n-/* Defaul mux board info. */\n+/* Default mux board info. */\n static struct i2c_board_info mlxreg_lc_mux_brdinfo = {\n \tI2C_BOARD_INFO(\"i2c-mux-mlxcpld\", 0x32),\n };\n@@ -688,7 +688,7 @@ static int mlxreg_lc_completion_notify(void *handle, struct i2c_adapter *parent,\n \tif (regval & mlxreg_lc->data->mask) {\n \t\tmlxreg_lc->state |= MLXREG_LC_SYNCED;\n \t\tmlxreg_lc_state_update_locked(mlxreg_lc, MLXREG_LC_SYNCED, 1);\n-\t\tif (mlxreg_lc->state & ~MLXREG_LC_POWERED) {\n+\t\tif (!(mlxreg_lc->state & MLXREG_LC_POWERED)) {\n \t\t\terr = mlxreg_lc_power_on_off(mlxreg_lc, 1);\n \t\t\tif (err)\n \t\t\t\tgoto mlxreg_lc_regmap_power_on_off_fail;\n@@ -758,7 +758,7 @@ mlxreg_lc_config_init(struct mlxreg_lc *mlxreg_lc, void *regmap,\n \t\tplatform_device_register_resndata(dev, \"mlxreg-io\", data->hpdev.nr, NULL, 0,\n \t\t\t\t\t\t  mlxreg_lc->io_data, sizeof(*mlxreg_lc->io_data));\n \t\tif (IS_ERR(mlxreg_lc->io_regs)) {\n-\t\t\tdev_err(dev, \"Failed to create regio for client %s at bus %d at addr 0x%02x\\n\",\n+\t\t\tdev_err(dev, \"Failed to create region for client %s at bus %d at addr 0x%02x\\n\",\n \t\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr,\n \t\t\t\tdata->hpdev.brdinfo->addr);\n \t\t\terr = PTR_ERR(mlxreg_lc->io_regs);\ndiff --git a/drivers/platform/mellanox/nvsw-sn2201.c b/drivers/platform/mellanox/nvsw-sn2201.c\nindex db31c8bf2255..51504113c17e 100644\n--- a/drivers/platform/mellanox/nvsw-sn2201.c\n+++ b/drivers/platform/mellanox/nvsw-sn2201.c\n@@ -1181,7 +1181,7 @@ static int nvsw_sn2201_i2c_completion_notify(void *handle, int id)\n \tif (!nvsw_sn2201->main_mux_devs->adapter) {\n \t\terr = -ENODEV;\n \t\tdev_err(nvsw_sn2201->dev, \"Failed to get adapter for bus %d\\n\",\n-\t\t\tnvsw_sn2201->cpld_devs->nr);\n+\t\t\tnvsw_sn2201->main_mux_devs->nr);\n \t\tgoto i2c_get_adapter_main_fail;\n \t}\n \ndiff --git a/drivers/platform/x86/amd/amd_isp4.c b/drivers/platform/x86/amd/amd_isp4.c\nindex 9f291aeb35f1..0d494899502c 100644\n--- a/drivers/platform/x86/amd/amd_isp4.c\n+++ b/drivers/platform/x86/amd/amd_isp4.c\n@@ -21,6 +21,9 @@\n #define AMDISP_OV05C10_REMOTE_EP_NAME\t\"ov05c10_isp_4_1_1\"\n #define AMD_ISP_PLAT_DRV_NAME\t\t\"amd-isp4\"\n \n+static const struct software_node isp4_mipi1_endpoint_node;\n+static const struct software_node ov05c10_endpoint_node;\n+\n /*\n  * AMD ISP platform info definition to initialize sensor\n  * specific platform configuration to prepare the amdisp\n@@ -43,55 +46,116 @@ struct amdisp_platform {\n \tstruct mutex lock;\t/* protects i2c client creation */\n };\n \n-/* Top-level OV05C10 camera node property table */\n+/* Root AMD CAMERA SWNODE */\n+\n+/* Root amd camera node definition */\n+static const struct software_node amd_camera_node = {\n+\t.name = \"amd_camera\",\n+};\n+\n+/* ISP4 SWNODE */\n+\n+/* ISP4 OV05C10 camera node definition */\n+static const struct software_node isp4_node = {\n+\t.name = \"isp4\",\n+\t.parent = &amd_camera_node,\n+};\n+\n+/*\n+ * ISP4 Ports node definition. No properties defined for\n+ * ports node.\n+ */\n+static const struct software_node isp4_ports = {\n+\t.name = \"ports\",\n+\t.parent = &isp4_node,\n+};\n+\n+/*\n+ * ISP4 Port node definition. No properties defined for\n+ * port node.\n+ */\n+static const struct software_node isp4_port_node = {\n+\t.name = \"port@0\",\n+\t.parent = &isp4_ports,\n+};\n+\n+/*\n+ * ISP4 MIPI1 remote endpoint points to OV05C10 endpoint\n+ * node.\n+ */\n+static const struct software_node_ref_args isp4_refs[] = {\n+\tSOFTWARE_NODE_REFERENCE(&ov05c10_endpoint_node),\n+};\n+\n+/* ISP4 MIPI1 endpoint node properties table */\n+static const struct property_entry isp4_mipi1_endpoint_props[] = {\n+\tPROPERTY_ENTRY_REF_ARRAY(\"remote-endpoint\", isp4_refs),\n+\t{ }\n+};\n+\n+/* ISP4 MIPI1 endpoint node definition */\n+static const struct software_node isp4_mipi1_endpoint_node = {\n+\t.name = \"endpoint\",\n+\t.parent = &isp4_port_node,\n+\t.properties = isp4_mipi1_endpoint_props,\n+};\n+\n+/* I2C1 SWNODE */\n+\n+/* I2C1 camera node property table */\n+static const struct property_entry i2c1_camera_props[] = {\n+\tPROPERTY_ENTRY_U32(\"clock-frequency\", 1 * HZ_PER_MHZ),\n+\t{ }\n+};\n+\n+/* I2C1 camera node definition */\n+static const struct software_node i2c1_node = {\n+\t.name = \"i2c1\",\n+\t.parent = &amd_camera_node,\n+\t.properties = i2c1_camera_props,\n+};\n+\n+/* I2C1 camera node property table */\n static const struct property_entry ov05c10_camera_props[] = {\n \tPROPERTY_ENTRY_U32(\"clock-frequency\", 24 * HZ_PER_MHZ),\n \t{ }\n };\n \n-/* Root AMD ISP OV05C10 camera node definition */\n-static const struct software_node camera_node = {\n+/* OV05C10 camera node definition */\n+static const struct software_node ov05c10_camera_node = {\n \t.name = AMDISP_OV05C10_HID,\n+\t.parent = &i2c1_node,\n \t.properties = ov05c10_camera_props,\n };\n \n /*\n- * AMD ISP OV05C10 Ports node definition. No properties defined for\n+ * OV05C10 Ports node definition. No properties defined for\n  * ports node for OV05C10.\n  */\n-static const struct software_node ports = {\n+static const struct software_node ov05c10_ports = {\n \t.name = \"ports\",\n-\t.parent = &camera_node,\n-};\n-\n-/*\n- * AMD ISP OV05C10 Port node definition. No properties defined for\n- * port node for OV05C10.\n- */\n-static const struct software_node port_node = {\n-\t.name = \"port@\",\n-\t.parent = &ports,\n+\t.parent = &ov05c10_camera_node,\n };\n \n /*\n- * Remote endpoint AMD ISP node definition. No properties defined for\n- * remote endpoint node for OV05C10.\n+ * OV05C10 Port node definition.\n  */\n-static const struct software_node remote_ep_isp_node = {\n-\t.name = AMDISP_OV05C10_REMOTE_EP_NAME,\n+static const struct software_node ov05c10_port_node = {\n+\t.name = \"port@0\",\n+\t.parent = &ov05c10_ports,\n };\n \n /*\n- * Remote endpoint reference for isp node included in the\n- * OV05C10 endpoint.\n+ * OV05C10 remote endpoint points to ISP4 MIPI1 endpoint\n+ * node.\n  */\n static const struct software_node_ref_args ov05c10_refs[] = {\n-\tSOFTWARE_NODE_REFERENCE(&remote_ep_isp_node),\n+\tSOFTWARE_NODE_REFERENCE(&isp4_mipi1_endpoint_node),\n };\n \n /* OV05C10 supports one single link frequency */\n static const u64 ov05c10_link_freqs[] = {\n-\t925 * HZ_PER_MHZ,\n+\t900 * HZ_PER_MHZ,\n };\n \n /* OV05C10 supports only 2-lane configuration */\n@@ -111,27 +175,64 @@ static const struct property_entry ov05c10_endpoint_props[] = {\n \t{ }\n };\n \n-/* AMD ISP endpoint node definition */\n-static const struct software_node endpoint_node = {\n+/* OV05C10 endpoint node definition */\n+static const struct software_node ov05c10_endpoint_node = {\n \t.name = \"endpoint\",\n-\t.parent = &port_node,\n+\t.parent = &ov05c10_port_node,\n \t.properties = ov05c10_endpoint_props,\n };\n \n /*\n- * AMD ISP swnode graph uses 5 nodes and also its relationship is\n- * fixed to align with the structure that v4l2 expects for successful\n- * endpoint fwnode parsing.\n+ * AMD Camera swnode graph uses 10 nodes and also its relationship is\n+ * fixed to align with the structure that v4l2 and i2c frameworks expects\n+ * for successful parsing of fwnodes and its properties with standard names.\n  *\n  * It is only the node property_entries that will vary for each platform\n  * supporting different sensor modules.\n+ *\n+ * AMD ISP4 SWNODE GRAPH Structure\n+ *\n+ * amd_camera {\n+ *  isp4 {\n+ *\t  ports {\n+ *\t\t  port@0 {\n+ *\t\t\t  isp4_mipi1_ep: endpoint {\n+ *\t\t\t\t\t  remote-endpoint = &OMNI5C10_ep;\n+ *\t\t\t  };\n+ *\t\t  };\n+ *\t  };\n+ *  };\n+ *\n+ *  i2c1 {\n+ *\t  clock-frequency = 1 MHz;\n+ *\t  OMNI5C10 {\n+ *\t\t  clock-frequency = 24MHz;\n+ *\t\t  ports {\n+ *\t\t\t  port@0 {\n+ *\t\t\t\t  OMNI5C10_ep: endpoint {\n+ *\t\t\t\t\t  bus-type = 4;\n+ *\t\t\t\t\t  data-lanes = <1 2>;\n+ *\t\t\t\t\t  link-frequencies = 900MHz;\n+ *\t\t\t\t\t  remote-endpoint = &isp4_mipi1;\n+ *\t\t\t\t  };\n+ *\t\t\t  };\n+ *\t\t  };\n+ *\t  };\n+ *\t};\n+ * };\n+ *\n  */\n-static const struct software_node *ov05c10_nodes[] = {\n-\t&camera_node,\n-\t&ports,\n-\t&port_node,\n-\t&endpoint_node,\n-\t&remote_ep_isp_node,\n+static const struct software_node *amd_isp4_nodes[] = {\n+\t&amd_camera_node,\n+\t&isp4_node,\n+\t&isp4_ports,\n+\t&isp4_port_node,\n+\t&isp4_mipi1_endpoint_node,\n+\t&i2c1_node,\n+\t&ov05c10_camera_node,\n+\t&ov05c10_ports,\n+\t&ov05c10_port_node,\n+\t&ov05c10_endpoint_node,\n \tNULL\n };\n \n@@ -141,7 +242,7 @@ static const struct amdisp_platform_info ov05c10_platform_config = {\n \t\t.dev_name = \"ov05c10\",\n \t\tI2C_BOARD_INFO(\"ov05c10\", AMDISP_OV05C10_I2C_ADDR),\n \t},\n-\t.swnodes = ov05c10_nodes,\n+\t.swnodes = amd_isp4_nodes,\n };\n \n static const struct acpi_device_id amdisp_sensor_ids[] = {\n@@ -233,7 +334,8 @@ static struct amdisp_platform *prepare_amdisp_platform(struct device *dev,\n \tif (ret)\n \t\treturn ERR_PTR(ret);\n \n-\tisp4_platform->board_info.swnode = src->swnodes[0];\n+\t/* initialize ov05c10_camera_node */\n+\tisp4_platform->board_info.swnode = src->swnodes[6];\n \n \treturn isp4_platform;\n }\n@@ -258,6 +360,7 @@ static int amd_isp_probe(struct platform_device *pdev)\n {\n \tconst struct amdisp_platform_info *pinfo;\n \tstruct amdisp_platform *isp4_platform;\n+\tstruct acpi_device *adev;\n \tint ret;\n \n \tpinfo = device_get_match_data(&pdev->dev);\n@@ -275,6 +378,10 @@ static int amd_isp_probe(struct platform_device *pdev)\n \tif (ret)\n \t\tgoto error_unregister_sw_node;\n \n+\tadev = ACPI_COMPANION(&pdev->dev);\n+\t/* initialize root amd_camera_node */\n+\tadev->driver_data = (void *)pinfo->swnodes[0];\n+\n \t/* check if adapter is already registered and create i2c client instance */\n \ti2c_for_each_dev(isp4_platform, try_to_instantiate_i2c_client);\n \ndiff --git a/drivers/platform/x86/amd/pmc/pmc-quirks.c b/drivers/platform/x86/amd/pmc/pmc-quirks.c\nindex f292111bd065..131f10b68308 100644\n--- a/drivers/platform/x86/amd/pmc/pmc-quirks.c\n+++ b/drivers/platform/x86/amd/pmc/pmc-quirks.c\n@@ -11,7 +11,7 @@\n #include <linux/dmi.h>\n #include <linux/io.h>\n #include <linux/ioport.h>\n-#include <asm/amd/fch.h>\n+#include <linux/platform_data/x86/amd-fch.h>\n \n #include \"pmc.h\"\n \ndiff --git a/drivers/platform/x86/asus-nb-wmi.c b/drivers/platform/x86/asus-nb-wmi.c\nindex 3f8b2a324efd..f84c3d03c1de 100644\n--- a/drivers/platform/x86/asus-nb-wmi.c\n+++ b/drivers/platform/x86/asus-nb-wmi.c\n@@ -530,6 +530,15 @@ static const struct dmi_system_id asus_quirks[] = {\n \t\t},\n \t\t.driver_data = &quirk_asus_zenbook_duo_kbd,\n \t},\n+\t{\n+\t\t.callback = dmi_matched,\n+\t\t.ident = \"ASUS Zenbook Duo UX8406CA\",\n+\t\t.matches = {\n+\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n+\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"UX8406CA\"),\n+\t\t},\n+\t\t.driver_data = &quirk_asus_zenbook_duo_kbd,\n+\t},\n \t{},\n };\n \ndiff --git a/drivers/platform/x86/dell/dell-lis3lv02d.c b/drivers/platform/x86/dell/dell-lis3lv02d.c\nindex efe26d667973..0791118dd6b7 100644\n--- a/drivers/platform/x86/dell/dell-lis3lv02d.c\n+++ b/drivers/platform/x86/dell/dell-lis3lv02d.c\n@@ -45,6 +45,7 @@ static const struct dmi_system_id lis3lv02d_devices[] __initconst = {\n \t * Additional individual entries were added after verification.\n \t */\n \tDELL_LIS3LV02D_DMI_ENTRY(\"Latitude 5480\",      0x29),\n+\tDELL_LIS3LV02D_DMI_ENTRY(\"Latitude 5500\",      0x29),\n \tDELL_LIS3LV02D_DMI_ENTRY(\"Latitude E6330\",     0x29),\n \tDELL_LIS3LV02D_DMI_ENTRY(\"Latitude E6430\",     0x29),\n \tDELL_LIS3LV02D_DMI_ENTRY(\"Precision 3540\",     0x29),\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/dell-wmi-sysman.h b/drivers/platform/x86/dell/dell-wmi-sysman/dell-wmi-sysman.h\nindex 3ad33a094588..817ee7ba07ca 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/dell-wmi-sysman.h\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/dell-wmi-sysman.h\n@@ -89,6 +89,11 @@ extern struct wmi_sysman_priv wmi_priv;\n \n enum { ENUM, INT, STR, PO };\n \n+#define ENUM_MIN_ELEMENTS\t\t8\n+#define INT_MIN_ELEMENTS\t\t9\n+#define STR_MIN_ELEMENTS\t\t8\n+#define PO_MIN_ELEMENTS\t\t\t4\n+\n enum {\n \tATTR_NAME,\n \tDISPL_NAME_LANG_CODE,\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/enum-attributes.c b/drivers/platform/x86/dell/dell-wmi-sysman/enum-attributes.c\nindex 8cc212c85266..fc2f58b4cbc6 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/enum-attributes.c\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/enum-attributes.c\n@@ -23,9 +23,10 @@ static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *a\n \tobj = get_wmiobj_pointer(instance_id, DELL_WMI_BIOS_ENUMERATION_ATTRIBUTE_GUID);\n \tif (!obj)\n \t\treturn -EIO;\n-\tif (obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_STRING) {\n+\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count < ENUM_MIN_ELEMENTS ||\n+\t    obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_STRING) {\n \t\tkfree(obj);\n-\t\treturn -EINVAL;\n+\t\treturn -EIO;\n \t}\n \tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", obj->package.elements[CURRENT_VAL].string.pointer);\n \tkfree(obj);\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/int-attributes.c b/drivers/platform/x86/dell/dell-wmi-sysman/int-attributes.c\nindex 951e75b538fa..735248064239 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/int-attributes.c\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/int-attributes.c\n@@ -25,9 +25,10 @@ static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *a\n \tobj = get_wmiobj_pointer(instance_id, DELL_WMI_BIOS_INTEGER_ATTRIBUTE_GUID);\n \tif (!obj)\n \t\treturn -EIO;\n-\tif (obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_INTEGER) {\n+\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count < INT_MIN_ELEMENTS ||\n+\t    obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_INTEGER) {\n \t\tkfree(obj);\n-\t\treturn -EINVAL;\n+\t\treturn -EIO;\n \t}\n \tret = snprintf(buf, PAGE_SIZE, \"%lld\\n\", obj->package.elements[CURRENT_VAL].integer.value);\n \tkfree(obj);\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c b/drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c\nindex d8f1bf5e58a0..3167e06d416e 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c\n@@ -26,9 +26,10 @@ static ssize_t is_enabled_show(struct kobject *kobj, struct kobj_attribute *attr\n \tobj = get_wmiobj_pointer(instance_id, DELL_WMI_BIOS_PASSOBJ_ATTRIBUTE_GUID);\n \tif (!obj)\n \t\treturn -EIO;\n-\tif (obj->package.elements[IS_PASS_SET].type != ACPI_TYPE_INTEGER) {\n+\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count < PO_MIN_ELEMENTS ||\n+\t    obj->package.elements[IS_PASS_SET].type != ACPI_TYPE_INTEGER) {\n \t\tkfree(obj);\n-\t\treturn -EINVAL;\n+\t\treturn -EIO;\n \t}\n \tret = snprintf(buf, PAGE_SIZE, \"%lld\\n\", obj->package.elements[IS_PASS_SET].integer.value);\n \tkfree(obj);\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/string-attributes.c b/drivers/platform/x86/dell/dell-wmi-sysman/string-attributes.c\nindex c392f0ecf8b5..0d2c74f8d1aa 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/string-attributes.c\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/string-attributes.c\n@@ -25,9 +25,10 @@ static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *a\n \tobj = get_wmiobj_pointer(instance_id, DELL_WMI_BIOS_STRING_ATTRIBUTE_GUID);\n \tif (!obj)\n \t\treturn -EIO;\n-\tif (obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_STRING) {\n+\tif (obj->type != ACPI_TYPE_PACKAGE || obj->package.count < STR_MIN_ELEMENTS ||\n+\t    obj->package.elements[CURRENT_VAL].type != ACPI_TYPE_STRING) {\n \t\tkfree(obj);\n-\t\treturn -EINVAL;\n+\t\treturn -EIO;\n \t}\n \tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", obj->package.elements[CURRENT_VAL].string.pointer);\n \tkfree(obj);\ndiff --git a/drivers/platform/x86/dell/dell-wmi-sysman/sysman.c b/drivers/platform/x86/dell/dell-wmi-sysman/sysman.c\nindex d00389b860e4..f5402b714657 100644\n--- a/drivers/platform/x86/dell/dell-wmi-sysman/sysman.c\n+++ b/drivers/platform/x86/dell/dell-wmi-sysman/sysman.c\n@@ -407,10 +407,10 @@ static int init_bios_attributes(int attr_type, const char *guid)\n \t\treturn retval;\n \n \tswitch (attr_type) {\n-\tcase ENUM:\tmin_elements = 8;\tbreak;\n-\tcase INT:\tmin_elements = 9;\tbreak;\n-\tcase STR:\tmin_elements = 8;\tbreak;\n-\tcase PO:\tmin_elements = 4;\tbreak;\n+\tcase ENUM:\tmin_elements = ENUM_MIN_ELEMENTS;\tbreak;\n+\tcase INT:\tmin_elements = INT_MIN_ELEMENTS;\tbreak;\n+\tcase STR:\tmin_elements = STR_MIN_ELEMENTS;\tbreak;\n+\tcase PO:\tmin_elements = PO_MIN_ELEMENTS;\t\tbreak;\n \tdefault:\n \t\tpr_err(\"Error: Unknown attr_type: %d\\n\", attr_type);\n \t\treturn -EINVAL;\n@@ -597,7 +597,7 @@ static int __init sysman_init(void)\n \trelease_attributes_data();\n \n err_destroy_classdev:\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(wmi_priv.class_dev);\n \n err_exit_bios_attr_pass_interface:\n \texit_bios_attr_pass_interface();\n@@ -611,7 +611,7 @@ static int __init sysman_init(void)\n static void __exit sysman_exit(void)\n {\n \trelease_attributes_data();\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(wmi_priv.class_dev);\n \texit_bios_attr_set_interface();\n \texit_bios_attr_pass_interface();\n }\ndiff --git a/drivers/platform/x86/hp/hp-bioscfg/bioscfg.c b/drivers/platform/x86/hp/hp-bioscfg/bioscfg.c\nindex 13237890fc92..5bfa7159f5bc 100644\n--- a/drivers/platform/x86/hp/hp-bioscfg/bioscfg.c\n+++ b/drivers/platform/x86/hp/hp-bioscfg/bioscfg.c\n@@ -1034,7 +1034,7 @@ static int __init hp_init(void)\n \trelease_attributes_data();\n \n err_destroy_classdev:\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(bioscfg_drv.class_dev);\n \n err_unregister_class:\n \thp_exit_attr_set_interface();\n@@ -1045,7 +1045,7 @@ static int __init hp_init(void)\n static void __exit hp_exit(void)\n {\n \trelease_attributes_data();\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(bioscfg_drv.class_dev);\n \n \thp_exit_attr_set_interface();\n }\ndiff --git a/drivers/platform/x86/intel/hid.c b/drivers/platform/x86/intel/hid.c\nindex 0b5e43444ed6..f25a427cccda 100644\n--- a/drivers/platform/x86/intel/hid.c\n+++ b/drivers/platform/x86/intel/hid.c\n@@ -54,6 +54,7 @@ static const struct acpi_device_id intel_hid_ids[] = {\n \t{ \"INTC107B\" },\n \t{ \"INTC10CB\" },\n \t{ \"INTC10CC\" },\n+\t{ \"INTC10F1\" },\n \t{ }\n };\n MODULE_DEVICE_TABLE(acpi, intel_hid_ids);\ndiff --git a/drivers/platform/x86/portwell-ec.c b/drivers/platform/x86/portwell-ec.c\nindex 8b788822237b..3e019c51913e 100644\n--- a/drivers/platform/x86/portwell-ec.c\n+++ b/drivers/platform/x86/portwell-ec.c\n@@ -236,6 +236,7 @@ static int pwec_probe(struct platform_device *pdev)\n \t\treturn ret;\n \t}\n \n+\tec_wdt_dev.parent = &pdev->dev;\n \tret = devm_watchdog_register_device(&pdev->dev, &ec_wdt_dev);\n \tif (ret < 0) {\n \t\tdev_err(&pdev->dev, \"failed to register Portwell EC Watchdog\\n\");\ndiff --git a/drivers/platform/x86/think-lmi.c b/drivers/platform/x86/think-lmi.c\nindex 00b1e7c79a3d..b73b84fdb15e 100644\n--- a/drivers/platform/x86/think-lmi.c\n+++ b/drivers/platform/x86/think-lmi.c\n@@ -973,6 +973,7 @@ static const struct attribute_group auth_attr_group = {\n \t.is_visible = auth_attr_is_visible,\n \t.attrs = auth_attrs,\n };\n+__ATTRIBUTE_GROUPS(auth_attr);\n \n /* ---- Attributes sysfs --------------------------------------------------------- */\n static ssize_t display_name_show(struct kobject *kobj, struct kobj_attribute *attr,\n@@ -1188,6 +1189,7 @@ static const struct attribute_group tlmi_attr_group = {\n \t.is_visible = attr_is_visible,\n \t.attrs = tlmi_attrs,\n };\n+__ATTRIBUTE_GROUPS(tlmi_attr);\n \n static void tlmi_attr_setting_release(struct kobject *kobj)\n {\n@@ -1207,11 +1209,13 @@ static void tlmi_pwd_setting_release(struct kobject *kobj)\n static const struct kobj_type tlmi_attr_setting_ktype = {\n \t.release        = &tlmi_attr_setting_release,\n \t.sysfs_ops\t= &kobj_sysfs_ops,\n+\t.default_groups = tlmi_attr_groups,\n };\n \n static const struct kobj_type tlmi_pwd_setting_ktype = {\n \t.release        = &tlmi_pwd_setting_release,\n \t.sysfs_ops\t= &kobj_sysfs_ops,\n+\t.default_groups = auth_attr_groups,\n };\n \n static ssize_t pending_reboot_show(struct kobject *kobj, struct kobj_attribute *attr,\n@@ -1380,21 +1384,18 @@ static struct kobj_attribute debug_cmd = __ATTR_WO(debug_cmd);\n /* ---- Initialisation --------------------------------------------------------- */\n static void tlmi_release_attr(void)\n {\n-\tint i;\n+\tstruct kobject *pos, *n;\n \n \t/* Attribute structures */\n-\tfor (i = 0; i < TLMI_SETTINGS_COUNT; i++) {\n-\t\tif (tlmi_priv.setting[i]) {\n-\t\t\tsysfs_remove_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);\n-\t\t\tkobject_put(&tlmi_priv.setting[i]->kobj);\n-\t\t}\n-\t}\n \tsysfs_remove_file(&tlmi_priv.attribute_kset->kobj, &pending_reboot.attr);\n \tsysfs_remove_file(&tlmi_priv.attribute_kset->kobj, &save_settings.attr);\n \n \tif (tlmi_priv.can_debug_cmd && debug_support)\n \t\tsysfs_remove_file(&tlmi_priv.attribute_kset->kobj, &debug_cmd.attr);\n \n+\tlist_for_each_entry_safe(pos, n, &tlmi_priv.attribute_kset->list, entry)\n+\t\tkobject_put(pos);\n+\n \tkset_unregister(tlmi_priv.attribute_kset);\n \n \t/* Free up any saved signatures */\n@@ -1402,19 +1403,8 @@ static void tlmi_release_attr(void)\n \tkfree(tlmi_priv.pwd_admin->save_signature);\n \n \t/* Authentication structures */\n-\tsysfs_remove_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);\n-\tkobject_put(&tlmi_priv.pwd_admin->kobj);\n-\tsysfs_remove_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);\n-\tkobject_put(&tlmi_priv.pwd_power->kobj);\n-\n-\tif (tlmi_priv.opcode_support) {\n-\t\tsysfs_remove_group(&tlmi_priv.pwd_system->kobj, &auth_attr_group);\n-\t\tkobject_put(&tlmi_priv.pwd_system->kobj);\n-\t\tsysfs_remove_group(&tlmi_priv.pwd_hdd->kobj, &auth_attr_group);\n-\t\tkobject_put(&tlmi_priv.pwd_hdd->kobj);\n-\t\tsysfs_remove_group(&tlmi_priv.pwd_nvme->kobj, &auth_attr_group);\n-\t\tkobject_put(&tlmi_priv.pwd_nvme->kobj);\n-\t}\n+\tlist_for_each_entry_safe(pos, n, &tlmi_priv.authentication_kset->list, entry)\n+\t\tkobject_put(pos);\n \n \tkset_unregister(tlmi_priv.authentication_kset);\n }\n@@ -1455,6 +1445,14 @@ static int tlmi_sysfs_init(void)\n \t\tgoto fail_device_created;\n \t}\n \n+\ttlmi_priv.authentication_kset = kset_create_and_add(\"authentication\", NULL,\n+\t\t\t\t\t\t\t    &tlmi_priv.class_dev->kobj);\n+\tif (!tlmi_priv.authentication_kset) {\n+\t\tkset_unregister(tlmi_priv.attribute_kset);\n+\t\tret = -ENOMEM;\n+\t\tgoto fail_device_created;\n+\t}\n+\n \tfor (i = 0; i < TLMI_SETTINGS_COUNT; i++) {\n \t\t/* Check if index is a valid setting - skip if it isn't */\n \t\tif (!tlmi_priv.setting[i])\n@@ -1471,12 +1469,8 @@ static int tlmi_sysfs_init(void)\n \n \t\t/* Build attribute */\n \t\ttlmi_priv.setting[i]->kobj.kset = tlmi_priv.attribute_kset;\n-\t\tret = kobject_add(&tlmi_priv.setting[i]->kobj, NULL,\n-\t\t\t\t  \"%s\", tlmi_priv.setting[i]->display_name);\n-\t\tif (ret)\n-\t\t\tgoto fail_create_attr;\n-\n-\t\tret = sysfs_create_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);\n+\t\tret = kobject_init_and_add(&tlmi_priv.setting[i]->kobj, &tlmi_attr_setting_ktype,\n+\t\t\t\t\t   NULL, \"%s\", tlmi_priv.setting[i]->display_name);\n \t\tif (ret)\n \t\t\tgoto fail_create_attr;\n \t}\n@@ -1496,55 +1490,34 @@ static int tlmi_sysfs_init(void)\n \t}\n \n \t/* Create authentication entries */\n-\ttlmi_priv.authentication_kset = kset_create_and_add(\"authentication\", NULL,\n-\t\t\t\t\t\t\t\t&tlmi_priv.class_dev->kobj);\n-\tif (!tlmi_priv.authentication_kset) {\n-\t\tret = -ENOMEM;\n-\t\tgoto fail_create_attr;\n-\t}\n \ttlmi_priv.pwd_admin->kobj.kset = tlmi_priv.authentication_kset;\n-\tret = kobject_add(&tlmi_priv.pwd_admin->kobj, NULL, \"%s\", \"Admin\");\n-\tif (ret)\n-\t\tgoto fail_create_attr;\n-\n-\tret = sysfs_create_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);\n+\tret = kobject_init_and_add(&tlmi_priv.pwd_admin->kobj, &tlmi_pwd_setting_ktype,\n+\t\t\t\t   NULL, \"%s\", \"Admin\");\n \tif (ret)\n \t\tgoto fail_create_attr;\n \n \ttlmi_priv.pwd_power->kobj.kset = tlmi_priv.authentication_kset;\n-\tret = kobject_add(&tlmi_priv.pwd_power->kobj, NULL, \"%s\", \"Power-on\");\n-\tif (ret)\n-\t\tgoto fail_create_attr;\n-\n-\tret = sysfs_create_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);\n+\tret = kobject_init_and_add(&tlmi_priv.pwd_power->kobj, &tlmi_pwd_setting_ktype,\n+\t\t\t\t   NULL, \"%s\", \"Power-on\");\n \tif (ret)\n \t\tgoto fail_create_attr;\n \n \tif (tlmi_priv.opcode_support) {\n \t\ttlmi_priv.pwd_system->kobj.kset = tlmi_priv.authentication_kset;\n-\t\tret = kobject_add(&tlmi_priv.pwd_system->kobj, NULL, \"%s\", \"System\");\n-\t\tif (ret)\n-\t\t\tgoto fail_create_attr;\n-\n-\t\tret = sysfs_create_group(&tlmi_priv.pwd_system->kobj, &auth_attr_group);\n+\t\tret = kobject_init_and_add(&tlmi_priv.pwd_system->kobj, &tlmi_pwd_setting_ktype,\n+\t\t\t\t\t   NULL, \"%s\", \"System\");\n \t\tif (ret)\n \t\t\tgoto fail_create_attr;\n \n \t\ttlmi_priv.pwd_hdd->kobj.kset = tlmi_priv.authentication_kset;\n-\t\tret = kobject_add(&tlmi_priv.pwd_hdd->kobj, NULL, \"%s\", \"HDD\");\n-\t\tif (ret)\n-\t\t\tgoto fail_create_attr;\n-\n-\t\tret = sysfs_create_group(&tlmi_priv.pwd_hdd->kobj, &auth_attr_group);\n+\t\tret = kobject_init_and_add(&tlmi_priv.pwd_hdd->kobj, &tlmi_pwd_setting_ktype,\n+\t\t\t\t\t   NULL, \"%s\", \"HDD\");\n \t\tif (ret)\n \t\t\tgoto fail_create_attr;\n \n \t\ttlmi_priv.pwd_nvme->kobj.kset = tlmi_priv.authentication_kset;\n-\t\tret = kobject_add(&tlmi_priv.pwd_nvme->kobj, NULL, \"%s\", \"NVMe\");\n-\t\tif (ret)\n-\t\t\tgoto fail_create_attr;\n-\n-\t\tret = sysfs_create_group(&tlmi_priv.pwd_nvme->kobj, &auth_attr_group);\n+\t\tret = kobject_init_and_add(&tlmi_priv.pwd_nvme->kobj, &tlmi_pwd_setting_ktype,\n+\t\t\t\t\t   NULL, \"%s\", \"NVMe\");\n \t\tif (ret)\n \t\t\tgoto fail_create_attr;\n \t}\n@@ -1554,7 +1527,7 @@ static int tlmi_sysfs_init(void)\n fail_create_attr:\n \ttlmi_release_attr();\n fail_device_created:\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(tlmi_priv.class_dev);\n fail_class_created:\n \treturn ret;\n }\n@@ -1577,8 +1550,6 @@ static struct tlmi_pwd_setting *tlmi_create_auth(const char *pwd_type,\n \tnew_pwd->maxlen = tlmi_priv.pwdcfg.core.max_length;\n \tnew_pwd->index = 0;\n \n-\tkobject_init(&new_pwd->kobj, &tlmi_pwd_setting_ktype);\n-\n \treturn new_pwd;\n }\n \n@@ -1683,7 +1654,6 @@ static int tlmi_analyze(struct wmi_device *wdev)\n \t\tif (setting->possible_values)\n \t\t\tstrreplace(setting->possible_values, ',', ';');\n \n-\t\tkobject_init(&setting->kobj, &tlmi_attr_setting_ktype);\n \t\ttlmi_priv.setting[i] = setting;\n \t\tkfree(item);\n \t}\n@@ -1781,7 +1751,7 @@ static int tlmi_analyze(struct wmi_device *wdev)\n static void tlmi_remove(struct wmi_device *wdev)\n {\n \ttlmi_release_attr();\n-\tdevice_destroy(&firmware_attributes_class, MKDEV(0, 0));\n+\tdevice_unregister(tlmi_priv.class_dev);\n }\n \n static int tlmi_probe(struct wmi_device *wdev, const void *context)\ndiff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c\nindex e7350c9fa3aa..b59b4d90b0c7 100644\n--- a/drivers/platform/x86/thinkpad_acpi.c\n+++ b/drivers/platform/x86/thinkpad_acpi.c\n@@ -3295,6 +3295,7 @@ static const struct key_entry keymap_lenovo[] __initconst = {\n \t */\n \t{ KE_KEY, 0x131d, { KEY_VENDOR } }, /* System debug info, similar to old ThinkPad key */\n \t{ KE_KEY, 0x1320, { KEY_LINK_PHONE } },\n+\t{ KE_KEY, 0x1402, { KEY_LINK_PHONE } },\n \t{ KE_KEY, TP_HKEY_EV_TRACK_DOUBLETAP /* 0x8036 */, { KEY_PROG4 } },\n \t{ KE_END }\n };\ndiff --git a/drivers/platform/x86/wmi.c b/drivers/platform/x86/wmi.c\nindex e46453750d5f..03aecf8bb7f8 100644\n--- a/drivers/platform/x86/wmi.c\n+++ b/drivers/platform/x86/wmi.c\n@@ -177,16 +177,22 @@ static int wmi_device_enable(struct wmi_device *wdev, bool enable)\n \tacpi_handle handle;\n \tacpi_status status;\n \n-\tif (!(wblock->gblock.flags & ACPI_WMI_EXPENSIVE))\n-\t\treturn 0;\n-\n \tif (wblock->dev.dev.type == &wmi_type_method)\n \t\treturn 0;\n \n-\tif (wblock->dev.dev.type == &wmi_type_event)\n+\tif (wblock->dev.dev.type == &wmi_type_event) {\n+\t\t/*\n+\t\t * Windows always enables/disables WMI events, even when they are\n+\t\t * not marked as being expensive. We follow this behavior for\n+\t\t * compatibility reasons.\n+\t\t */\n \t\tsnprintf(method, sizeof(method), \"WE%02X\", wblock->gblock.notify_id);\n-\telse\n+\t} else {\n+\t\tif (!(wblock->gblock.flags & ACPI_WMI_EXPENSIVE))\n+\t\t\treturn 0;\n+\n \t\tget_acpi_method_name(wblock, 'C', method);\n+\t}\n \n \t/*\n \t * Not all WMI devices marked as expensive actually implement the\ndiff --git a/arch/x86/include/asm/amd/fch.h b/include/linux/platform_data/x86/amd-fch.h\nsimilarity index 100%\nrename from arch/x86/include/asm/amd/fch.h\nrename to include/linux/platform_data/x86/amd-fch.h",
    "stats": {
      "insertions": 263,
      "deletions": 153,
      "files": 27
    }
  },
  {
    "sha": "3c2bd251d2039ce2778c35ced5ef47b3a379f5df",
    "message": "Merge tag 'usb-6.16-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb\n\nPull USB fixes from Greg KH:\n \"Here are some USB driver fixes for 6.16-rc5. I originally wanted this\n  to get into -rc4, but there were some regressions that had to be\n  handled first. Now all looks good. Included in here are the following\n  fixes:\n\n   - cdns3 driver fixes\n\n   - xhci driver fixes\n\n   - typec driver fixes\n\n   - USB hub fixes (this is what took the longest to get right)\n\n   - new USB driver quirks added\n\n   - chipidea driver fixes\n\n  All of these have been in linux-next for a while and now we have no\n  more reported problems with them\"\n\n* tag 'usb-6.16-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (21 commits)\n  usb: hub: Fix flushing of delayed work used for post resume purposes\n  xhci: dbc: Flush queued requests before stopping dbc\n  xhci: dbctty: disable ECHO flag by default\n  xhci: Disable stream for xHC controller with XHCI_BROKEN_STREAMS\n  usb: xhci: quirk for data loss in ISOC transfers\n  usb: dwc3: gadget: Fix TRB reclaim logic for short transfers and ZLPs\n  usb: hub: Fix flushing and scheduling of delayed work that tunes runtime pm\n  usb: typec: displayport: Fix potential deadlock\n  usb: typec: altmodes/displayport: do not index invalid pin_assignments\n  usb: cdnsp: Fix issue with CV Bad Descriptor test\n  usb: typec: tcpm: apply vbus before data bringup in tcpm_src_attach\n  Revert \"usb: xhci: Implement xhci_handshake_check_state() helper\"\n  usb: xhci: Skip xhci_reset in xhci_resume if xhci is being removed\n  usb: gadget: u_serial: Fix race condition in TTY wakeup\n  Revert \"usb: gadget: u_serial: Add null pointer check in gs_start_io\"\n  usb: chipidea: udc: disconnect/reconnect from host when do suspend/resume\n  usb: acpi: fix device link removal\n  usb: hub: fix detection of high tier USB3 devices behind suspended hubs\n  Logitech C-270 even more broken\n  usb: dwc3: Abort suspend on soft disconnect failure\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-07-04T09:57:12-07:00",
    "files_changed": [
      "drivers/usb/cdns3/cdnsp-debug.h",
      "drivers/usb/cdns3/cdnsp-ep0.c",
      "drivers/usb/cdns3/cdnsp-gadget.h",
      "drivers/usb/cdns3/cdnsp-ring.c",
      "drivers/usb/chipidea/udc.c",
      "drivers/usb/core/hub.c",
      "drivers/usb/core/hub.h",
      "drivers/usb/core/quirks.c",
      "drivers/usb/core/usb-acpi.c",
      "drivers/usb/dwc3/core.c",
      "drivers/usb/dwc3/gadget.c",
      "drivers/usb/gadget/function/u_serial.c",
      "drivers/usb/host/xhci-dbgcap.c",
      "drivers/usb/host/xhci-dbgtty.c",
      "drivers/usb/host/xhci-mem.c",
      "drivers/usb/host/xhci-pci.c",
      "drivers/usb/host/xhci-plat.c",
      "drivers/usb/host/xhci-ring.c",
      "drivers/usb/host/xhci.c",
      "drivers/usb/host/xhci.h",
      "drivers/usb/typec/altmodes/displayport.c",
      "drivers/usb/typec/tcpm/tcpm.c",
      "include/linux/usb.h",
      "include/linux/usb/typec_dp.h"
    ],
    "diff": "diff --git a/drivers/usb/cdns3/cdnsp-debug.h b/drivers/usb/cdns3/cdnsp-debug.h\nindex cd138acdcce1..86860686d836 100644\n--- a/drivers/usb/cdns3/cdnsp-debug.h\n+++ b/drivers/usb/cdns3/cdnsp-debug.h\n@@ -327,12 +327,13 @@ static inline const char *cdnsp_decode_trb(char *str, size_t size, u32 field0,\n \tcase TRB_RESET_EP:\n \tcase TRB_HALT_ENDPOINT:\n \t\tret = scnprintf(str, size,\n-\t\t\t\t\"%s: ep%d%s(%d) ctx %08x%08x slot %ld flags %c\",\n+\t\t\t\t\"%s: ep%d%s(%d) ctx %08x%08x slot %ld flags %c %c\",\n \t\t\t\tcdnsp_trb_type_string(type),\n \t\t\t\tep_num, ep_id % 2 ? \"out\" : \"in\",\n \t\t\t\tTRB_TO_EP_INDEX(field3), field1, field0,\n \t\t\t\tTRB_TO_SLOT_ID(field3),\n-\t\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n+\t\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c',\n+\t\t\t\tfield3 & TRB_ESP ? 'P' : 'p');\n \t\tbreak;\n \tcase TRB_STOP_RING:\n \t\tret = scnprintf(str, size,\ndiff --git a/drivers/usb/cdns3/cdnsp-ep0.c b/drivers/usb/cdns3/cdnsp-ep0.c\nindex f317d3c84781..5cd9b898ce97 100644\n--- a/drivers/usb/cdns3/cdnsp-ep0.c\n+++ b/drivers/usb/cdns3/cdnsp-ep0.c\n@@ -414,6 +414,7 @@ static int cdnsp_ep0_std_request(struct cdnsp_device *pdev,\n void cdnsp_setup_analyze(struct cdnsp_device *pdev)\n {\n \tstruct usb_ctrlrequest *ctrl = &pdev->setup;\n+\tstruct cdnsp_ep *pep;\n \tint ret = -EINVAL;\n \tu16 len;\n \n@@ -427,10 +428,21 @@ void cdnsp_setup_analyze(struct cdnsp_device *pdev)\n \t\tgoto out;\n \t}\n \n+\tpep = &pdev->eps[0];\n+\n \t/* Restore the ep0 to Stopped/Running state. */\n-\tif (pdev->eps[0].ep_state & EP_HALTED) {\n-\t\ttrace_cdnsp_ep0_halted(\"Restore to normal state\");\n-\t\tcdnsp_halt_endpoint(pdev, &pdev->eps[0], 0);\n+\tif (pep->ep_state & EP_HALTED) {\n+\t\tif (GET_EP_CTX_STATE(pep->out_ctx) == EP_STATE_HALTED)\n+\t\t\tcdnsp_halt_endpoint(pdev, pep, 0);\n+\n+\t\t/*\n+\t\t * Halt Endpoint Command for SSP2 for ep0 preserve current\n+\t\t * endpoint state and driver has to synchronize the\n+\t\t * software endpoint state with endpoint output context\n+\t\t * state.\n+\t\t */\n+\t\tpep->ep_state &= ~EP_HALTED;\n+\t\tpep->ep_state |= EP_STOPPED;\n \t}\n \n \t/*\ndiff --git a/drivers/usb/cdns3/cdnsp-gadget.h b/drivers/usb/cdns3/cdnsp-gadget.h\nindex 2afa3e558f85..a91cca509db0 100644\n--- a/drivers/usb/cdns3/cdnsp-gadget.h\n+++ b/drivers/usb/cdns3/cdnsp-gadget.h\n@@ -987,6 +987,12 @@ enum cdnsp_setup_dev {\n #define STREAM_ID_FOR_TRB(p)\t\t((((p)) << 16) & GENMASK(31, 16))\n #define SCT_FOR_TRB(p)\t\t\t(((p) << 1) & 0x7)\n \n+/*\n+ * Halt Endpoint Command TRB field.\n+ * The ESP bit only exists in the SSP2 controller.\n+ */\n+#define TRB_ESP\t\t\t\tBIT(9)\n+\n /* Link TRB specific fields. */\n #define TRB_TC\t\t\t\tBIT(1)\n \ndiff --git a/drivers/usb/cdns3/cdnsp-ring.c b/drivers/usb/cdns3/cdnsp-ring.c\nindex fd06cb85c4ea..0758f171f73e 100644\n--- a/drivers/usb/cdns3/cdnsp-ring.c\n+++ b/drivers/usb/cdns3/cdnsp-ring.c\n@@ -772,7 +772,9 @@ static int cdnsp_update_port_id(struct cdnsp_device *pdev, u32 port_id)\n \t}\n \n \tif (port_id != old_port) {\n-\t\tcdnsp_disable_slot(pdev);\n+\t\tif (pdev->slot_id)\n+\t\t\tcdnsp_disable_slot(pdev);\n+\n \t\tpdev->active_port = port;\n \t\tcdnsp_enable_slot(pdev);\n \t}\n@@ -2483,7 +2485,8 @@ void cdnsp_queue_halt_endpoint(struct cdnsp_device *pdev, unsigned int ep_index)\n {\n \tcdnsp_queue_command(pdev, 0, 0, 0, TRB_TYPE(TRB_HALT_ENDPOINT) |\n \t\t\t    SLOT_ID_FOR_TRB(pdev->slot_id) |\n-\t\t\t    EP_ID_FOR_TRB(ep_index));\n+\t\t\t    EP_ID_FOR_TRB(ep_index) |\n+\t\t\t    (!ep_index ? TRB_ESP : 0));\n }\n \n void cdnsp_force_header_wakeup(struct cdnsp_device *pdev, int intf_num)\ndiff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c\nindex 8a9b31fd5c89..1a48e6440e6c 100644\n--- a/drivers/usb/chipidea/udc.c\n+++ b/drivers/usb/chipidea/udc.c\n@@ -2374,6 +2374,10 @@ static void udc_suspend(struct ci_hdrc *ci)\n \t */\n \tif (hw_read(ci, OP_ENDPTLISTADDR, ~0) == 0)\n \t\thw_write(ci, OP_ENDPTLISTADDR, ~0, ~0);\n+\n+\tif (ci->gadget.connected &&\n+\t    (!ci->suspended || !device_may_wakeup(ci->dev)))\n+\t\tusb_gadget_disconnect(&ci->gadget);\n }\n \n static void udc_resume(struct ci_hdrc *ci, bool power_lost)\n@@ -2384,6 +2388,9 @@ static void udc_resume(struct ci_hdrc *ci, bool power_lost)\n \t\t\t\t\tOTGSC_BSVIS | OTGSC_BSVIE);\n \t\tif (ci->vbus_active)\n \t\t\tusb_gadget_vbus_disconnect(&ci->gadget);\n+\t} else if (ci->vbus_active && ci->driver &&\n+\t\t   !ci->gadget.connected) {\n+\t\tusb_gadget_connect(&ci->gadget);\n \t}\n \n \t/* Restore value 0 if it was set for power lost check */\ndiff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c\nindex 770d1e91183c..3e1215f7a9a0 100644\n--- a/drivers/usb/core/hub.c\n+++ b/drivers/usb/core/hub.c\n@@ -68,6 +68,12 @@\n  */\n #define USB_SHORT_SET_ADDRESS_REQ_TIMEOUT\t500  /* ms */\n \n+/*\n+ * Give SS hubs 200ms time after wake to train downstream links before\n+ * assuming no port activity and allowing hub to runtime suspend back.\n+ */\n+#define USB_SS_PORT_U0_WAKE_TIME\t200  /* ms */\n+\n /* Protect struct usb_device->state and ->children members\n  * Note: Both are also protected by ->dev.sem, except that ->state can\n  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */\n@@ -1095,6 +1101,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n \t\t\tgoto init2;\n \t\tgoto init3;\n \t}\n+\n \thub_get(hub);\n \n \t/* The superspeed hub except for root hub has to use Hub Depth\n@@ -1343,6 +1350,17 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n \t\tdevice_unlock(&hdev->dev);\n \t}\n \n+\tif (type == HUB_RESUME && hub_is_superspeed(hub->hdev)) {\n+\t\t/* give usb3 downstream links training time after hub resume */\n+\t\tusb_autopm_get_interface_no_resume(\n+\t\t\tto_usb_interface(hub->intfdev));\n+\n+\t\tqueue_delayed_work(system_power_efficient_wq,\n+\t\t\t\t   &hub->post_resume_work,\n+\t\t\t\t   msecs_to_jiffies(USB_SS_PORT_U0_WAKE_TIME));\n+\t\treturn;\n+\t}\n+\n \thub_put(hub);\n }\n \n@@ -1361,6 +1379,14 @@ static void hub_init_func3(struct work_struct *ws)\n \thub_activate(hub, HUB_INIT3);\n }\n \n+static void hub_post_resume(struct work_struct *ws)\n+{\n+\tstruct usb_hub *hub = container_of(ws, struct usb_hub, post_resume_work.work);\n+\n+\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n+\thub_put(hub);\n+}\n+\n enum hub_quiescing_type {\n \tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n };\n@@ -1386,6 +1412,7 @@ static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n \n \t/* Stop hub_wq and related activity */\n \ttimer_delete_sync(&hub->irq_urb_retry);\n+\tflush_delayed_work(&hub->post_resume_work);\n \tusb_kill_urb(hub->urb);\n \tif (hub->has_indicators)\n \t\tcancel_delayed_work_sync(&hub->leds);\n@@ -1944,6 +1971,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n \thub->hdev = hdev;\n \tINIT_DELAYED_WORK(&hub->leds, led_work);\n \tINIT_DELAYED_WORK(&hub->init_work, NULL);\n+\tINIT_DELAYED_WORK(&hub->post_resume_work, hub_post_resume);\n \tINIT_WORK(&hub->events, hub_event);\n \tINIT_LIST_HEAD(&hub->onboard_devs);\n \tspin_lock_init(&hub->irq_urb_lock);\n@@ -2337,6 +2365,9 @@ void usb_disconnect(struct usb_device **pdev)\n \tusb_remove_ep_devs(&udev->ep0);\n \tusb_unlock_device(udev);\n \n+\tif (udev->usb4_link)\n+\t\tdevice_link_del(udev->usb4_link);\n+\n \t/* Unregister the device.  The device driver is responsible\n \t * for de-configuring the device and invoking the remove-device\n \t * notifier chain (used by usbfs and possibly others).\ndiff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h\nindex e6ae73f8a95d..9ebc5ef54a32 100644\n--- a/drivers/usb/core/hub.h\n+++ b/drivers/usb/core/hub.h\n@@ -70,6 +70,7 @@ struct usb_hub {\n \tu8\t\t\tindicator[USB_MAXCHILDREN];\n \tstruct delayed_work\tleds;\n \tstruct delayed_work\tinit_work;\n+\tstruct delayed_work\tpost_resume_work;\n \tstruct work_struct      events;\n \tspinlock_t\t\tirq_urb_lock;\n \tstruct timer_list\tirq_urb_retry;\ndiff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c\nindex 53d68d20fb62..0cf94c7a2c9c 100644\n--- a/drivers/usb/core/quirks.c\n+++ b/drivers/usb/core/quirks.c\n@@ -227,7 +227,8 @@ static const struct usb_device_id usb_quirk_list[] = {\n \t{ USB_DEVICE(0x046a, 0x0023), .driver_info = USB_QUIRK_RESET_RESUME },\n \n \t/* Logitech HD Webcam C270 */\n-\t{ USB_DEVICE(0x046d, 0x0825), .driver_info = USB_QUIRK_RESET_RESUME },\n+\t{ USB_DEVICE(0x046d, 0x0825), .driver_info = USB_QUIRK_RESET_RESUME |\n+\t\tUSB_QUIRK_NO_LPM},\n \n \t/* Logitech HD Pro Webcams C920, C920-C, C922, C925e and C930e */\n \t{ USB_DEVICE(0x046d, 0x082d), .driver_info = USB_QUIRK_DELAY_INIT },\ndiff --git a/drivers/usb/core/usb-acpi.c b/drivers/usb/core/usb-acpi.c\nindex ea1ce8beb0cb..489dbdc96f94 100644\n--- a/drivers/usb/core/usb-acpi.c\n+++ b/drivers/usb/core/usb-acpi.c\n@@ -157,7 +157,7 @@ EXPORT_SYMBOL_GPL(usb_acpi_set_power_state);\n  */\n static int usb_acpi_add_usb4_devlink(struct usb_device *udev)\n {\n-\tconst struct device_link *link;\n+\tstruct device_link *link;\n \tstruct usb_port *port_dev;\n \tstruct usb_hub *hub;\n \n@@ -188,6 +188,8 @@ static int usb_acpi_add_usb4_devlink(struct usb_device *udev)\n \tdev_dbg(&port_dev->dev, \"Created device link from %s to %s\\n\",\n \t\tdev_name(&port_dev->child->dev), dev_name(nhi_fwnode->dev));\n \n+\tudev->usb4_link = link;\n+\n \treturn 0;\n }\n \ndiff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c\nindex 2bc775a747f2..8002c23a5a02 100644\n--- a/drivers/usb/dwc3/core.c\n+++ b/drivers/usb/dwc3/core.c\n@@ -2422,6 +2422,7 @@ static int dwc3_suspend_common(struct dwc3 *dwc, pm_message_t msg)\n {\n \tu32 reg;\n \tint i;\n+\tint ret;\n \n \tif (!pm_runtime_suspended(dwc->dev) && !PMSG_IS_AUTO(msg)) {\n \t\tdwc->susphy_state = (dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0)) &\n@@ -2440,7 +2441,9 @@ static int dwc3_suspend_common(struct dwc3 *dwc, pm_message_t msg)\n \tcase DWC3_GCTL_PRTCAP_DEVICE:\n \t\tif (pm_runtime_suspended(dwc->dev))\n \t\t\tbreak;\n-\t\tdwc3_gadget_suspend(dwc);\n+\t\tret = dwc3_gadget_suspend(dwc);\n+\t\tif (ret)\n+\t\t\treturn ret;\n \t\tsynchronize_irq(dwc->irq_gadget);\n \t\tdwc3_core_exit(dwc);\n \t\tbreak;\n@@ -2475,7 +2478,9 @@ static int dwc3_suspend_common(struct dwc3 *dwc, pm_message_t msg)\n \t\t\tbreak;\n \n \t\tif (dwc->current_otg_role == DWC3_OTG_ROLE_DEVICE) {\n-\t\t\tdwc3_gadget_suspend(dwc);\n+\t\t\tret = dwc3_gadget_suspend(dwc);\n+\t\t\tif (ret)\n+\t\t\t\treturn ret;\n \t\t\tsynchronize_irq(dwc->irq_gadget);\n \t\t}\n \ndiff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c\nindex 321361288935..74968f93d4a3 100644\n--- a/drivers/usb/dwc3/gadget.c\n+++ b/drivers/usb/dwc3/gadget.c\n@@ -3516,7 +3516,7 @@ static int dwc3_gadget_ep_reclaim_completed_trb(struct dwc3_ep *dep,\n \t * We're going to do that here to avoid problems of HW trying\n \t * to use bogus TRBs for transfers.\n \t */\n-\tif (chain && (trb->ctrl & DWC3_TRB_CTRL_HWO))\n+\tif (trb->ctrl & DWC3_TRB_CTRL_HWO)\n \t\ttrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\n \n \t/*\n@@ -4821,26 +4821,22 @@ int dwc3_gadget_suspend(struct dwc3 *dwc)\n \tint ret;\n \n \tret = dwc3_gadget_soft_disconnect(dwc);\n-\tif (ret)\n-\t\tgoto err;\n-\n-\tspin_lock_irqsave(&dwc->lock, flags);\n-\tif (dwc->gadget_driver)\n-\t\tdwc3_disconnect_gadget(dwc);\n-\tspin_unlock_irqrestore(&dwc->lock, flags);\n-\n-\treturn 0;\n-\n-err:\n \t/*\n \t * Attempt to reset the controller's state. Likely no\n \t * communication can be established until the host\n \t * performs a port reset.\n \t */\n-\tif (dwc->softconnect)\n+\tif (ret && dwc->softconnect) {\n \t\tdwc3_gadget_soft_connect(dwc);\n+\t\treturn -EAGAIN;\n+\t}\n \n-\treturn ret;\n+\tspin_lock_irqsave(&dwc->lock, flags);\n+\tif (dwc->gadget_driver)\n+\t\tdwc3_disconnect_gadget(dwc);\n+\tspin_unlock_irqrestore(&dwc->lock, flags);\n+\n+\treturn 0;\n }\n \n int dwc3_gadget_resume(struct dwc3 *dwc)\ndiff --git a/drivers/usb/gadget/function/u_serial.c b/drivers/usb/gadget/function/u_serial.c\nindex ab544f6824be..540dc5ab96fc 100644\n--- a/drivers/usb/gadget/function/u_serial.c\n+++ b/drivers/usb/gadget/function/u_serial.c\n@@ -295,8 +295,8 @@ __acquires(&port->port_lock)\n \t\t\tbreak;\n \t}\n \n-\tif (do_tty_wake && port->port.tty)\n-\t\ttty_wakeup(port->port.tty);\n+\tif (do_tty_wake)\n+\t\ttty_port_tty_wakeup(&port->port);\n \treturn status;\n }\n \n@@ -544,20 +544,16 @@ static int gs_alloc_requests(struct usb_ep *ep, struct list_head *head,\n static int gs_start_io(struct gs_port *port)\n {\n \tstruct list_head\t*head = &port->read_pool;\n-\tstruct usb_ep\t\t*ep;\n+\tstruct usb_ep\t\t*ep = port->port_usb->out;\n \tint\t\t\tstatus;\n \tunsigned\t\tstarted;\n \n-\tif (!port->port_usb || !port->port.tty)\n-\t\treturn -EIO;\n-\n \t/* Allocate RX and TX I/O buffers.  We can't easily do this much\n \t * earlier (with GFP_KERNEL) because the requests are coupled to\n \t * endpoints, as are the packet sizes we'll be using.  Different\n \t * configurations may use different endpoints with a given port;\n \t * and high speed vs full speed changes packet sizes too.\n \t */\n-\tep = port->port_usb->out;\n \tstatus = gs_alloc_requests(ep, head, gs_read_complete,\n \t\t&port->read_allocated);\n \tif (status)\n@@ -578,7 +574,7 @@ static int gs_start_io(struct gs_port *port)\n \t\tgs_start_tx(port);\n \t\t/* Unblock any pending writes into our circular buffer, in case\n \t\t * we didn't in gs_start_tx() */\n-\t\ttty_wakeup(port->port.tty);\n+\t\ttty_port_tty_wakeup(&port->port);\n \t} else {\n \t\t/* Free reqs only if we are still connected */\n \t\tif (port->port_usb) {\ndiff --git a/drivers/usb/host/xhci-dbgcap.c b/drivers/usb/host/xhci-dbgcap.c\nindex 0d4ce5734165..06a2edb9e86e 100644\n--- a/drivers/usb/host/xhci-dbgcap.c\n+++ b/drivers/usb/host/xhci-dbgcap.c\n@@ -652,6 +652,10 @@ static void xhci_dbc_stop(struct xhci_dbc *dbc)\n \tcase DS_DISABLED:\n \t\treturn;\n \tcase DS_CONFIGURED:\n+\t\tspin_lock(&dbc->lock);\n+\t\txhci_dbc_flush_requests(dbc);\n+\t\tspin_unlock(&dbc->lock);\n+\n \t\tif (dbc->driver->disconnect)\n \t\t\tdbc->driver->disconnect(dbc);\n \t\tbreak;\ndiff --git a/drivers/usb/host/xhci-dbgtty.c b/drivers/usb/host/xhci-dbgtty.c\nindex 60ed753c85bb..d894081d8d15 100644\n--- a/drivers/usb/host/xhci-dbgtty.c\n+++ b/drivers/usb/host/xhci-dbgtty.c\n@@ -617,6 +617,7 @@ int dbc_tty_init(void)\n \tdbc_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n \tdbc_tty_driver->subtype = SERIAL_TYPE_NORMAL;\n \tdbc_tty_driver->init_termios = tty_std_termios;\n+\tdbc_tty_driver->init_termios.c_lflag &= ~ECHO;\n \tdbc_tty_driver->init_termios.c_cflag =\n \t\t\tB9600 | CS8 | CREAD | HUPCL | CLOCAL;\n \tdbc_tty_driver->init_termios.c_ispeed = 9600;\ndiff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c\nindex bd745a0f2f78..6680afa4f596 100644\n--- a/drivers/usb/host/xhci-mem.c\n+++ b/drivers/usb/host/xhci-mem.c\n@@ -1449,6 +1449,10 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,\n \t/* Periodic endpoint bInterval limit quirk */\n \tif (usb_endpoint_xfer_int(&ep->desc) ||\n \t    usb_endpoint_xfer_isoc(&ep->desc)) {\n+\t\tif ((xhci->quirks & XHCI_LIMIT_ENDPOINT_INTERVAL_9) &&\n+\t\t    interval >= 9) {\n+\t\t\tinterval = 8;\n+\t\t}\n \t\tif ((xhci->quirks & XHCI_LIMIT_ENDPOINT_INTERVAL_7) &&\n \t\t    udev->speed >= USB_SPEED_HIGH &&\n \t\t    interval >= 7) {\ndiff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c\nindex 0c481cbc8f08..00fac8b233d2 100644\n--- a/drivers/usb/host/xhci-pci.c\n+++ b/drivers/usb/host/xhci-pci.c\n@@ -71,12 +71,22 @@\n #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI\t\t0x15ec\n #define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI\t\t0x15f0\n \n+#define PCI_DEVICE_ID_AMD_ARIEL_TYPEC_XHCI\t\t0x13ed\n+#define PCI_DEVICE_ID_AMD_ARIEL_TYPEA_XHCI\t\t0x13ee\n+#define PCI_DEVICE_ID_AMD_STARSHIP_XHCI\t\t\t0x148c\n+#define PCI_DEVICE_ID_AMD_FIREFLIGHT_15D4_XHCI\t\t0x15d4\n+#define PCI_DEVICE_ID_AMD_FIREFLIGHT_15D5_XHCI\t\t0x15d5\n+#define PCI_DEVICE_ID_AMD_RAVEN_15E0_XHCI\t\t0x15e0\n+#define PCI_DEVICE_ID_AMD_RAVEN_15E1_XHCI\t\t0x15e1\n+#define PCI_DEVICE_ID_AMD_RAVEN2_XHCI\t\t\t0x15e5\n #define PCI_DEVICE_ID_AMD_RENOIR_XHCI\t\t\t0x1639\n #define PCI_DEVICE_ID_AMD_PROMONTORYA_4\t\t\t0x43b9\n #define PCI_DEVICE_ID_AMD_PROMONTORYA_3\t\t\t0x43ba\n #define PCI_DEVICE_ID_AMD_PROMONTORYA_2\t\t\t0x43bb\n #define PCI_DEVICE_ID_AMD_PROMONTORYA_1\t\t\t0x43bc\n \n+#define PCI_DEVICE_ID_ATI_NAVI10_7316_XHCI\t\t0x7316\n+\n #define PCI_DEVICE_ID_ASMEDIA_1042_XHCI\t\t\t0x1042\n #define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI\t\t0x1142\n #define PCI_DEVICE_ID_ASMEDIA_1142_XHCI\t\t\t0x1242\n@@ -280,6 +290,21 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)\n \tif (pdev->vendor == PCI_VENDOR_ID_NEC)\n \t\txhci->quirks |= XHCI_NEC_HOST;\n \n+\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n+\t    (pdev->device == PCI_DEVICE_ID_AMD_ARIEL_TYPEC_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_ARIEL_TYPEA_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_STARSHIP_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_FIREFLIGHT_15D4_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_FIREFLIGHT_15D5_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_RAVEN_15E0_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_RAVEN_15E1_XHCI ||\n+\t     pdev->device == PCI_DEVICE_ID_AMD_RAVEN2_XHCI))\n+\t\txhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_9;\n+\n+\tif (pdev->vendor == PCI_VENDOR_ID_ATI &&\n+\t    pdev->device == PCI_DEVICE_ID_ATI_NAVI10_7316_XHCI)\n+\t\txhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_9;\n+\n \tif (pdev->vendor == PCI_VENDOR_ID_AMD && xhci->hci_version == 0x96)\n \t\txhci->quirks |= XHCI_AMD_0x96_HOST;\n \ndiff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c\nindex 6dab142e7278..c79d5ed48a08 100644\n--- a/drivers/usb/host/xhci-plat.c\n+++ b/drivers/usb/host/xhci-plat.c\n@@ -328,7 +328,8 @@ int xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const s\n \t}\n \n \tusb3_hcd = xhci_get_usb3_hcd(xhci);\n-\tif (usb3_hcd && HCC_MAX_PSA(xhci->hcc_params) >= 4)\n+\tif (usb3_hcd && HCC_MAX_PSA(xhci->hcc_params) >= 4 &&\n+\t    !(xhci->quirks & XHCI_BROKEN_STREAMS))\n \t\tusb3_hcd->can_do_streams = 1;\n \n \tif (xhci->shared_hcd) {\ndiff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c\nindex e038ad3375dc..94c9c9271658 100644\n--- a/drivers/usb/host/xhci-ring.c\n+++ b/drivers/usb/host/xhci-ring.c\n@@ -518,9 +518,8 @@ static int xhci_abort_cmd_ring(struct xhci_hcd *xhci, unsigned long flags)\n \t * In the future we should distinguish between -ENODEV and -ETIMEDOUT\n \t * and try to recover a -ETIMEDOUT with a host controller reset.\n \t */\n-\tret = xhci_handshake_check_state(xhci, &xhci->op_regs->cmd_ring,\n-\t\t\tCMD_RING_RUNNING, 0, 5 * 1000 * 1000,\n-\t\t\tXHCI_STATE_REMOVING);\n+\tret = xhci_handshake(&xhci->op_regs->cmd_ring,\n+\t\t\tCMD_RING_RUNNING, 0, 5 * 1000 * 1000);\n \tif (ret < 0) {\n \t\txhci_err(xhci, \"Abort failed to stop command ring: %d\\n\", ret);\n \t\txhci_halt(xhci);\ndiff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c\nindex 4e6dbd2375c3..8a819e853288 100644\n--- a/drivers/usb/host/xhci.c\n+++ b/drivers/usb/host/xhci.c\n@@ -84,29 +84,6 @@ int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us)\n \treturn ret;\n }\n \n-/*\n- * xhci_handshake_check_state - same as xhci_handshake but takes an additional\n- * exit_state parameter, and bails out with an error immediately when xhc_state\n- * has exit_state flag set.\n- */\n-int xhci_handshake_check_state(struct xhci_hcd *xhci, void __iomem *ptr,\n-\t\tu32 mask, u32 done, int usec, unsigned int exit_state)\n-{\n-\tu32\tresult;\n-\tint\tret;\n-\n-\tret = readl_poll_timeout_atomic(ptr, result,\n-\t\t\t\t(result & mask) == done ||\n-\t\t\t\tresult == U32_MAX ||\n-\t\t\t\txhci->xhc_state & exit_state,\n-\t\t\t\t1, usec);\n-\n-\tif (result == U32_MAX || xhci->xhc_state & exit_state)\n-\t\treturn -ENODEV;\n-\n-\treturn ret;\n-}\n-\n /*\n  * Disable interrupts and begin the xHCI halting process.\n  */\n@@ -227,8 +204,7 @@ int xhci_reset(struct xhci_hcd *xhci, u64 timeout_us)\n \tif (xhci->quirks & XHCI_INTEL_HOST)\n \t\tudelay(1000);\n \n-\tret = xhci_handshake_check_state(xhci, &xhci->op_regs->command,\n-\t\t\t\tCMD_RESET, 0, timeout_us, XHCI_STATE_REMOVING);\n+\tret = xhci_handshake(&xhci->op_regs->command, CMD_RESET, 0, timeout_us);\n \tif (ret)\n \t\treturn ret;\n \n@@ -1182,7 +1158,10 @@ int xhci_resume(struct xhci_hcd *xhci, bool power_lost, bool is_auto_resume)\n \t\txhci_dbg(xhci, \"Stop HCD\\n\");\n \t\txhci_halt(xhci);\n \t\txhci_zero_64b_regs(xhci);\n-\t\tretval = xhci_reset(xhci, XHCI_RESET_LONG_USEC);\n+\t\tif (xhci->xhc_state & XHCI_STATE_REMOVING)\n+\t\t\tretval = -ENODEV;\n+\t\telse\n+\t\t\tretval = xhci_reset(xhci, XHCI_RESET_LONG_USEC);\n \t\tspin_unlock_irq(&xhci->lock);\n \t\tif (retval)\n \t\t\treturn retval;\ndiff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h\nindex 49887a303e43..a20f4e7cd43a 100644\n--- a/drivers/usb/host/xhci.h\n+++ b/drivers/usb/host/xhci.h\n@@ -1643,6 +1643,7 @@ struct xhci_hcd {\n #define XHCI_WRITE_64_HI_LO\tBIT_ULL(47)\n #define XHCI_CDNS_SCTX_QUIRK\tBIT_ULL(48)\n #define XHCI_ETRON_HOST\tBIT_ULL(49)\n+#define XHCI_LIMIT_ENDPOINT_INTERVAL_9 BIT_ULL(50)\n \n \tunsigned int\t\tnum_active_eps;\n \tunsigned int\t\tlimit_active_eps;\n@@ -1868,8 +1869,6 @@ void xhci_skip_sec_intr_events(struct xhci_hcd *xhci,\n /* xHCI host controller glue */\n typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);\n int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us);\n-int xhci_handshake_check_state(struct xhci_hcd *xhci, void __iomem *ptr,\n-\t\tu32 mask, u32 done, int usec, unsigned int exit_state);\n void xhci_quiesce(struct xhci_hcd *xhci);\n int xhci_halt(struct xhci_hcd *xhci);\n int xhci_start(struct xhci_hcd *xhci);\ndiff --git a/drivers/usb/typec/altmodes/displayport.c b/drivers/usb/typec/altmodes/displayport.c\nindex b09b58d7311d..d8b906ec4d1c 100644\n--- a/drivers/usb/typec/altmodes/displayport.c\n+++ b/drivers/usb/typec/altmodes/displayport.c\n@@ -394,8 +394,7 @@ static int dp_altmode_vdm(struct typec_altmode *alt,\n \tcase CMDT_RSP_NAK:\n \t\tswitch (cmd) {\n \t\tcase DP_CMD_STATUS_UPDATE:\n-\t\t\tif (typec_altmode_exit(alt))\n-\t\t\t\tdev_err(&dp->alt->dev, \"Exit Mode Failed!\\n\");\n+\t\t\tdp->state = DP_STATE_EXIT;\n \t\t\tbreak;\n \t\tcase DP_CMD_CONFIGURE:\n \t\t\tdp->data.conf = 0;\n@@ -677,7 +676,7 @@ static ssize_t pin_assignment_show(struct device *dev,\n \n \tassignments = get_current_pin_assignments(dp);\n \n-\tfor (i = 0; assignments; assignments >>= 1, i++) {\n+\tfor (i = 0; assignments && i < DP_PIN_ASSIGN_MAX; assignments >>= 1, i++) {\n \t\tif (assignments & 1) {\n \t\t\tif (i == cur)\n \t\t\t\tlen += sprintf(buf + len, \"[%s] \",\ndiff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c\nindex 1a1f9e1f8e4e..1f6fdfaa34bf 100644\n--- a/drivers/usb/typec/tcpm/tcpm.c\n+++ b/drivers/usb/typec/tcpm/tcpm.c\n@@ -4410,17 +4410,6 @@ static int tcpm_src_attach(struct tcpm_port *port)\n \n \ttcpm_enable_auto_vbus_discharge(port, true);\n \n-\tret = tcpm_set_roles(port, true, TYPEC_STATE_USB,\n-\t\t\t     TYPEC_SOURCE, tcpm_data_role_for_source(port));\n-\tif (ret < 0)\n-\t\treturn ret;\n-\n-\tif (port->pd_supported) {\n-\t\tret = port->tcpc->set_pd_rx(port->tcpc, true);\n-\t\tif (ret < 0)\n-\t\t\tgoto out_disable_mux;\n-\t}\n-\n \t/*\n \t * USB Type-C specification, version 1.2,\n \t * chapter 4.5.2.2.8.1 (Attached.SRC Requirements)\n@@ -4430,13 +4419,24 @@ static int tcpm_src_attach(struct tcpm_port *port)\n \t    (polarity == TYPEC_POLARITY_CC2 && port->cc1 == TYPEC_CC_RA)) {\n \t\tret = tcpm_set_vconn(port, true);\n \t\tif (ret < 0)\n-\t\t\tgoto out_disable_pd;\n+\t\t\treturn ret;\n \t}\n \n \tret = tcpm_set_vbus(port, true);\n \tif (ret < 0)\n \t\tgoto out_disable_vconn;\n \n+\tret = tcpm_set_roles(port, true, TYPEC_STATE_USB, TYPEC_SOURCE,\n+\t\t\t     tcpm_data_role_for_source(port));\n+\tif (ret < 0)\n+\t\tgoto out_disable_vbus;\n+\n+\tif (port->pd_supported) {\n+\t\tret = port->tcpc->set_pd_rx(port->tcpc, true);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_disable_mux;\n+\t}\n+\n \tport->pd_capable = false;\n \n \tport->partner = NULL;\n@@ -4447,14 +4447,14 @@ static int tcpm_src_attach(struct tcpm_port *port)\n \n \treturn 0;\n \n-out_disable_vconn:\n-\ttcpm_set_vconn(port, false);\n-out_disable_pd:\n-\tif (port->pd_supported)\n-\t\tport->tcpc->set_pd_rx(port->tcpc, false);\n out_disable_mux:\n \ttcpm_mux_set(port, TYPEC_STATE_SAFE, USB_ROLE_NONE,\n \t\t     TYPEC_ORIENTATION_NONE);\n+out_disable_vbus:\n+\ttcpm_set_vbus(port, false);\n+out_disable_vconn:\n+\ttcpm_set_vconn(port, false);\n+\n \treturn ret;\n }\n \ndiff --git a/include/linux/usb.h b/include/linux/usb.h\nindex 1b2545b4363b..92c752f5446f 100644\n--- a/include/linux/usb.h\n+++ b/include/linux/usb.h\n@@ -614,6 +614,7 @@ struct usb3_lpm_parameters {\n  *\tFIXME -- complete doc\n  * @authenticated: Crypto authentication passed\n  * @tunnel_mode: Connection native or tunneled over USB4\n+ * @usb4_link: device link to the USB4 host interface\n  * @lpm_capable: device supports LPM\n  * @lpm_devinit_allow: Allow USB3 device initiated LPM, exit latency is in range\n  * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM\n@@ -724,6 +725,7 @@ struct usb_device {\n \tunsigned reset_resume:1;\n \tunsigned port_is_suspended:1;\n \tenum usb_link_tunnel_mode tunnel_mode;\n+\tstruct device_link *usb4_link;\n \n \tint slot_id;\n \tstruct usb2_lpm_parameters l1_params;\ndiff --git a/include/linux/usb/typec_dp.h b/include/linux/usb/typec_dp.h\nindex f2da264d9c14..acb0ad03bdac 100644\n--- a/include/linux/usb/typec_dp.h\n+++ b/include/linux/usb/typec_dp.h\n@@ -57,6 +57,7 @@ enum {\n \tDP_PIN_ASSIGN_D,\n \tDP_PIN_ASSIGN_E,\n \tDP_PIN_ASSIGN_F, /* Not supported after v1.0b */\n+\tDP_PIN_ASSIGN_MAX,\n };\n \n /* DisplayPort alt mode specific commands */",
    "stats": {
      "insertions": 160,
      "deletions": 85,
      "files": 24
    }
  },
  {
    "sha": "42bb9b630c4c6c0964cddca98d9d30aa992826de",
    "message": "Merge tag 'drm-fixes-2025-07-04' of https://gitlab.freedesktop.org/drm/kernel\n\nPull drm fixes from Dave Airlie:\n \"Weekly drm fixes, bit of a bumper crop, the usual amdgpu/xe/i915\n  suspects, then there is a large scattering of fixes across core and\n  drivers. I think the simple panel lookup fix is probably the largest,\n  the sched race fix is also fun, but I don't see anything standing out\n  too badly.\n\n  dma-buf:\n   - fix timeout handling\n\n  gem:\n   - fix framebuffer object references\n\n  sched:\n   - fix spsc queue job count race\n\n  bridge:\n   - fix aux hpd bridge of node\n   - panel: move missing flag handling\n   - samsung-dsim: fix %pK usage to %p\n\n  panel:\n   - fix problem with simple panel lookup\n\n  ttm:\n   - fix error path handling\n\n  amdgpu:\n   - SDMA 5.x reset fix\n   - Add missing firmware declaration\n   - Fix leak in amdgpu_ctx_mgr_entity_fini()\n   - Freesync fix\n   - OLED backlight fix\n\n  amdkfd:\n   - mtype fix for ext coherent system memory\n   - MMU notifier fix\n   - gfx7/8 fix\n\n  xe:\n   - Fix chunking the PTE updates and overflowing the maximum number of\n     dwords with with MI_STORE_DATA_IMM\n   - Move WA BB to the LRC BO to mitigate hangs on context switch\n   - Fix frequency/flush WAs for BMG\n   - Fix kconfig prompt title and description\n   - Do not require kunit\n   - Extend 14018094691 WA to BMG\n   - Fix wedging the device on signal\n\n  i915:\n   - Make mei interrupt top half irq disabled to fix RT builds\n   - Fix timeline left held on VMA alloc error\n   - Fix NULL pointer deref in vlv_dphy_param_init()\n   - Fix selftest mock_request() to avoid NULL deref\n\n  exynos:\n   - switch to using %p instead of %pK\n   - fix vblank NULL ptr race\n   - fix lockup on samsung peach-pit/pi chromebooks\n\n  vesadrm:\n   - NULL ptr fix\n\n  vmwgfx:\n   - fix encrypted memory allocation bug\n\n  v3d:\n   - fix irq enabled during reset\"\n\n* tag 'drm-fixes-2025-07-04' of https://gitlab.freedesktop.org/drm/kernel: (41 commits)\n  drm/xe: Do not wedge device on killed exec queues\n  drm/xe: Extend WA 14018094691 to BMG\n  drm/v3d: Disable interrupts before resetting the GPU\n  drm/gem: Acquire references on GEM handles for framebuffers\n  drm/sched: Increment job count before swapping tail spsc queue\n  drm/xe: Allow dropping kunit dependency as built-in\n  drm/xe: Fix kconfig prompt\n  drm/xe/bmg: Update Wa_22019338487\n  drm/xe/bmg: Update Wa_14022085890\n  drm/xe: Split xe_device_td_flush()\n  drm/xe/xe_guc_pc: Lock once to update stashed frequencies\n  drm/xe/guc_pc: Add _locked variant for min/max freq\n  drm/xe: Make WA BB part of LRC BO\n  drm/xe: Fix out-of-bounds field write in MI_STORE_DATA_IMM\n  drm/i915/gsc: mei interrupt top half should be in irq disabled context\n  drm/i915/gt: Fix timeline left held on VMA alloc error\n  drm/vmwgfx: Fix guests running with TDX/SEV\n  drm/amd/display: Don't allow OLED to go down to fully off\n  drm/amd/display: Added case for when RR equals panel's max RR using freesync\n  drm/amdkfd: add hqd_sdma_get_doorbell callbacks for gfx7/8\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-07-04T09:48:36-07:00",
    "files_changed": [
      "drivers/dma-buf/dma-resv.c",
      "drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c",
      "drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c",
      "drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c",
      "drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c",
      "drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c",
      "drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c",
      "drivers/gpu/drm/amd/amdkfd/kfd_svm.c",
      "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
      "drivers/gpu/drm/amd/display/dc/dc_hw_types.h",
      "drivers/gpu/drm/amd/display/modules/freesync/freesync.c",
      "drivers/gpu/drm/bridge/aux-hpd-bridge.c",
      "drivers/gpu/drm/bridge/panel.c",
      "drivers/gpu/drm/bridge/samsung-dsim.c",
      "drivers/gpu/drm/drm_gem.c",
      "drivers/gpu/drm/drm_gem_framebuffer_helper.c",
      "drivers/gpu/drm/drm_internal.h",
      "drivers/gpu/drm/drm_mipi_dsi.c",
      "drivers/gpu/drm/exynos/exynos7_drm_decon.c",
      "drivers/gpu/drm/exynos/exynos_drm_fimd.c",
      "drivers/gpu/drm/exynos/exynos_drm_gem.c",
      "drivers/gpu/drm/exynos/exynos_drm_ipp.c",
      "drivers/gpu/drm/i915/display/vlv_dsi.c",
      "drivers/gpu/drm/i915/gt/intel_gsc.c",
      "drivers/gpu/drm/i915/gt/intel_ring_submission.c",
      "drivers/gpu/drm/i915/selftests/i915_request.c",
      "drivers/gpu/drm/i915/selftests/mock_request.c",
      "drivers/gpu/drm/panel/panel-simple.c",
      "drivers/gpu/drm/sysfb/vesadrm.c",
      "drivers/gpu/drm/ttm/ttm_bo_util.c",
      "drivers/gpu/drm/v3d/v3d_drv.h",
      "drivers/gpu/drm/v3d/v3d_gem.c",
      "drivers/gpu/drm/v3d/v3d_irq.c",
      "drivers/gpu/drm/vmwgfx/vmwgfx_drv.c",
      "drivers/gpu/drm/xe/xe_device.c",
      "drivers/gpu/drm/xe/xe_drv.h",
      "drivers/gpu/drm/xe/xe_guc_pc.c",
      "drivers/gpu/drm/xe/xe_guc_pc.h",
      "drivers/gpu/drm/xe/xe_guc_pc_types.h",
      "drivers/gpu/drm/xe/xe_guc_submit.c",
      "drivers/gpu/drm/xe/xe_lrc.c",
      "drivers/gpu/drm/xe/xe_lrc_types.h",
      "drivers/gpu/drm/xe/xe_migrate.c",
      "include/drm/drm_mipi_dsi.h",
      "include/drm/spsc_queue.h"
    ],
    "diff": "diff --git a/drivers/dma-buf/dma-resv.c b/drivers/dma-buf/dma-resv.c\nindex b1ef4546346d..bea3e9858aca 100644\n--- a/drivers/dma-buf/dma-resv.c\n+++ b/drivers/dma-buf/dma-resv.c\n@@ -685,11 +685,13 @@ long dma_resv_wait_timeout(struct dma_resv *obj, enum dma_resv_usage usage,\n \tdma_resv_iter_begin(&cursor, obj, usage);\n \tdma_resv_for_each_fence_unlocked(&cursor, fence) {\n \n-\t\tret = dma_fence_wait_timeout(fence, intr, ret);\n-\t\tif (ret <= 0) {\n-\t\t\tdma_resv_iter_end(&cursor);\n-\t\t\treturn ret;\n-\t\t}\n+\t\tret = dma_fence_wait_timeout(fence, intr, timeout);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\t/* Even for zero timeout the return value is 1 */\n+\t\tif (timeout)\n+\t\t\ttimeout = ret;\n \t}\n \tdma_resv_iter_end(&cursor);\n \ndiff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c\nindex ca4a6b82817f..df77558e03ef 100644\n--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c\n+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v7.c\n@@ -561,6 +561,13 @@ static uint32_t read_vmid_from_vmfault_reg(struct amdgpu_device *adev)\n \treturn REG_GET_FIELD(status, VM_CONTEXT1_PROTECTION_FAULT_STATUS, VMID);\n }\n \n+static uint32_t kgd_hqd_sdma_get_doorbell(struct amdgpu_device *adev,\n+\t\t\t\t\t  int engine, int queue)\n+\n+{\n+\treturn 0;\n+}\n+\n const struct kfd2kgd_calls gfx_v7_kfd2kgd = {\n \t.program_sh_mem_settings = kgd_program_sh_mem_settings,\n \t.set_pasid_vmid_mapping = kgd_set_pasid_vmid_mapping,\n@@ -578,4 +585,5 @@ const struct kfd2kgd_calls gfx_v7_kfd2kgd = {\n \t.set_scratch_backing_va = set_scratch_backing_va,\n \t.set_vm_context_page_table_base = set_vm_context_page_table_base,\n \t.read_vmid_from_vmfault_reg = read_vmid_from_vmfault_reg,\n+\t.hqd_sdma_get_doorbell = kgd_hqd_sdma_get_doorbell,\n };\ndiff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c\nindex 0f3e2944edd7..e68c0fa8d751 100644\n--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c\n+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd_gfx_v8.c\n@@ -582,6 +582,13 @@ static void set_vm_context_page_table_base(struct amdgpu_device *adev,\n \t\t\tlower_32_bits(page_table_base));\n }\n \n+static uint32_t kgd_hqd_sdma_get_doorbell(struct amdgpu_device *adev,\n+\t\t\t\t\t  int engine, int queue)\n+\n+{\n+\treturn 0;\n+}\n+\n const struct kfd2kgd_calls gfx_v8_kfd2kgd = {\n \t.program_sh_mem_settings = kgd_program_sh_mem_settings,\n \t.set_pasid_vmid_mapping = kgd_set_pasid_vmid_mapping,\n@@ -599,4 +606,5 @@ const struct kfd2kgd_calls gfx_v8_kfd2kgd = {\n \t\t\tget_atc_vmid_pasid_mapping_info,\n \t.set_scratch_backing_va = set_scratch_backing_va,\n \t.set_vm_context_page_table_base = set_vm_context_page_table_base,\n+\t.hqd_sdma_get_doorbell = kgd_hqd_sdma_get_doorbell,\n };\ndiff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c\nindex 85567d0d9545..f5d5c45ddc0d 100644\n--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c\n+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c\n@@ -944,6 +944,7 @@ static void amdgpu_ctx_mgr_entity_fini(struct amdgpu_ctx_mgr *mgr)\n \t\t\t\tdrm_sched_entity_fini(entity);\n \t\t\t}\n \t\t}\n+\t\tkref_put(&ctx->refcount, amdgpu_ctx_fini);\n \t}\n }\n \ndiff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c b/drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c\nindex cef68df4c663..bb82c652e4c0 100644\n--- a/drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c\n+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c\n@@ -45,6 +45,7 @@\n #include \"amdgpu_ras.h\"\n \n MODULE_FIRMWARE(\"amdgpu/sdma_4_4_2.bin\");\n+MODULE_FIRMWARE(\"amdgpu/sdma_4_4_4.bin\");\n MODULE_FIRMWARE(\"amdgpu/sdma_4_4_5.bin\");\n \n static const struct amdgpu_hwip_reg_entry sdma_reg_list_4_4_2[] = {\ndiff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c b/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c\nindex 1813c3ed0aa6..37f4b5b4a098 100644\n--- a/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c\n+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c\n@@ -1543,8 +1543,13 @@ static int sdma_v5_0_reset_queue(struct amdgpu_ring *ring, unsigned int vmid)\n {\n \tstruct amdgpu_device *adev = ring->adev;\n \tu32 inst_id = ring->me;\n+\tint r;\n+\n+\tamdgpu_amdkfd_suspend(adev, true);\n+\tr = amdgpu_sdma_reset_engine(adev, inst_id);\n+\tamdgpu_amdkfd_resume(adev, true);\n \n-\treturn amdgpu_sdma_reset_engine(adev, inst_id);\n+\treturn r;\n }\n \n static int sdma_v5_0_stop_queue(struct amdgpu_ring *ring)\ndiff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c\nindex 23f97da62808..0b40411b92a0 100644\n--- a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c\n+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c\n@@ -1456,8 +1456,13 @@ static int sdma_v5_2_reset_queue(struct amdgpu_ring *ring, unsigned int vmid)\n {\n \tstruct amdgpu_device *adev = ring->adev;\n \tu32 inst_id = ring->me;\n+\tint r;\n+\n+\tamdgpu_amdkfd_suspend(adev, true);\n+\tr = amdgpu_sdma_reset_engine(adev, inst_id);\n+\tamdgpu_amdkfd_resume(adev, true);\n \n-\treturn amdgpu_sdma_reset_engine(adev, inst_id);\n+\treturn r;\n }\n \n static int sdma_v5_2_stop_queue(struct amdgpu_ring *ring)\ndiff --git a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c\nindex 865dca2547de..a0f22ea6d15a 100644\n--- a/drivers/gpu/drm/amd/amdkfd/kfd_svm.c\n+++ b/drivers/gpu/drm/amd/amdkfd/kfd_svm.c\n@@ -1171,13 +1171,12 @@ svm_range_split_head(struct svm_range *prange, uint64_t new_start,\n }\n \n static void\n-svm_range_add_child(struct svm_range *prange, struct mm_struct *mm,\n-\t\t    struct svm_range *pchild, enum svm_work_list_ops op)\n+svm_range_add_child(struct svm_range *prange, struct svm_range *pchild, enum svm_work_list_ops op)\n {\n \tpr_debug(\"add child 0x%p [0x%lx 0x%lx] to prange 0x%p child list %d\\n\",\n \t\t pchild, pchild->start, pchild->last, prange, op);\n \n-\tpchild->work_item.mm = mm;\n+\tpchild->work_item.mm = NULL;\n \tpchild->work_item.op = op;\n \tlist_add_tail(&pchild->child_list, &prange->child_list);\n }\n@@ -1278,7 +1277,7 @@ svm_range_get_pte_flags(struct kfd_node *node,\n \t\t\t\tmapping_flags |= ext_coherent ? AMDGPU_VM_MTYPE_UC : AMDGPU_VM_MTYPE_NC;\n \t\t/* system memory accessed by the dGPU */\n \t\t} else {\n-\t\t\tif (gc_ip_version < IP_VERSION(9, 5, 0))\n+\t\t\tif (gc_ip_version < IP_VERSION(9, 5, 0) || ext_coherent)\n \t\t\t\tmapping_flags |= AMDGPU_VM_MTYPE_UC;\n \t\t\telse\n \t\t\t\tmapping_flags |= AMDGPU_VM_MTYPE_NC;\n@@ -2394,15 +2393,17 @@ svm_range_add_list_work(struct svm_range_list *svms, struct svm_range *prange,\n \t\t    prange->work_item.op != SVM_OP_UNMAP_RANGE)\n \t\t\tprange->work_item.op = op;\n \t} else {\n-\t\tprange->work_item.op = op;\n-\n-\t\t/* Pairs with mmput in deferred_list_work */\n-\t\tmmget(mm);\n-\t\tprange->work_item.mm = mm;\n-\t\tlist_add_tail(&prange->deferred_list,\n-\t\t\t      &prange->svms->deferred_range_list);\n-\t\tpr_debug(\"add prange 0x%p [0x%lx 0x%lx] to work list op %d\\n\",\n-\t\t\t prange, prange->start, prange->last, op);\n+\t\t/* Pairs with mmput in deferred_list_work.\n+\t\t * If process is exiting and mm is gone, don't update mmu notifier.\n+\t\t */\n+\t\tif (mmget_not_zero(mm)) {\n+\t\t\tprange->work_item.mm = mm;\n+\t\t\tprange->work_item.op = op;\n+\t\t\tlist_add_tail(&prange->deferred_list,\n+\t\t\t\t      &prange->svms->deferred_range_list);\n+\t\t\tpr_debug(\"add prange 0x%p [0x%lx 0x%lx] to work list op %d\\n\",\n+\t\t\t\t prange, prange->start, prange->last, op);\n+\t\t}\n \t}\n \tspin_unlock(&svms->deferred_list_lock);\n }\n@@ -2416,8 +2417,7 @@ void schedule_deferred_list_work(struct svm_range_list *svms)\n }\n \n static void\n-svm_range_unmap_split(struct mm_struct *mm, struct svm_range *parent,\n-\t\t      struct svm_range *prange, unsigned long start,\n+svm_range_unmap_split(struct svm_range *parent, struct svm_range *prange, unsigned long start,\n \t\t      unsigned long last)\n {\n \tstruct svm_range *head;\n@@ -2438,12 +2438,12 @@ svm_range_unmap_split(struct mm_struct *mm, struct svm_range *parent,\n \t\tsvm_range_split(tail, last + 1, tail->last, &head);\n \n \tif (head != prange && tail != prange) {\n-\t\tsvm_range_add_child(parent, mm, head, SVM_OP_UNMAP_RANGE);\n-\t\tsvm_range_add_child(parent, mm, tail, SVM_OP_ADD_RANGE);\n+\t\tsvm_range_add_child(parent, head, SVM_OP_UNMAP_RANGE);\n+\t\tsvm_range_add_child(parent, tail, SVM_OP_ADD_RANGE);\n \t} else if (tail != prange) {\n-\t\tsvm_range_add_child(parent, mm, tail, SVM_OP_UNMAP_RANGE);\n+\t\tsvm_range_add_child(parent, tail, SVM_OP_UNMAP_RANGE);\n \t} else if (head != prange) {\n-\t\tsvm_range_add_child(parent, mm, head, SVM_OP_UNMAP_RANGE);\n+\t\tsvm_range_add_child(parent, head, SVM_OP_UNMAP_RANGE);\n \t} else if (parent != prange) {\n \t\tprange->work_item.op = SVM_OP_UNMAP_RANGE;\n \t}\n@@ -2520,14 +2520,14 @@ svm_range_unmap_from_cpu(struct mm_struct *mm, struct svm_range *prange,\n \t\tl = min(last, pchild->last);\n \t\tif (l >= s)\n \t\t\tsvm_range_unmap_from_gpus(pchild, s, l, trigger);\n-\t\tsvm_range_unmap_split(mm, prange, pchild, start, last);\n+\t\tsvm_range_unmap_split(prange, pchild, start, last);\n \t\tmutex_unlock(&pchild->lock);\n \t}\n \ts = max(start, prange->start);\n \tl = min(last, prange->last);\n \tif (l >= s)\n \t\tsvm_range_unmap_from_gpus(prange, s, l, trigger);\n-\tsvm_range_unmap_split(mm, prange, prange, start, last);\n+\tsvm_range_unmap_split(prange, prange, start, last);\n \n \tif (unmap_parent)\n \t\tsvm_range_add_list_work(svms, prange, mm, SVM_OP_UNMAP_RANGE);\n@@ -2570,8 +2570,6 @@ svm_range_cpu_invalidate_pagetables(struct mmu_interval_notifier *mni,\n \n \tif (range->event == MMU_NOTIFY_RELEASE)\n \t\treturn true;\n-\tif (!mmget_not_zero(mni->mm))\n-\t\treturn true;\n \n \tstart = mni->interval_tree.start;\n \tlast = mni->interval_tree.last;\n@@ -2598,7 +2596,6 @@ svm_range_cpu_invalidate_pagetables(struct mmu_interval_notifier *mni,\n \t}\n \n \tsvm_range_unlock(prange);\n-\tmmput(mni->mm);\n \n \treturn true;\n }\ndiff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c\nindex 0b8ac9edc070..f58fa5da7fe5 100644\n--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c\n+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c\n@@ -3610,13 +3610,15 @@ static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)\n \n \tluminance_range = &conn_base->display_info.luminance_range;\n \n-\tif (luminance_range->max_luminance) {\n-\t\tcaps->aux_min_input_signal = luminance_range->min_luminance;\n+\tif (luminance_range->max_luminance)\n \t\tcaps->aux_max_input_signal = luminance_range->max_luminance;\n-\t} else {\n-\t\tcaps->aux_min_input_signal = 0;\n+\telse\n \t\tcaps->aux_max_input_signal = 512;\n-\t}\n+\n+\tif (luminance_range->min_luminance)\n+\t\tcaps->aux_min_input_signal = luminance_range->min_luminance;\n+\telse\n+\t\tcaps->aux_min_input_signal = 1;\n \n \tmin_input_signal_override = drm_get_panel_min_brightness_quirk(aconnector->drm_edid);\n \tif (min_input_signal_override >= 0)\ndiff --git a/drivers/gpu/drm/amd/display/dc/dc_hw_types.h b/drivers/gpu/drm/amd/display/dc/dc_hw_types.h\nindex d562ddeca512..c9f6c6275ca1 100644\n--- a/drivers/gpu/drm/amd/display/dc/dc_hw_types.h\n+++ b/drivers/gpu/drm/amd/display/dc/dc_hw_types.h\n@@ -974,6 +974,7 @@ struct dc_crtc_timing {\n \tuint32_t pix_clk_100hz;\n \n \tuint32_t min_refresh_in_uhz;\n+\tuint32_t max_refresh_in_uhz;\n \n \tuint32_t vic;\n \tuint32_t hdmi_vic;\ndiff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c\nindex 3ba9b62ba70b..250f09922d2f 100644\n--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c\n+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c\n@@ -155,6 +155,14 @@ unsigned int mod_freesync_calc_v_total_from_refresh(\n \t\tv_total = div64_u64(div64_u64(((unsigned long long)(\n \t\t\t\tframe_duration_in_ns) * (stream->timing.pix_clk_100hz / 10)),\n \t\t\t\tstream->timing.h_total), 1000000);\n+\t} else if (refresh_in_uhz >= stream->timing.max_refresh_in_uhz) {\n+\t\t/* When the target refresh rate is the maximum panel refresh rate\n+\t\t * round up the vtotal value to prevent off-by-one error causing\n+\t\t * v_total_min to be below the panel's lower bound\n+\t\t */\n+\t\tv_total = div64_u64(div64_u64(((unsigned long long)(\n+\t\t\t\tframe_duration_in_ns) * (stream->timing.pix_clk_100hz / 10)),\n+\t\t\t\tstream->timing.h_total) + (1000000 - 1), 1000000);\n \t} else {\n \t\tv_total = div64_u64(div64_u64(((unsigned long long)(\n \t\t\t\tframe_duration_in_ns) * (stream->timing.pix_clk_100hz / 10)),\ndiff --git a/drivers/gpu/drm/bridge/aux-hpd-bridge.c b/drivers/gpu/drm/bridge/aux-hpd-bridge.c\nindex b3f588b71a7d..af6f79793407 100644\n--- a/drivers/gpu/drm/bridge/aux-hpd-bridge.c\n+++ b/drivers/gpu/drm/bridge/aux-hpd-bridge.c\n@@ -64,10 +64,11 @@ struct auxiliary_device *devm_drm_dp_hpd_bridge_alloc(struct device *parent, str\n \tadev->id = ret;\n \tadev->name = \"dp_hpd_bridge\";\n \tadev->dev.parent = parent;\n-\tadev->dev.of_node = of_node_get(parent->of_node);\n \tadev->dev.release = drm_aux_hpd_bridge_release;\n \tadev->dev.platform_data = of_node_get(np);\n \n+\tdevice_set_of_node_from_dev(&adev->dev, parent);\n+\n \tret = auxiliary_device_init(adev);\n \tif (ret) {\n \t\tof_node_put(adev->dev.platform_data);\ndiff --git a/drivers/gpu/drm/bridge/panel.c b/drivers/gpu/drm/bridge/panel.c\nindex 79b009ab9396..29b0358a7b6d 100644\n--- a/drivers/gpu/drm/bridge/panel.c\n+++ b/drivers/gpu/drm/bridge/panel.c\n@@ -299,6 +299,7 @@ struct drm_bridge *drm_panel_bridge_add_typed(struct drm_panel *panel,\n \tpanel_bridge->bridge.of_node = panel->dev->of_node;\n \tpanel_bridge->bridge.ops = DRM_BRIDGE_OP_MODES;\n \tpanel_bridge->bridge.type = connector_type;\n+\tpanel_bridge->bridge.pre_enable_prev_first = panel->prepare_prev_first;\n \n \tdrm_bridge_add(&panel_bridge->bridge);\n \n@@ -413,8 +414,6 @@ struct drm_bridge *devm_drm_panel_bridge_add_typed(struct device *dev,\n \t\treturn bridge;\n \t}\n \n-\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n-\n \t*ptr = bridge;\n \tdevres_add(dev, ptr);\n \n@@ -456,8 +455,6 @@ struct drm_bridge *drmm_panel_bridge_add(struct drm_device *drm,\n \tif (ret)\n \t\treturn ERR_PTR(ret);\n \n-\tbridge->pre_enable_prev_first = panel->prepare_prev_first;\n-\n \treturn bridge;\n }\n EXPORT_SYMBOL(drmm_panel_bridge_add);\ndiff --git a/drivers/gpu/drm/bridge/samsung-dsim.c b/drivers/gpu/drm/bridge/samsung-dsim.c\nindex 0014c497e3fe..bccc88d25948 100644\n--- a/drivers/gpu/drm/bridge/samsung-dsim.c\n+++ b/drivers/gpu/drm/bridge/samsung-dsim.c\n@@ -1095,7 +1095,7 @@ static void samsung_dsim_send_to_fifo(struct samsung_dsim *dsi,\n \tbool first = !xfer->tx_done;\n \tu32 reg;\n \n-\tdev_dbg(dev, \"< xfer %pK: tx len %u, done %u, rx len %u, done %u\\n\",\n+\tdev_dbg(dev, \"< xfer %p: tx len %u, done %u, rx len %u, done %u\\n\",\n \t\txfer, length, xfer->tx_done, xfer->rx_len, xfer->rx_done);\n \n \tif (length > DSI_TX_FIFO_SIZE)\n@@ -1293,7 +1293,7 @@ static bool samsung_dsim_transfer_finish(struct samsung_dsim *dsi)\n \tspin_unlock_irqrestore(&dsi->transfer_lock, flags);\n \n \tdev_dbg(dsi->dev,\n-\t\t\"> xfer %pK, tx_len %zu, tx_done %u, rx_len %u, rx_done %u\\n\",\n+\t\t\"> xfer %p, tx_len %zu, tx_done %u, rx_len %u, rx_done %u\\n\",\n \t\txfer, xfer->packet.payload_length, xfer->tx_done, xfer->rx_len,\n \t\txfer->rx_done);\n \ndiff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c\nindex 1e659d2660f7..4bf0a76bb35e 100644\n--- a/drivers/gpu/drm/drm_gem.c\n+++ b/drivers/gpu/drm/drm_gem.c\n@@ -212,6 +212,35 @@ void drm_gem_private_object_fini(struct drm_gem_object *obj)\n }\n EXPORT_SYMBOL(drm_gem_private_object_fini);\n \n+static void drm_gem_object_handle_get(struct drm_gem_object *obj)\n+{\n+\tstruct drm_device *dev = obj->dev;\n+\n+\tdrm_WARN_ON(dev, !mutex_is_locked(&dev->object_name_lock));\n+\n+\tif (obj->handle_count++ == 0)\n+\t\tdrm_gem_object_get(obj);\n+}\n+\n+/**\n+ * drm_gem_object_handle_get_unlocked - acquire reference on user-space handles\n+ * @obj: GEM object\n+ *\n+ * Acquires a reference on the GEM buffer object's handle. Required\n+ * to keep the GEM object alive. Call drm_gem_object_handle_put_unlocked()\n+ * to release the reference.\n+ */\n+void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj)\n+{\n+\tstruct drm_device *dev = obj->dev;\n+\n+\tguard(mutex)(&dev->object_name_lock);\n+\n+\tdrm_WARN_ON(dev, !obj->handle_count); /* first ref taken in create-tail helper */\n+\tdrm_gem_object_handle_get(obj);\n+}\n+EXPORT_SYMBOL(drm_gem_object_handle_get_unlocked);\n+\n /**\n  * drm_gem_object_handle_free - release resources bound to userspace handles\n  * @obj: GEM object to clean up.\n@@ -242,8 +271,14 @@ static void drm_gem_object_exported_dma_buf_free(struct drm_gem_object *obj)\n \t}\n }\n \n-static void\n-drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n+/**\n+ * drm_gem_object_handle_put_unlocked - releases reference on user-space handles\n+ * @obj: GEM object\n+ *\n+ * Releases a reference on the GEM buffer object's handle. Possibly releases\n+ * the GEM buffer object and associated dma-buf objects.\n+ */\n+void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n {\n \tstruct drm_device *dev = obj->dev;\n \tbool final = false;\n@@ -268,6 +303,7 @@ drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n \tif (final)\n \t\tdrm_gem_object_put(obj);\n }\n+EXPORT_SYMBOL(drm_gem_object_handle_put_unlocked);\n \n /*\n  * Called at device or object close to release the file's\n@@ -389,8 +425,8 @@ drm_gem_handle_create_tail(struct drm_file *file_priv,\n \tint ret;\n \n \tWARN_ON(!mutex_is_locked(&dev->object_name_lock));\n-\tif (obj->handle_count++ == 0)\n-\t\tdrm_gem_object_get(obj);\n+\n+\tdrm_gem_object_handle_get(obj);\n \n \t/*\n \t * Get the user-visible handle using idr.  Preload and perform\ndiff --git a/drivers/gpu/drm/drm_gem_framebuffer_helper.c b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\nindex 6f72e7a0f427..14a87788695d 100644\n--- a/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n+++ b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n@@ -99,7 +99,7 @@ void drm_gem_fb_destroy(struct drm_framebuffer *fb)\n \tunsigned int i;\n \n \tfor (i = 0; i < fb->format->num_planes; i++)\n-\t\tdrm_gem_object_put(fb->obj[i]);\n+\t\tdrm_gem_object_handle_put_unlocked(fb->obj[i]);\n \n \tdrm_framebuffer_cleanup(fb);\n \tkfree(fb);\n@@ -182,8 +182,10 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\tif (!objs[i]) {\n \t\t\tdrm_dbg_kms(dev, \"Failed to lookup GEM object\\n\");\n \t\t\tret = -ENOENT;\n-\t\t\tgoto err_gem_object_put;\n+\t\t\tgoto err_gem_object_handle_put_unlocked;\n \t\t}\n+\t\tdrm_gem_object_handle_get_unlocked(objs[i]);\n+\t\tdrm_gem_object_put(objs[i]);\n \n \t\tmin_size = (height - 1) * mode_cmd->pitches[i]\n \t\t\t + drm_format_info_min_pitch(info, i, width)\n@@ -193,22 +195,22 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\t\tdrm_dbg_kms(dev,\n \t\t\t\t    \"GEM object size (%zu) smaller than minimum size (%u) for plane %d\\n\",\n \t\t\t\t    objs[i]->size, min_size, i);\n-\t\t\tdrm_gem_object_put(objs[i]);\n+\t\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n \t\t\tret = -EINVAL;\n-\t\t\tgoto err_gem_object_put;\n+\t\t\tgoto err_gem_object_handle_put_unlocked;\n \t\t}\n \t}\n \n \tret = drm_gem_fb_init(dev, fb, mode_cmd, objs, i, funcs);\n \tif (ret)\n-\t\tgoto err_gem_object_put;\n+\t\tgoto err_gem_object_handle_put_unlocked;\n \n \treturn 0;\n \n-err_gem_object_put:\n+err_gem_object_handle_put_unlocked:\n \twhile (i > 0) {\n \t\t--i;\n-\t\tdrm_gem_object_put(objs[i]);\n+\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n \t}\n \treturn ret;\n }\ndiff --git a/drivers/gpu/drm/drm_internal.h b/drivers/gpu/drm/drm_internal.h\nindex e44f28fd81d3..be77d61a16ce 100644\n--- a/drivers/gpu/drm/drm_internal.h\n+++ b/drivers/gpu/drm/drm_internal.h\n@@ -161,6 +161,8 @@ void drm_sysfs_lease_event(struct drm_device *dev);\n \n /* drm_gem.c */\n int drm_gem_init(struct drm_device *dev);\n+void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj);\n+void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj);\n int drm_gem_handle_create_tail(struct drm_file *file_priv,\n \t\t\t       struct drm_gem_object *obj,\n \t\t\t       u32 *handlep);\ndiff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c\nindex e5184a0c2465..21fd647f8ce1 100644\n--- a/drivers/gpu/drm/drm_mipi_dsi.c\n+++ b/drivers/gpu/drm/drm_mipi_dsi.c\n@@ -91,12 +91,13 @@ static const struct dev_pm_ops mipi_dsi_device_pm_ops = {\n \t.restore = pm_generic_restore,\n };\n \n-static const struct bus_type mipi_dsi_bus_type = {\n+const struct bus_type mipi_dsi_bus_type = {\n \t.name = \"mipi-dsi\",\n \t.match = mipi_dsi_device_match,\n \t.uevent = mipi_dsi_uevent,\n \t.pm = &mipi_dsi_device_pm_ops,\n };\n+EXPORT_SYMBOL_GPL(mipi_dsi_bus_type);\n \n /**\n  * of_find_mipi_dsi_device_by_node() - find the MIPI DSI device matching a\ndiff --git a/drivers/gpu/drm/exynos/exynos7_drm_decon.c b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\nindex f91daefa9d2b..805aa28c1723 100644\n--- a/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n+++ b/drivers/gpu/drm/exynos/exynos7_drm_decon.c\n@@ -636,6 +636,10 @@ static irqreturn_t decon_irq_handler(int irq, void *dev_id)\n \tif (!ctx->drm_dev)\n \t\tgoto out;\n \n+\t/* check if crtc and vblank have been initialized properly */\n+\tif (!drm_dev_has_vblank(ctx->drm_dev))\n+\t\tgoto out;\n+\n \tif (!ctx->i80_if) {\n \t\tdrm_crtc_handle_vblank(&ctx->crtc->base);\n \ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_fimd.c b/drivers/gpu/drm/exynos/exynos_drm_fimd.c\nindex c394cc702d7d..205c238cc73a 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_fimd.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_fimd.c\n@@ -187,6 +187,7 @@ struct fimd_context {\n \tu32\t\t\t\ti80ifcon;\n \tbool\t\t\t\ti80_if;\n \tbool\t\t\t\tsuspended;\n+\tbool\t\t\t\tdp_clk_enabled;\n \twait_queue_head_t\t\twait_vsync_queue;\n \tatomic_t\t\t\twait_vsync_event;\n \tatomic_t\t\t\twin_updated;\n@@ -1047,7 +1048,18 @@ static void fimd_dp_clock_enable(struct exynos_drm_clk *clk, bool enable)\n \tstruct fimd_context *ctx = container_of(clk, struct fimd_context,\n \t\t\t\t\t\tdp_clk);\n \tu32 val = enable ? DP_MIE_CLK_DP_ENABLE : DP_MIE_CLK_DISABLE;\n+\n+\tif (enable == ctx->dp_clk_enabled)\n+\t\treturn;\n+\n+\tif (enable)\n+\t\tpm_runtime_resume_and_get(ctx->dev);\n+\n+\tctx->dp_clk_enabled = enable;\n \twritel(val, ctx->regs + DP_MIE_CLKCON);\n+\n+\tif (!enable)\n+\t\tpm_runtime_put(ctx->dev);\n }\n \n static const struct exynos_drm_crtc_ops fimd_crtc_ops = {\ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_gem.c b/drivers/gpu/drm/exynos/exynos_drm_gem.c\nindex 4787fee4696f..d44401a695e2 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_gem.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_gem.c\n@@ -174,7 +174,7 @@ static struct exynos_drm_gem *exynos_drm_gem_init(struct drm_device *dev,\n \t\treturn ERR_PTR(ret);\n \t}\n \n-\tDRM_DEV_DEBUG_KMS(dev->dev, \"created file object = %pK\\n\", obj->filp);\n+\tDRM_DEV_DEBUG_KMS(dev->dev, \"created file object = %p\\n\", obj->filp);\n \n \treturn exynos_gem;\n }\ndiff --git a/drivers/gpu/drm/exynos/exynos_drm_ipp.c b/drivers/gpu/drm/exynos/exynos_drm_ipp.c\nindex ea9f66037600..03c8490af4f4 100644\n--- a/drivers/gpu/drm/exynos/exynos_drm_ipp.c\n+++ b/drivers/gpu/drm/exynos/exynos_drm_ipp.c\n@@ -271,7 +271,7 @@ static inline struct exynos_drm_ipp_task *\n \ttask->src.rect.h = task->dst.rect.h = UINT_MAX;\n \ttask->transform.rotation = DRM_MODE_ROTATE_0;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Allocated task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Allocated task %p\\n\", task);\n \n \treturn task;\n }\n@@ -339,7 +339,7 @@ static int exynos_drm_ipp_task_set(struct exynos_drm_ipp_task *task,\n \t}\n \n \tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t     \"Got task %pK configuration from userspace\\n\",\n+\t\t\t     \"Got task %p configuration from userspace\\n\",\n \t\t\t     task);\n \treturn 0;\n }\n@@ -394,7 +394,7 @@ static void exynos_drm_ipp_task_release_buf(struct exynos_drm_ipp_buffer *buf)\n static void exynos_drm_ipp_task_free(struct exynos_drm_ipp *ipp,\n \t\t\t\t struct exynos_drm_ipp_task *task)\n {\n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Freeing task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Freeing task %p\\n\", task);\n \n \texynos_drm_ipp_task_release_buf(&task->src);\n \texynos_drm_ipp_task_release_buf(&task->dst);\n@@ -559,7 +559,7 @@ static int exynos_drm_ipp_check_format(struct exynos_drm_ipp_task *task,\n \t\t\t\t\t    DRM_EXYNOS_IPP_FORMAT_DESTINATION);\n \tif (!fmt) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: %s format not supported\\n\",\n+\t\t\t\t     \"Task %p: %s format not supported\\n\",\n \t\t\t\t     task, buf == src ? \"src\" : \"dst\");\n \t\treturn -EINVAL;\n \t}\n@@ -609,7 +609,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \tbool rotate = (rotation != DRM_MODE_ROTATE_0);\n \tbool scale = false;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Checking task %pK\\n\", task);\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Checking task %p\\n\", task);\n \n \tif (src->rect.w == UINT_MAX)\n \t\tsrc->rect.w = src->buf.width;\n@@ -625,7 +625,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \t    dst->rect.x + dst->rect.w > (dst->buf.width) ||\n \t    dst->rect.y + dst->rect.h > (dst->buf.height)) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: defined area is outside provided buffers\\n\",\n+\t\t\t\t     \"Task %p: defined area is outside provided buffers\\n\",\n \t\t\t\t     task);\n \t\treturn -EINVAL;\n \t}\n@@ -642,7 +642,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_SCALE) && scale) ||\n \t    (!(ipp->capabilities & DRM_EXYNOS_IPP_CAP_CONVERT) &&\n \t     src->buf.fourcc != dst->buf.fourcc)) {\n-\t\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: hw capabilities exceeded\\n\",\n+\t\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %p: hw capabilities exceeded\\n\",\n \t\t\t\t     task);\n \t\treturn -EINVAL;\n \t}\n@@ -655,7 +655,7 @@ static int exynos_drm_ipp_task_check(struct exynos_drm_ipp_task *task)\n \tif (ret)\n \t\treturn ret;\n \n-\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"Task %pK: all checks done.\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"Task %p: all checks done.\\n\",\n \t\t\t     task);\n \n \treturn ret;\n@@ -667,25 +667,25 @@ static int exynos_drm_ipp_task_setup_buffers(struct exynos_drm_ipp_task *task,\n \tstruct exynos_drm_ipp_buffer *src = &task->src, *dst = &task->dst;\n \tint ret = 0;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Setting buffer for task %pK\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Setting buffer for task %p\\n\",\n \t\t\t     task);\n \n \tret = exynos_drm_ipp_task_setup_buffer(src, filp);\n \tif (ret) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: src buffer setup failed\\n\",\n+\t\t\t\t     \"Task %p: src buffer setup failed\\n\",\n \t\t\t\t     task);\n \t\treturn ret;\n \t}\n \tret = exynos_drm_ipp_task_setup_buffer(dst, filp);\n \tif (ret) {\n \t\tDRM_DEV_DEBUG_DRIVER(task->dev,\n-\t\t\t\t     \"Task %pK: dst buffer setup failed\\n\",\n+\t\t\t\t     \"Task %p: dst buffer setup failed\\n\",\n \t\t\t\t     task);\n \t\treturn ret;\n \t}\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %pK: buffers prepared.\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"Task %p: buffers prepared.\\n\",\n \t\t\t     task);\n \n \treturn ret;\n@@ -764,7 +764,7 @@ void exynos_drm_ipp_task_done(struct exynos_drm_ipp_task *task, int ret)\n \tstruct exynos_drm_ipp *ipp = task->ipp;\n \tunsigned long flags;\n \n-\tDRM_DEV_DEBUG_DRIVER(task->dev, \"ipp: %d, task %pK done: %d\\n\",\n+\tDRM_DEV_DEBUG_DRIVER(task->dev, \"ipp: %d, task %p done: %d\\n\",\n \t\t\t     ipp->id, task, ret);\n \n \tspin_lock_irqsave(&ipp->lock, flags);\n@@ -807,7 +807,7 @@ static void exynos_drm_ipp_next_task(struct exynos_drm_ipp *ipp)\n \tspin_unlock_irqrestore(&ipp->lock, flags);\n \n \tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n-\t\t\t     \"ipp: %d, selected task %pK to run\\n\", ipp->id,\n+\t\t\t     \"ipp: %d, selected task %p to run\\n\", ipp->id,\n \t\t\t     task);\n \n \tret = ipp->funcs->commit(ipp, task);\n@@ -917,14 +917,14 @@ int exynos_drm_ipp_commit_ioctl(struct drm_device *dev, void *data,\n \t */\n \tif (arg->flags & DRM_EXYNOS_IPP_FLAG_NONBLOCK) {\n \t\tDRM_DEV_DEBUG_DRIVER(ipp->dev,\n-\t\t\t\t     \"ipp: %d, nonblocking processing task %pK\\n\",\n+\t\t\t\t     \"ipp: %d, nonblocking processing task %p\\n\",\n \t\t\t\t     ipp->id, task);\n \n \t\ttask->flags |= DRM_EXYNOS_IPP_TASK_ASYNC;\n \t\texynos_drm_ipp_schedule_task(task->ipp, task);\n \t\tret = 0;\n \t} else {\n-\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, processing task %pK\\n\",\n+\t\tDRM_DEV_DEBUG_DRIVER(ipp->dev, \"ipp: %d, processing task %p\\n\",\n \t\t\t\t     ipp->id, task);\n \t\texynos_drm_ipp_schedule_task(ipp, task);\n \t\tret = wait_event_interruptible(ipp->done_wq,\ndiff --git a/drivers/gpu/drm/i915/display/vlv_dsi.c b/drivers/gpu/drm/i915/display/vlv_dsi.c\nindex 21c1e10caf68..2007bb9d974d 100644\n--- a/drivers/gpu/drm/i915/display/vlv_dsi.c\n+++ b/drivers/gpu/drm/i915/display/vlv_dsi.c\n@@ -1589,8 +1589,8 @@ static void vlv_dsi_add_properties(struct intel_connector *connector)\n \n static void vlv_dphy_param_init(struct intel_dsi *intel_dsi)\n {\n+\tstruct intel_display *display = to_intel_display(&intel_dsi->base);\n \tstruct intel_connector *connector = intel_dsi->attached_connector;\n-\tstruct intel_display *display = to_intel_display(connector);\n \tstruct mipi_config *mipi_config = connector->panel.vbt.dsi.config;\n \tu32 tlpx_ns, extra_byte_count, tlpx_ui;\n \tu32 ui_num, ui_den;\ndiff --git a/drivers/gpu/drm/i915/gt/intel_gsc.c b/drivers/gpu/drm/i915/gt/intel_gsc.c\nindex 1e925c75fb08..c43febc862dc 100644\n--- a/drivers/gpu/drm/i915/gt/intel_gsc.c\n+++ b/drivers/gpu/drm/i915/gt/intel_gsc.c\n@@ -284,7 +284,7 @@ static void gsc_irq_handler(struct intel_gt *gt, unsigned int intf_id)\n \tif (gt->gsc.intf[intf_id].irq < 0)\n \t\treturn;\n \n-\tret = generic_handle_irq(gt->gsc.intf[intf_id].irq);\n+\tret = generic_handle_irq_safe(gt->gsc.intf[intf_id].irq);\n \tif (ret)\n \t\tgt_err_ratelimited(gt, \"error handling GSC irq: %d\\n\", ret);\n }\ndiff --git a/drivers/gpu/drm/i915/gt/intel_ring_submission.c b/drivers/gpu/drm/i915/gt/intel_ring_submission.c\nindex a876a34455f1..2a6d79abf25b 100644\n--- a/drivers/gpu/drm/i915/gt/intel_ring_submission.c\n+++ b/drivers/gpu/drm/i915/gt/intel_ring_submission.c\n@@ -610,7 +610,6 @@ static int ring_context_alloc(struct intel_context *ce)\n \t/* One ringbuffer to rule them all */\n \tGEM_BUG_ON(!engine->legacy.ring);\n \tce->ring = engine->legacy.ring;\n-\tce->timeline = intel_timeline_get(engine->legacy.timeline);\n \n \tGEM_BUG_ON(ce->state);\n \tif (engine->context_size) {\n@@ -623,6 +622,8 @@ static int ring_context_alloc(struct intel_context *ce)\n \t\tce->state = vma;\n \t}\n \n+\tce->timeline = intel_timeline_get(engine->legacy.timeline);\n+\n \treturn 0;\n }\n \ndiff --git a/drivers/gpu/drm/i915/selftests/i915_request.c b/drivers/gpu/drm/i915/selftests/i915_request.c\nindex 88870844b5bd..2fb7a9e7efec 100644\n--- a/drivers/gpu/drm/i915/selftests/i915_request.c\n+++ b/drivers/gpu/drm/i915/selftests/i915_request.c\n@@ -73,8 +73,8 @@ static int igt_add_request(void *arg)\n \t/* Basic preliminary test to create a request and let it loose! */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, HZ / 10);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_add(request);\n \n@@ -91,8 +91,8 @@ static int igt_wait_request(void *arg)\n \t/* Submit a request, then wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \ti915_request_get(request);\n \n@@ -160,8 +160,8 @@ static int igt_fence_wait(void *arg)\n \t/* Submit a request, treat it as a fence and wait upon it */\n \n \trequest = mock_request(rcs0(i915)->kernel_context, T);\n-\tif (!request)\n-\t\treturn -ENOMEM;\n+\tif (IS_ERR(request))\n+\t\treturn PTR_ERR(request);\n \n \tif (dma_fence_wait_timeout(&request->fence, false, T) != -ETIME) {\n \t\tpr_err(\"fence wait success before submit (expected timeout)!\\n\");\n@@ -219,8 +219,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \trequest = mock_request(ce, 2 * HZ);\n \tintel_context_put(ce);\n-\tif (!request) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(request)) {\n+\t\terr = PTR_ERR(request);\n \t\tgoto err_context_0;\n \t}\n \n@@ -237,8 +237,8 @@ static int igt_request_rewind(void *arg)\n \tGEM_BUG_ON(IS_ERR(ce));\n \tvip = mock_request(ce, 0);\n \tintel_context_put(ce);\n-\tif (!vip) {\n-\t\terr = -ENOMEM;\n+\tif (IS_ERR(vip)) {\n+\t\terr = PTR_ERR(vip);\n \t\tgoto err_context_1;\n \t}\n \ndiff --git a/drivers/gpu/drm/i915/selftests/mock_request.c b/drivers/gpu/drm/i915/selftests/mock_request.c\nindex 09f747228dff..1b0cf073e964 100644\n--- a/drivers/gpu/drm/i915/selftests/mock_request.c\n+++ b/drivers/gpu/drm/i915/selftests/mock_request.c\n@@ -35,7 +35,7 @@ mock_request(struct intel_context *ce, unsigned long delay)\n \t/* NB the i915->requests slab cache is enlarged to fit mock_request */\n \trequest = intel_context_create_request(ce);\n \tif (IS_ERR(request))\n-\t\treturn NULL;\n+\t\treturn request;\n \n \trequest->mock.delay = delay;\n \treturn request;\ndiff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c\nindex 0a3b26bb4d73..9f81fa960b46 100644\n--- a/drivers/gpu/drm/panel/panel-simple.c\n+++ b/drivers/gpu/drm/panel/panel-simple.c\n@@ -26,6 +26,7 @@\n #include <linux/i2c.h>\n #include <linux/media-bus-format.h>\n #include <linux/module.h>\n+#include <linux/of_device.h>\n #include <linux/of_platform.h>\n #include <linux/platform_device.h>\n #include <linux/pm_runtime.h>\n@@ -136,6 +137,14 @@ struct panel_desc {\n \tint connector_type;\n };\n \n+struct panel_desc_dsi {\n+\tstruct panel_desc desc;\n+\n+\tunsigned long flags;\n+\tenum mipi_dsi_pixel_format format;\n+\tunsigned int lanes;\n+};\n+\n struct panel_simple {\n \tstruct drm_panel base;\n \n@@ -430,10 +439,7 @@ static const struct drm_panel_funcs panel_simple_funcs = {\n \t.get_timings = panel_simple_get_timings,\n };\n \n-static struct panel_desc panel_dpi;\n-\n-static int panel_dpi_probe(struct device *dev,\n-\t\t\t   struct panel_simple *panel)\n+static struct panel_desc *panel_dpi_probe(struct device *dev)\n {\n \tstruct display_timing *timing;\n \tconst struct device_node *np;\n@@ -445,17 +451,17 @@ static int panel_dpi_probe(struct device *dev,\n \tnp = dev->of_node;\n \tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n \tif (!desc)\n-\t\treturn -ENOMEM;\n+\t\treturn ERR_PTR(-ENOMEM);\n \n \ttiming = devm_kzalloc(dev, sizeof(*timing), GFP_KERNEL);\n \tif (!timing)\n-\t\treturn -ENOMEM;\n+\t\treturn ERR_PTR(-ENOMEM);\n \n \tret = of_get_display_timing(np, \"panel-timing\", timing);\n \tif (ret < 0) {\n \t\tdev_err(dev, \"%pOF: no panel-timing node found for \\\"panel-dpi\\\" binding\\n\",\n \t\t\tnp);\n-\t\treturn ret;\n+\t\treturn ERR_PTR(ret);\n \t}\n \n \tdesc->timings = timing;\n@@ -473,9 +479,7 @@ static int panel_dpi_probe(struct device *dev,\n \t/* We do not know the connector for the DT node, so guess it */\n \tdesc->connector_type = DRM_MODE_CONNECTOR_DPI;\n \n-\tpanel->desc = desc;\n-\n-\treturn 0;\n+\treturn desc;\n }\n \n #define PANEL_SIMPLE_BOUNDS_CHECK(to_check, bounds, field) \\\n@@ -570,8 +574,44 @@ static int panel_simple_override_nondefault_lvds_datamapping(struct device *dev,\n \treturn 0;\n }\n \n-static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n+static const struct panel_desc *panel_simple_get_desc(struct device *dev)\n {\n+\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI) &&\n+\t    dev_is_mipi_dsi(dev)) {\n+\t\tconst struct panel_desc_dsi *dsi_desc;\n+\n+\t\tdsi_desc = of_device_get_match_data(dev);\n+\t\tif (!dsi_desc)\n+\t\t\treturn ERR_PTR(-ENODEV);\n+\n+\t\treturn &dsi_desc->desc;\n+\t}\n+\n+\tif (dev_is_platform(dev)) {\n+\t\tconst struct panel_desc *desc;\n+\n+\t\tdesc = of_device_get_match_data(dev);\n+\t\tif (!desc) {\n+\t\t\t/*\n+\t\t\t * panel-dpi probes without a descriptor and\n+\t\t\t * panel_dpi_probe() will initialize one for us\n+\t\t\t * based on the device tree.\n+\t\t\t */\n+\t\t\tif (of_device_is_compatible(dev->of_node, \"panel-dpi\"))\n+\t\t\t\treturn panel_dpi_probe(dev);\n+\t\t\telse\n+\t\t\t\treturn ERR_PTR(-ENODEV);\n+\t\t}\n+\n+\t\treturn desc;\n+\t}\n+\n+\treturn ERR_PTR(-ENODEV);\n+}\n+\n+static struct panel_simple *panel_simple_probe(struct device *dev)\n+{\n+\tconst struct panel_desc *desc;\n \tstruct panel_simple *panel;\n \tstruct display_timing dt;\n \tstruct device_node *ddc;\n@@ -579,27 +619,31 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \tu32 bus_flags;\n \tint err;\n \n+\tdesc = panel_simple_get_desc(dev);\n+\tif (IS_ERR(desc))\n+\t\treturn ERR_CAST(desc);\n+\n \tpanel = devm_drm_panel_alloc(dev, struct panel_simple, base,\n \t\t\t\t     &panel_simple_funcs, desc->connector_type);\n \tif (IS_ERR(panel))\n-\t\treturn PTR_ERR(panel);\n+\t\treturn ERR_CAST(panel);\n \n \tpanel->desc = desc;\n \n \tpanel->supply = devm_regulator_get(dev, \"power\");\n \tif (IS_ERR(panel->supply))\n-\t\treturn PTR_ERR(panel->supply);\n+\t\treturn ERR_CAST(panel->supply);\n \n \tpanel->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n \t\t\t\t\t\t     GPIOD_OUT_LOW);\n \tif (IS_ERR(panel->enable_gpio))\n-\t\treturn dev_err_probe(dev, PTR_ERR(panel->enable_gpio),\n-\t\t\t\t     \"failed to request GPIO\\n\");\n+\t\treturn dev_err_cast_probe(dev, panel->enable_gpio,\n+\t\t\t\t\t  \"failed to request GPIO\\n\");\n \n \terr = of_drm_get_panel_orientation(dev->of_node, &panel->orientation);\n \tif (err) {\n \t\tdev_err(dev, \"%pOF: failed to get orientation %d\\n\", dev->of_node, err);\n-\t\treturn err;\n+\t\treturn ERR_PTR(err);\n \t}\n \n \tddc = of_parse_phandle(dev->of_node, \"ddc-i2c-bus\", 0);\n@@ -608,19 +652,12 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \t\tof_node_put(ddc);\n \n \t\tif (!panel->ddc)\n-\t\t\treturn -EPROBE_DEFER;\n+\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n \t}\n \n-\tif (desc == &panel_dpi) {\n-\t\t/* Handle the generic panel-dpi binding */\n-\t\terr = panel_dpi_probe(dev, panel);\n-\t\tif (err)\n-\t\t\tgoto free_ddc;\n-\t\tdesc = panel->desc;\n-\t} else {\n-\t\tif (!of_get_display_timing(dev->of_node, \"panel-timing\", &dt))\n-\t\t\tpanel_simple_parse_panel_timing_node(dev, panel, &dt);\n-\t}\n+\tif (!of_device_is_compatible(dev->of_node, \"panel-dpi\") &&\n+\t    !of_get_display_timing(dev->of_node, \"panel-timing\", &dt))\n+\t\tpanel_simple_parse_panel_timing_node(dev, panel, &dt);\n \n \tif (desc->connector_type == DRM_MODE_CONNECTOR_LVDS) {\n \t\t/* Optional data-mapping property for overriding bus format */\n@@ -703,7 +740,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \n \tdrm_panel_add(&panel->base);\n \n-\treturn 0;\n+\treturn panel;\n \n disable_pm_runtime:\n \tpm_runtime_dont_use_autosuspend(dev);\n@@ -712,7 +749,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)\n \tif (panel->ddc)\n \t\tput_device(&panel->ddc->dev);\n \n-\treturn err;\n+\treturn ERR_PTR(err);\n }\n \n static void panel_simple_shutdown(struct device *dev)\n@@ -5367,7 +5404,12 @@ static const struct of_device_id platform_of_match[] = {\n \t}, {\n \t\t/* Must be the last entry */\n \t\t.compatible = \"panel-dpi\",\n-\t\t.data = &panel_dpi,\n+\n+\t\t/*\n+\t\t * Explicitly NULL, the panel_desc structure will be\n+\t\t * allocated by panel_dpi_probe().\n+\t\t */\n+\t\t.data = NULL,\n \t}, {\n \t\t/* sentinel */\n \t}\n@@ -5376,13 +5418,13 @@ MODULE_DEVICE_TABLE(of, platform_of_match);\n \n static int panel_simple_platform_probe(struct platform_device *pdev)\n {\n-\tconst struct panel_desc *desc;\n+\tstruct panel_simple *panel;\n \n-\tdesc = of_device_get_match_data(&pdev->dev);\n-\tif (!desc)\n-\t\treturn -ENODEV;\n+\tpanel = panel_simple_probe(&pdev->dev);\n+\tif (IS_ERR(panel))\n+\t\treturn PTR_ERR(panel);\n \n-\treturn panel_simple_probe(&pdev->dev, desc);\n+\treturn 0;\n }\n \n static void panel_simple_platform_remove(struct platform_device *pdev)\n@@ -5412,14 +5454,6 @@ static struct platform_driver panel_simple_platform_driver = {\n \t.shutdown = panel_simple_platform_shutdown,\n };\n \n-struct panel_desc_dsi {\n-\tstruct panel_desc desc;\n-\n-\tunsigned long flags;\n-\tenum mipi_dsi_pixel_format format;\n-\tunsigned int lanes;\n-};\n-\n static const struct drm_display_mode auo_b080uan01_mode = {\n \t.clock = 154500,\n \t.hdisplay = 1200,\n@@ -5653,16 +5687,14 @@ MODULE_DEVICE_TABLE(of, dsi_of_match);\n static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)\n {\n \tconst struct panel_desc_dsi *desc;\n+\tstruct panel_simple *panel;\n \tint err;\n \n-\tdesc = of_device_get_match_data(&dsi->dev);\n-\tif (!desc)\n-\t\treturn -ENODEV;\n-\n-\terr = panel_simple_probe(&dsi->dev, &desc->desc);\n-\tif (err < 0)\n-\t\treturn err;\n+\tpanel = panel_simple_probe(&dsi->dev);\n+\tif (IS_ERR(panel))\n+\t\treturn PTR_ERR(panel);\n \n+\tdesc = container_of(panel->desc, struct panel_desc_dsi, desc);\n \tdsi->mode_flags = desc->flags;\n \tdsi->format = desc->format;\n \tdsi->lanes = desc->lanes;\ndiff --git a/drivers/gpu/drm/sysfb/vesadrm.c b/drivers/gpu/drm/sysfb/vesadrm.c\nindex 4d62c78e7d1e..f7532db3831f 100644\n--- a/drivers/gpu/drm/sysfb/vesadrm.c\n+++ b/drivers/gpu/drm/sysfb/vesadrm.c\n@@ -362,14 +362,19 @@ static struct vesadrm_device *vesadrm_device_create(struct drm_driver *drv,\n \n \tif (!__screen_info_vbe_mode_nonvga(si)) {\n \t\tvesa->cmap_write = vesadrm_vga_cmap_write;\n-#if defined(CONFIG_X86_32)\n \t} else {\n+#if defined(CONFIG_X86_32)\n \t\tphys_addr_t pmi_base = __screen_info_vesapm_info_base(si);\n-\t\tconst u16 *pmi_addr = phys_to_virt(pmi_base);\n \n-\t\tvesa->pmi.PrimaryPalette = (u8 *)pmi_addr + pmi_addr[2];\n-\t\tvesa->cmap_write = vesadrm_pmi_cmap_write;\n+\t\tif (pmi_base) {\n+\t\t\tconst u16 *pmi_addr = phys_to_virt(pmi_base);\n+\n+\t\t\tvesa->pmi.PrimaryPalette = (u8 *)pmi_addr + pmi_addr[2];\n+\t\t\tvesa->cmap_write = vesadrm_pmi_cmap_write;\n+\t\t} else\n #endif\n+\t\tif (format->is_color_indexed)\n+\t\t\tdrm_warn(dev, \"hardware palette is unchangeable, colors may be incorrect\\n\");\n \t}\n \n #ifdef CONFIG_X86\ndiff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c\nindex 15cab9bda17f..bd90404ea609 100644\n--- a/drivers/gpu/drm/ttm/ttm_bo_util.c\n+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c\n@@ -254,6 +254,13 @@ static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,\n \tret = dma_resv_trylock(&fbo->base.base._resv);\n \tWARN_ON(!ret);\n \n+\tret = dma_resv_reserve_fences(&fbo->base.base._resv, 1);\n+\tif (ret) {\n+\t\tdma_resv_unlock(&fbo->base.base._resv);\n+\t\tkfree(fbo);\n+\t\treturn ret;\n+\t}\n+\n \tif (fbo->base.resource) {\n \t\tttm_resource_set_bo(fbo->base.resource, &fbo->base);\n \t\tbo->resource = NULL;\n@@ -262,12 +269,6 @@ static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,\n \t\tfbo->base.bulk_move = NULL;\n \t}\n \n-\tret = dma_resv_reserve_fences(&fbo->base.base._resv, 1);\n-\tif (ret) {\n-\t\tkfree(fbo);\n-\t\treturn ret;\n-\t}\n-\n \tttm_bo_get(bo);\n \tfbo->bo = bo;\n \ndiff --git a/drivers/gpu/drm/v3d/v3d_drv.h b/drivers/gpu/drm/v3d/v3d_drv.h\nindex b51f0b648a08..411e47702f8a 100644\n--- a/drivers/gpu/drm/v3d/v3d_drv.h\n+++ b/drivers/gpu/drm/v3d/v3d_drv.h\n@@ -101,6 +101,12 @@ enum v3d_gen {\n \tV3D_GEN_71 = 71,\n };\n \n+enum v3d_irq {\n+\tV3D_CORE_IRQ,\n+\tV3D_HUB_IRQ,\n+\tV3D_MAX_IRQS,\n+};\n+\n struct v3d_dev {\n \tstruct drm_device drm;\n \n@@ -112,6 +118,8 @@ struct v3d_dev {\n \n \tbool single_irq_line;\n \n+\tint irq[V3D_MAX_IRQS];\n+\n \tstruct v3d_perfmon_info perfmon_info;\n \n \tvoid __iomem *hub_regs;\ndiff --git a/drivers/gpu/drm/v3d/v3d_gem.c b/drivers/gpu/drm/v3d/v3d_gem.c\nindex d7d16da78db3..37bf5eecdd2c 100644\n--- a/drivers/gpu/drm/v3d/v3d_gem.c\n+++ b/drivers/gpu/drm/v3d/v3d_gem.c\n@@ -134,6 +134,8 @@ v3d_reset(struct v3d_dev *v3d)\n \tif (false)\n \t\tv3d_idle_axi(v3d, 0);\n \n+\tv3d_irq_disable(v3d);\n+\n \tv3d_idle_gca(v3d);\n \tv3d_reset_sms(v3d);\n \tv3d_reset_v3d(v3d);\ndiff --git a/drivers/gpu/drm/v3d/v3d_irq.c b/drivers/gpu/drm/v3d/v3d_irq.c\nindex 2cca5d3a26a2..a515a301e480 100644\n--- a/drivers/gpu/drm/v3d/v3d_irq.c\n+++ b/drivers/gpu/drm/v3d/v3d_irq.c\n@@ -260,7 +260,7 @@ v3d_hub_irq(int irq, void *arg)\n int\n v3d_irq_init(struct v3d_dev *v3d)\n {\n-\tint irq1, ret, core;\n+\tint irq, ret, core;\n \n \tINIT_WORK(&v3d->overflow_mem_work, v3d_overflow_mem_work);\n \n@@ -271,17 +271,24 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));\n \tV3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS(v3d->ver));\n \n-\tirq1 = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n-\tif (irq1 == -EPROBE_DEFER)\n-\t\treturn irq1;\n-\tif (irq1 > 0) {\n-\t\tret = devm_request_irq(v3d->drm.dev, irq1,\n+\tirq = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n+\tif (irq == -EPROBE_DEFER)\n+\t\treturn irq;\n+\tif (irq > 0) {\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_core0\", v3d);\n \t\tif (ret)\n \t\t\tgoto fail;\n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_HUB_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_HUB_IRQ],\n \t\t\t\t       v3d_hub_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d_hub\", v3d);\n \t\tif (ret)\n@@ -289,8 +296,12 @@ v3d_irq_init(struct v3d_dev *v3d)\n \t} else {\n \t\tv3d->single_irq_line = true;\n \n-\t\tret = devm_request_irq(v3d->drm.dev,\n-\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n+\t\tirq = platform_get_irq(v3d_to_pdev(v3d), 0);\n+\t\tif (irq < 0)\n+\t\t\treturn irq;\n+\t\tv3d->irq[V3D_CORE_IRQ] = irq;\n+\n+\t\tret = devm_request_irq(v3d->drm.dev, v3d->irq[V3D_CORE_IRQ],\n \t\t\t\t       v3d_irq, IRQF_SHARED,\n \t\t\t\t       \"v3d\", v3d);\n \t\tif (ret)\n@@ -331,6 +342,12 @@ v3d_irq_disable(struct v3d_dev *v3d)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~0);\n \tV3D_WRITE(V3D_HUB_INT_MSK_SET, ~0);\n \n+\t/* Finish any interrupt handler still in flight. */\n+\tfor (int i = 0; i < V3D_MAX_IRQS; i++) {\n+\t\tif (v3d->irq[i])\n+\t\t\tsynchronize_irq(v3d->irq[i]);\n+\t}\n+\n \t/* Clear any pending interrupts we might have left. */\n \tfor (core = 0; core < v3d->cores; core++)\n \t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS(v3d->ver));\ndiff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\nindex 0695a342b1ef..5205552b1970 100644\n--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\n+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c\n@@ -749,7 +749,7 @@ static int vmw_setup_pci_resources(struct vmw_private *dev,\n \t\tdev->fifo_mem = devm_memremap(dev->drm.dev,\n \t\t\t\t\t      fifo_start,\n \t\t\t\t\t      fifo_size,\n-\t\t\t\t\t      MEMREMAP_WB);\n+\t\t\t\t\t      MEMREMAP_WB | MEMREMAP_DEC);\n \n \t\tif (IS_ERR(dev->fifo_mem)) {\n \t\t\tdrm_err(&dev->drm,\ndiff --git a/drivers/gpu/drm/xe/Kconfig b/drivers/gpu/drm/xe/Kconfig\nindex fcc2677a4229..99a91355842e 100644\n--- a/drivers/gpu/drm/xe/Kconfig\n+++ b/drivers/gpu/drm/xe/Kconfig\n@@ -1,7 +1,8 @@\n # SPDX-License-Identifier: GPL-2.0-only\n config DRM_XE\n-\ttristate \"Intel Xe Graphics\"\n-\tdepends on DRM && PCI && (m || (y && KUNIT=y))\n+\ttristate \"Intel Xe2 Graphics\"\n+\tdepends on DRM && PCI\n+\tdepends on KUNIT || !KUNIT\n \tdepends on INTEL_VSEC || !INTEL_VSEC\n \tdepends on X86_PLATFORM_DEVICES || !(X86 && ACPI)\n \tselect INTERVAL_TREE\n@@ -46,7 +47,8 @@ config DRM_XE\n \tselect AUXILIARY_BUS\n \tselect HMM_MIRROR\n \thelp\n-\t  Experimental driver for Intel Xe series GPUs\n+\t  Driver for Intel Xe2 series GPUs and later. Experimental support\n+\t  for Xe series is also available.\n \n \t  If \"M\" is selected, the module will be called xe.\n \ndiff --git a/drivers/gpu/drm/xe/xe_device.c b/drivers/gpu/drm/xe/xe_device.c\nindex c02c4c4e9412..e9f3c1a53db2 100644\n--- a/drivers/gpu/drm/xe/xe_device.c\n+++ b/drivers/gpu/drm/xe/xe_device.c\n@@ -40,6 +40,7 @@\n #include \"xe_gt_printk.h\"\n #include \"xe_gt_sriov_vf.h\"\n #include \"xe_guc.h\"\n+#include \"xe_guc_pc.h\"\n #include \"xe_hw_engine_group.h\"\n #include \"xe_hwmon.h\"\n #include \"xe_irq.h\"\n@@ -986,38 +987,15 @@ void xe_device_wmb(struct xe_device *xe)\n \t\txe_mmio_write32(xe_root_tile_mmio(xe), VF_CAP_REG, 0);\n }\n \n-/**\n- * xe_device_td_flush() - Flush transient L3 cache entries\n- * @xe: The device\n- *\n- * Display engine has direct access to memory and is never coherent with L3/L4\n- * caches (or CPU caches), however KMD is responsible for specifically flushing\n- * transient L3 GPU cache entries prior to the flip sequence to ensure scanout\n- * can happen from such a surface without seeing corruption.\n- *\n- * Display surfaces can be tagged as transient by mapping it using one of the\n- * various L3:XD PAT index modes on Xe2.\n- *\n- * Note: On non-discrete xe2 platforms, like LNL, the entire L3 cache is flushed\n- * at the end of each submission via PIPE_CONTROL for compute/render, since SA\n- * Media is not coherent with L3 and we want to support render-vs-media\n- * usescases. For other engines like copy/blt the HW internally forces uncached\n- * behaviour, hence why we can skip the TDF on such platforms.\n+/*\n+ * Issue a TRANSIENT_FLUSH_REQUEST and wait for completion on each gt.\n  */\n-void xe_device_td_flush(struct xe_device *xe)\n+static void tdf_request_sync(struct xe_device *xe)\n {\n-\tstruct xe_gt *gt;\n \tunsigned int fw_ref;\n+\tstruct xe_gt *gt;\n \tu8 id;\n \n-\tif (!IS_DGFX(xe) || GRAPHICS_VER(xe) < 20)\n-\t\treturn;\n-\n-\tif (XE_WA(xe_root_mmio_gt(xe), 16023588340)) {\n-\t\txe_device_l2_flush(xe);\n-\t\treturn;\n-\t}\n-\n \tfor_each_gt(gt, xe, id) {\n \t\tif (xe_gt_is_media_type(gt))\n \t\t\tcontinue;\n@@ -1027,6 +1005,7 @@ void xe_device_td_flush(struct xe_device *xe)\n \t\t\treturn;\n \n \t\txe_mmio_write32(&gt->mmio, XE2_TDF_CTRL, TRANSIENT_FLUSH_REQUEST);\n+\n \t\t/*\n \t\t * FIXME: We can likely do better here with our choice of\n \t\t * timeout. Currently we just assume the worst case, i.e. 150us,\n@@ -1057,15 +1036,52 @@ void xe_device_l2_flush(struct xe_device *xe)\n \t\treturn;\n \n \tspin_lock(&gt->global_invl_lock);\n-\txe_mmio_write32(&gt->mmio, XE2_GLOBAL_INVAL, 0x1);\n \n+\txe_mmio_write32(&gt->mmio, XE2_GLOBAL_INVAL, 0x1);\n \tif (xe_mmio_wait32(&gt->mmio, XE2_GLOBAL_INVAL, 0x1, 0x0, 500, NULL, true))\n \t\txe_gt_err_once(gt, \"Global invalidation timeout\\n\");\n+\n \tspin_unlock(&gt->global_invl_lock);\n \n \txe_force_wake_put(gt_to_fw(gt), fw_ref);\n }\n \n+/**\n+ * xe_device_td_flush() - Flush transient L3 cache entries\n+ * @xe: The device\n+ *\n+ * Display engine has direct access to memory and is never coherent with L3/L4\n+ * caches (or CPU caches), however KMD is responsible for specifically flushing\n+ * transient L3 GPU cache entries prior to the flip sequence to ensure scanout\n+ * can happen from such a surface without seeing corruption.\n+ *\n+ * Display surfaces can be tagged as transient by mapping it using one of the\n+ * various L3:XD PAT index modes on Xe2.\n+ *\n+ * Note: On non-discrete xe2 platforms, like LNL, the entire L3 cache is flushed\n+ * at the end of each submission via PIPE_CONTROL for compute/render, since SA\n+ * Media is not coherent with L3 and we want to support render-vs-media\n+ * usescases. For other engines like copy/blt the HW internally forces uncached\n+ * behaviour, hence why we can skip the TDF on such platforms.\n+ */\n+void xe_device_td_flush(struct xe_device *xe)\n+{\n+\tstruct xe_gt *root_gt;\n+\n+\tif (!IS_DGFX(xe) || GRAPHICS_VER(xe) < 20)\n+\t\treturn;\n+\n+\troot_gt = xe_root_mmio_gt(xe);\n+\tif (XE_WA(root_gt, 16023588340)) {\n+\t\t/* A transient flush is not sufficient: flush the L2 */\n+\t\txe_device_l2_flush(xe);\n+\t} else {\n+\t\txe_guc_pc_apply_flush_freq_limit(&root_gt->uc.guc.pc);\n+\t\ttdf_request_sync(xe);\n+\t\txe_guc_pc_remove_flush_freq_limit(&root_gt->uc.guc.pc);\n+\t}\n+}\n+\n u32 xe_device_ccs_bytes(struct xe_device *xe, u64 size)\n {\n \treturn xe_device_has_flat_ccs(xe) ?\ndiff --git a/drivers/gpu/drm/xe/xe_drv.h b/drivers/gpu/drm/xe/xe_drv.h\nindex d61650d4aa0b..95242a375e54 100644\n--- a/drivers/gpu/drm/xe/xe_drv.h\n+++ b/drivers/gpu/drm/xe/xe_drv.h\n@@ -9,7 +9,7 @@\n #include <drm/drm_drv.h>\n \n #define DRIVER_NAME\t\t\"xe\"\n-#define DRIVER_DESC\t\t\"Intel Xe Graphics\"\n+#define DRIVER_DESC\t\t\"Intel Xe2 Graphics\"\n \n /* Interface history:\n  *\ndiff --git a/drivers/gpu/drm/xe/xe_guc_pc.c b/drivers/gpu/drm/xe/xe_guc_pc.c\nindex 3beaaa7b25c1..c0ca61695d76 100644\n--- a/drivers/gpu/drm/xe/xe_guc_pc.c\n+++ b/drivers/gpu/drm/xe/xe_guc_pc.c\n@@ -5,8 +5,11 @@\n \n #include \"xe_guc_pc.h\"\n \n+#include <linux/cleanup.h>\n #include <linux/delay.h>\n+#include <linux/jiffies.h>\n #include <linux/ktime.h>\n+#include <linux/wait_bit.h>\n \n #include <drm/drm_managed.h>\n #include <drm/drm_print.h>\n@@ -51,9 +54,12 @@\n \n #define LNL_MERT_FREQ_CAP\t800\n #define BMG_MERT_FREQ_CAP\t2133\n+#define BMG_MIN_FREQ\t\t1200\n+#define BMG_MERT_FLUSH_FREQ_CAP\t2600\n \n #define SLPC_RESET_TIMEOUT_MS 5 /* roughly 5ms, but no need for precision */\n #define SLPC_RESET_EXTENDED_TIMEOUT_MS 1000 /* To be used only at pc_start */\n+#define SLPC_ACT_FREQ_TIMEOUT_MS 100\n \n /**\n  * DOC: GuC Power Conservation (PC)\n@@ -141,6 +147,36 @@ static int wait_for_pc_state(struct xe_guc_pc *pc,\n \treturn -ETIMEDOUT;\n }\n \n+static int wait_for_flush_complete(struct xe_guc_pc *pc)\n+{\n+\tconst unsigned long timeout = msecs_to_jiffies(30);\n+\n+\tif (!wait_var_event_timeout(&pc->flush_freq_limit,\n+\t\t\t\t    !atomic_read(&pc->flush_freq_limit),\n+\t\t\t\t    timeout))\n+\t\treturn -ETIMEDOUT;\n+\n+\treturn 0;\n+}\n+\n+static int wait_for_act_freq_limit(struct xe_guc_pc *pc, u32 freq)\n+{\n+\tint timeout_us = SLPC_ACT_FREQ_TIMEOUT_MS * USEC_PER_MSEC;\n+\tint slept, wait = 10;\n+\n+\tfor (slept = 0; slept < timeout_us;) {\n+\t\tif (xe_guc_pc_get_act_freq(pc) <= freq)\n+\t\t\treturn 0;\n+\n+\t\tusleep_range(wait, wait << 1);\n+\t\tslept += wait;\n+\t\twait <<= 1;\n+\t\tif (slept + wait > timeout_us)\n+\t\t\twait = timeout_us - slept;\n+\t}\n+\n+\treturn -ETIMEDOUT;\n+}\n static int pc_action_reset(struct xe_guc_pc *pc)\n {\n \tstruct xe_guc_ct *ct = pc_to_ct(pc);\n@@ -553,6 +589,25 @@ u32 xe_guc_pc_get_rpn_freq(struct xe_guc_pc *pc)\n \treturn pc->rpn_freq;\n }\n \n+static int xe_guc_pc_get_min_freq_locked(struct xe_guc_pc *pc, u32 *freq)\n+{\n+\tint ret;\n+\n+\tlockdep_assert_held(&pc->freq_lock);\n+\n+\t/* Might be in the middle of a gt reset */\n+\tif (!pc->freq_ready)\n+\t\treturn -EAGAIN;\n+\n+\tret = pc_action_query_task_state(pc);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\t*freq = pc_get_min_freq(pc);\n+\n+\treturn 0;\n+}\n+\n /**\n  * xe_guc_pc_get_min_freq - Get the min operational frequency\n  * @pc: The GuC PC\n@@ -562,27 +617,29 @@ u32 xe_guc_pc_get_rpn_freq(struct xe_guc_pc *pc)\n  *         -EAGAIN if GuC PC not ready (likely in middle of a reset).\n  */\n int xe_guc_pc_get_min_freq(struct xe_guc_pc *pc, u32 *freq)\n+{\n+\tguard(mutex)(&pc->freq_lock);\n+\n+\treturn xe_guc_pc_get_min_freq_locked(pc, freq);\n+}\n+\n+static int xe_guc_pc_set_min_freq_locked(struct xe_guc_pc *pc, u32 freq)\n {\n \tint ret;\n \n-\txe_device_assert_mem_access(pc_to_xe(pc));\n+\tlockdep_assert_held(&pc->freq_lock);\n \n-\tmutex_lock(&pc->freq_lock);\n-\tif (!pc->freq_ready) {\n-\t\t/* Might be in the middle of a gt reset */\n-\t\tret = -EAGAIN;\n-\t\tgoto out;\n-\t}\n+\t/* Might be in the middle of a gt reset */\n+\tif (!pc->freq_ready)\n+\t\treturn -EAGAIN;\n \n-\tret = pc_action_query_task_state(pc);\n+\tret = pc_set_min_freq(pc, freq);\n \tif (ret)\n-\t\tgoto out;\n+\t\treturn ret;\n \n-\t*freq = pc_get_min_freq(pc);\n+\tpc->user_requested_min = freq;\n \n-out:\n-\tmutex_unlock(&pc->freq_lock);\n-\treturn ret;\n+\treturn 0;\n }\n \n /**\n@@ -595,25 +652,29 @@ int xe_guc_pc_get_min_freq(struct xe_guc_pc *pc, u32 *freq)\n  *         -EINVAL if value out of bounds.\n  */\n int xe_guc_pc_set_min_freq(struct xe_guc_pc *pc, u32 freq)\n+{\n+\tguard(mutex)(&pc->freq_lock);\n+\n+\treturn xe_guc_pc_set_min_freq_locked(pc, freq);\n+}\n+\n+static int xe_guc_pc_get_max_freq_locked(struct xe_guc_pc *pc, u32 *freq)\n {\n \tint ret;\n \n-\tmutex_lock(&pc->freq_lock);\n-\tif (!pc->freq_ready) {\n-\t\t/* Might be in the middle of a gt reset */\n-\t\tret = -EAGAIN;\n-\t\tgoto out;\n-\t}\n+\tlockdep_assert_held(&pc->freq_lock);\n \n-\tret = pc_set_min_freq(pc, freq);\n+\t/* Might be in the middle of a gt reset */\n+\tif (!pc->freq_ready)\n+\t\treturn -EAGAIN;\n+\n+\tret = pc_action_query_task_state(pc);\n \tif (ret)\n-\t\tgoto out;\n+\t\treturn ret;\n \n-\tpc->user_requested_min = freq;\n+\t*freq = pc_get_max_freq(pc);\n \n-out:\n-\tmutex_unlock(&pc->freq_lock);\n-\treturn ret;\n+\treturn 0;\n }\n \n /**\n@@ -625,25 +686,29 @@ int xe_guc_pc_set_min_freq(struct xe_guc_pc *pc, u32 freq)\n  *         -EAGAIN if GuC PC not ready (likely in middle of a reset).\n  */\n int xe_guc_pc_get_max_freq(struct xe_guc_pc *pc, u32 *freq)\n+{\n+\tguard(mutex)(&pc->freq_lock);\n+\n+\treturn xe_guc_pc_get_max_freq_locked(pc, freq);\n+}\n+\n+static int xe_guc_pc_set_max_freq_locked(struct xe_guc_pc *pc, u32 freq)\n {\n \tint ret;\n \n-\tmutex_lock(&pc->freq_lock);\n-\tif (!pc->freq_ready) {\n-\t\t/* Might be in the middle of a gt reset */\n-\t\tret = -EAGAIN;\n-\t\tgoto out;\n-\t}\n+\tlockdep_assert_held(&pc->freq_lock);\n \n-\tret = pc_action_query_task_state(pc);\n+\t/* Might be in the middle of a gt reset */\n+\tif (!pc->freq_ready)\n+\t\treturn -EAGAIN;\n+\n+\tret = pc_set_max_freq(pc, freq);\n \tif (ret)\n-\t\tgoto out;\n+\t\treturn ret;\n \n-\t*freq = pc_get_max_freq(pc);\n+\tpc->user_requested_max = freq;\n \n-out:\n-\tmutex_unlock(&pc->freq_lock);\n-\treturn ret;\n+\treturn 0;\n }\n \n /**\n@@ -657,24 +722,14 @@ int xe_guc_pc_get_max_freq(struct xe_guc_pc *pc, u32 *freq)\n  */\n int xe_guc_pc_set_max_freq(struct xe_guc_pc *pc, u32 freq)\n {\n-\tint ret;\n-\n-\tmutex_lock(&pc->freq_lock);\n-\tif (!pc->freq_ready) {\n-\t\t/* Might be in the middle of a gt reset */\n-\t\tret = -EAGAIN;\n-\t\tgoto out;\n+\tif (XE_WA(pc_to_gt(pc), 22019338487)) {\n+\t\tif (wait_for_flush_complete(pc) != 0)\n+\t\t\treturn -EAGAIN;\n \t}\n \n-\tret = pc_set_max_freq(pc, freq);\n-\tif (ret)\n-\t\tgoto out;\n-\n-\tpc->user_requested_max = freq;\n+\tguard(mutex)(&pc->freq_lock);\n \n-out:\n-\tmutex_unlock(&pc->freq_lock);\n-\treturn ret;\n+\treturn xe_guc_pc_set_max_freq_locked(pc, freq);\n }\n \n /**\n@@ -817,6 +872,7 @@ void xe_guc_pc_init_early(struct xe_guc_pc *pc)\n \n static int pc_adjust_freq_bounds(struct xe_guc_pc *pc)\n {\n+\tstruct xe_tile *tile = gt_to_tile(pc_to_gt(pc));\n \tint ret;\n \n \tlockdep_assert_held(&pc->freq_lock);\n@@ -843,6 +899,9 @@ static int pc_adjust_freq_bounds(struct xe_guc_pc *pc)\n \tif (pc_get_min_freq(pc) > pc->rp0_freq)\n \t\tret = pc_set_min_freq(pc, pc->rp0_freq);\n \n+\tif (XE_WA(tile->primary_gt, 14022085890))\n+\t\tret = pc_set_min_freq(pc, max(BMG_MIN_FREQ, pc_get_min_freq(pc)));\n+\n out:\n \treturn ret;\n }\n@@ -868,30 +927,117 @@ static int pc_adjust_requested_freq(struct xe_guc_pc *pc)\n \treturn ret;\n }\n \n-static int pc_set_mert_freq_cap(struct xe_guc_pc *pc)\n+static bool needs_flush_freq_limit(struct xe_guc_pc *pc)\n {\n-\tint ret = 0;\n+\tstruct xe_gt *gt = pc_to_gt(pc);\n \n-\tif (XE_WA(pc_to_gt(pc), 22019338487)) {\n-\t\t/*\n-\t\t * Get updated min/max and stash them.\n-\t\t */\n-\t\tret = xe_guc_pc_get_min_freq(pc, &pc->stashed_min_freq);\n-\t\tif (!ret)\n-\t\t\tret = xe_guc_pc_get_max_freq(pc, &pc->stashed_max_freq);\n-\t\tif (ret)\n-\t\t\treturn ret;\n+\treturn  XE_WA(gt, 22019338487) &&\n+\t\tpc->rp0_freq > BMG_MERT_FLUSH_FREQ_CAP;\n+}\n+\n+/**\n+ * xe_guc_pc_apply_flush_freq_limit() - Limit max GT freq during L2 flush\n+ * @pc: the xe_guc_pc object\n+ *\n+ * As per the WA, reduce max GT frequency during L2 cache flush\n+ */\n+void xe_guc_pc_apply_flush_freq_limit(struct xe_guc_pc *pc)\n+{\n+\tstruct xe_gt *gt = pc_to_gt(pc);\n+\tu32 max_freq;\n+\tint ret;\n+\n+\tif (!needs_flush_freq_limit(pc))\n+\t\treturn;\n+\n+\tguard(mutex)(&pc->freq_lock);\n+\n+\tret = xe_guc_pc_get_max_freq_locked(pc, &max_freq);\n+\tif (!ret && max_freq > BMG_MERT_FLUSH_FREQ_CAP) {\n+\t\tret = pc_set_max_freq(pc, BMG_MERT_FLUSH_FREQ_CAP);\n+\t\tif (ret) {\n+\t\t\txe_gt_err_once(gt, \"Failed to cap max freq on flush to %u, %pe\\n\",\n+\t\t\t\t       BMG_MERT_FLUSH_FREQ_CAP, ERR_PTR(ret));\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tatomic_set(&pc->flush_freq_limit, 1);\n \n \t\t/*\n-\t\t * Ensure min and max are bound by MERT_FREQ_CAP until driver loads.\n+\t\t * If user has previously changed max freq, stash that value to\n+\t\t * restore later, otherwise use the current max. New user\n+\t\t * requests wait on flush.\n \t\t */\n-\t\tmutex_lock(&pc->freq_lock);\n-\t\tret = pc_set_min_freq(pc, min(pc->rpe_freq, pc_max_freq_cap(pc)));\n-\t\tif (!ret)\n-\t\t\tret = pc_set_max_freq(pc, min(pc->rp0_freq, pc_max_freq_cap(pc)));\n-\t\tmutex_unlock(&pc->freq_lock);\n+\t\tif (pc->user_requested_max != 0)\n+\t\t\tpc->stashed_max_freq = pc->user_requested_max;\n+\t\telse\n+\t\t\tpc->stashed_max_freq = max_freq;\n \t}\n \n+\t/*\n+\t * Wait for actual freq to go below the flush cap: even if the previous\n+\t * max was below cap, the current one might still be above it\n+\t */\n+\tret = wait_for_act_freq_limit(pc, BMG_MERT_FLUSH_FREQ_CAP);\n+\tif (ret)\n+\t\txe_gt_err_once(gt, \"Actual freq did not reduce to %u, %pe\\n\",\n+\t\t\t       BMG_MERT_FLUSH_FREQ_CAP, ERR_PTR(ret));\n+}\n+\n+/**\n+ * xe_guc_pc_remove_flush_freq_limit() - Remove max GT freq limit after L2 flush completes.\n+ * @pc: the xe_guc_pc object\n+ *\n+ * Retrieve the previous GT max frequency value.\n+ */\n+void xe_guc_pc_remove_flush_freq_limit(struct xe_guc_pc *pc)\n+{\n+\tstruct xe_gt *gt = pc_to_gt(pc);\n+\tint ret = 0;\n+\n+\tif (!needs_flush_freq_limit(pc))\n+\t\treturn;\n+\n+\tif (!atomic_read(&pc->flush_freq_limit))\n+\t\treturn;\n+\n+\tmutex_lock(&pc->freq_lock);\n+\n+\tret = pc_set_max_freq(&gt->uc.guc.pc, pc->stashed_max_freq);\n+\tif (ret)\n+\t\txe_gt_err_once(gt, \"Failed to restore max freq %u:%d\",\n+\t\t\t       pc->stashed_max_freq, ret);\n+\n+\tatomic_set(&pc->flush_freq_limit, 0);\n+\tmutex_unlock(&pc->freq_lock);\n+\twake_up_var(&pc->flush_freq_limit);\n+}\n+\n+static int pc_set_mert_freq_cap(struct xe_guc_pc *pc)\n+{\n+\tint ret;\n+\n+\tif (!XE_WA(pc_to_gt(pc), 22019338487))\n+\t\treturn 0;\n+\n+\tguard(mutex)(&pc->freq_lock);\n+\n+\t/*\n+\t * Get updated min/max and stash them.\n+\t */\n+\tret = xe_guc_pc_get_min_freq_locked(pc, &pc->stashed_min_freq);\n+\tif (!ret)\n+\t\tret = xe_guc_pc_get_max_freq_locked(pc, &pc->stashed_max_freq);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\t/*\n+\t * Ensure min and max are bound by MERT_FREQ_CAP until driver loads.\n+\t */\n+\tret = pc_set_min_freq(pc, min(pc->rpe_freq, pc_max_freq_cap(pc)));\n+\tif (!ret)\n+\t\tret = pc_set_max_freq(pc, min(pc->rp0_freq, pc_max_freq_cap(pc)));\n+\n \treturn ret;\n }\n \ndiff --git a/drivers/gpu/drm/xe/xe_guc_pc.h b/drivers/gpu/drm/xe/xe_guc_pc.h\nindex 0a2664d5c811..52ecdd5ddbff 100644\n--- a/drivers/gpu/drm/xe/xe_guc_pc.h\n+++ b/drivers/gpu/drm/xe/xe_guc_pc.h\n@@ -38,5 +38,7 @@ u64 xe_guc_pc_mc6_residency(struct xe_guc_pc *pc);\n void xe_guc_pc_init_early(struct xe_guc_pc *pc);\n int xe_guc_pc_restore_stashed_freq(struct xe_guc_pc *pc);\n void xe_guc_pc_raise_unslice(struct xe_guc_pc *pc);\n+void xe_guc_pc_apply_flush_freq_limit(struct xe_guc_pc *pc);\n+void xe_guc_pc_remove_flush_freq_limit(struct xe_guc_pc *pc);\n \n #endif /* _XE_GUC_PC_H_ */\ndiff --git a/drivers/gpu/drm/xe/xe_guc_pc_types.h b/drivers/gpu/drm/xe/xe_guc_pc_types.h\nindex 2978ac9a249b..c02053948a57 100644\n--- a/drivers/gpu/drm/xe/xe_guc_pc_types.h\n+++ b/drivers/gpu/drm/xe/xe_guc_pc_types.h\n@@ -15,6 +15,8 @@\n struct xe_guc_pc {\n \t/** @bo: GGTT buffer object that is shared with GuC PC */\n \tstruct xe_bo *bo;\n+\t/** @flush_freq_limit: 1 when max freq changes are limited by driver */\n+\tatomic_t flush_freq_limit;\n \t/** @rp0_freq: HW RP0 frequency - The Maximum one */\n \tu32 rp0_freq;\n \t/** @rpa_freq: HW RPa frequency - The Achievable one */\ndiff --git a/drivers/gpu/drm/xe/xe_guc_submit.c b/drivers/gpu/drm/xe/xe_guc_submit.c\nindex 9567f6700cf2..2ac87ff4a057 100644\n--- a/drivers/gpu/drm/xe/xe_guc_submit.c\n+++ b/drivers/gpu/drm/xe/xe_guc_submit.c\n@@ -891,12 +891,13 @@ static void xe_guc_exec_queue_lr_cleanup(struct work_struct *w)\n \tstruct xe_exec_queue *q = ge->q;\n \tstruct xe_guc *guc = exec_queue_to_guc(q);\n \tstruct xe_gpu_scheduler *sched = &ge->sched;\n-\tbool wedged;\n+\tbool wedged = false;\n \n \txe_gt_assert(guc_to_gt(guc), xe_exec_queue_is_lr(q));\n \ttrace_xe_exec_queue_lr_cleanup(q);\n \n-\twedged = guc_submit_hint_wedged(exec_queue_to_guc(q));\n+\tif (!exec_queue_killed(q))\n+\t\twedged = guc_submit_hint_wedged(exec_queue_to_guc(q));\n \n \t/* Kill the run_job / process_msg entry points */\n \txe_sched_submission_stop(sched);\n@@ -1070,7 +1071,7 @@ guc_exec_queue_timedout_job(struct drm_sched_job *drm_job)\n \tint err = -ETIME;\n \tpid_t pid = -1;\n \tint i = 0;\n-\tbool wedged, skip_timeout_check;\n+\tbool wedged = false, skip_timeout_check;\n \n \t/*\n \t * TDR has fired before free job worker. Common if exec queue\n@@ -1116,7 +1117,8 @@ guc_exec_queue_timedout_job(struct drm_sched_job *drm_job)\n \t * doesn't work for SRIOV. For now assuming timeouts in wedged mode are\n \t * genuine timeouts.\n \t */\n-\twedged = guc_submit_hint_wedged(exec_queue_to_guc(q));\n+\tif (!exec_queue_killed(q))\n+\t\twedged = guc_submit_hint_wedged(exec_queue_to_guc(q));\n \n \t/* Engine state now stable, disable scheduling to check timestamp */\n \tif (!wedged && exec_queue_registered(q)) {\ndiff --git a/drivers/gpu/drm/xe/xe_lrc.c b/drivers/gpu/drm/xe/xe_lrc.c\nindex bf7c3981897d..6e7b70532d11 100644\n--- a/drivers/gpu/drm/xe/xe_lrc.c\n+++ b/drivers/gpu/drm/xe/xe_lrc.c\n@@ -40,6 +40,7 @@\n \n #define LRC_PPHWSP_SIZE\t\t\t\tSZ_4K\n #define LRC_INDIRECT_RING_STATE_SIZE\t\tSZ_4K\n+#define LRC_WA_BB_SIZE\t\t\t\tSZ_4K\n \n static struct xe_device *\n lrc_to_xe(struct xe_lrc *lrc)\n@@ -910,7 +911,11 @@ static void xe_lrc_finish(struct xe_lrc *lrc)\n {\n \txe_hw_fence_ctx_finish(&lrc->fence_ctx);\n \txe_bo_unpin_map_no_vm(lrc->bo);\n-\txe_bo_unpin_map_no_vm(lrc->bb_per_ctx_bo);\n+}\n+\n+static size_t wa_bb_offset(struct xe_lrc *lrc)\n+{\n+\treturn lrc->bo->size - LRC_WA_BB_SIZE;\n }\n \n /*\n@@ -943,15 +948,16 @@ static void xe_lrc_finish(struct xe_lrc *lrc)\n #define CONTEXT_ACTIVE 1ULL\n static int xe_lrc_setup_utilization(struct xe_lrc *lrc)\n {\n+\tconst size_t max_size = LRC_WA_BB_SIZE;\n \tu32 *cmd, *buf = NULL;\n \n-\tif (lrc->bb_per_ctx_bo->vmap.is_iomem) {\n-\t\tbuf = kmalloc(lrc->bb_per_ctx_bo->size, GFP_KERNEL);\n+\tif (lrc->bo->vmap.is_iomem) {\n+\t\tbuf = kmalloc(max_size, GFP_KERNEL);\n \t\tif (!buf)\n \t\t\treturn -ENOMEM;\n \t\tcmd = buf;\n \t} else {\n-\t\tcmd = lrc->bb_per_ctx_bo->vmap.vaddr;\n+\t\tcmd = lrc->bo->vmap.vaddr + wa_bb_offset(lrc);\n \t}\n \n \t*cmd++ = MI_STORE_REGISTER_MEM | MI_SRM_USE_GGTT | MI_SRM_ADD_CS_OFFSET;\n@@ -974,13 +980,14 @@ static int xe_lrc_setup_utilization(struct xe_lrc *lrc)\n \t*cmd++ = MI_BATCH_BUFFER_END;\n \n \tif (buf) {\n-\t\txe_map_memcpy_to(gt_to_xe(lrc->gt), &lrc->bb_per_ctx_bo->vmap, 0,\n-\t\t\t\t buf, (cmd - buf) * sizeof(*cmd));\n+\t\txe_map_memcpy_to(gt_to_xe(lrc->gt), &lrc->bo->vmap,\n+\t\t\t\t wa_bb_offset(lrc), buf,\n+\t\t\t\t (cmd - buf) * sizeof(*cmd));\n \t\tkfree(buf);\n \t}\n \n-\txe_lrc_write_ctx_reg(lrc, CTX_BB_PER_CTX_PTR,\n-\t\t\t     xe_bo_ggtt_addr(lrc->bb_per_ctx_bo) | 1);\n+\txe_lrc_write_ctx_reg(lrc, CTX_BB_PER_CTX_PTR, xe_bo_ggtt_addr(lrc->bo) +\n+\t\t\t     wa_bb_offset(lrc) + 1);\n \n \treturn 0;\n }\n@@ -1018,20 +1025,13 @@ static int xe_lrc_init(struct xe_lrc *lrc, struct xe_hw_engine *hwe,\n \t * FIXME: Perma-pinning LRC as we don't yet support moving GGTT address\n \t * via VM bind calls.\n \t */\n-\tlrc->bo = xe_bo_create_pin_map(xe, tile, NULL, lrc_size,\n+\tlrc->bo = xe_bo_create_pin_map(xe, tile, NULL,\n+\t\t\t\t       lrc_size + LRC_WA_BB_SIZE,\n \t\t\t\t       ttm_bo_type_kernel,\n \t\t\t\t       bo_flags);\n \tif (IS_ERR(lrc->bo))\n \t\treturn PTR_ERR(lrc->bo);\n \n-\tlrc->bb_per_ctx_bo = xe_bo_create_pin_map(xe, tile, NULL, SZ_4K,\n-\t\t\t\t\t\t  ttm_bo_type_kernel,\n-\t\t\t\t\t\t  bo_flags);\n-\tif (IS_ERR(lrc->bb_per_ctx_bo)) {\n-\t\terr = PTR_ERR(lrc->bb_per_ctx_bo);\n-\t\tgoto err_lrc_finish;\n-\t}\n-\n \tlrc->size = lrc_size;\n \tlrc->ring.size = ring_size;\n \tlrc->ring.tail = 0;\n@@ -1819,7 +1819,8 @@ struct xe_lrc_snapshot *xe_lrc_snapshot_capture(struct xe_lrc *lrc)\n \tsnapshot->seqno = xe_lrc_seqno(lrc);\n \tsnapshot->lrc_bo = xe_bo_get(lrc->bo);\n \tsnapshot->lrc_offset = xe_lrc_pphwsp_offset(lrc);\n-\tsnapshot->lrc_size = lrc->bo->size - snapshot->lrc_offset;\n+\tsnapshot->lrc_size = lrc->bo->size - snapshot->lrc_offset -\n+\t\tLRC_WA_BB_SIZE;\n \tsnapshot->lrc_snapshot = NULL;\n \tsnapshot->ctx_timestamp = lower_32_bits(xe_lrc_ctx_timestamp(lrc));\n \tsnapshot->ctx_job_timestamp = xe_lrc_ctx_job_timestamp(lrc);\ndiff --git a/drivers/gpu/drm/xe/xe_lrc_types.h b/drivers/gpu/drm/xe/xe_lrc_types.h\nindex ae24cf6f8dd9..883e550a9423 100644\n--- a/drivers/gpu/drm/xe/xe_lrc_types.h\n+++ b/drivers/gpu/drm/xe/xe_lrc_types.h\n@@ -53,9 +53,6 @@ struct xe_lrc {\n \n \t/** @ctx_timestamp: readout value of CTX_TIMESTAMP on last update */\n \tu64 ctx_timestamp;\n-\n-\t/** @bb_per_ctx_bo: buffer object for per context batch wa buffer */\n-\tstruct xe_bo *bb_per_ctx_bo;\n };\n \n struct xe_lrc_snapshot;\ndiff --git a/drivers/gpu/drm/xe/xe_migrate.c b/drivers/gpu/drm/xe/xe_migrate.c\nindex 8f8e9fdfb2a8..7acdc4c78866 100644\n--- a/drivers/gpu/drm/xe/xe_migrate.c\n+++ b/drivers/gpu/drm/xe/xe_migrate.c\n@@ -82,7 +82,7 @@ struct xe_migrate {\n  * of the instruction.  Subtracting the instruction header (1 dword) and\n  * address (2 dwords), that leaves 0x3FD dwords (0x1FE qwords) for PTE values.\n  */\n-#define MAX_PTE_PER_SDI 0x1FE\n+#define MAX_PTE_PER_SDI 0x1FEU\n \n /**\n  * xe_tile_migrate_exec_queue() - Get this tile's migrate exec queue.\n@@ -1553,15 +1553,17 @@ static u32 pte_update_cmd_size(u64 size)\n \tu64 entries = DIV_U64_ROUND_UP(size, XE_PAGE_SIZE);\n \n \tXE_WARN_ON(size > MAX_PREEMPTDISABLE_TRANSFER);\n+\n \t/*\n \t * MI_STORE_DATA_IMM command is used to update page table. Each\n-\t * instruction can update maximumly 0x1ff pte entries. To update\n-\t * n (n <= 0x1ff) pte entries, we need:\n-\t * 1 dword for the MI_STORE_DATA_IMM command header (opcode etc)\n-\t * 2 dword for the page table's physical location\n-\t * 2*n dword for value of pte to fill (each pte entry is 2 dwords)\n+\t * instruction can update maximumly MAX_PTE_PER_SDI pte entries. To\n+\t * update n (n <= MAX_PTE_PER_SDI) pte entries, we need:\n+\t *\n+\t * - 1 dword for the MI_STORE_DATA_IMM command header (opcode etc)\n+\t * - 2 dword for the page table's physical location\n+\t * - 2*n dword for value of pte to fill (each pte entry is 2 dwords)\n \t */\n-\tnum_dword = (1 + 2) * DIV_U64_ROUND_UP(entries, 0x1ff);\n+\tnum_dword = (1 + 2) * DIV_U64_ROUND_UP(entries, MAX_PTE_PER_SDI);\n \tnum_dword += entries * 2;\n \n \treturn num_dword;\n@@ -1577,7 +1579,7 @@ static void build_pt_update_batch_sram(struct xe_migrate *m,\n \n \tptes = DIV_ROUND_UP(size, XE_PAGE_SIZE);\n \twhile (ptes) {\n-\t\tu32 chunk = min(0x1ffU, ptes);\n+\t\tu32 chunk = min(MAX_PTE_PER_SDI, ptes);\n \n \t\tbb->cs[bb->len++] = MI_STORE_DATA_IMM | MI_SDI_NUM_QW(chunk);\n \t\tbb->cs[bb->len++] = pt_offset;\ndiff --git a/drivers/gpu/drm/xe/xe_wa_oob.rules b/drivers/gpu/drm/xe/xe_wa_oob.rules\nindex 9efc5accd43d..69c1d7fc695e 100644\n--- a/drivers/gpu/drm/xe/xe_wa_oob.rules\n+++ b/drivers/gpu/drm/xe/xe_wa_oob.rules\n@@ -21,7 +21,8 @@\n \t\tGRAPHICS_VERSION_RANGE(1270, 1274)\n \t\tMEDIA_VERSION(1300)\n \t\tPLATFORM(DG2)\n-14018094691\tGRAPHICS_VERSION(2004)\n+14018094691\tGRAPHICS_VERSION_RANGE(2001, 2002)\n+\t\tGRAPHICS_VERSION(2004)\n 14019882105\tGRAPHICS_VERSION(2004), GRAPHICS_STEP(A0, B0)\n 18024947630\tGRAPHICS_VERSION(2001)\n \t\tGRAPHICS_VERSION(2004)\n@@ -59,3 +60,7 @@ no_media_l3\tMEDIA_VERSION(3000)\n \t\tMEDIA_VERSION_RANGE(1301, 3000)\n 16026508708\tGRAPHICS_VERSION_RANGE(1200, 3001)\n \t\tMEDIA_VERSION_RANGE(1300, 3000)\n+\n+# SoC workaround - currently applies to all platforms with the following\n+# primary GT GMDID\n+14022085890\tGRAPHICS_VERSION(2001)\ndiff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h\nindex b37860f4a895..6d2c08e81101 100644\n--- a/include/drm/drm_mipi_dsi.h\n+++ b/include/drm/drm_mipi_dsi.h\n@@ -223,6 +223,9 @@ struct mipi_dsi_multi_context {\n \n #define to_mipi_dsi_device(__dev)\tcontainer_of_const(__dev, struct mipi_dsi_device, dev)\n \n+extern const struct bus_type mipi_dsi_bus_type;\n+#define dev_is_mipi_dsi(dev)\t((dev)->bus == &mipi_dsi_bus_type)\n+\n /**\n  * mipi_dsi_pixel_format_to_bpp - obtain the number of bits per pixel for any\n  *                                given pixel format defined by the MIPI DSI\ndiff --git a/include/drm/spsc_queue.h b/include/drm/spsc_queue.h\nindex 125f096c88cb..ee9df8cc67b7 100644\n--- a/include/drm/spsc_queue.h\n+++ b/include/drm/spsc_queue.h\n@@ -70,9 +70,11 @@ static inline bool spsc_queue_push(struct spsc_queue *queue, struct spsc_node *n\n \n \tpreempt_disable();\n \n+\tatomic_inc(&queue->job_count);\n+\tsmp_mb__after_atomic();\n+\n \ttail = (struct spsc_node **)atomic_long_xchg(&queue->tail, (long)&node->next);\n \tWRITE_ONCE(*tail, node);\n-\tatomic_inc(&queue->job_count);\n \n \t/*\n \t * In case of first element verify new node will be visible to the consumer",
    "stats": {
      "insertions": 632,
      "deletions": 293,
      "files": 47
    }
  },
  {
    "sha": "923d401238c590f39833a2015f6f9493f146d98f",
    "message": "Merge tag 'iommu-fixes-v6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/iommu/linux\n\nPull iommu fixes from Joerg Roedel:\n\n - Rockchip: fix infinite loop caused by probing race condition\n\n - Intel VT-d: assign devtlb cache tag on ATS enablement\n\n* tag 'iommu-fixes-v6.16-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/iommu/linux:\n  iommu/vt-d: Assign devtlb cache tag on ATS enablement\n  iommu/rockchip: prevent iommus dead loop when two masters share one IOMMU",
    "author": "Linus Torvalds",
    "date": "2025-07-04T09:43:08-07:00",
    "files_changed": [
      "drivers/iommu/intel/cache.c",
      "drivers/iommu/intel/iommu.c",
      "drivers/iommu/intel/iommu.h",
      "drivers/iommu/rockchip-iommu.c"
    ],
    "diff": "diff --git a/drivers/iommu/intel/cache.c b/drivers/iommu/intel/cache.c\nindex fc35cba59145..47692cbfaabd 100644\n--- a/drivers/iommu/intel/cache.c\n+++ b/drivers/iommu/intel/cache.c\n@@ -40,9 +40,8 @@ static bool cache_tage_match(struct cache_tag *tag, u16 domain_id,\n }\n \n /* Assign a cache tag with specified type to domain. */\n-static int cache_tag_assign(struct dmar_domain *domain, u16 did,\n-\t\t\t    struct device *dev, ioasid_t pasid,\n-\t\t\t    enum cache_tag_type type)\n+int cache_tag_assign(struct dmar_domain *domain, u16 did, struct device *dev,\n+\t\t     ioasid_t pasid, enum cache_tag_type type)\n {\n \tstruct device_domain_info *info = dev_iommu_priv_get(dev);\n \tstruct intel_iommu *iommu = info->iommu;\ndiff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c\nindex 7aa3932251b2..148b944143b8 100644\n--- a/drivers/iommu/intel/iommu.c\n+++ b/drivers/iommu/intel/iommu.c\n@@ -3780,8 +3780,17 @@ static void intel_iommu_probe_finalize(struct device *dev)\n \t    !pci_enable_pasid(to_pci_dev(dev), info->pasid_supported & ~1))\n \t\tinfo->pasid_enabled = 1;\n \n-\tif (sm_supported(iommu) && !dev_is_real_dma_subdevice(dev))\n+\tif (sm_supported(iommu) && !dev_is_real_dma_subdevice(dev)) {\n \t\tiommu_enable_pci_ats(info);\n+\t\t/* Assign a DEVTLB cache tag to the default domain. */\n+\t\tif (info->ats_enabled && info->domain) {\n+\t\t\tu16 did = domain_id_iommu(info->domain, iommu);\n+\n+\t\t\tif (cache_tag_assign(info->domain, did, dev,\n+\t\t\t\t\t     IOMMU_NO_PASID, CACHE_TAG_DEVTLB))\n+\t\t\t\tiommu_disable_pci_ats(info);\n+\t\t}\n+\t}\n \tiommu_enable_pci_pri(info);\n }\n \ndiff --git a/drivers/iommu/intel/iommu.h b/drivers/iommu/intel/iommu.h\nindex 3ddbcc603de2..2d1afab5eedc 100644\n--- a/drivers/iommu/intel/iommu.h\n+++ b/drivers/iommu/intel/iommu.h\n@@ -1289,6 +1289,8 @@ struct cache_tag {\n \tunsigned int users;\n };\n \n+int cache_tag_assign(struct dmar_domain *domain, u16 did, struct device *dev,\n+\t\t     ioasid_t pasid, enum cache_tag_type type);\n int cache_tag_assign_domain(struct dmar_domain *domain,\n \t\t\t    struct device *dev, ioasid_t pasid);\n void cache_tag_unassign_domain(struct dmar_domain *domain,\ndiff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c\nindex 22f74ba33a0e..e6bb3c784017 100644\n--- a/drivers/iommu/rockchip-iommu.c\n+++ b/drivers/iommu/rockchip-iommu.c\n@@ -1157,7 +1157,6 @@ static int rk_iommu_of_xlate(struct device *dev,\n \t\treturn -ENOMEM;\n \n \tdata->iommu = platform_get_drvdata(iommu_dev);\n-\tdata->iommu->domain = &rk_identity_domain;\n \tdev_iommu_priv_set(dev, data);\n \n \tplatform_device_put(iommu_dev);\n@@ -1195,6 +1194,8 @@ static int rk_iommu_probe(struct platform_device *pdev)\n \tif (!iommu)\n \t\treturn -ENOMEM;\n \n+\tiommu->domain = &rk_identity_domain;\n+\n \tplatform_set_drvdata(pdev, iommu);\n \tiommu->dev = dev;\n \tiommu->num_mmu = 0;",
    "stats": {
      "insertions": 16,
      "deletions": 5,
      "files": 4
    }
  },
  {
    "sha": "1880df2cf44af6266b48a905596726c267bc2b04",
    "message": "Merge tag 'block-6.16-20250704' of git://git.kernel.dk/linux\n\nPull block fixes from Jens Axboe:\n\n - NVMe fixes via Christoph:\n     - fix incorrect cdw15 value in passthru error logging (Alok Tiwari)\n     - fix memory leak of bio integrity in nvmet (Dmitry Bogdanov)\n     - refresh visible attrs after being checked (Eugen Hristev)\n     - fix suspicious RCU usage warning in the multipath code (Geliang Tang)\n     - correctly account for namespace head reference counter (Nilay Shroff)\n\n - Fix for a regression introduced in ublk in this cycle, where it would\n   attempt to queue a canceled request.\n\n - brd RCU sleeping fix, also introduced in this cycle. Bare bones fix,\n   should be improved upon for the next release.\n\n* tag 'block-6.16-20250704' of git://git.kernel.dk/linux:\n  brd: fix sleeping function called from invalid context in brd_insert_page()\n  ublk: don't queue request if the associated uring_cmd is canceled\n  nvme-multipath: fix suspicious RCU usage warning\n  nvme-pci: refresh visible attrs after being checked\n  nvmet: fix memory leak of bio integrity\n  nvme: correctly account for namespace head reference counter\n  nvme: Fix incorrect cdw15 value in passthru error logging",
    "author": "Linus Torvalds",
    "date": "2025-07-04T09:33:59-07:00",
    "files_changed": [
      "drivers/block/brd.c",
      "drivers/block/ublk_drv.c",
      "drivers/nvme/host/core.c",
      "drivers/nvme/host/multipath.c",
      "drivers/nvme/host/pci.c",
      "drivers/nvme/target/nvmet.h"
    ],
    "diff": "diff --git a/drivers/block/brd.c b/drivers/block/brd.c\nindex b1be6c510372..0c2eabe14af3 100644\n--- a/drivers/block/brd.c\n+++ b/drivers/block/brd.c\n@@ -64,13 +64,15 @@ static struct page *brd_insert_page(struct brd_device *brd, sector_t sector,\n \n \trcu_read_unlock();\n \tpage = alloc_page(gfp | __GFP_ZERO | __GFP_HIGHMEM);\n-\trcu_read_lock();\n-\tif (!page)\n+\tif (!page) {\n+\t\trcu_read_lock();\n \t\treturn ERR_PTR(-ENOMEM);\n+\t}\n \n \txa_lock(&brd->brd_pages);\n \tret = __xa_cmpxchg(&brd->brd_pages, sector >> PAGE_SECTORS_SHIFT, NULL,\n \t\t\tpage, gfp);\n+\trcu_read_lock();\n \tif (ret) {\n \t\txa_unlock(&brd->brd_pages);\n \t\t__free_page(page);\ndiff --git a/drivers/block/ublk_drv.c b/drivers/block/ublk_drv.c\nindex c3e3c3b65a6d..9fd284fa76dc 100644\n--- a/drivers/block/ublk_drv.c\n+++ b/drivers/block/ublk_drv.c\n@@ -1442,15 +1442,16 @@ static void ublk_queue_rqs(struct rq_list *rqlist)\n \t\tstruct ublk_queue *this_q = req->mq_hctx->driver_data;\n \t\tstruct ublk_io *this_io = &this_q->ios[req->tag];\n \n+\t\tif (ublk_prep_req(this_q, req, true) != BLK_STS_OK) {\n+\t\t\trq_list_add_tail(&requeue_list, req);\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tif (io && !ublk_belong_to_same_batch(io, this_io) &&\n \t\t\t\t!rq_list_empty(&submit_list))\n \t\t\tublk_queue_cmd_list(io, &submit_list);\n \t\tio = this_io;\n-\n-\t\tif (ublk_prep_req(this_q, req, true) == BLK_STS_OK)\n-\t\t\trq_list_add_tail(&submit_list, req);\n-\t\telse\n-\t\t\trq_list_add_tail(&requeue_list, req);\n+\t\trq_list_add_tail(&submit_list, req);\n \t}\n \n \tif (!rq_list_empty(&submit_list))\ndiff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c\nindex e533d791955d..7493e5aa984c 100644\n--- a/drivers/nvme/host/core.c\n+++ b/drivers/nvme/host/core.c\n@@ -386,7 +386,7 @@ static void nvme_log_err_passthru(struct request *req)\n \t\tnr->cmd->common.cdw12,\n \t\tnr->cmd->common.cdw13,\n \t\tnr->cmd->common.cdw14,\n-\t\tnr->cmd->common.cdw14);\n+\t\tnr->cmd->common.cdw15);\n }\n \n enum nvme_disposition {\n@@ -4086,6 +4086,7 @@ static void nvme_alloc_ns(struct nvme_ctrl *ctrl, struct nvme_ns_info *info)\n \tstruct nvme_ns *ns;\n \tstruct gendisk *disk;\n \tint node = ctrl->numa_node;\n+\tbool last_path = false;\n \n \tns = kzalloc_node(sizeof(*ns), GFP_KERNEL, node);\n \tif (!ns)\n@@ -4178,9 +4179,22 @@ static void nvme_alloc_ns(struct nvme_ctrl *ctrl, struct nvme_ns_info *info)\n  out_unlink_ns:\n \tmutex_lock(&ctrl->subsys->lock);\n \tlist_del_rcu(&ns->siblings);\n-\tif (list_empty(&ns->head->list))\n+\tif (list_empty(&ns->head->list)) {\n \t\tlist_del_init(&ns->head->entry);\n+\t\t/*\n+\t\t * If multipath is not configured, we still create a namespace\n+\t\t * head (nshead), but head->disk is not initialized in that\n+\t\t * case.  As a result, only a single reference to nshead is held\n+\t\t * (via kref_init()) when it is created. Therefore, ensure that\n+\t\t * we do not release the reference to nshead twice if head->disk\n+\t\t * is not present.\n+\t\t */\n+\t\tif (ns->head->disk)\n+\t\t\tlast_path = true;\n+\t}\n \tmutex_unlock(&ctrl->subsys->lock);\n+\tif (last_path)\n+\t\tnvme_put_ns_head(ns->head);\n \tnvme_put_ns_head(ns->head);\n  out_cleanup_disk:\n \tput_disk(disk);\ndiff --git a/drivers/nvme/host/multipath.c b/drivers/nvme/host/multipath.c\nindex 316a269842fa..3da980dc60d9 100644\n--- a/drivers/nvme/host/multipath.c\n+++ b/drivers/nvme/host/multipath.c\n@@ -690,8 +690,8 @@ static void nvme_remove_head(struct nvme_ns_head *head)\n \t\tnvme_cdev_del(&head->cdev, &head->cdev_device);\n \t\tsynchronize_srcu(&head->srcu);\n \t\tdel_gendisk(head->disk);\n-\t\tnvme_put_ns_head(head);\n \t}\n+\tnvme_put_ns_head(head);\n }\n \n static void nvme_remove_head_work(struct work_struct *work)\n@@ -1200,7 +1200,8 @@ void nvme_mpath_add_sysfs_link(struct nvme_ns_head *head)\n \t */\n \tsrcu_idx = srcu_read_lock(&head->srcu);\n \n-\tlist_for_each_entry_rcu(ns, &head->list, siblings) {\n+\tlist_for_each_entry_srcu(ns, &head->list, siblings,\n+\t\t\t\t srcu_read_lock_held(&head->srcu)) {\n \t\t/*\n \t\t * Ensure that ns path disk node is already added otherwise we\n \t\t * may get invalid kobj name for target\n@@ -1291,6 +1292,9 @@ void nvme_mpath_remove_disk(struct nvme_ns_head *head)\n {\n \tbool remove = false;\n \n+\tif (!head->disk)\n+\t\treturn;\n+\n \tmutex_lock(&head->subsys->lock);\n \t/*\n \t * We are called when all paths have been removed, and at that point\ndiff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c\nindex 8ff12e415cb5..320aaa41ec39 100644\n--- a/drivers/nvme/host/pci.c\n+++ b/drivers/nvme/host/pci.c\n@@ -2101,8 +2101,6 @@ static void nvme_map_cmb(struct nvme_dev *dev)\n \tif ((dev->cmbsz & (NVME_CMBSZ_WDS | NVME_CMBSZ_RDS)) ==\n \t\t\t(NVME_CMBSZ_WDS | NVME_CMBSZ_RDS))\n \t\tpci_p2pmem_publish(pdev, true);\n-\n-\tnvme_update_attrs(dev);\n }\n \n static int nvme_set_host_mem(struct nvme_dev *dev, u32 bits)\n@@ -3010,6 +3008,8 @@ static void nvme_reset_work(struct work_struct *work)\n \tif (result < 0)\n \t\tgoto out;\n \n+\tnvme_update_attrs(dev);\n+\n \tresult = nvme_setup_io_queues(dev);\n \tif (result)\n \t\tgoto out;\n@@ -3343,6 +3343,8 @@ static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n \tif (result < 0)\n \t\tgoto out_disable;\n \n+\tnvme_update_attrs(dev);\n+\n \tresult = nvme_setup_io_queues(dev);\n \tif (result)\n \t\tgoto out_disable;\ndiff --git a/drivers/nvme/target/nvmet.h b/drivers/nvme/target/nvmet.h\nindex df69a9dee71c..51df72f5e89b 100644\n--- a/drivers/nvme/target/nvmet.h\n+++ b/drivers/nvme/target/nvmet.h\n@@ -867,6 +867,8 @@ static inline void nvmet_req_bio_put(struct nvmet_req *req, struct bio *bio)\n {\n \tif (bio != &req->b.inline_bio)\n \t\tbio_put(bio);\n+\telse\n+\t\tbio_uninit(bio);\n }\n \n #ifdef CONFIG_NVME_TARGET_TCP_TLS",
    "stats": {
      "insertions": 38,
      "deletions": 13,
      "files": 6
    }
  }
]
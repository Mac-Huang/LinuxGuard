[
  {
    "sha": "7484e15dbb016d9d40f8c6e0475810212ae181db",
    "message": "replace collect_mounts()/drop_collected_mounts() with a safer variant\n\ncollect_mounts() has several problems - one can't iterate over the results\ndirectly, so it has to be done with callback passed to iterate_mounts();\nit has an oopsable race with d_invalidate(); it creates temporary clones\nof mounts invisibly for sync umount (IOW, you can have non-lazy umount\nsucceed leaving filesystem not mounted anywhere and yet still busy).\n\nA saner approach is to give caller an array of struct path that would pin\nevery mount in a subtree, without cloning any mounts.\n\n        * collect_mounts()/drop_collected_mounts()/iterate_mounts() is gone\n        * collect_paths(where, preallocated, size) gives either ERR_PTR(-E...) or\na pointer to array of struct path, one for each chunk of tree visible under\n'where' (i.e. the first element is a copy of where, followed by (mount,root)\nfor everything mounted under it - the same set collect_mounts() would give).\nUnlike collect_mounts(), the mounts are *not* cloned - we just get pinning\nreferences to the roots of subtrees in the caller's namespace.\n        Array is terminated by {NULL, NULL} struct path.  If it fits into\npreallocated array (on-stack, normally), that's where it goes; otherwise\nit's allocated by kmalloc_array().  Passing 0 as size means that 'preallocated'\nis ignored (and expected to be NULL).\n        * drop_collected_paths(paths, preallocated) is given the array returned\nby an earlier call of collect_paths() and the preallocated array passed to that\ncall.  All mount/dentry references are dropped and array is kfree'd if it's not\nequal to 'preallocated'.\n        * instead of iterate_mounts(), users should just iterate over array\nof struct path - nothing exotic is needed for that.  Existing users (all in\naudit_tree.c) are converted.\n\n[folded a fix for braino reported by Venkat Rao Bagalkote <venkat88@linux.ibm.com>]\n\nFixes: 80b5dce8c59b0 (\"vfs: Add a function to lazily unmount all mounts from any dentry\")\nTested-by: Venkat Rao Bagalkote <venkat88@linux.ibm.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "author": "Al Viro",
    "date": "2025-06-23T14:01:49-04:00",
    "files_changed": [
      "fs/namespace.c",
      "fs/pnode.h",
      "include/linux/mount.h",
      "kernel/audit_tree.c"
    ],
    "diff": "diff --git a/Documentation/filesystems/porting.rst b/Documentation/filesystems/porting.rst\nindex 3616d7161dab..a5734bdd1cc7 100644\n--- a/Documentation/filesystems/porting.rst\n+++ b/Documentation/filesystems/porting.rst\n@@ -1249,3 +1249,12 @@ Using try_lookup_noperm() will require linux/namei.h to be included.\n \n Calling conventions for ->d_automount() have changed; we should *not* grab\n an extra reference to new mount - it should be returned with refcount 1.\n+\n+---\n+\n+collect_mounts()/drop_collected_mounts()/iterate_mounts() are gone now.\n+Replacement is collect_paths()/drop_collected_path(), with no special\n+iterator needed.  Instead of a cloned mount tree, the new interface returns\n+an array of struct path, one for each mount collect_mounts() would've\n+created.  These struct path point to locations in the caller's namespace\n+that would be roots of the cloned mounts.\ndiff --git a/fs/namespace.c b/fs/namespace.c\nindex e13d9ab4f564..14601ec4c2c5 100644\n--- a/fs/namespace.c\n+++ b/fs/namespace.c\n@@ -2310,21 +2310,62 @@ struct mount *copy_tree(struct mount *src_root, struct dentry *dentry,\n \treturn dst_mnt;\n }\n \n-/* Caller should check returned pointer for errors */\n+static inline bool extend_array(struct path **res, struct path **to_free,\n+\t\t\t\tunsigned n, unsigned *count, unsigned new_count)\n+{\n+\tstruct path *p;\n+\n+\tif (likely(n < *count))\n+\t\treturn true;\n+\tp = kmalloc_array(new_count, sizeof(struct path), GFP_KERNEL);\n+\tif (p && *count)\n+\t\tmemcpy(p, *res, *count * sizeof(struct path));\n+\t*count = new_count;\n+\tkfree(*to_free);\n+\t*to_free = *res = p;\n+\treturn p;\n+}\n \n-struct vfsmount *collect_mounts(const struct path *path)\n+struct path *collect_paths(const struct path *path,\n+\t\t\t      struct path *prealloc, unsigned count)\n {\n-\tstruct mount *tree;\n-\tnamespace_lock();\n-\tif (!check_mnt(real_mount(path->mnt)))\n-\t\ttree = ERR_PTR(-EINVAL);\n-\telse\n-\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n-\t\t\t\t CL_COPY_ALL | CL_PRIVATE);\n-\tnamespace_unlock();\n-\tif (IS_ERR(tree))\n-\t\treturn ERR_CAST(tree);\n-\treturn &tree->mnt;\n+\tstruct mount *root = real_mount(path->mnt);\n+\tstruct mount *child;\n+\tstruct path *res = prealloc, *to_free = NULL;\n+\tunsigned n = 0;\n+\n+\tguard(rwsem_read)(&namespace_sem);\n+\n+\tif (!check_mnt(root))\n+\t\treturn ERR_PTR(-EINVAL);\n+\tif (!extend_array(&res, &to_free, 0, &count, 32))\n+\t\treturn ERR_PTR(-ENOMEM);\n+\tres[n++] = *path;\n+\tlist_for_each_entry(child, &root->mnt_mounts, mnt_child) {\n+\t\tif (!is_subdir(child->mnt_mountpoint, path->dentry))\n+\t\t\tcontinue;\n+\t\tfor (struct mount *m = child; m; m = next_mnt(m, child)) {\n+\t\t\tif (!extend_array(&res, &to_free, n, &count, 2 * count))\n+\t\t\t\treturn ERR_PTR(-ENOMEM);\n+\t\t\tres[n].mnt = &m->mnt;\n+\t\t\tres[n].dentry = m->mnt.mnt_root;\n+\t\t\tn++;\n+\t\t}\n+\t}\n+\tif (!extend_array(&res, &to_free, n, &count, count + 1))\n+\t\treturn ERR_PTR(-ENOMEM);\n+\tmemset(res + n, 0, (count - n) * sizeof(struct path));\n+\tfor (struct path *p = res; p->mnt; p++)\n+\t\tpath_get(p);\n+\treturn res;\n+}\n+\n+void drop_collected_paths(struct path *paths, struct path *prealloc)\n+{\n+\tfor (struct path *p = paths; p->mnt; p++)\n+\t\tpath_put(p);\n+\tif (paths != prealloc)\n+\t\tkfree(paths);\n }\n \n static void free_mnt_ns(struct mnt_namespace *);\n@@ -2401,15 +2442,6 @@ void dissolve_on_fput(struct vfsmount *mnt)\n \tfree_mnt_ns(ns);\n }\n \n-void drop_collected_mounts(struct vfsmount *mnt)\n-{\n-\tnamespace_lock();\n-\tlock_mount_hash();\n-\tumount_tree(real_mount(mnt), 0);\n-\tunlock_mount_hash();\n-\tnamespace_unlock();\n-}\n-\n static bool __has_locked_children(struct mount *mnt, struct dentry *dentry)\n {\n \tstruct mount *child;\n@@ -2511,21 +2543,6 @@ struct vfsmount *clone_private_mount(const struct path *path)\n }\n EXPORT_SYMBOL_GPL(clone_private_mount);\n \n-int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,\n-\t\t   struct vfsmount *root)\n-{\n-\tstruct mount *mnt;\n-\tint res = f(root, arg);\n-\tif (res)\n-\t\treturn res;\n-\tlist_for_each_entry(mnt, &real_mount(root)->mnt_list, mnt_list) {\n-\t\tres = f(&mnt->mnt, arg);\n-\t\tif (res)\n-\t\t\treturn res;\n-\t}\n-\treturn 0;\n-}\n-\n static void lock_mnt_tree(struct mount *mnt)\n {\n \tstruct mount *p;\n@@ -6262,7 +6279,11 @@ void put_mnt_ns(struct mnt_namespace *ns)\n {\n \tif (!refcount_dec_and_test(&ns->ns.count))\n \t\treturn;\n-\tdrop_collected_mounts(&ns->root->mnt);\n+\tnamespace_lock();\n+\tlock_mount_hash();\n+\tumount_tree(ns->root, 0);\n+\tunlock_mount_hash();\n+\tnamespace_unlock();\n \tfree_mnt_ns(ns);\n }\n \ndiff --git a/fs/pnode.h b/fs/pnode.h\nindex 34b6247af01d..2d026fb98b18 100644\n--- a/fs/pnode.h\n+++ b/fs/pnode.h\n@@ -28,8 +28,6 @@\n #define CL_SHARED_TO_SLAVE\t0x20\n #define CL_COPY_MNT_NS_FILE\t0x40\n \n-#define CL_COPY_ALL\t\t(CL_COPY_UNBINDABLE | CL_COPY_MNT_NS_FILE)\n-\n static inline void set_mnt_shared(struct mount *mnt)\n {\n \tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\ndiff --git a/include/linux/mount.h b/include/linux/mount.h\nindex 4880f434c021..1a508beba446 100644\n--- a/include/linux/mount.h\n+++ b/include/linux/mount.h\n@@ -116,10 +116,8 @@ extern int may_umount_tree(struct vfsmount *);\n extern int may_umount(struct vfsmount *);\n int do_mount(const char *, const char __user *,\n \t\t     const char *, unsigned long, void *);\n-extern struct vfsmount *collect_mounts(const struct path *);\n-extern void drop_collected_mounts(struct vfsmount *);\n-extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,\n-\t\t\t  struct vfsmount *);\n+extern struct path *collect_paths(const struct path *, struct path *, unsigned);\n+extern void drop_collected_paths(struct path *, struct path *);\n extern void kern_unmount_array(struct vfsmount *mnt[], unsigned int num);\n \n extern int cifs_root_data(char **dev, char **opts);\ndiff --git a/kernel/audit_tree.c b/kernel/audit_tree.c\nindex f2f38903b2fe..b0eae2a3c895 100644\n--- a/kernel/audit_tree.c\n+++ b/kernel/audit_tree.c\n@@ -668,12 +668,6 @@ int audit_remove_tree_rule(struct audit_krule *rule)\n \treturn 0;\n }\n \n-static int compare_root(struct vfsmount *mnt, void *arg)\n-{\n-\treturn inode_to_key(d_backing_inode(mnt->mnt_root)) ==\n-\t       (unsigned long)arg;\n-}\n-\n void audit_trim_trees(void)\n {\n \tstruct list_head cursor;\n@@ -683,8 +677,9 @@ void audit_trim_trees(void)\n \twhile (cursor.next != &tree_list) {\n \t\tstruct audit_tree *tree;\n \t\tstruct path path;\n-\t\tstruct vfsmount *root_mnt;\n \t\tstruct audit_node *node;\n+\t\tstruct path *paths;\n+\t\tstruct path array[16];\n \t\tint err;\n \n \t\ttree = container_of(cursor.next, struct audit_tree, list);\n@@ -696,9 +691,9 @@ void audit_trim_trees(void)\n \t\tif (err)\n \t\t\tgoto skip_it;\n \n-\t\troot_mnt = collect_mounts(&path);\n+\t\tpaths = collect_paths(&path, array, 16);\n \t\tpath_put(&path);\n-\t\tif (IS_ERR(root_mnt))\n+\t\tif (IS_ERR(paths))\n \t\t\tgoto skip_it;\n \n \t\tspin_lock(&hash_lock);\n@@ -706,14 +701,17 @@ void audit_trim_trees(void)\n \t\t\tstruct audit_chunk *chunk = find_chunk(node);\n \t\t\t/* this could be NULL if the watch is dying else where... */\n \t\t\tnode->index |= 1U<<31;\n-\t\t\tif (iterate_mounts(compare_root,\n-\t\t\t\t\t   (void *)(chunk->key),\n-\t\t\t\t\t   root_mnt))\n-\t\t\t\tnode->index &= ~(1U<<31);\n+\t\t\tfor (struct path *p = paths; p->dentry; p++) {\n+\t\t\t\tstruct inode *inode = p->dentry->d_inode;\n+\t\t\t\tif (inode_to_key(inode) == chunk->key) {\n+\t\t\t\t\tnode->index &= ~(1U<<31);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tspin_unlock(&hash_lock);\n \t\ttrim_marked(tree);\n-\t\tdrop_collected_mounts(root_mnt);\n+\t\tdrop_collected_paths(paths, array);\n skip_it:\n \t\tput_tree(tree);\n \t\tmutex_lock(&audit_filter_mutex);\n@@ -742,9 +740,14 @@ void audit_put_tree(struct audit_tree *tree)\n \tput_tree(tree);\n }\n \n-static int tag_mount(struct vfsmount *mnt, void *arg)\n+static int tag_mounts(struct path *paths, struct audit_tree *tree)\n {\n-\treturn tag_chunk(d_backing_inode(mnt->mnt_root), arg);\n+\tfor (struct path *p = paths; p->dentry; p++) {\n+\t\tint err = tag_chunk(p->dentry->d_inode, tree);\n+\t\tif (err)\n+\t\t\treturn err;\n+\t}\n+\treturn 0;\n }\n \n /*\n@@ -801,7 +804,8 @@ int audit_add_tree_rule(struct audit_krule *rule)\n {\n \tstruct audit_tree *seed = rule->tree, *tree;\n \tstruct path path;\n-\tstruct vfsmount *mnt;\n+\tstruct path array[16];\n+\tstruct path *paths;\n \tint err;\n \n \trule->tree = NULL;\n@@ -828,16 +832,16 @@ int audit_add_tree_rule(struct audit_krule *rule)\n \terr = kern_path(tree->pathname, 0, &path);\n \tif (err)\n \t\tgoto Err;\n-\tmnt = collect_mounts(&path);\n+\tpaths = collect_paths(&path, array, 16);\n \tpath_put(&path);\n-\tif (IS_ERR(mnt)) {\n-\t\terr = PTR_ERR(mnt);\n+\tif (IS_ERR(paths)) {\n+\t\terr = PTR_ERR(paths);\n \t\tgoto Err;\n \t}\n \n \tget_tree(tree);\n-\terr = iterate_mounts(tag_mount, tree, mnt);\n-\tdrop_collected_mounts(mnt);\n+\terr = tag_mounts(paths, tree);\n+\tdrop_collected_paths(paths, array);\n \n \tif (!err) {\n \t\tstruct audit_node *node;\n@@ -872,20 +876,21 @@ int audit_tag_tree(char *old, char *new)\n \tstruct list_head cursor, barrier;\n \tint failed = 0;\n \tstruct path path1, path2;\n-\tstruct vfsmount *tagged;\n+\tstruct path array[16];\n+\tstruct path *paths;\n \tint err;\n \n \terr = kern_path(new, 0, &path2);\n \tif (err)\n \t\treturn err;\n-\ttagged = collect_mounts(&path2);\n+\tpaths = collect_paths(&path2, array, 16);\n \tpath_put(&path2);\n-\tif (IS_ERR(tagged))\n-\t\treturn PTR_ERR(tagged);\n+\tif (IS_ERR(paths))\n+\t\treturn PTR_ERR(paths);\n \n \terr = kern_path(old, 0, &path1);\n \tif (err) {\n-\t\tdrop_collected_mounts(tagged);\n+\t\tdrop_collected_paths(paths, array);\n \t\treturn err;\n \t}\n \n@@ -914,7 +919,7 @@ int audit_tag_tree(char *old, char *new)\n \t\t\tcontinue;\n \t\t}\n \n-\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n+\t\tfailed = tag_mounts(paths, tree);\n \t\tif (failed) {\n \t\t\tput_tree(tree);\n \t\t\tmutex_lock(&audit_filter_mutex);\n@@ -955,7 +960,7 @@ int audit_tag_tree(char *old, char *new)\n \tlist_del(&cursor);\n \tmutex_unlock(&audit_filter_mutex);\n \tpath_put(&path1);\n-\tdrop_collected_mounts(tagged);\n+\tdrop_collected_paths(paths, array);\n \treturn failed;\n }\n ",
    "stats": {
      "insertions": 104,
      "deletions": 73,
      "files": 5
    }
  },
  {
    "sha": "00f452a1b084efbe8dcb60a29860527944a002a1",
    "message": "scsi: qla4xxx: Fix missing DMA mapping error in qla4xxx_alloc_pdu()\n\ndma_map_XXX() can fail and should be tested for errors with\ndma_mapping_error().\n\nFixes: b3a271a94d00 (\"[SCSI] qla4xxx: support iscsiadm session mgmt\")\nSigned-off-by: Thomas Fourier <fourier.thomas@gmail.com>\nLink: https://lore.kernel.org/r/20250618071742.21822-2-fourier.thomas@gmail.com\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "author": "Thomas Fourier",
    "date": "2025-06-23T13:23:45-04:00",
    "files_changed": [
      "drivers/scsi/qla4xxx/ql4_os.c"
    ],
    "diff": "diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c\nindex d4141656b204..a39f1da4ce47 100644\n--- a/drivers/scsi/qla4xxx/ql4_os.c\n+++ b/drivers/scsi/qla4xxx/ql4_os.c\n@@ -3420,6 +3420,8 @@ static int qla4xxx_alloc_pdu(struct iscsi_task *task, uint8_t opcode)\n \t\ttask_data->data_dma = dma_map_single(&ha->pdev->dev, task->data,\n \t\t\t\t\t\t     task->data_count,\n \t\t\t\t\t\t     DMA_TO_DEVICE);\n+\t\tif (dma_mapping_error(&ha->pdev->dev, task_data->data_dma))\n+\t\t\treturn -ENOMEM;\n \t}\n \n \tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: MaxRecvLen %u, iscsi hrd %d\\n\",",
    "stats": {
      "insertions": 2,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "e8d6f3ab59468e230f3253efe5cb63efa35289f7",
    "message": "nfs: Clean up /proc/net/rpc/nfs when nfs_fs_proc_net_init() fails.\n\nsyzbot reported a warning below [1] following a fault injection in\nnfs_fs_proc_net_init(). [0]\n\nWhen nfs_fs_proc_net_init() fails, /proc/net/rpc/nfs is not removed.\n\nLater, rpc_proc_exit() tries to remove /proc/net/rpc, and the warning\nis logged as the directory is not empty.\n\nLet's handle the error of nfs_fs_proc_net_init() properly.\n\n[0]:\nFAULT_INJECTION: forcing a failure.\nname failslab, interval 1, probability 0, space 0, times 0\nCPU: 1 UID: 0 PID: 6120 Comm: syz.2.27 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n  dump_stack_lvl (lib/dump_stack.c:123)\n should_fail_ex (lib/fault-inject.c:73 lib/fault-inject.c:174)\n should_failslab (mm/failslab.c:46)\n kmem_cache_alloc_noprof (mm/slub.c:4178 mm/slub.c:4204)\n __proc_create (fs/proc/generic.c:427)\n proc_create_reg (fs/proc/generic.c:554)\n proc_create_net_data (fs/proc/proc_net.c:120)\n nfs_fs_proc_net_init (fs/nfs/client.c:1409)\n nfs_net_init (fs/nfs/inode.c:2600)\n ops_init (net/core/net_namespace.c:138)\n setup_net (net/core/net_namespace.c:443)\n copy_net_ns (net/core/net_namespace.c:576)\n create_new_namespaces (kernel/nsproxy.c:110)\n unshare_nsproxy_namespaces (kernel/nsproxy.c:218 (discriminator 4))\n ksys_unshare (kernel/fork.c:3123)\n __x64_sys_unshare (kernel/fork.c:3190)\n do_syscall_64 (arch/x86/entry/syscall_64.c:63 arch/x86/entry/syscall_64.c:94)\n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\n </TASK>\n\n[1]:\nremove_proc_entry: removing non-empty directory 'net/rpc', leaking at least 'nfs'\n WARNING: CPU: 1 PID: 6120 at fs/proc/generic.c:727 remove_proc_entry+0x45e/0x530 fs/proc/generic.c:727\nModules linked in:\nCPU: 1 UID: 0 PID: 6120 Comm: syz.2.27 Not tainted 6.16.0-rc1-syzkaller-00010-g2c4a1f3fe03e #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\n RIP: 0010:remove_proc_entry+0x45e/0x530 fs/proc/generic.c:727\nCode: 3c 02 00 0f 85 85 00 00 00 48 8b 93 d8 00 00 00 4d 89 f0 4c 89 e9 48 c7 c6 40 ba a2 8b 48 c7 c7 60 b9 a2 8b e8 33 81 1d ff 90 <0f> 0b 90 90 e9 5f fe ff ff e8 04 69 5e ff 90 48 b8 00 00 00 00 00\nRSP: 0018:ffffc90003637b08 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff88805f534140 RCX: ffffffff817a92c8\nRDX: ffff88807da99e00 RSI: ffffffff817a92d5 RDI: 0000000000000001\nRBP: ffff888033431ac0 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff888033431a00\nR13: ffff888033431ae4 R14: ffff888033184724 R15: dffffc0000000000\nFS:  0000555580328500(0000) GS:ffff888124a62000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f71733743e0 CR3: 000000007f618000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n  sunrpc_exit_net+0x46/0x90 net/sunrpc/sunrpc_syms.c:76\n  ops_exit_list net/core/net_namespace.c:200 [inline]\n  ops_undo_list+0x2eb/0xab0 net/core/net_namespace.c:253\n  setup_net+0x2e1/0x510 net/core/net_namespace.c:457\n  copy_net_ns+0x2a6/0x5f0 net/core/net_namespace.c:574\n  create_new_namespaces+0x3ea/0xa90 kernel/nsproxy.c:110\n  unshare_nsproxy_namespaces+0xc0/0x1f0 kernel/nsproxy.c:218\n  ksys_unshare+0x45b/0xa40 kernel/fork.c:3121\n  __do_sys_unshare kernel/fork.c:3192 [inline]\n  __se_sys_unshare kernel/fork.c:3190 [inline]\n  __x64_sys_unshare+0x31/0x40 kernel/fork.c:3190\n  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n  do_syscall_64+0xcd/0x490 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fa1a6b8e929\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fff3a090368 EFLAGS: 00000246 ORIG_RAX: 0000000000000110\nRAX: ffffffffffffffda RBX: 00007fa1a6db5fa0 RCX: 00007fa1a6b8e929\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000080\nRBP: 00007fa1a6c10b39 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fa1a6db5fa0 R14: 00007fa1a6db5fa0 R15: 0000000000000001\n </TASK>\n\nFixes: d47151b79e32 (\"nfs: expose /proc/net/sunrpc/nfs in net namespaces\")\nReported-by: syzbot+a4cc4ac22daa4a71b87c@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=a4cc4ac22daa4a71b87c\nTested-by: syzbot+a4cc4ac22daa4a71b87c@syzkaller.appspotmail.com\nSigned-off-by: Kuniyuki Iwashima <kuniyu@google.com>\nSigned-off-by: Anna Schumaker <anna.schumaker@oracle.com>",
    "author": "Kuniyuki Iwashima",
    "date": "2025-06-23T11:01:16-04:00",
    "files_changed": [
      "fs/nfs/inode.c"
    ],
    "diff": "diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c\nindex 8ab7868807a7..a2fa6bc4d74e 100644\n--- a/fs/nfs/inode.c\n+++ b/fs/nfs/inode.c\n@@ -2589,15 +2589,26 @@ EXPORT_SYMBOL_GPL(nfs_net_id);\n static int nfs_net_init(struct net *net)\n {\n \tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n+\tint err;\n \n \tnfs_clients_init(net);\n \n \tif (!rpc_proc_register(net, &nn->rpcstats)) {\n-\t\tnfs_clients_exit(net);\n-\t\treturn -ENOMEM;\n+\t\terr = -ENOMEM;\n+\t\tgoto err_proc_rpc;\n \t}\n \n-\treturn nfs_fs_proc_net_init(net);\n+\terr = nfs_fs_proc_net_init(net);\n+\tif (err)\n+\t\tgoto err_proc_nfs;\n+\n+\treturn 0;\n+\n+err_proc_nfs:\n+\trpc_proc_unregister(net, \"nfs\");\n+err_proc_rpc:\n+\tnfs_clients_exit(net);\n+\treturn err;\n }\n \n static void nfs_net_exit(struct net *net)",
    "stats": {
      "insertions": 14,
      "deletions": 3,
      "files": 1
    }
  },
  {
    "sha": "1d6123102e9fbedc8d25bf4731da6d513173e49e",
    "message": "Bluetooth: hci_core: Fix use-after-free in vhci_flush()\n\nsyzbot reported use-after-free in vhci_flush() without repro. [0]\n\nFrom the splat, a thread close()d a vhci file descriptor while\nits device was being used by iotcl() on another thread.\n\nOnce the last fd refcnt is released, vhci_release() calls\nhci_unregister_dev(), hci_free_dev(), and kfree() for struct\nvhci_data, which is set to hci_dev->dev->driver_data.\n\nThe problem is that there is no synchronisation after unlinking\nhdev from hci_dev_list in hci_unregister_dev().  There might be\nanother thread still accessing the hdev which was fetched before\nthe unlink operation.\n\nWe can use SRCU for such synchronisation.\n\nLet's run hci_dev_reset() under SRCU and wait for its completion\nin hci_unregister_dev().\n\nAnother option would be to restore hci_dev->destruct(), which was\nremoved in commit 587ae086f6e4 (\"Bluetooth: Remove unused\nhci-destruct cb\").  However, this would not be a good solution, as\nwe should not run hci_unregister_dev() while there are in-flight\nioctl() requests, which could lead to another data-race KCSAN splat.\n\nNote that other drivers seem to have the same problem, for exmaple,\nvirtbt_remove().\n\n[0]:\nBUG: KASAN: slab-use-after-free in skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline]\nBUG: KASAN: slab-use-after-free in skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937\nRead of size 8 at addr ffff88807cb8d858 by task syz.1.219/6718\n\nCPU: 1 UID: 0 PID: 6718 Comm: syz.1.219 Not tainted 6.16.0-rc1-syzkaller-00196-g08207f42d3ff #0 PREEMPT(full)\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025\nCall Trace:\n <TASK>\n dump_stack_lvl+0x189/0x250 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0xd2/0x2b0 mm/kasan/report.c:521\n kasan_report+0x118/0x150 mm/kasan/report.c:634\n skb_queue_empty_lockless include/linux/skbuff.h:1891 [inline]\n skb_queue_purge_reason+0x99/0x360 net/core/skbuff.c:3937\n skb_queue_purge include/linux/skbuff.h:3368 [inline]\n vhci_flush+0x44/0x50 drivers/bluetooth/hci_vhci.c:69\n hci_dev_do_reset net/bluetooth/hci_core.c:552 [inline]\n hci_dev_reset+0x420/0x5c0 net/bluetooth/hci_core.c:592\n sock_do_ioctl+0xd9/0x300 net/socket.c:1190\n sock_ioctl+0x576/0x790 net/socket.c:1311\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fcf5b98e929\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fcf5c7b9038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007fcf5bbb6160 RCX: 00007fcf5b98e929\nRDX: 0000000000000000 RSI: 00000000400448cb RDI: 0000000000000009\nRBP: 00007fcf5ba10b39 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 0000000000000000 R14: 00007fcf5bbb6160 R15: 00007ffd6353d528\n </TASK>\n\nAllocated by task 6535:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x93/0xb0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __kmalloc_cache_noprof+0x230/0x3d0 mm/slub.c:4359\n kmalloc_noprof include/linux/slab.h:905 [inline]\n kzalloc_noprof include/linux/slab.h:1039 [inline]\n vhci_open+0x57/0x360 drivers/bluetooth/hci_vhci.c:635\n misc_open+0x2bc/0x330 drivers/char/misc.c:161\n chrdev_open+0x4c9/0x5e0 fs/char_dev.c:414\n do_dentry_open+0xdf0/0x1970 fs/open.c:964\n vfs_open+0x3b/0x340 fs/open.c:1094\n do_open fs/namei.c:3887 [inline]\n path_openat+0x2ee5/0x3830 fs/namei.c:4046\n do_filp_open+0x1fa/0x410 fs/namei.c:4073\n do_sys_openat2+0x121/0x1c0 fs/open.c:1437\n do_sys_open fs/open.c:1452 [inline]\n __do_sys_openat fs/open.c:1468 [inline]\n __se_sys_openat fs/open.c:1463 [inline]\n __x64_sys_openat+0x138/0x170 fs/open.c:1463\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed by task 6535:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3e/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x46/0x50 mm/kasan/generic.c:576\n poison_slab_object mm/kasan/common.c:247 [inline]\n __kasan_slab_free+0x62/0x70 mm/kasan/common.c:264\n kasan_slab_free include/linux/kasan.h:233 [inline]\n slab_free_hook mm/slub.c:2381 [inline]\n slab_free mm/slub.c:4643 [inline]\n kfree+0x18e/0x440 mm/slub.c:4842\n vhci_release+0xbc/0xd0 drivers/bluetooth/hci_vhci.c:671\n __fput+0x44c/0xa70 fs/file_table.c:465\n task_work_run+0x1d1/0x260 kernel/task_work.c:227\n exit_task_work include/linux/task_work.h:40 [inline]\n do_exit+0x6ad/0x22e0 kernel/exit.c:955\n do_group_exit+0x21c/0x2d0 kernel/exit.c:1104\n __do_sys_exit_group kernel/exit.c:1115 [inline]\n __se_sys_exit_group kernel/exit.c:1113 [inline]\n __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1113\n x64_sys_call+0x21ba/0x21c0 arch/x86/include/generated/asm/syscalls_64.h:232\n do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]\n do_syscall_64+0xfa/0x3b0 arch/x86/entry/syscall_64.c:94\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nThe buggy address belongs to the object at ffff88807cb8d800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 88 bytes inside of\n freed 1024-byte region [ffff88807cb8d800, ffff88807cb8dc00)\n\nFixes: bf18c7118cf8 (\"Bluetooth: vhci: Free driver_data on file release\")\nReported-by: syzbot+2faa4825e556199361f9@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=f62d64848fc4c7c30cd6\nSigned-off-by: Kuniyuki Iwashima <kuniyu@google.com>\nAcked-by: Paul Menzel <pmenzel@molgen.mpg.de>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>",
    "author": "Kuniyuki Iwashima",
    "date": "2025-06-23T10:59:29-04:00",
    "files_changed": [
      "include/net/bluetooth/hci_core.h",
      "net/bluetooth/hci_core.c"
    ],
    "diff": "diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h\nindex a760f05fa3fb..9fc8f544e20e 100644\n--- a/include/net/bluetooth/hci_core.h\n+++ b/include/net/bluetooth/hci_core.h\n@@ -29,6 +29,7 @@\n #include <linux/idr.h>\n #include <linux/leds.h>\n #include <linux/rculist.h>\n+#include <linux/srcu.h>\n \n #include <net/bluetooth/hci.h>\n #include <net/bluetooth/hci_drv.h>\n@@ -347,6 +348,7 @@ struct adv_monitor {\n \n struct hci_dev {\n \tstruct list_head list;\n+\tstruct srcu_struct srcu;\n \tstruct mutex\tlock;\n \n \tstruct ida\tunset_handle_ida;\ndiff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c\nindex 07a8b4281a39..14d7221b8ac0 100644\n--- a/net/bluetooth/hci_core.c\n+++ b/net/bluetooth/hci_core.c\n@@ -64,7 +64,7 @@ static DEFINE_IDA(hci_index_ida);\n \n /* Get HCI device by index.\n  * Device is held on return. */\n-struct hci_dev *hci_dev_get(int index)\n+static struct hci_dev *__hci_dev_get(int index, int *srcu_index)\n {\n \tstruct hci_dev *hdev = NULL, *d;\n \n@@ -77,6 +77,8 @@ struct hci_dev *hci_dev_get(int index)\n \tlist_for_each_entry(d, &hci_dev_list, list) {\n \t\tif (d->id == index) {\n \t\t\thdev = hci_dev_hold(d);\n+\t\t\tif (srcu_index)\n+\t\t\t\t*srcu_index = srcu_read_lock(&d->srcu);\n \t\t\tbreak;\n \t\t}\n \t}\n@@ -84,6 +86,22 @@ struct hci_dev *hci_dev_get(int index)\n \treturn hdev;\n }\n \n+struct hci_dev *hci_dev_get(int index)\n+{\n+\treturn __hci_dev_get(index, NULL);\n+}\n+\n+static struct hci_dev *hci_dev_get_srcu(int index, int *srcu_index)\n+{\n+\treturn __hci_dev_get(index, srcu_index);\n+}\n+\n+static void hci_dev_put_srcu(struct hci_dev *hdev, int srcu_index)\n+{\n+\tsrcu_read_unlock(&hdev->srcu, srcu_index);\n+\thci_dev_put(hdev);\n+}\n+\n /* ---- Inquiry support ---- */\n \n bool hci_discovery_active(struct hci_dev *hdev)\n@@ -568,9 +586,9 @@ static int hci_dev_do_reset(struct hci_dev *hdev)\n int hci_dev_reset(__u16 dev)\n {\n \tstruct hci_dev *hdev;\n-\tint err;\n+\tint err, srcu_index;\n \n-\thdev = hci_dev_get(dev);\n+\thdev = hci_dev_get_srcu(dev, &srcu_index);\n \tif (!hdev)\n \t\treturn -ENODEV;\n \n@@ -592,7 +610,7 @@ int hci_dev_reset(__u16 dev)\n \terr = hci_dev_do_reset(hdev);\n \n done:\n-\thci_dev_put(hdev);\n+\thci_dev_put_srcu(hdev, srcu_index);\n \treturn err;\n }\n \n@@ -2433,6 +2451,11 @@ struct hci_dev *hci_alloc_dev_priv(int sizeof_priv)\n \tif (!hdev)\n \t\treturn NULL;\n \n+\tif (init_srcu_struct(&hdev->srcu)) {\n+\t\tkfree(hdev);\n+\t\treturn NULL;\n+\t}\n+\n \thdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);\n \thdev->esco_type = (ESCO_HV1);\n \thdev->link_mode = (HCI_LM_ACCEPT);\n@@ -2678,6 +2701,9 @@ void hci_unregister_dev(struct hci_dev *hdev)\n \tlist_del(&hdev->list);\n \twrite_unlock(&hci_dev_list_lock);\n \n+\tsynchronize_srcu(&hdev->srcu);\n+\tcleanup_srcu_struct(&hdev->srcu);\n+\n \tdisable_work_sync(&hdev->rx_work);\n \tdisable_work_sync(&hdev->cmd_work);\n \tdisable_work_sync(&hdev->tx_work);",
    "stats": {
      "insertions": 32,
      "deletions": 4,
      "files": 2
    }
  },
  {
    "sha": "95b6759a81833d0e8c7456430186c2f6d174764e",
    "message": "net: qed: reduce stack usage for TLV processing\n\nclang gets a bit confused by the code in the qed_mfw_process_tlv_req and\nends up spilling registers to the stack hundreds of times. When sanitizers\nare enabled, this can end up blowing the stack warning limit:\n\ndrivers/net/ethernet/qlogic/qed/qed_mng_tlv.c:1244:5: error: stack frame size (1824) exceeds limit (1280) in 'qed_mfw_process_tlv_req' [-Werror,-Wframe-larger-than]\n\nApparently the problem is the complexity of qed_mfw_update_tlvs()\nafter inlining, and marking the four main branches of that function\nas noinline_for_stack makes this problem completely go away, the stack\nusage goes down to 100 bytes.\n\nSigned-off-by: Arnd Bergmann <arnd@arndb.de>\nReviewed-by: Alexander Lobakin <aleksander.lobakin@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "author": "Arnd Bergmann",
    "date": "2025-06-23T14:21:32+01:00",
    "files_changed": [
      "drivers/net/ethernet/qlogic/qed/qed_mng_tlv.c"
    ],
    "diff": "diff --git a/drivers/net/ethernet/qlogic/qed/qed_mng_tlv.c b/drivers/net/ethernet/qlogic/qed/qed_mng_tlv.c\nindex f55eed092f25..7d78f072b0a1 100644\n--- a/drivers/net/ethernet/qlogic/qed/qed_mng_tlv.c\n+++ b/drivers/net/ethernet/qlogic/qed/qed_mng_tlv.c\n@@ -242,7 +242,7 @@ static int qed_mfw_get_tlv_group(u8 tlv_type, u8 *tlv_group)\n }\n \n /* Returns size of the data buffer or, -1 in case TLV data is not available. */\n-static int\n+static noinline_for_stack int\n qed_mfw_get_gen_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \t\t\t  struct qed_mfw_tlv_generic *p_drv_buf,\n \t\t\t  struct qed_tlv_parsed_buf *p_buf)\n@@ -304,7 +304,7 @@ qed_mfw_get_gen_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \treturn -1;\n }\n \n-static int\n+static noinline_for_stack int\n qed_mfw_get_eth_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \t\t\t  struct qed_mfw_tlv_eth *p_drv_buf,\n \t\t\t  struct qed_tlv_parsed_buf *p_buf)\n@@ -438,7 +438,7 @@ qed_mfw_get_tlv_time_value(struct qed_mfw_tlv_time *p_time,\n \treturn QED_MFW_TLV_TIME_SIZE;\n }\n \n-static int\n+static noinline_for_stack int\n qed_mfw_get_fcoe_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \t\t\t   struct qed_mfw_tlv_fcoe *p_drv_buf,\n \t\t\t   struct qed_tlv_parsed_buf *p_buf)\n@@ -1073,7 +1073,7 @@ qed_mfw_get_fcoe_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \treturn -1;\n }\n \n-static int\n+static noinline_for_stack int\n qed_mfw_get_iscsi_tlv_value(struct qed_drv_tlv_hdr *p_tlv,\n \t\t\t    struct qed_mfw_tlv_iscsi *p_drv_buf,\n \t\t\t    struct qed_tlv_parsed_buf *p_buf)",
    "stats": {
      "insertions": 4,
      "deletions": 4,
      "files": 1
    }
  }
]
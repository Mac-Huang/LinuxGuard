[
  {
    "sha": "75f99f8cf445d577132ed97514032d9a3d3e2758",
    "message": "Merge tag 'v6.16-rc2-smb3-client-fixes-v2' of git://git.samba.org/sfrench/cifs-2.6\n\nPull smb client fixes from Steve French:\n\n - Multichannel channel allocation fix for Kerberos mounts\n\n - Two reconnect fixes\n\n - Fix netfs_writepages crash with smbdirect/RDMA\n\n - Directory caching fix\n\n - Three minor cleanup fixes\n\n - Log error when close cached dirs fails\n\n* tag 'v6.16-rc2-smb3-client-fixes-v2' of git://git.samba.org/sfrench/cifs-2.6:\n  smb: minor fix to use SMB2_NTLMV2_SESSKEY_SIZE for auth_key size\n  smb: minor fix to use sizeof to initialize flags_string buffer\n  smb: Use loff_t for directory position in cached_dirents\n  smb: Log an error when close_all_cached_dirs fails\n  cifs: Fix prepare_write to negotiate wsize if needed\n  smb: client: fix max_sge overflow in smb_extract_folioq_to_rdma()\n  smb: client: fix first command failure during re-negotiation\n  cifs: Remove duplicate fattr->cf_dtype assignment from wsl_to_fattr() function\n  smb: fix secondary channel creation issue with kerberos by populating hostname when adding channels",
    "author": "Linus Torvalds",
    "date": "2025-06-22T09:46:11-07:00",
    "files_changed": [
      "fs/smb/client/cached_dir.c",
      "fs/smb/client/cached_dir.h",
      "fs/smb/client/cifs_debug.c",
      "fs/smb/client/cifs_ioctl.h",
      "fs/smb/client/connect.c",
      "fs/smb/client/file.c",
      "fs/smb/client/ioctl.c",
      "fs/smb/client/reparse.c",
      "fs/smb/client/sess.c",
      "fs/smb/client/smbdirect.c"
    ],
    "diff": "diff --git a/fs/smb/client/cached_dir.c b/fs/smb/client/cached_dir.c\nindex 5200a0f3cafc..368e870624da 100644\n--- a/fs/smb/client/cached_dir.c\n+++ b/fs/smb/client/cached_dir.c\n@@ -509,8 +509,17 @@ void close_all_cached_dirs(struct cifs_sb_info *cifs_sb)\n \t\tspin_lock(&cfids->cfid_list_lock);\n \t\tlist_for_each_entry(cfid, &cfids->entries, entry) {\n \t\t\ttmp_list = kmalloc(sizeof(*tmp_list), GFP_ATOMIC);\n-\t\t\tif (tmp_list == NULL)\n-\t\t\t\tbreak;\n+\t\t\tif (tmp_list == NULL) {\n+\t\t\t\t/*\n+\t\t\t\t * If the malloc() fails, we won't drop all\n+\t\t\t\t * dentries, and unmounting is likely to trigger\n+\t\t\t\t * a 'Dentry still in use' error.\n+\t\t\t\t */\n+\t\t\t\tcifs_tcon_dbg(VFS, \"Out of memory while dropping dentries\\n\");\n+\t\t\t\tspin_unlock(&cfids->cfid_list_lock);\n+\t\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n+\t\t\t\tgoto done;\n+\t\t\t}\n \t\t\tspin_lock(&cfid->fid_lock);\n \t\t\ttmp_list->dentry = cfid->dentry;\n \t\t\tcfid->dentry = NULL;\n@@ -522,6 +531,7 @@ void close_all_cached_dirs(struct cifs_sb_info *cifs_sb)\n \t}\n \tspin_unlock(&cifs_sb->tlink_tree_lock);\n \n+done:\n \tlist_for_each_entry_safe(tmp_list, q, &entry, entry) {\n \t\tlist_del(&tmp_list->entry);\n \t\tdput(tmp_list->dentry);\ndiff --git a/fs/smb/client/cached_dir.h b/fs/smb/client/cached_dir.h\nindex bc8a812ff95f..a28f7cae3caa 100644\n--- a/fs/smb/client/cached_dir.h\n+++ b/fs/smb/client/cached_dir.h\n@@ -26,7 +26,7 @@ struct cached_dirents {\n \t\t\t    * open file instance.\n \t\t\t    */\n \tstruct mutex de_mutex;\n-\tint pos;\t\t /* Expected ctx->pos */\n+\tloff_t pos;\t\t /* Expected ctx->pos */\n \tstruct list_head entries;\n };\n \ndiff --git a/fs/smb/client/cifs_debug.c b/fs/smb/client/cifs_debug.c\nindex c0196be0e65f..3fdf75737d43 100644\n--- a/fs/smb/client/cifs_debug.c\n+++ b/fs/smb/client/cifs_debug.c\n@@ -1105,7 +1105,7 @@ static ssize_t cifs_security_flags_proc_write(struct file *file,\n \tif ((count < 1) || (count > 11))\n \t\treturn -EINVAL;\n \n-\tmemset(flags_string, 0, 12);\n+\tmemset(flags_string, 0, sizeof(flags_string));\n \n \tif (copy_from_user(flags_string, buffer, count))\n \t\treturn -EFAULT;\ndiff --git a/fs/smb/client/cifs_ioctl.h b/fs/smb/client/cifs_ioctl.h\nindex 26327442e383..b51ce64fcccf 100644\n--- a/fs/smb/client/cifs_ioctl.h\n+++ b/fs/smb/client/cifs_ioctl.h\n@@ -61,7 +61,7 @@ struct smb_query_info {\n struct smb3_key_debug_info {\n \t__u64\tSuid;\n \t__u16\tcipher_type;\n-\t__u8\tauth_key[16]; /* SMB2_NTLMV2_SESSKEY_SIZE */\n+\t__u8\tauth_key[SMB2_NTLMV2_SESSKEY_SIZE];\n \t__u8\tsmb3encryptionkey[SMB3_SIGN_KEY_SIZE];\n \t__u8\tsmb3decryptionkey[SMB3_SIGN_KEY_SIZE];\n } __packed;\ndiff --git a/fs/smb/client/connect.c b/fs/smb/client/connect.c\nindex c4fb80b37738..c48869c29e15 100644\n--- a/fs/smb/client/connect.c\n+++ b/fs/smb/client/connect.c\n@@ -4199,6 +4199,7 @@ cifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses,\n \t\treturn 0;\n \t}\n \n+\tserver->lstrp = jiffies;\n \tserver->tcpStatus = CifsInNegotiate;\n \tspin_unlock(&server->srv_lock);\n \ndiff --git a/fs/smb/client/file.c b/fs/smb/client/file.c\nindex 9835672267d2..e9212da32f01 100644\n--- a/fs/smb/client/file.c\n+++ b/fs/smb/client/file.c\n@@ -52,6 +52,7 @@ static void cifs_prepare_write(struct netfs_io_subrequest *subreq)\n \tstruct netfs_io_stream *stream = &req->rreq.io_streams[subreq->stream_nr];\n \tstruct TCP_Server_Info *server;\n \tstruct cifsFileInfo *open_file = req->cfile;\n+\tstruct cifs_sb_info *cifs_sb = CIFS_SB(wdata->rreq->inode->i_sb);\n \tsize_t wsize = req->rreq.wsize;\n \tint rc;\n \n@@ -63,6 +64,10 @@ static void cifs_prepare_write(struct netfs_io_subrequest *subreq)\n \tserver = cifs_pick_channel(tlink_tcon(open_file->tlink)->ses);\n \twdata->server = server;\n \n+\tif (cifs_sb->ctx->wsize == 0)\n+\t\tcifs_negotiate_wsize(server, cifs_sb->ctx,\n+\t\t\t\t     tlink_tcon(req->cfile->tlink));\n+\n retry:\n \tif (open_file->invalidHandle) {\n \t\trc = cifs_reopen_file(open_file, false);\n@@ -160,10 +165,9 @@ static int cifs_prepare_read(struct netfs_io_subrequest *subreq)\n \tserver = cifs_pick_channel(tlink_tcon(req->cfile->tlink)->ses);\n \trdata->server = server;\n \n-\tif (cifs_sb->ctx->rsize == 0) {\n+\tif (cifs_sb->ctx->rsize == 0)\n \t\tcifs_negotiate_rsize(server, cifs_sb->ctx,\n \t\t\t\t     tlink_tcon(req->cfile->tlink));\n-\t}\n \n \trc = server->ops->wait_mtu_credits(server, cifs_sb->ctx->rsize,\n \t\t\t\t\t   &size, &rdata->credits);\ndiff --git a/fs/smb/client/ioctl.c b/fs/smb/client/ioctl.c\nindex 56439da4f119..0a9935ce05a5 100644\n--- a/fs/smb/client/ioctl.c\n+++ b/fs/smb/client/ioctl.c\n@@ -506,7 +506,7 @@ long cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)\n \t\t\t\tle16_to_cpu(tcon->ses->server->cipher_type);\n \t\t\tpkey_inf.Suid = tcon->ses->Suid;\n \t\t\tmemcpy(pkey_inf.auth_key, tcon->ses->auth_key.response,\n-\t\t\t\t\t16 /* SMB2_NTLMV2_SESSKEY_SIZE */);\n+\t\t\t\t  SMB2_NTLMV2_SESSKEY_SIZE);\n \t\t\tmemcpy(pkey_inf.smb3decryptionkey,\n \t\t\t      tcon->ses->smb3decryptionkey, SMB3_SIGN_KEY_SIZE);\n \t\t\tmemcpy(pkey_inf.smb3encryptionkey,\ndiff --git a/fs/smb/client/reparse.c b/fs/smb/client/reparse.c\nindex bb25e77c5540..511611206dab 100644\n--- a/fs/smb/client/reparse.c\n+++ b/fs/smb/client/reparse.c\n@@ -1172,7 +1172,6 @@ static bool wsl_to_fattr(struct cifs_open_info_data *data,\n \tif (!have_xattr_dev && (tag == IO_REPARSE_TAG_LX_CHR || tag == IO_REPARSE_TAG_LX_BLK))\n \t\treturn false;\n \n-\tfattr->cf_dtype = S_DT(fattr->cf_mode);\n \treturn true;\n }\n \ndiff --git a/fs/smb/client/sess.c b/fs/smb/client/sess.c\nindex ec0db32c7d98..330bc3d25bad 100644\n--- a/fs/smb/client/sess.c\n+++ b/fs/smb/client/sess.c\n@@ -498,8 +498,7 @@ cifs_ses_add_channel(struct cifs_ses *ses,\n \tctx->domainauto = ses->domainAuto;\n \tctx->domainname = ses->domainName;\n \n-\t/* no hostname for extra channels */\n-\tctx->server_hostname = \"\";\n+\tctx->server_hostname = ses->server->hostname;\n \n \tctx->username = ses->user_name;\n \tctx->password = ses->password;\ndiff --git a/fs/smb/client/smbdirect.c b/fs/smb/client/smbdirect.c\nindex 5ae847919da5..cbc85bca006f 100644\n--- a/fs/smb/client/smbdirect.c\n+++ b/fs/smb/client/smbdirect.c\n@@ -2589,13 +2589,14 @@ static ssize_t smb_extract_folioq_to_rdma(struct iov_iter *iter,\n \t\tsize_t fsize = folioq_folio_size(folioq, slot);\n \n \t\tif (offset < fsize) {\n-\t\t\tsize_t part = umin(maxsize - ret, fsize - offset);\n+\t\t\tsize_t part = umin(maxsize, fsize - offset);\n \n \t\t\tif (!smb_set_sge(rdma, folio_page(folio, 0), offset, part))\n \t\t\t\treturn -EIO;\n \n \t\t\toffset += part;\n \t\t\tret += part;\n+\t\t\tmaxsize -= part;\n \t\t}\n \n \t\tif (offset >= fsize) {\n@@ -2610,7 +2611,7 @@ static ssize_t smb_extract_folioq_to_rdma(struct iov_iter *iter,\n \t\t\t\tslot = 0;\n \t\t\t}\n \t\t}\n-\t} while (rdma->nr_sge < rdma->max_sge || maxsize > 0);\n+\t} while (rdma->nr_sge < rdma->max_sge && maxsize > 0);\n \n \titer->folioq = folioq;\n \titer->folioq_slot = slot;",
    "stats": {
      "insertions": 27,
      "deletions": 13,
      "files": 10
    }
  },
  {
    "sha": "72c0d9cb0fc48b6d382c3b5b6f702108a612cfdb",
    "message": "bcachefs: Fix range in bch2_lookup_indirect_extent() error path\n\nBefore calling bch2_indirect_extent_missing_error(), we have to\ncalculate the missing range, which is the intersection of the reflink\npointer and the non-indirect-extent we found.\n\nThe calculation didn't take into account that the returned extent may\nspan the iter position, leading to an infinite loop when we\n(unnecessarily) resized the extent we were returning to one that didn't\nextend past the offset we were looking up.\n\nSigned-off-by: Kent Overstreet <kent.overstreet@linux.dev>",
    "author": "Kent Overstreet",
    "date": "2025-06-22T00:29:03-04:00",
    "files_changed": [
      "fs/bcachefs/reflink.c"
    ],
    "diff": "diff --git a/fs/bcachefs/reflink.c b/fs/bcachefs/reflink.c\nindex a535abd44df3..92b90cfe622b 100644\n--- a/fs/bcachefs/reflink.c\n+++ b/fs/bcachefs/reflink.c\n@@ -64,6 +64,9 @@ void bch2_reflink_p_to_text(struct printbuf *out, struct bch_fs *c,\n \t       REFLINK_P_IDX(p.v),\n \t       le32_to_cpu(p.v->front_pad),\n \t       le32_to_cpu(p.v->back_pad));\n+\n+\tif (REFLINK_P_ERROR(p.v))\n+\t\tprt_str(out, \" error\");\n }\n \n bool bch2_reflink_p_merge(struct bch_fs *c, struct bkey_s _l, struct bkey_s_c _r)\n@@ -269,13 +272,12 @@ struct bkey_s_c bch2_lookup_indirect_extent(struct btree_trans *trans,\n \t\treturn k;\n \n \tif (unlikely(!bkey_extent_is_reflink_data(k.k))) {\n-\t\tunsigned size = min((u64) k.k->size,\n-\t\t\t\t    REFLINK_P_IDX(p.v) + p.k->size + le32_to_cpu(p.v->back_pad) -\n-\t\t\t\t    reflink_offset);\n-\t\tbch2_key_resize(&iter->k, size);\n+\t\tu64 missing_end = min(k.k->p.offset,\n+\t\t\t\t      REFLINK_P_IDX(p.v) + p.k->size + le32_to_cpu(p.v->back_pad));\n+\t\tBUG_ON(reflink_offset == missing_end);\n \n \t\tint ret = bch2_indirect_extent_missing_error(trans, p, reflink_offset,\n-\t\t\t\t\t\t\t     k.k->p.offset, should_commit);\n+\t\t\t\t\t\t\t     missing_end, should_commit);\n \t\tif (ret) {\n \t\t\tbch2_trans_iter_exit(trans, iter);\n \t\t\treturn bkey_s_c_err(ret);",
    "stats": {
      "insertions": 7,
      "deletions": 5,
      "files": 1
    }
  },
  {
    "sha": "4eb11a34b72c86d559f437fdadc47e512bba41d2",
    "message": "smb: Use loff_t for directory position in cached_dirents\n\nChange the pos field in struct cached_dirents from int to loff_t\nto support large directory offsets. This avoids overflow and\nmatches kernel conventions for directory positions.\n\nReviewed-by: Paulo Alcantara (Red Hat) <pc@manguebit.org>\nSigned-off-by: Bharath SM <bharathsm@microsoft.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "author": "Bharath SM",
    "date": "2025-06-21T11:03:25-05:00",
    "files_changed": [
      "fs/smb/client/cached_dir.h"
    ],
    "diff": "diff --git a/fs/smb/client/cached_dir.h b/fs/smb/client/cached_dir.h\nindex bc8a812ff95f..a28f7cae3caa 100644\n--- a/fs/smb/client/cached_dir.h\n+++ b/fs/smb/client/cached_dir.h\n@@ -26,7 +26,7 @@ struct cached_dirents {\n \t\t\t    * open file instance.\n \t\t\t    */\n \tstruct mutex de_mutex;\n-\tint pos;\t\t /* Expected ctx->pos */\n+\tloff_t pos;\t\t /* Expected ctx->pos */\n \tstruct list_head entries;\n };\n ",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "a379a8a2a0032e12e7ef397197c9c2ad011588d6",
    "message": "smb: client: fix max_sge overflow in smb_extract_folioq_to_rdma()\n\nThis fixes the following problem:\n\n[  749.901015] [   T8673] run fstests cifs/001 at 2025-06-17 09:40:30\n[  750.346409] [   T9870] ==================================================================\n[  750.346814] [   T9870] BUG: KASAN: slab-out-of-bounds in smb_set_sge+0x2cc/0x3b0 [cifs]\n[  750.347330] [   T9870] Write of size 8 at addr ffff888011082890 by task xfs_io/9870\n[  750.347705] [   T9870]\n[  750.348077] [   T9870] CPU: 0 UID: 0 PID: 9870 Comm: xfs_io Kdump: loaded Not tainted 6.16.0-rc2-metze.02+ #1 PREEMPT(voluntary)\n[  750.348082] [   T9870] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006\n[  750.348085] [   T9870] Call Trace:\n[  750.348086] [   T9870]  <TASK>\n[  750.348088] [   T9870]  dump_stack_lvl+0x76/0xa0\n[  750.348106] [   T9870]  print_report+0xd1/0x640\n[  750.348116] [   T9870]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[  750.348120] [   T9870]  ? kasan_complete_mode_report_info+0x26/0x210\n[  750.348124] [   T9870]  kasan_report+0xe7/0x130\n[  750.348128] [   T9870]  ? smb_set_sge+0x2cc/0x3b0 [cifs]\n[  750.348262] [   T9870]  ? smb_set_sge+0x2cc/0x3b0 [cifs]\n[  750.348377] [   T9870]  __asan_report_store8_noabort+0x17/0x30\n[  750.348381] [   T9870]  smb_set_sge+0x2cc/0x3b0 [cifs]\n[  750.348496] [   T9870]  smbd_post_send_iter+0x1990/0x3070 [cifs]\n[  750.348625] [   T9870]  ? __pfx_smbd_post_send_iter+0x10/0x10 [cifs]\n[  750.348741] [   T9870]  ? update_stack_state+0x2a0/0x670\n[  750.348749] [   T9870]  ? cifs_flush+0x153/0x320 [cifs]\n[  750.348870] [   T9870]  ? cifs_flush+0x153/0x320 [cifs]\n[  750.348990] [   T9870]  ? update_stack_state+0x2a0/0x670\n[  750.348995] [   T9870]  smbd_send+0x58c/0x9c0 [cifs]\n[  750.349117] [   T9870]  ? __pfx_smbd_send+0x10/0x10 [cifs]\n[  750.349231] [   T9870]  ? unwind_get_return_address+0x65/0xb0\n[  750.349235] [   T9870]  ? __pfx_stack_trace_consume_entry+0x10/0x10\n[  750.349242] [   T9870]  ? arch_stack_walk+0xa7/0x100\n[  750.349250] [   T9870]  ? stack_trace_save+0x92/0xd0\n[  750.349254] [   T9870]  __smb_send_rqst+0x931/0xec0 [cifs]\n[  750.349374] [   T9870]  ? kernel_text_address+0x173/0x190\n[  750.349379] [   T9870]  ? kasan_save_stack+0x39/0x70\n[  750.349382] [   T9870]  ? kasan_save_track+0x18/0x70\n[  750.349385] [   T9870]  ? __kasan_slab_alloc+0x9d/0xa0\n[  750.349389] [   T9870]  ? __pfx___smb_send_rqst+0x10/0x10 [cifs]\n[  750.349508] [   T9870]  ? smb2_mid_entry_alloc+0xb4/0x7e0 [cifs]\n[  750.349626] [   T9870]  ? cifs_call_async+0x277/0xb00 [cifs]\n[  750.349746] [   T9870]  ? cifs_issue_write+0x256/0x610 [cifs]\n[  750.349867] [   T9870]  ? netfs_do_issue_write+0xc2/0x340 [netfs]\n[  750.349900] [   T9870]  ? netfs_advance_write+0x45b/0x1270 [netfs]\n[  750.349929] [   T9870]  ? netfs_write_folio+0xd6c/0x1be0 [netfs]\n[  750.349958] [   T9870]  ? netfs_writepages+0x2e9/0xa80 [netfs]\n[  750.349987] [   T9870]  ? do_writepages+0x21f/0x590\n[  750.349993] [   T9870]  ? filemap_fdatawrite_wbc+0xe1/0x140\n[  750.349997] [   T9870]  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.350002] [   T9870]  smb_send_rqst+0x22e/0x2f0 [cifs]\n[  750.350131] [   T9870]  ? __pfx_smb_send_rqst+0x10/0x10 [cifs]\n[  750.350255] [   T9870]  ? local_clock_noinstr+0xe/0xd0\n[  750.350261] [   T9870]  ? kasan_save_alloc_info+0x37/0x60\n[  750.350268] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.350271] [   T9870]  ? _raw_spin_lock+0x81/0xf0\n[  750.350275] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.350278] [   T9870]  ? smb2_setup_async_request+0x293/0x580 [cifs]\n[  750.350398] [   T9870]  cifs_call_async+0x477/0xb00 [cifs]\n[  750.350518] [   T9870]  ? __pfx_smb2_writev_callback+0x10/0x10 [cifs]\n[  750.350636] [   T9870]  ? __pfx_cifs_call_async+0x10/0x10 [cifs]\n[  750.350756] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.350760] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.350763] [   T9870]  ? __smb2_plain_req_init+0x933/0x1090 [cifs]\n[  750.350891] [   T9870]  smb2_async_writev+0x15ff/0x2460 [cifs]\n[  750.351008] [   T9870]  ? sched_clock_noinstr+0x9/0x10\n[  750.351012] [   T9870]  ? local_clock_noinstr+0xe/0xd0\n[  750.351018] [   T9870]  ? __pfx_smb2_async_writev+0x10/0x10 [cifs]\n[  750.351144] [   T9870]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[  750.351150] [   T9870]  ? _raw_spin_unlock+0xe/0x40\n[  750.351154] [   T9870]  ? cifs_pick_channel+0x242/0x370 [cifs]\n[  750.351275] [   T9870]  cifs_issue_write+0x256/0x610 [cifs]\n[  750.351554] [   T9870]  ? cifs_issue_write+0x256/0x610 [cifs]\n[  750.351677] [   T9870]  netfs_do_issue_write+0xc2/0x340 [netfs]\n[  750.351710] [   T9870]  netfs_advance_write+0x45b/0x1270 [netfs]\n[  750.351740] [   T9870]  ? rolling_buffer_append+0x12d/0x440 [netfs]\n[  750.351769] [   T9870]  netfs_write_folio+0xd6c/0x1be0 [netfs]\n[  750.351798] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.351804] [   T9870]  netfs_writepages+0x2e9/0xa80 [netfs]\n[  750.351835] [   T9870]  ? __pfx_netfs_writepages+0x10/0x10 [netfs]\n[  750.351864] [   T9870]  ? exit_files+0xab/0xe0\n[  750.351867] [   T9870]  ? do_exit+0x148f/0x2980\n[  750.351871] [   T9870]  ? do_group_exit+0xb5/0x250\n[  750.351874] [   T9870]  ? arch_do_signal_or_restart+0x92/0x630\n[  750.351879] [   T9870]  ? exit_to_user_mode_loop+0x98/0x170\n[  750.351882] [   T9870]  ? do_syscall_64+0x2cf/0xd80\n[  750.351886] [   T9870]  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.351890] [   T9870]  do_writepages+0x21f/0x590\n[  750.351894] [   T9870]  ? __pfx_do_writepages+0x10/0x10\n[  750.351897] [   T9870]  filemap_fdatawrite_wbc+0xe1/0x140\n[  750.351901] [   T9870]  __filemap_fdatawrite_range+0xba/0x100\n[  750.351904] [   T9870]  ? __pfx___filemap_fdatawrite_range+0x10/0x10\n[  750.351912] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.351916] [   T9870]  filemap_write_and_wait_range+0x7d/0xf0\n[  750.351920] [   T9870]  cifs_flush+0x153/0x320 [cifs]\n[  750.352042] [   T9870]  filp_flush+0x107/0x1a0\n[  750.352046] [   T9870]  filp_close+0x14/0x30\n[  750.352049] [   T9870]  put_files_struct.part.0+0x126/0x2a0\n[  750.352053] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.352058] [   T9870]  exit_files+0xab/0xe0\n[  750.352061] [   T9870]  do_exit+0x148f/0x2980\n[  750.352065] [   T9870]  ? __pfx_do_exit+0x10/0x10\n[  750.352069] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.352072] [   T9870]  ? _raw_spin_lock_irq+0x8a/0xf0\n[  750.352076] [   T9870]  do_group_exit+0xb5/0x250\n[  750.352080] [   T9870]  get_signal+0x22d3/0x22e0\n[  750.352086] [   T9870]  ? __pfx_get_signal+0x10/0x10\n[  750.352089] [   T9870]  ? fpregs_assert_state_consistent+0x68/0x100\n[  750.352101] [   T9870]  ? folio_add_lru+0xda/0x120\n[  750.352105] [   T9870]  arch_do_signal_or_restart+0x92/0x630\n[  750.352109] [   T9870]  ? __pfx_arch_do_signal_or_restart+0x10/0x10\n[  750.352115] [   T9870]  exit_to_user_mode_loop+0x98/0x170\n[  750.352118] [   T9870]  do_syscall_64+0x2cf/0xd80\n[  750.352123] [   T9870]  ? __kasan_check_read+0x11/0x20\n[  750.352126] [   T9870]  ? count_memcg_events+0x1b4/0x420\n[  750.352132] [   T9870]  ? handle_mm_fault+0x148/0x690\n[  750.352136] [   T9870]  ? _raw_spin_lock_irq+0x8a/0xf0\n[  750.352140] [   T9870]  ? __kasan_check_read+0x11/0x20\n[  750.352143] [   T9870]  ? fpregs_assert_state_consistent+0x68/0x100\n[  750.352146] [   T9870]  ? irqentry_exit_to_user_mode+0x2e/0x250\n[  750.352151] [   T9870]  ? irqentry_exit+0x43/0x50\n[  750.352154] [   T9870]  ? exc_page_fault+0x75/0xe0\n[  750.352160] [   T9870]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.352163] [   T9870] RIP: 0033:0x7858c94ab6e2\n[  750.352167] [   T9870] Code: Unable to access opcode bytes at 0x7858c94ab6b8.\n[  750.352175] [   T9870] RSP: 002b:00007858c9248ce8 EFLAGS: 00000246 ORIG_RAX: 0000000000000022\n[  750.352179] [   T9870] RAX: fffffffffffffdfe RBX: 00007858c92496c0 RCX: 00007858c94ab6e2\n[  750.352182] [   T9870] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n[  750.352184] [   T9870] RBP: 00007858c9248d10 R08: 0000000000000000 R09: 0000000000000000\n[  750.352185] [   T9870] R10: 0000000000000000 R11: 0000000000000246 R12: fffffffffffffde0\n[  750.352187] [   T9870] R13: 0000000000000020 R14: 0000000000000002 R15: 00007ffc072d2230\n[  750.352191] [   T9870]  </TASK>\n[  750.352195] [   T9870]\n[  750.395206] [   T9870] Allocated by task 9870 on cpu 0 at 750.346406s:\n[  750.395523] [   T9870]  kasan_save_stack+0x39/0x70\n[  750.395532] [   T9870]  kasan_save_track+0x18/0x70\n[  750.395536] [   T9870]  kasan_save_alloc_info+0x37/0x60\n[  750.395539] [   T9870]  __kasan_slab_alloc+0x9d/0xa0\n[  750.395543] [   T9870]  kmem_cache_alloc_noprof+0x13c/0x3f0\n[  750.395548] [   T9870]  mempool_alloc_slab+0x15/0x20\n[  750.395553] [   T9870]  mempool_alloc_noprof+0x135/0x340\n[  750.395557] [   T9870]  smbd_post_send_iter+0x63e/0x3070 [cifs]\n[  750.395694] [   T9870]  smbd_send+0x58c/0x9c0 [cifs]\n[  750.395819] [   T9870]  __smb_send_rqst+0x931/0xec0 [cifs]\n[  750.395950] [   T9870]  smb_send_rqst+0x22e/0x2f0 [cifs]\n[  750.396081] [   T9870]  cifs_call_async+0x477/0xb00 [cifs]\n[  750.396232] [   T9870]  smb2_async_writev+0x15ff/0x2460 [cifs]\n[  750.396359] [   T9870]  cifs_issue_write+0x256/0x610 [cifs]\n[  750.396492] [   T9870]  netfs_do_issue_write+0xc2/0x340 [netfs]\n[  750.396544] [   T9870]  netfs_advance_write+0x45b/0x1270 [netfs]\n[  750.396576] [   T9870]  netfs_write_folio+0xd6c/0x1be0 [netfs]\n[  750.396608] [   T9870]  netfs_writepages+0x2e9/0xa80 [netfs]\n[  750.396639] [   T9870]  do_writepages+0x21f/0x590\n[  750.396643] [   T9870]  filemap_fdatawrite_wbc+0xe1/0x140\n[  750.396647] [   T9870]  __filemap_fdatawrite_range+0xba/0x100\n[  750.396651] [   T9870]  filemap_write_and_wait_range+0x7d/0xf0\n[  750.396656] [   T9870]  cifs_flush+0x153/0x320 [cifs]\n[  750.396787] [   T9870]  filp_flush+0x107/0x1a0\n[  750.396791] [   T9870]  filp_close+0x14/0x30\n[  750.396795] [   T9870]  put_files_struct.part.0+0x126/0x2a0\n[  750.396800] [   T9870]  exit_files+0xab/0xe0\n[  750.396803] [   T9870]  do_exit+0x148f/0x2980\n[  750.396808] [   T9870]  do_group_exit+0xb5/0x250\n[  750.396813] [   T9870]  get_signal+0x22d3/0x22e0\n[  750.396817] [   T9870]  arch_do_signal_or_restart+0x92/0x630\n[  750.396822] [   T9870]  exit_to_user_mode_loop+0x98/0x170\n[  750.396827] [   T9870]  do_syscall_64+0x2cf/0xd80\n[  750.396832] [   T9870]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.396836] [   T9870]\n[  750.397150] [   T9870] The buggy address belongs to the object at ffff888011082800\n                           which belongs to the cache smbd_request_0000000008f3bd7b of size 144\n[  750.397798] [   T9870] The buggy address is located 0 bytes to the right of\n                           allocated 144-byte region [ffff888011082800, ffff888011082890)\n[  750.398469] [   T9870]\n[  750.398800] [   T9870] The buggy address belongs to the physical page:\n[  750.399141] [   T9870] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x11082\n[  750.399148] [   T9870] flags: 0xfffffc0000000(node=0|zone=1|lastcpupid=0x1fffff)\n[  750.399155] [   T9870] page_type: f5(slab)\n[  750.399161] [   T9870] raw: 000fffffc0000000 ffff888022d65640 dead000000000122 0000000000000000\n[  750.399165] [   T9870] raw: 0000000000000000 0000000080100010 00000000f5000000 0000000000000000\n[  750.399169] [   T9870] page dumped because: kasan: bad access detected\n[  750.399172] [   T9870]\n[  750.399505] [   T9870] Memory state around the buggy address:\n[  750.399863] [   T9870]  ffff888011082780: fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  750.400247] [   T9870]  ffff888011082800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[  750.400618] [   T9870] >ffff888011082880: 00 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  750.400982] [   T9870]                          ^\n[  750.401370] [   T9870]  ffff888011082900: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  750.401774] [   T9870]  ffff888011082980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[  750.402171] [   T9870] ==================================================================\n[  750.402696] [   T9870] Disabling lock debugging due to kernel taint\n[  750.403202] [   T9870] BUG: unable to handle page fault for address: ffff8880110a2000\n[  750.403797] [   T9870] #PF: supervisor write access in kernel mode\n[  750.404204] [   T9870] #PF: error_code(0x0003) - permissions violation\n[  750.404581] [   T9870] PGD 5ce01067 P4D 5ce01067 PUD 5ce02067 PMD 78aa063 PTE 80000000110a2021\n[  750.404969] [   T9870] Oops: Oops: 0003 [#1] SMP KASAN PTI\n[  750.405394] [   T9870] CPU: 0 UID: 0 PID: 9870 Comm: xfs_io Kdump: loaded Tainted: G    B               6.16.0-rc2-metze.02+ #1 PREEMPT(voluntary)\n[  750.406510] [   T9870] Tainted: [B]=BAD_PAGE\n[  750.406967] [   T9870] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006\n[  750.407440] [   T9870] RIP: 0010:smb_set_sge+0x15c/0x3b0 [cifs]\n[  750.408065] [   T9870] Code: 48 83 f8 ff 0f 84 b0 00 00 00 48 ba 00 00 00 00 00 fc ff df 4c 89 e1 48 c1 e9 03 80 3c 11 00 0f 85 69 01 00 00 49 8d 7c 24 08 <49> 89 04 24 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 0f\n[  750.409283] [   T9870] RSP: 0018:ffffc90005e2e758 EFLAGS: 00010246\n[  750.409803] [   T9870] RAX: ffff888036c53400 RBX: ffffc90005e2e878 RCX: 1ffff11002214400\n[  750.410323] [   T9870] RDX: dffffc0000000000 RSI: dffffc0000000000 RDI: ffff8880110a2008\n[  750.411217] [   T9870] RBP: ffffc90005e2e798 R08: 0000000000000001 R09: 0000000000000400\n[  750.411770] [   T9870] R10: ffff888011082800 R11: 0000000000000000 R12: ffff8880110a2000\n[  750.412325] [   T9870] R13: 0000000000000000 R14: ffffc90005e2e888 R15: ffff88801a4b6000\n[  750.412901] [   T9870] FS:  0000000000000000(0000) GS:ffff88812bc68000(0000) knlGS:0000000000000000\n[  750.413477] [   T9870] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  750.414077] [   T9870] CR2: ffff8880110a2000 CR3: 000000005b0a6005 CR4: 00000000000726f0\n[  750.414654] [   T9870] Call Trace:\n[  750.415211] [   T9870]  <TASK>\n[  750.415748] [   T9870]  smbd_post_send_iter+0x1990/0x3070 [cifs]\n[  750.416449] [   T9870]  ? __pfx_smbd_post_send_iter+0x10/0x10 [cifs]\n[  750.417128] [   T9870]  ? update_stack_state+0x2a0/0x670\n[  750.417685] [   T9870]  ? cifs_flush+0x153/0x320 [cifs]\n[  750.418380] [   T9870]  ? cifs_flush+0x153/0x320 [cifs]\n[  750.419055] [   T9870]  ? update_stack_state+0x2a0/0x670\n[  750.419624] [   T9870]  smbd_send+0x58c/0x9c0 [cifs]\n[  750.420297] [   T9870]  ? __pfx_smbd_send+0x10/0x10 [cifs]\n[  750.420936] [   T9870]  ? unwind_get_return_address+0x65/0xb0\n[  750.421456] [   T9870]  ? __pfx_stack_trace_consume_entry+0x10/0x10\n[  750.421954] [   T9870]  ? arch_stack_walk+0xa7/0x100\n[  750.422460] [   T9870]  ? stack_trace_save+0x92/0xd0\n[  750.422948] [   T9870]  __smb_send_rqst+0x931/0xec0 [cifs]\n[  750.423579] [   T9870]  ? kernel_text_address+0x173/0x190\n[  750.424056] [   T9870]  ? kasan_save_stack+0x39/0x70\n[  750.424813] [   T9870]  ? kasan_save_track+0x18/0x70\n[  750.425323] [   T9870]  ? __kasan_slab_alloc+0x9d/0xa0\n[  750.425831] [   T9870]  ? __pfx___smb_send_rqst+0x10/0x10 [cifs]\n[  750.426548] [   T9870]  ? smb2_mid_entry_alloc+0xb4/0x7e0 [cifs]\n[  750.427231] [   T9870]  ? cifs_call_async+0x277/0xb00 [cifs]\n[  750.427882] [   T9870]  ? cifs_issue_write+0x256/0x610 [cifs]\n[  750.428909] [   T9870]  ? netfs_do_issue_write+0xc2/0x340 [netfs]\n[  750.429425] [   T9870]  ? netfs_advance_write+0x45b/0x1270 [netfs]\n[  750.429882] [   T9870]  ? netfs_write_folio+0xd6c/0x1be0 [netfs]\n[  750.430345] [   T9870]  ? netfs_writepages+0x2e9/0xa80 [netfs]\n[  750.430809] [   T9870]  ? do_writepages+0x21f/0x590\n[  750.431239] [   T9870]  ? filemap_fdatawrite_wbc+0xe1/0x140\n[  750.431652] [   T9870]  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.432041] [   T9870]  smb_send_rqst+0x22e/0x2f0 [cifs]\n[  750.432586] [   T9870]  ? __pfx_smb_send_rqst+0x10/0x10 [cifs]\n[  750.433108] [   T9870]  ? local_clock_noinstr+0xe/0xd0\n[  750.433482] [   T9870]  ? kasan_save_alloc_info+0x37/0x60\n[  750.433855] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.434214] [   T9870]  ? _raw_spin_lock+0x81/0xf0\n[  750.434561] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.434903] [   T9870]  ? smb2_setup_async_request+0x293/0x580 [cifs]\n[  750.435394] [   T9870]  cifs_call_async+0x477/0xb00 [cifs]\n[  750.435892] [   T9870]  ? __pfx_smb2_writev_callback+0x10/0x10 [cifs]\n[  750.436388] [   T9870]  ? __pfx_cifs_call_async+0x10/0x10 [cifs]\n[  750.436881] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.437237] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.437579] [   T9870]  ? __smb2_plain_req_init+0x933/0x1090 [cifs]\n[  750.438062] [   T9870]  smb2_async_writev+0x15ff/0x2460 [cifs]\n[  750.438557] [   T9870]  ? sched_clock_noinstr+0x9/0x10\n[  750.438906] [   T9870]  ? local_clock_noinstr+0xe/0xd0\n[  750.439293] [   T9870]  ? __pfx_smb2_async_writev+0x10/0x10 [cifs]\n[  750.439786] [   T9870]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10\n[  750.440143] [   T9870]  ? _raw_spin_unlock+0xe/0x40\n[  750.440495] [   T9870]  ? cifs_pick_channel+0x242/0x370 [cifs]\n[  750.440989] [   T9870]  cifs_issue_write+0x256/0x610 [cifs]\n[  750.441492] [   T9870]  ? cifs_issue_write+0x256/0x610 [cifs]\n[  750.441987] [   T9870]  netfs_do_issue_write+0xc2/0x340 [netfs]\n[  750.442387] [   T9870]  netfs_advance_write+0x45b/0x1270 [netfs]\n[  750.442969] [   T9870]  ? rolling_buffer_append+0x12d/0x440 [netfs]\n[  750.443376] [   T9870]  netfs_write_folio+0xd6c/0x1be0 [netfs]\n[  750.443768] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.444145] [   T9870]  netfs_writepages+0x2e9/0xa80 [netfs]\n[  750.444541] [   T9870]  ? __pfx_netfs_writepages+0x10/0x10 [netfs]\n[  750.444936] [   T9870]  ? exit_files+0xab/0xe0\n[  750.445312] [   T9870]  ? do_exit+0x148f/0x2980\n[  750.445672] [   T9870]  ? do_group_exit+0xb5/0x250\n[  750.446028] [   T9870]  ? arch_do_signal_or_restart+0x92/0x630\n[  750.446402] [   T9870]  ? exit_to_user_mode_loop+0x98/0x170\n[  750.446762] [   T9870]  ? do_syscall_64+0x2cf/0xd80\n[  750.447132] [   T9870]  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.447499] [   T9870]  do_writepages+0x21f/0x590\n[  750.447859] [   T9870]  ? __pfx_do_writepages+0x10/0x10\n[  750.448236] [   T9870]  filemap_fdatawrite_wbc+0xe1/0x140\n[  750.448595] [   T9870]  __filemap_fdatawrite_range+0xba/0x100\n[  750.448953] [   T9870]  ? __pfx___filemap_fdatawrite_range+0x10/0x10\n[  750.449336] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.449697] [   T9870]  filemap_write_and_wait_range+0x7d/0xf0\n[  750.450062] [   T9870]  cifs_flush+0x153/0x320 [cifs]\n[  750.450592] [   T9870]  filp_flush+0x107/0x1a0\n[  750.450952] [   T9870]  filp_close+0x14/0x30\n[  750.451322] [   T9870]  put_files_struct.part.0+0x126/0x2a0\n[  750.451678] [   T9870]  ? __pfx__raw_spin_lock+0x10/0x10\n[  750.452033] [   T9870]  exit_files+0xab/0xe0\n[  750.452401] [   T9870]  do_exit+0x148f/0x2980\n[  750.452751] [   T9870]  ? __pfx_do_exit+0x10/0x10\n[  750.453109] [   T9870]  ? __kasan_check_write+0x14/0x30\n[  750.453459] [   T9870]  ? _raw_spin_lock_irq+0x8a/0xf0\n[  750.453787] [   T9870]  do_group_exit+0xb5/0x250\n[  750.454082] [   T9870]  get_signal+0x22d3/0x22e0\n[  750.454406] [   T9870]  ? __pfx_get_signal+0x10/0x10\n[  750.454709] [   T9870]  ? fpregs_assert_state_consistent+0x68/0x100\n[  750.455031] [   T9870]  ? folio_add_lru+0xda/0x120\n[  750.455347] [   T9870]  arch_do_signal_or_restart+0x92/0x630\n[  750.455656] [   T9870]  ? __pfx_arch_do_signal_or_restart+0x10/0x10\n[  750.455967] [   T9870]  exit_to_user_mode_loop+0x98/0x170\n[  750.456282] [   T9870]  do_syscall_64+0x2cf/0xd80\n[  750.456591] [   T9870]  ? __kasan_check_read+0x11/0x20\n[  750.456897] [   T9870]  ? count_memcg_events+0x1b4/0x420\n[  750.457280] [   T9870]  ? handle_mm_fault+0x148/0x690\n[  750.457616] [   T9870]  ? _raw_spin_lock_irq+0x8a/0xf0\n[  750.457925] [   T9870]  ? __kasan_check_read+0x11/0x20\n[  750.458297] [   T9870]  ? fpregs_assert_state_consistent+0x68/0x100\n[  750.458672] [   T9870]  ? irqentry_exit_to_user_mode+0x2e/0x250\n[  750.459191] [   T9870]  ? irqentry_exit+0x43/0x50\n[  750.459600] [   T9870]  ? exc_page_fault+0x75/0xe0\n[  750.460130] [   T9870]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  750.460570] [   T9870] RIP: 0033:0x7858c94ab6e2\n[  750.461206] [   T9870] Code: Unable to access opcode bytes at 0x7858c94ab6b8.\n[  750.461780] [   T9870] RSP: 002b:00007858c9248ce8 EFLAGS: 00000246 ORIG_RAX: 0000000000000022\n[  750.462327] [   T9870] RAX: fffffffffffffdfe RBX: 00007858c92496c0 RCX: 00007858c94ab6e2\n[  750.462653] [   T9870] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n[  750.462969] [   T9870] RBP: 00007858c9248d10 R08: 0000000000000000 R09: 0000000000000000\n[  750.463290] [   T9870] R10: 0000000000000000 R11: 0000000000000246 R12: fffffffffffffde0\n[  750.463640] [   T9870] R13: 0000000000000020 R14: 0000000000000002 R15: 00007ffc072d2230\n[  750.463965] [   T9870]  </TASK>\n[  750.464285] [   T9870] Modules linked in: siw ib_uverbs ccm cmac nls_utf8 cifs cifs_arc4 nls_ucs2_utils rdma_cm iw_cm ib_cm ib_core cifs_md4 netfs softdog vboxsf vboxguest cpuid intel_rapl_msr intel_rapl_common intel_uncore_frequency_common intel_pmc_core pmt_telemetry pmt_class intel_pmc_ssram_telemetry intel_vsec polyval_clmulni ghash_clmulni_intel sha1_ssse3 aesni_intel rapl i2c_piix4 i2c_smbus joydev input_leds mac_hid sunrpc binfmt_misc kvm_intel kvm irqbypass sch_fq_codel efi_pstore nfnetlink vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock vmw_vmci dmi_sysfs ip_tables x_tables autofs4 hid_generic vboxvideo usbhid drm_vram_helper psmouse vga16fb vgastate drm_ttm_helper serio_raw hid ahci libahci ttm pata_acpi video wmi [last unloaded: vboxguest]\n[  750.467127] [   T9870] CR2: ffff8880110a2000\n\ncc: Tom Talpey <tom@talpey.com>\ncc: linux-cifs@vger.kernel.org\nReviewed-by: David Howells <dhowells@redhat.com>\nReviewed-by: Tom Talpey <tom@talpey.com>\nFixes: c45ebd636c32 (\"cifs: Provide the capability to extract from ITER_FOLIOQ to RDMA SGEs\")\nSigned-off-by: Stefan Metzmacher <metze@samba.org>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "author": "Stefan Metzmacher",
    "date": "2025-06-21T11:03:24-05:00",
    "files_changed": [
      "fs/smb/client/smbdirect.c"
    ],
    "diff": "diff --git a/fs/smb/client/smbdirect.c b/fs/smb/client/smbdirect.c\nindex 5ae847919da5..cbc85bca006f 100644\n--- a/fs/smb/client/smbdirect.c\n+++ b/fs/smb/client/smbdirect.c\n@@ -2589,13 +2589,14 @@ static ssize_t smb_extract_folioq_to_rdma(struct iov_iter *iter,\n \t\tsize_t fsize = folioq_folio_size(folioq, slot);\n \n \t\tif (offset < fsize) {\n-\t\t\tsize_t part = umin(maxsize - ret, fsize - offset);\n+\t\t\tsize_t part = umin(maxsize, fsize - offset);\n \n \t\t\tif (!smb_set_sge(rdma, folio_page(folio, 0), offset, part))\n \t\t\t\treturn -EIO;\n \n \t\t\toffset += part;\n \t\t\tret += part;\n+\t\t\tmaxsize -= part;\n \t\t}\n \n \t\tif (offset >= fsize) {\n@@ -2610,7 +2611,7 @@ static ssize_t smb_extract_folioq_to_rdma(struct iov_iter *iter,\n \t\t\t\tslot = 0;\n \t\t\t}\n \t\t}\n-\t} while (rdma->nr_sge < rdma->max_sge || maxsize > 0);\n+\t} while (rdma->nr_sge < rdma->max_sge && maxsize > 0);\n \n \titer->folioq = folioq;\n \titer->folioq_slot = slot;",
    "stats": {
      "insertions": 3,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "26fef998eb4df8781c038ffa4be8287219a8df0a",
    "message": "Merge tag 'acpi-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm\n\nPull ACPI fix from Rafael Wysocki:\n \"Fix a crash in ACPICA while attempting to evaluate a control method\n  that expects more arguments than are being passed to it, which was\n  exposed by a defective firmware update from a prominent OEM on\n  multiple systems (Rafael Wysocki)\"\n\n* tag 'acpi-6.16-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:\n  ACPICA: Refuse to evaluate a method if arguments are missing",
    "author": "Linus Torvalds",
    "date": "2025-06-21T08:27:12-07:00",
    "files_changed": [
      "drivers/acpi/acpica/dsmethod.c"
    ],
    "diff": "diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c\nindex c8f37f4e6626..fef6fb29ece4 100644\n--- a/drivers/acpi/acpica/dsmethod.c\n+++ b/drivers/acpi/acpica/dsmethod.c\n@@ -483,6 +483,13 @@ acpi_ds_call_control_method(struct acpi_thread_state *thread,\n \t\treturn_ACPI_STATUS(AE_NULL_OBJECT);\n \t}\n \n+\tif (this_walk_state->num_operands < obj_desc->method.param_count) {\n+\t\tACPI_ERROR((AE_INFO, \"Missing argument for method [%4.4s]\",\n+\t\t\t    acpi_ut_get_node_name(method_node)));\n+\n+\t\treturn_ACPI_STATUS(AE_AML_UNINITIALIZED_ARG);\n+\t}\n+\n \t/* Init for new method, possibly wait on method mutex */\n \n \tstatus =",
    "stats": {
      "insertions": 7,
      "deletions": 0,
      "files": 1
    }
  }
]
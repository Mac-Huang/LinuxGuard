[
  {
    "sha": "9a5d769c9084678c0f21c3f9cf83ca17466a16fb",
    "message": "Merge tag 'ffa-fixes-6.16' of https://git.kernel.org/pub/scm/linux/kernel/git/sudeep.holla/linux into arm/fixes\n\nArm FF-A fixes for v6.16\n\nCouple of fixes to address:\n\n1. The safety and memory issues in the FF-A notification callback handler:\n\n   The fixes replaces a mutex with an rwlock to prevent sleeping in atomic\n   context, resolving kernel warnings. Memory allocation is moved outside\n   the lock to support this transition safely. Additionally, a memory leak\n   in the notifier unregistration path is fixed by properly freeing the\n   callback node.\n\n2. The missing entry in struct ffa_indirect_msg_hdr:\n\n   The fix adds the missing 32 bit reserved entry in the structure as\n   required by the FF-A specification.\n\n* tag 'ffa-fixes-6.16' of https://git.kernel.org/pub/scm/linux/kernel/git/sudeep.holla/linux:\n  firmware: arm_ffa: Fix the missing entry in struct ffa_indirect_msg_hdr\n  firmware: arm_ffa: Replace mutex with rwlock to avoid sleep in atomic context\n  firmware: arm_ffa: Move memory allocation outside the mutex locking\n  firmware: arm_ffa: Fix memory leak by freeing notifier callback node\n\nLink: https://lore.kernel.org/r/20250609105207.1185570-1-sudeep.holla@arm.com\nSigned-off-by: Arnd Bergmann <arnd@arndb.de>",
    "author": "Arnd Bergmann",
    "date": "2025-07-03T13:56:21+02:00",
    "files_changed": [
      "drivers/firmware/arm_ffa/driver.c",
      "include/linux/arm_ffa.h"
    ],
    "diff": "diff --git a/drivers/firmware/arm_ffa/driver.c b/drivers/firmware/arm_ffa/driver.c\nindex fe55613a8ea9..37eb2e6c2f9f 100644\n--- a/drivers/firmware/arm_ffa/driver.c\n+++ b/drivers/firmware/arm_ffa/driver.c\n@@ -110,7 +110,7 @@ struct ffa_drv_info {\n \tstruct work_struct sched_recv_irq_work;\n \tstruct xarray partition_info;\n \tDECLARE_HASHTABLE(notifier_hash, ilog2(FFA_MAX_NOTIFICATIONS));\n-\tstruct mutex notify_lock; /* lock to protect notifier hashtable  */\n+\trwlock_t notify_lock; /* lock to protect notifier hashtable  */\n };\n \n static struct ffa_drv_info *drv_info;\n@@ -1250,13 +1250,12 @@ notifier_hnode_get_by_type(u16 notify_id, enum notify_type type)\n \treturn NULL;\n }\n \n-static int\n-update_notifier_cb(struct ffa_device *dev, int notify_id, void *cb,\n-\t\t   void *cb_data, bool is_registration, bool is_framework)\n+static int update_notifier_cb(struct ffa_device *dev, int notify_id,\n+\t\t\t      struct notifier_cb_info *cb, bool is_framework)\n {\n \tstruct notifier_cb_info *cb_info = NULL;\n \tenum notify_type type = ffa_notify_type_get(dev->vm_id);\n-\tbool cb_found;\n+\tbool cb_found, is_registration = !!cb;\n \n \tif (is_framework)\n \t\tcb_info = notifier_hnode_get_by_vmid_uuid(notify_id, dev->vm_id,\n@@ -1270,20 +1269,10 @@ update_notifier_cb(struct ffa_device *dev, int notify_id, void *cb,\n \t\treturn -EINVAL;\n \n \tif (is_registration) {\n-\t\tcb_info = kzalloc(sizeof(*cb_info), GFP_KERNEL);\n-\t\tif (!cb_info)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tcb_info->dev = dev;\n-\t\tcb_info->cb_data = cb_data;\n-\t\tif (is_framework)\n-\t\t\tcb_info->fwk_cb = cb;\n-\t\telse\n-\t\t\tcb_info->cb = cb;\n-\n-\t\thash_add(drv_info->notifier_hash, &cb_info->hnode, notify_id);\n+\t\thash_add(drv_info->notifier_hash, &cb->hnode, notify_id);\n \t} else {\n \t\thash_del(&cb_info->hnode);\n+\t\tkfree(cb_info);\n \t}\n \n \treturn 0;\n@@ -1300,20 +1289,19 @@ static int __ffa_notify_relinquish(struct ffa_device *dev, int notify_id,\n \tif (notify_id >= FFA_MAX_NOTIFICATIONS)\n \t\treturn -EINVAL;\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\twrite_lock(&drv_info->notify_lock);\n \n-\trc = update_notifier_cb(dev, notify_id, NULL, NULL, false,\n-\t\t\t\tis_framework);\n+\trc = update_notifier_cb(dev, notify_id, NULL, is_framework);\n \tif (rc) {\n \t\tpr_err(\"Could not unregister notification callback\\n\");\n-\t\tmutex_unlock(&drv_info->notify_lock);\n+\t\twrite_unlock(&drv_info->notify_lock);\n \t\treturn rc;\n \t}\n \n \tif (!is_framework)\n \t\trc = ffa_notification_unbind(dev->vm_id, BIT(notify_id));\n \n-\tmutex_unlock(&drv_info->notify_lock);\n+\twrite_unlock(&drv_info->notify_lock);\n \n \treturn rc;\n }\n@@ -1334,6 +1322,7 @@ static int __ffa_notify_request(struct ffa_device *dev, bool is_per_vcpu,\n {\n \tint rc;\n \tu32 flags = 0;\n+\tstruct notifier_cb_info *cb_info = NULL;\n \n \tif (ffa_notifications_disabled())\n \t\treturn -EOPNOTSUPP;\n@@ -1341,28 +1330,40 @@ static int __ffa_notify_request(struct ffa_device *dev, bool is_per_vcpu,\n \tif (notify_id >= FFA_MAX_NOTIFICATIONS)\n \t\treturn -EINVAL;\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\tcb_info = kzalloc(sizeof(*cb_info), GFP_KERNEL);\n+\tif (!cb_info)\n+\t\treturn -ENOMEM;\n+\n+\tcb_info->dev = dev;\n+\tcb_info->cb_data = cb_data;\n+\tif (is_framework)\n+\t\tcb_info->fwk_cb = cb;\n+\telse\n+\t\tcb_info->cb = cb;\n+\n+\twrite_lock(&drv_info->notify_lock);\n \n \tif (!is_framework) {\n \t\tif (is_per_vcpu)\n \t\t\tflags = PER_VCPU_NOTIFICATION_FLAG;\n \n \t\trc = ffa_notification_bind(dev->vm_id, BIT(notify_id), flags);\n-\t\tif (rc) {\n-\t\t\tmutex_unlock(&drv_info->notify_lock);\n-\t\t\treturn rc;\n-\t\t}\n+\t\tif (rc)\n+\t\t\tgoto out_unlock_free;\n \t}\n \n-\trc = update_notifier_cb(dev, notify_id, cb, cb_data, true,\n-\t\t\t\tis_framework);\n+\trc = update_notifier_cb(dev, notify_id, cb_info, is_framework);\n \tif (rc) {\n \t\tpr_err(\"Failed to register callback for %d - %d\\n\",\n \t\t       notify_id, rc);\n \t\tif (!is_framework)\n \t\t\tffa_notification_unbind(dev->vm_id, BIT(notify_id));\n \t}\n-\tmutex_unlock(&drv_info->notify_lock);\n+\n+out_unlock_free:\n+\twrite_unlock(&drv_info->notify_lock);\n+\tif (rc)\n+\t\tkfree(cb_info);\n \n \treturn rc;\n }\n@@ -1406,9 +1407,9 @@ static void handle_notif_callbacks(u64 bitmap, enum notify_type type)\n \t\tif (!(bitmap & 1))\n \t\t\tcontinue;\n \n-\t\tmutex_lock(&drv_info->notify_lock);\n+\t\tread_lock(&drv_info->notify_lock);\n \t\tcb_info = notifier_hnode_get_by_type(notify_id, type);\n-\t\tmutex_unlock(&drv_info->notify_lock);\n+\t\tread_unlock(&drv_info->notify_lock);\n \n \t\tif (cb_info && cb_info->cb)\n \t\t\tcb_info->cb(notify_id, cb_info->cb_data);\n@@ -1446,9 +1447,9 @@ static void handle_fwk_notif_callbacks(u32 bitmap)\n \n \tffa_rx_release();\n \n-\tmutex_lock(&drv_info->notify_lock);\n+\tread_lock(&drv_info->notify_lock);\n \tcb_info = notifier_hnode_get_by_vmid_uuid(notify_id, target, &uuid);\n-\tmutex_unlock(&drv_info->notify_lock);\n+\tread_unlock(&drv_info->notify_lock);\n \n \tif (cb_info && cb_info->fwk_cb)\n \t\tcb_info->fwk_cb(notify_id, cb_info->cb_data, buf);\n@@ -1973,7 +1974,7 @@ static void ffa_notifications_setup(void)\n \t\tgoto cleanup;\n \n \thash_init(drv_info->notifier_hash);\n-\tmutex_init(&drv_info->notify_lock);\n+\trwlock_init(&drv_info->notify_lock);\n \n \tdrv_info->notif_enabled = true;\n \treturn;\ndiff --git a/include/linux/arm_ffa.h b/include/linux/arm_ffa.h\nindex 5bded24dc24f..e1634897e159 100644\n--- a/include/linux/arm_ffa.h\n+++ b/include/linux/arm_ffa.h\n@@ -283,6 +283,7 @@ struct ffa_indirect_msg_hdr {\n \tu32 offset;\n \tu32 send_recv_id;\n \tu32 size;\n+\tu32 res1;\n \tuuid_t uuid;\n };\n ",
    "stats": {
      "insertions": 37,
      "deletions": 35,
      "files": 2
    }
  },
  {
    "sha": "45ebc7e6c125ce93d2ddf82cd5bea20121bb0258",
    "message": "virtio_ring: Fix error reporting in virtqueue_resize\n\nThe virtqueue_resize() function was not correctly propagating error codes\nfrom its internal resize helper functions, specifically\nvirtqueue_resize_packet() and virtqueue_resize_split(). If these helpers\nreturned an error, but the subsequent call to virtqueue_enable_after_reset()\nsucceeded, the original error from the resize operation would be masked.\nConsequently, virtqueue_resize() could incorrectly report success to its\ncaller despite an underlying resize failure.\n\nThis change restores the original code behavior:\n\n       if (vdev->config->enable_vq_after_reset(_vq))\n               return -EBUSY;\n\n       return err;\n\nFix: commit ad48d53b5b3f (\"virtio_ring: separate the logic of reset/enable from virtqueue_resize\")\nCc: xuanzhuo@linux.alibaba.com\nSigned-off-by: Laurent Vivier <lvivier@redhat.com>\nAcked-by: Jason Wang <jasowang@redhat.com>\nLink: https://patch.msgid.link/20250521092236.661410-2-lvivier@redhat.com\nTested-by: Lei Yang <leiyang@redhat.com>\nAcked-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
    "author": "Laurent Vivier",
    "date": "2025-07-03T11:40:02+02:00",
    "files_changed": [
      "drivers/virtio/virtio_ring.c"
    ],
    "diff": "diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c\nindex b784aab66867..4397392bfef0 100644\n--- a/drivers/virtio/virtio_ring.c\n+++ b/drivers/virtio/virtio_ring.c\n@@ -2797,7 +2797,7 @@ int virtqueue_resize(struct virtqueue *_vq, u32 num,\n \t\t     void (*recycle_done)(struct virtqueue *vq))\n {\n \tstruct vring_virtqueue *vq = to_vvq(_vq);\n-\tint err;\n+\tint err, err_reset;\n \n \tif (num > vq->vq.num_max)\n \t\treturn -E2BIG;\n@@ -2819,7 +2819,11 @@ int virtqueue_resize(struct virtqueue *_vq, u32 num,\n \telse\n \t\terr = virtqueue_resize_split(_vq, num);\n \n-\treturn virtqueue_enable_after_reset(_vq);\n+\terr_reset = virtqueue_enable_after_reset(_vq);\n+\tif (err_reset)\n+\t\treturn err_reset;\n+\n+\treturn err;\n }\n EXPORT_SYMBOL_GPL(virtqueue_resize);\n ",
    "stats": {
      "insertions": 6,
      "deletions": 2,
      "files": 1
    }
  },
  {
    "sha": "38224c472a038fa9ccd4085511dd9f3d6119dbf9",
    "message": "HID: appletb-kbd: fix slab use-after-free bug in appletb_kbd_probe\n\nIn probe appletb_kbd_probe() a \"struct appletb_kbd *kbd\" is allocated\nvia devm_kzalloc() to store touch bar keyboard related data.\nLater on if backlight_device_get_by_name() finds a backlight device\nwith name \"appletb_backlight\" a timer (kbd->inactivity_timer) is setup\nwith appletb_inactivity_timer() and the timer is armed to run after\nappletb_tb_dim_timeout (60) seconds.\n\nA use-after-free is triggered when failure occurs after the timer is\narmed. This ultimately means probe failure occurs and as a result the\n\"struct appletb_kbd *kbd\" which is device managed memory is freed.\nAfter 60 seconds the timer will have expired and __run_timers will\nattempt to access the timer (kbd->inactivity_timer) however the kdb\nstructure has been freed causing a use-after free.\n\n[   71.636938] ==================================================================\n[   71.637915] BUG: KASAN: slab-use-after-free in __run_timers+0x7ad/0x890\n[   71.637915] Write of size 8 at addr ffff8881178c5958 by task swapper/1/0\n[   71.637915]\n[   71.637915] CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Not tainted 6.16.0-rc2-00318-g739a6c93cc75-dirty #12 PREEMPT(voluntary)\n[   71.637915] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n[   71.637915] Call Trace:\n[   71.637915]  <IRQ>\n[   71.637915]  dump_stack_lvl+0x53/0x70\n[   71.637915]  print_report+0xce/0x670\n[   71.637915]  ? __run_timers+0x7ad/0x890\n[   71.637915]  kasan_report+0xce/0x100\n[   71.637915]  ? __run_timers+0x7ad/0x890\n[   71.637915]  __run_timers+0x7ad/0x890\n[   71.637915]  ? __pfx___run_timers+0x10/0x10\n[   71.637915]  ? update_process_times+0xfc/0x190\n[   71.637915]  ? __pfx_update_process_times+0x10/0x10\n[   71.637915]  ? _raw_spin_lock_irq+0x80/0xe0\n[   71.637915]  ? _raw_spin_lock_irq+0x80/0xe0\n[   71.637915]  ? __pfx__raw_spin_lock_irq+0x10/0x10\n[   71.637915]  run_timer_softirq+0x141/0x240\n[   71.637915]  ? __pfx_run_timer_softirq+0x10/0x10\n[   71.637915]  ? __pfx___hrtimer_run_queues+0x10/0x10\n[   71.637915]  ? kvm_clock_get_cycles+0x18/0x30\n[   71.637915]  ? ktime_get+0x60/0x140\n[   71.637915]  handle_softirqs+0x1b8/0x5c0\n[   71.637915]  ? __pfx_handle_softirqs+0x10/0x10\n[   71.637915]  irq_exit_rcu+0xaf/0xe0\n[   71.637915]  sysvec_apic_timer_interrupt+0x6c/0x80\n[   71.637915]  </IRQ>\n[   71.637915]\n[   71.637915] Allocated by task 39:\n[   71.637915]  kasan_save_stack+0x33/0x60\n[   71.637915]  kasan_save_track+0x14/0x30\n[   71.637915]  __kasan_kmalloc+0x8f/0xa0\n[   71.637915]  __kmalloc_node_track_caller_noprof+0x195/0x420\n[   71.637915]  devm_kmalloc+0x74/0x1e0\n[   71.637915]  appletb_kbd_probe+0x37/0x3c0\n[   71.637915]  hid_device_probe+0x2d1/0x680\n[   71.637915]  really_probe+0x1c3/0x690\n[   71.637915]  __driver_probe_device+0x247/0x300\n[   71.637915]  driver_probe_device+0x49/0x210\n[...]\n[   71.637915]\n[   71.637915] Freed by task 39:\n[   71.637915]  kasan_save_stack+0x33/0x60\n[   71.637915]  kasan_save_track+0x14/0x30\n[   71.637915]  kasan_save_free_info+0x3b/0x60\n[   71.637915]  __kasan_slab_free+0x37/0x50\n[   71.637915]  kfree+0xcf/0x360\n[   71.637915]  devres_release_group+0x1f8/0x3c0\n[   71.637915]  hid_device_probe+0x315/0x680\n[   71.637915]  really_probe+0x1c3/0x690\n[   71.637915]  __driver_probe_device+0x247/0x300\n[   71.637915]  driver_probe_device+0x49/0x210\n[...]\n\nThe root cause of the issue is that the timer is not disarmed\non failure paths leading to it remaining active and accessing\nfreed memory. To fix this call timer_delete_sync() to deactivate\nthe timer.\n\nAnother small issue is that timer_delete_sync is called\nunconditionally in appletb_kbd_remove(), fix this by checking\nfor a valid kbd->backlight_dev before calling timer_delete_sync.\n\nFixes: 93a0fc489481 (\"HID: hid-appletb-kbd: add support for automatic brightness control while using the touchbar\")\nCc: stable@vger.kernel.org\nSigned-off-by: Qasim Ijaz <qasdev00@gmail.com>\nReviewed-by: Aditya Garg <gargaditya08@live.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.com>",
    "author": "Qasim Ijaz",
    "date": "2025-07-03T11:34:49+02:00",
    "files_changed": [
      "drivers/hid/hid-appletb-kbd.c"
    ],
    "diff": "diff --git a/drivers/hid/hid-appletb-kbd.c b/drivers/hid/hid-appletb-kbd.c\nindex b5d9e50bc231..271d1b27b8dd 100644\n--- a/drivers/hid/hid-appletb-kbd.c\n+++ b/drivers/hid/hid-appletb-kbd.c\n@@ -440,8 +440,10 @@ static int appletb_kbd_probe(struct hid_device *hdev, const struct hid_device_id\n unregister_handler:\n \tinput_unregister_handler(&kbd->inp_handler);\n close_hw:\n-\tif (kbd->backlight_dev)\n+\tif (kbd->backlight_dev) {\n \t\tput_device(&kbd->backlight_dev->dev);\n+\t\ttimer_delete_sync(&kbd->inactivity_timer);\n+\t}\n \thid_hw_close(hdev);\n stop_hw:\n \thid_hw_stop(hdev);\n@@ -455,10 +457,10 @@ static void appletb_kbd_remove(struct hid_device *hdev)\n \tappletb_kbd_set_mode(kbd, APPLETB_KBD_MODE_OFF);\n \n \tinput_unregister_handler(&kbd->inp_handler);\n-\ttimer_delete_sync(&kbd->inactivity_timer);\n-\n-\tif (kbd->backlight_dev)\n+\tif (kbd->backlight_dev) {\n \t\tput_device(&kbd->backlight_dev->dev);\n+\t\ttimer_delete_sync(&kbd->inactivity_timer);\n+\t}\n \n \thid_hw_close(hdev);\n \thid_hw_stop(hdev);",
    "stats": {
      "insertions": 6,
      "deletions": 4,
      "files": 1
    }
  },
  {
    "sha": "ba677dbe77af5ffe6204e0f3f547f3ba059c6302",
    "message": "perf: Revert to requiring CAP_SYS_ADMIN for uprobes\n\nJann reports that uprobes can be used destructively when used in the\nmiddle of an instruction. The kernel only verifies there is a valid\ninstruction at the requested offset, but due to variable instruction\nlength cannot determine if this is an instruction as seen by the\nintended execution stream.\n\nAdditionally, Mark Rutland notes that on architectures that mix data\nin the text segment (like arm64), a similar things can be done if the\ndata word is 'mistaken' for an instruction.\n\nAs such, require CAP_SYS_ADMIN for uprobes.\n\nFixes: c9e0924e5c2b (\"perf/core: open access to probes for CAP_PERFMON privileged process\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nLink: https://lkml.kernel.org/r/CAG48ez1n4520sq0XrWYDHKiKxE_+WCfAK+qt9qkY4ZiBGmL-5g@mail.gmail.com",
    "author": "Peter Zijlstra",
    "date": "2025-07-03T10:33:55+02:00",
    "files_changed": [
      "kernel/events/core.c"
    ],
    "diff": "diff --git a/kernel/events/core.c b/kernel/events/core.c\nindex bf2118c22126..0db36b2b2448 100644\n--- a/kernel/events/core.c\n+++ b/kernel/events/core.c\n@@ -11116,7 +11116,7 @@ static int perf_uprobe_event_init(struct perf_event *event)\n \tif (event->attr.type != perf_uprobe.type)\n \t\treturn -ENOENT;\n \n-\tif (!perfmon_capable())\n+\tif (!capable(CAP_SYS_ADMIN))\n \t\treturn -EACCES;\n \n \t/*",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "c80f2b047d5cc42fbd2dff9d1942d4ba7545100f",
    "message": "HID: appletb-kbd: fix memory corruption of input_handler_list\n\nIn appletb_kbd_probe an input handler is initialised and then registered\nwith input core through input_register_handler(). When this happens input\ncore will add the input handler (specifically its node) to the global\ninput_handler_list. The input_handler_list is central to the functionality\nof input core and is traversed in various places in input core. An example\nof this is when a new input device is plugged in and gets registered with\ninput core.\n\nThe input_handler in probe is allocated as device managed memory. If a\nprobe failure occurs after input_register_handler() the input_handler\nmemory is freed, yet it will remain in the input_handler_list. This\neffectively means the input_handler_list contains a dangling pointer\nto data belonging to a freed input handler.\n\nThis causes an issue when any other input device is plugged in - in my\ncase I had an old PixArt HP USB optical mouse and I decided to\nplug it in after a failure occurred after input_register_handler().\nThis lead to the registration of this input device via\ninput_register_device which involves traversing over every handler\nin the corrupted input_handler_list and calling input_attach_handler(),\ngiving each handler a chance to bind to newly registered device.\n\nThe core of this bug is a UAF which causes memory corruption of\ninput_handler_list and to fix it we must ensure the input handler is\nunregistered from input core, this is done through\ninput_unregister_handler().\n\n[   63.191597] ==================================================================\n[   63.192094] BUG: KASAN: slab-use-after-free in input_attach_handler.isra.0+0x1a9/0x1e0\n[   63.192094] Read of size 8 at addr ffff888105ea7c80 by task kworker/0:2/54\n[   63.192094]\n[   63.192094] CPU: 0 UID: 0 PID: 54 Comm: kworker/0:2 Not tainted 6.16.0-rc2-00321-g2aa6621d\n[   63.192094] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.164\n[   63.192094] Workqueue: usb_hub_wq hub_event\n[   63.192094] Call Trace:\n[   63.192094]  <TASK>\n[   63.192094]  dump_stack_lvl+0x53/0x70\n[   63.192094]  print_report+0xce/0x670\n[   63.192094]  kasan_report+0xce/0x100\n[   63.192094]  input_attach_handler.isra.0+0x1a9/0x1e0\n[   63.192094]  input_register_device+0x76c/0xd00\n[   63.192094]  hidinput_connect+0x686d/0xad60\n[   63.192094]  hid_connect+0xf20/0x1b10\n[   63.192094]  hid_hw_start+0x83/0x100\n[   63.192094]  hid_device_probe+0x2d1/0x680\n[   63.192094]  really_probe+0x1c3/0x690\n[   63.192094]  __driver_probe_device+0x247/0x300\n[   63.192094]  driver_probe_device+0x49/0x210\n[   63.192094]  __device_attach_driver+0x160/0x320\n[   63.192094]  bus_for_each_drv+0x10f/0x190\n[   63.192094]  __device_attach+0x18e/0x370\n[   63.192094]  bus_probe_device+0x123/0x170\n[   63.192094]  device_add+0xd4d/0x1460\n[   63.192094]  hid_add_device+0x30b/0x910\n[   63.192094]  usbhid_probe+0x920/0xe00\n[   63.192094]  usb_probe_interface+0x363/0x9a0\n[   63.192094]  really_probe+0x1c3/0x690\n[   63.192094]  __driver_probe_device+0x247/0x300\n[   63.192094]  driver_probe_device+0x49/0x210\n[   63.192094]  __device_attach_driver+0x160/0x320\n[   63.192094]  bus_for_each_drv+0x10f/0x190\n[   63.192094]  __device_attach+0x18e/0x370\n[   63.192094]  bus_probe_device+0x123/0x170\n[   63.192094]  device_add+0xd4d/0x1460\n[   63.192094]  usb_set_configuration+0xd14/0x1880\n[   63.192094]  usb_generic_driver_probe+0x78/0xb0\n[   63.192094]  usb_probe_device+0xaa/0x2e0\n[   63.192094]  really_probe+0x1c3/0x690\n[   63.192094]  __driver_probe_device+0x247/0x300\n[   63.192094]  driver_probe_device+0x49/0x210\n[   63.192094]  __device_attach_driver+0x160/0x320\n[   63.192094]  bus_for_each_drv+0x10f/0x190\n[   63.192094]  __device_attach+0x18e/0x370\n[   63.192094]  bus_probe_device+0x123/0x170\n[   63.192094]  device_add+0xd4d/0x1460\n[   63.192094]  usb_new_device+0x7b4/0x1000\n[   63.192094]  hub_event+0x234d/0x3fa0\n[   63.192094]  process_one_work+0x5bf/0xfe0\n[   63.192094]  worker_thread+0x777/0x13a0\n[   63.192094]  </TASK>\n[   63.192094]\n[   63.192094] Allocated by task 54:\n[   63.192094]  kasan_save_stack+0x33/0x60\n[   63.192094]  kasan_save_track+0x14/0x30\n[   63.192094]  __kasan_kmalloc+0x8f/0xa0\n[   63.192094]  __kmalloc_node_track_caller_noprof+0x195/0x420\n[   63.192094]  devm_kmalloc+0x74/0x1e0\n[   63.192094]  appletb_kbd_probe+0x39/0x440\n[   63.192094]  hid_device_probe+0x2d1/0x680\n[   63.192094]  really_probe+0x1c3/0x690\n[   63.192094]  __driver_probe_device+0x247/0x300\n[   63.192094]  driver_probe_device+0x49/0x210\n[   63.192094]  __device_attach_driver+0x160/0x320\n[...]\n[   63.192094]\n[   63.192094] Freed by task 54:\n[   63.192094]  kasan_save_stack+0x33/0x60\n[   63.192094]  kasan_save_track+0x14/0x30\n[   63.192094]  kasan_save_free_info+0x3b/0x60\n[   63.192094]  __kasan_slab_free+0x37/0x50\n[   63.192094]  kfree+0xcf/0x360\n[   63.192094]  devres_release_group+0x1f8/0x3c0\n[   63.192094]  hid_device_probe+0x315/0x680\n[   63.192094]  really_probe+0x1c3/0x690\n[   63.192094]  __driver_probe_device+0x247/0x300\n[   63.192094]  driver_probe_device+0x49/0x210\n[   63.192094]  __device_attach_driver+0x160/0x320\n[...]\n\nFixes: 7d62ba8deacf (\"HID: hid-appletb-kbd: add support for fn toggle between media and function mode\")\nCc: stable@vger.kernel.org\nReviewed-by: Aditya Garg <gargaditya08@live.com>\nSigned-off-by: Qasim Ijaz <qasdev00@gmail.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.com>",
    "author": "Qasim Ijaz",
    "date": "2025-07-03T09:38:05+02:00",
    "files_changed": [
      "drivers/hid/hid-appletb-kbd.c"
    ],
    "diff": "diff --git a/drivers/hid/hid-appletb-kbd.c b/drivers/hid/hid-appletb-kbd.c\nindex e06567886e50..b5d9e50bc231 100644\n--- a/drivers/hid/hid-appletb-kbd.c\n+++ b/drivers/hid/hid-appletb-kbd.c\n@@ -430,13 +430,15 @@ static int appletb_kbd_probe(struct hid_device *hdev, const struct hid_device_id\n \tret = appletb_kbd_set_mode(kbd, appletb_tb_def_mode);\n \tif (ret) {\n \t\tdev_err_probe(dev, ret, \"Failed to set touchbar mode\\n\");\n-\t\tgoto close_hw;\n+\t\tgoto unregister_handler;\n \t}\n \n \thid_set_drvdata(hdev, kbd);\n \n \treturn 0;\n \n+unregister_handler:\n+\tinput_unregister_handler(&kbd->inp_handler);\n close_hw:\n \tif (kbd->backlight_dev)\n \t\tput_device(&kbd->backlight_dev->dev);",
    "stats": {
      "insertions": 3,
      "deletions": 1,
      "files": 1
    }
  }
]
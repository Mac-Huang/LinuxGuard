[
  {
    "sha": "b7dc79a6332fe6f58f2e6b2a631bad101dc79107",
    "message": "Merge tag 'drm-misc-fixes-2025-07-10' of https://gitlab.freedesktop.org/drm/misc/kernel into drm-fixes\n\ndrm-misc-fixes for v6.16-rc6 or final:\n- Fix nouveau fail on debugfs errors.\n- Magic 50 ms to fix nouveau suspend.\n- Call rust destructor on drm device release.\n- Fix DMA api error handling in tegra/nvdec.\n- Fix PVR device reset.\n- Habanalabs maintainer update.\n- Small memory leak fix when nouveau acpi init fails.\n- Do not attempt to bind to any PCI device with AGP capability.\n- Make FB's acquire handles on backing object, same as i915/xe already does.\n- Fix race in drm_gem_handle_create_tail.\n\nSigned-off-by: Simona Vetter <simona.vetter@ffwll.ch>\nFrom: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/e522cdc7-1787-48f2-97e5-0f94783970ab@linux.intel.com",
    "author": "Simona Vetter",
    "date": "2025-07-11T14:11:19+02:00",
    "files_changed": [
      "drivers/char/agp/amd64-agp.c",
      "drivers/gpu/drm/drm_framebuffer.c",
      "drivers/gpu/drm/drm_gem.c",
      "drivers/gpu/drm/drm_gem_framebuffer_helper.c",
      "drivers/gpu/drm/drm_internal.h",
      "drivers/gpu/drm/imagination/pvr_power.c",
      "drivers/gpu/drm/nouveau/nouveau_debugfs.c",
      "drivers/gpu/drm/nouveau/nouveau_debugfs.h",
      "drivers/gpu/drm/nouveau/nouveau_drm.c",
      "drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c",
      "drivers/gpu/drm/tegra/nvdec.c",
      "include/drm/drm_file.h",
      "include/drm/drm_framebuffer.h"
    ],
    "diff": "diff --git a/MAINTAINERS b/MAINTAINERS\nindex fad6cb025a19..76f78fe8e545 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -10504,7 +10504,7 @@ S:\tMaintained\n F:\tblock/partitions/efi.*\n \n HABANALABS PCI DRIVER\n-M:\tOfir Bitton <obitton@habana.ai>\n+M:\tYaron Avizrat <yaron.avizrat@intel.com>\n L:\tdri-devel@lists.freedesktop.org\n S:\tSupported\n C:\tirc://irc.oftc.net/dri-devel\ndiff --git a/drivers/char/agp/amd64-agp.c b/drivers/char/agp/amd64-agp.c\nindex bf490967241a..2505df1f4e69 100644\n--- a/drivers/char/agp/amd64-agp.c\n+++ b/drivers/char/agp/amd64-agp.c\n@@ -720,11 +720,6 @@ static const struct pci_device_id agp_amd64_pci_table[] = {\n \n MODULE_DEVICE_TABLE(pci, agp_amd64_pci_table);\n \n-static const struct pci_device_id agp_amd64_pci_promisc_table[] = {\n-\t{ PCI_DEVICE_CLASS(0, 0) },\n-\t{ }\n-};\n-\n static DEFINE_SIMPLE_DEV_PM_OPS(agp_amd64_pm_ops, NULL, agp_amd64_resume);\n \n static struct pci_driver agp_amd64_pci_driver = {\n@@ -739,6 +734,7 @@ static struct pci_driver agp_amd64_pci_driver = {\n /* Not static due to IOMMU code calling it early. */\n int __init agp_amd64_init(void)\n {\n+\tstruct pci_dev *pdev = NULL;\n \tint err = 0;\n \n \tif (agp_off)\n@@ -767,9 +763,13 @@ int __init agp_amd64_init(void)\n \t\t}\n \n \t\t/* Look for any AGP bridge */\n-\t\tagp_amd64_pci_driver.id_table = agp_amd64_pci_promisc_table;\n-\t\terr = driver_attach(&agp_amd64_pci_driver.driver);\n-\t\tif (err == 0 && agp_bridges_found == 0) {\n+\t\tfor_each_pci_dev(pdev)\n+\t\t\tif (pci_find_capability(pdev, PCI_CAP_ID_AGP))\n+\t\t\t\tpci_add_dynid(&agp_amd64_pci_driver,\n+\t\t\t\t\t      pdev->vendor, pdev->device,\n+\t\t\t\t\t      pdev->subsystem_vendor,\n+\t\t\t\t\t      pdev->subsystem_device, 0, 0, 0);\n+\t\tif (agp_bridges_found == 0) {\n \t\t\tpci_unregister_driver(&agp_amd64_pci_driver);\n \t\t\terr = -ENODEV;\n \t\t}\ndiff --git a/drivers/gpu/drm/drm_framebuffer.c b/drivers/gpu/drm/drm_framebuffer.c\nindex b781601946db..63a70f285cce 100644\n--- a/drivers/gpu/drm/drm_framebuffer.c\n+++ b/drivers/gpu/drm/drm_framebuffer.c\n@@ -862,11 +862,23 @@ EXPORT_SYMBOL_FOR_TESTS_ONLY(drm_framebuffer_free);\n int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n \t\t\t const struct drm_framebuffer_funcs *funcs)\n {\n+\tunsigned int i;\n \tint ret;\n+\tbool exists;\n \n \tif (WARN_ON_ONCE(fb->dev != dev || !fb->format))\n \t\treturn -EINVAL;\n \n+\tfor (i = 0; i < fb->format->num_planes; i++) {\n+\t\tif (drm_WARN_ON_ONCE(dev, fb->internal_flags & DRM_FRAMEBUFFER_HAS_HANDLE_REF(i)))\n+\t\t\tfb->internal_flags &= ~DRM_FRAMEBUFFER_HAS_HANDLE_REF(i);\n+\t\tif (fb->obj[i]) {\n+\t\t\texists = drm_gem_object_handle_get_if_exists_unlocked(fb->obj[i]);\n+\t\t\tif (exists)\n+\t\t\t\tfb->internal_flags |= DRM_FRAMEBUFFER_HAS_HANDLE_REF(i);\n+\t\t}\n+\t}\n+\n \tINIT_LIST_HEAD(&fb->filp_head);\n \n \tfb->funcs = funcs;\n@@ -875,7 +887,7 @@ int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n \tret = __drm_mode_object_add(dev, &fb->base, DRM_MODE_OBJECT_FB,\n \t\t\t\t    false, drm_framebuffer_free);\n \tif (ret)\n-\t\tgoto out;\n+\t\tgoto err;\n \n \tmutex_lock(&dev->mode_config.fb_lock);\n \tdev->mode_config.num_fb++;\n@@ -883,7 +895,16 @@ int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n \tmutex_unlock(&dev->mode_config.fb_lock);\n \n \tdrm_mode_object_register(dev, &fb->base);\n-out:\n+\n+\treturn 0;\n+\n+err:\n+\tfor (i = 0; i < fb->format->num_planes; i++) {\n+\t\tif (fb->internal_flags & DRM_FRAMEBUFFER_HAS_HANDLE_REF(i)) {\n+\t\t\tdrm_gem_object_handle_put_unlocked(fb->obj[i]);\n+\t\t\tfb->internal_flags &= ~DRM_FRAMEBUFFER_HAS_HANDLE_REF(i);\n+\t\t}\n+\t}\n \treturn ret;\n }\n EXPORT_SYMBOL(drm_framebuffer_init);\n@@ -960,6 +981,12 @@ EXPORT_SYMBOL(drm_framebuffer_unregister_private);\n void drm_framebuffer_cleanup(struct drm_framebuffer *fb)\n {\n \tstruct drm_device *dev = fb->dev;\n+\tunsigned int i;\n+\n+\tfor (i = 0; i < fb->format->num_planes; i++) {\n+\t\tif (fb->internal_flags & DRM_FRAMEBUFFER_HAS_HANDLE_REF(i))\n+\t\t\tdrm_gem_object_handle_put_unlocked(fb->obj[i]);\n+\t}\n \n \tmutex_lock(&dev->mode_config.fb_lock);\n \tlist_del(&fb->head);\ndiff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c\nindex 4bf0a76bb35e..ac0524595bd6 100644\n--- a/drivers/gpu/drm/drm_gem.c\n+++ b/drivers/gpu/drm/drm_gem.c\n@@ -223,23 +223,34 @@ static void drm_gem_object_handle_get(struct drm_gem_object *obj)\n }\n \n /**\n- * drm_gem_object_handle_get_unlocked - acquire reference on user-space handles\n+ * drm_gem_object_handle_get_if_exists_unlocked - acquire reference on user-space handle, if any\n  * @obj: GEM object\n  *\n- * Acquires a reference on the GEM buffer object's handle. Required\n- * to keep the GEM object alive. Call drm_gem_object_handle_put_unlocked()\n- * to release the reference.\n+ * Acquires a reference on the GEM buffer object's handle. Required to keep\n+ * the GEM object alive. Call drm_gem_object_handle_put_if_exists_unlocked()\n+ * to release the reference. Does nothing if the buffer object has no handle.\n+ *\n+ * Returns:\n+ * True if a handle exists, or false otherwise\n  */\n-void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj)\n+bool drm_gem_object_handle_get_if_exists_unlocked(struct drm_gem_object *obj)\n {\n \tstruct drm_device *dev = obj->dev;\n \n \tguard(mutex)(&dev->object_name_lock);\n \n-\tdrm_WARN_ON(dev, !obj->handle_count); /* first ref taken in create-tail helper */\n+\t/*\n+\t * First ref taken during GEM object creation, if any. Some\n+\t * drivers set up internal framebuffers with GEM objects that\n+\t * do not have a GEM handle. Hence, this counter can be zero.\n+\t */\n+\tif (!obj->handle_count)\n+\t\treturn false;\n+\n \tdrm_gem_object_handle_get(obj);\n+\n+\treturn true;\n }\n-EXPORT_SYMBOL(drm_gem_object_handle_get_unlocked);\n \n /**\n  * drm_gem_object_handle_free - release resources bound to userspace handles\n@@ -272,7 +283,7 @@ static void drm_gem_object_exported_dma_buf_free(struct drm_gem_object *obj)\n }\n \n /**\n- * drm_gem_object_handle_put_unlocked - releases reference on user-space handles\n+ * drm_gem_object_handle_put_unlocked - releases reference on user-space handle\n  * @obj: GEM object\n  *\n  * Releases a reference on the GEM buffer object's handle. Possibly releases\n@@ -283,14 +294,14 @@ void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n \tstruct drm_device *dev = obj->dev;\n \tbool final = false;\n \n-\tif (WARN_ON(READ_ONCE(obj->handle_count) == 0))\n+\tif (drm_WARN_ON(dev, READ_ONCE(obj->handle_count) == 0))\n \t\treturn;\n \n \t/*\n-\t* Must bump handle count first as this may be the last\n-\t* ref, in which case the object would disappear before we\n-\t* checked for a name\n-\t*/\n+\t * Must bump handle count first as this may be the last\n+\t * ref, in which case the object would disappear before\n+\t * we checked for a name.\n+\t */\n \n \tmutex_lock(&dev->object_name_lock);\n \tif (--obj->handle_count == 0) {\n@@ -303,7 +314,6 @@ void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj)\n \tif (final)\n \t\tdrm_gem_object_put(obj);\n }\n-EXPORT_SYMBOL(drm_gem_object_handle_put_unlocked);\n \n /*\n  * Called at device or object close to release the file's\n@@ -315,6 +325,9 @@ drm_gem_object_release_handle(int id, void *ptr, void *data)\n \tstruct drm_file *file_priv = data;\n \tstruct drm_gem_object *obj = ptr;\n \n+\tif (drm_WARN_ON(obj->dev, !data))\n+\t\treturn 0;\n+\n \tif (obj->funcs->close)\n \t\tobj->funcs->close(obj, file_priv);\n \n@@ -435,7 +448,7 @@ drm_gem_handle_create_tail(struct drm_file *file_priv,\n \tidr_preload(GFP_KERNEL);\n \tspin_lock(&file_priv->table_lock);\n \n-\tret = idr_alloc(&file_priv->object_idr, obj, 1, 0, GFP_NOWAIT);\n+\tret = idr_alloc(&file_priv->object_idr, NULL, 1, 0, GFP_NOWAIT);\n \n \tspin_unlock(&file_priv->table_lock);\n \tidr_preload_end();\n@@ -456,6 +469,11 @@ drm_gem_handle_create_tail(struct drm_file *file_priv,\n \t\t\tgoto err_revoke;\n \t}\n \n+\t/* mirrors drm_gem_handle_delete to avoid races */\n+\tspin_lock(&file_priv->table_lock);\n+\tobj = idr_replace(&file_priv->object_idr, obj, handle);\n+\tWARN_ON(obj != NULL);\n+\tspin_unlock(&file_priv->table_lock);\n \t*handlep = handle;\n \treturn 0;\n \ndiff --git a/drivers/gpu/drm/drm_gem_framebuffer_helper.c b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\nindex 14a87788695d..6f72e7a0f427 100644\n--- a/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n+++ b/drivers/gpu/drm/drm_gem_framebuffer_helper.c\n@@ -99,7 +99,7 @@ void drm_gem_fb_destroy(struct drm_framebuffer *fb)\n \tunsigned int i;\n \n \tfor (i = 0; i < fb->format->num_planes; i++)\n-\t\tdrm_gem_object_handle_put_unlocked(fb->obj[i]);\n+\t\tdrm_gem_object_put(fb->obj[i]);\n \n \tdrm_framebuffer_cleanup(fb);\n \tkfree(fb);\n@@ -182,10 +182,8 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\tif (!objs[i]) {\n \t\t\tdrm_dbg_kms(dev, \"Failed to lookup GEM object\\n\");\n \t\t\tret = -ENOENT;\n-\t\t\tgoto err_gem_object_handle_put_unlocked;\n+\t\t\tgoto err_gem_object_put;\n \t\t}\n-\t\tdrm_gem_object_handle_get_unlocked(objs[i]);\n-\t\tdrm_gem_object_put(objs[i]);\n \n \t\tmin_size = (height - 1) * mode_cmd->pitches[i]\n \t\t\t + drm_format_info_min_pitch(info, i, width)\n@@ -195,22 +193,22 @@ int drm_gem_fb_init_with_funcs(struct drm_device *dev,\n \t\t\tdrm_dbg_kms(dev,\n \t\t\t\t    \"GEM object size (%zu) smaller than minimum size (%u) for plane %d\\n\",\n \t\t\t\t    objs[i]->size, min_size, i);\n-\t\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n+\t\t\tdrm_gem_object_put(objs[i]);\n \t\t\tret = -EINVAL;\n-\t\t\tgoto err_gem_object_handle_put_unlocked;\n+\t\t\tgoto err_gem_object_put;\n \t\t}\n \t}\n \n \tret = drm_gem_fb_init(dev, fb, mode_cmd, objs, i, funcs);\n \tif (ret)\n-\t\tgoto err_gem_object_handle_put_unlocked;\n+\t\tgoto err_gem_object_put;\n \n \treturn 0;\n \n-err_gem_object_handle_put_unlocked:\n+err_gem_object_put:\n \twhile (i > 0) {\n \t\t--i;\n-\t\tdrm_gem_object_handle_put_unlocked(objs[i]);\n+\t\tdrm_gem_object_put(objs[i]);\n \t}\n \treturn ret;\n }\ndiff --git a/drivers/gpu/drm/drm_internal.h b/drivers/gpu/drm/drm_internal.h\nindex be77d61a16ce..60c282881958 100644\n--- a/drivers/gpu/drm/drm_internal.h\n+++ b/drivers/gpu/drm/drm_internal.h\n@@ -161,7 +161,7 @@ void drm_sysfs_lease_event(struct drm_device *dev);\n \n /* drm_gem.c */\n int drm_gem_init(struct drm_device *dev);\n-void drm_gem_object_handle_get_unlocked(struct drm_gem_object *obj);\n+bool drm_gem_object_handle_get_if_exists_unlocked(struct drm_gem_object *obj);\n void drm_gem_object_handle_put_unlocked(struct drm_gem_object *obj);\n int drm_gem_handle_create_tail(struct drm_file *file_priv,\n \t\t\t       struct drm_gem_object *obj,\ndiff --git a/drivers/gpu/drm/drm_panic_qr.rs b/drivers/gpu/drm/drm_panic_qr.rs\nindex dd55b1cb764d..18492daae4b3 100644\n--- a/drivers/gpu/drm/drm_panic_qr.rs\n+++ b/drivers/gpu/drm/drm_panic_qr.rs\n@@ -27,7 +27,7 @@\n //! * <https://github.com/erwanvivien/fast_qr>\n //! * <https://github.com/bjguillot/qr>\n \n-use kernel::{prelude::*, str::CStr};\n+use kernel::prelude::*;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Ord, PartialOrd)]\n struct Version(usize);\ndiff --git a/drivers/gpu/drm/imagination/pvr_power.c b/drivers/gpu/drm/imagination/pvr_power.c\nindex 41f5d89e78b8..3e349d039fc0 100644\n--- a/drivers/gpu/drm/imagination/pvr_power.c\n+++ b/drivers/gpu/drm/imagination/pvr_power.c\n@@ -386,13 +386,13 @@ pvr_power_reset(struct pvr_device *pvr_dev, bool hard_reset)\n \t\tif (!err) {\n \t\t\tif (hard_reset) {\n \t\t\t\tpvr_dev->fw_dev.booted = false;\n-\t\t\t\tWARN_ON(pm_runtime_force_suspend(from_pvr_device(pvr_dev)->dev));\n+\t\t\t\tWARN_ON(pvr_power_device_suspend(from_pvr_device(pvr_dev)->dev));\n \n \t\t\t\terr = pvr_fw_hard_reset(pvr_dev);\n \t\t\t\tif (err)\n \t\t\t\t\tgoto err_device_lost;\n \n-\t\t\t\terr = pm_runtime_force_resume(from_pvr_device(pvr_dev)->dev);\n+\t\t\t\terr = pvr_power_device_resume(from_pvr_device(pvr_dev)->dev);\n \t\t\t\tpvr_dev->fw_dev.booted = true;\n \t\t\t\tif (err)\n \t\t\t\t\tgoto err_device_lost;\ndiff --git a/drivers/gpu/drm/nouveau/nouveau_debugfs.c b/drivers/gpu/drm/nouveau/nouveau_debugfs.c\nindex 200e65a7cefc..c7869a639bef 100644\n--- a/drivers/gpu/drm/nouveau/nouveau_debugfs.c\n+++ b/drivers/gpu/drm/nouveau/nouveau_debugfs.c\n@@ -314,14 +314,10 @@ nouveau_debugfs_fini(struct nouveau_drm *drm)\n \tdrm->debugfs = NULL;\n }\n \n-int\n+void\n nouveau_module_debugfs_init(void)\n {\n \tnouveau_debugfs_root = debugfs_create_dir(\"nouveau\", NULL);\n-\tif (IS_ERR(nouveau_debugfs_root))\n-\t\treturn PTR_ERR(nouveau_debugfs_root);\n-\n-\treturn 0;\n }\n \n void\ndiff --git a/drivers/gpu/drm/nouveau/nouveau_debugfs.h b/drivers/gpu/drm/nouveau/nouveau_debugfs.h\nindex b7617b344ee2..d05ed0e641c4 100644\n--- a/drivers/gpu/drm/nouveau/nouveau_debugfs.h\n+++ b/drivers/gpu/drm/nouveau/nouveau_debugfs.h\n@@ -24,7 +24,7 @@ extern void nouveau_debugfs_fini(struct nouveau_drm *);\n \n extern struct dentry *nouveau_debugfs_root;\n \n-int  nouveau_module_debugfs_init(void);\n+void nouveau_module_debugfs_init(void);\n void nouveau_module_debugfs_fini(void);\n #else\n static inline void\n@@ -42,10 +42,9 @@ nouveau_debugfs_fini(struct nouveau_drm *drm)\n {\n }\n \n-static inline int\n+static inline void\n nouveau_module_debugfs_init(void)\n {\n-\treturn 0;\n }\n \n static inline void\ndiff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c\nindex 0c82a63cd49d..1527b801f013 100644\n--- a/drivers/gpu/drm/nouveau/nouveau_drm.c\n+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c\n@@ -1461,9 +1461,7 @@ nouveau_drm_init(void)\n \tif (!nouveau_modeset)\n \t\treturn 0;\n \n-\tret = nouveau_module_debugfs_init();\n-\tif (ret)\n-\t\treturn ret;\n+\tnouveau_module_debugfs_init();\n \n #ifdef CONFIG_NOUVEAU_PLATFORM_DRIVER\n \tplatform_driver_register(&nouveau_platform_driver);\ndiff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\nindex baf42339f93e..588cb4ab85cb 100644\n--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/rm/r535/gsp.c\n@@ -719,7 +719,6 @@ r535_gsp_acpi_caps(acpi_handle handle, CAPS_METHOD_DATA *caps)\n \tunion acpi_object argv4 = {\n \t\t.buffer.type    = ACPI_TYPE_BUFFER,\n \t\t.buffer.length  = 4,\n-\t\t.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL),\n \t}, *obj;\n \n \tcaps->status = 0xffff;\n@@ -727,17 +726,22 @@ r535_gsp_acpi_caps(acpi_handle handle, CAPS_METHOD_DATA *caps)\n \tif (!acpi_check_dsm(handle, &NVOP_DSM_GUID, NVOP_DSM_REV, BIT_ULL(0x1a)))\n \t\treturn;\n \n+\targv4.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL);\n+\tif (!argv4.buffer.pointer)\n+\t\treturn;\n+\n \tobj = acpi_evaluate_dsm(handle, &NVOP_DSM_GUID, NVOP_DSM_REV, 0x1a, &argv4);\n \tif (!obj)\n-\t\treturn;\n+\t\tgoto done;\n \n \tif (WARN_ON(obj->type != ACPI_TYPE_BUFFER) ||\n \t    WARN_ON(obj->buffer.length != 4))\n-\t\treturn;\n+\t\tgoto done;\n \n \tcaps->status = 0;\n \tcaps->optimusCaps = *(u32 *)obj->buffer.pointer;\n \n+done:\n \tACPI_FREE(obj);\n \n \tkfree(argv4.buffer.pointer);\n@@ -754,24 +758,28 @@ r535_gsp_acpi_jt(acpi_handle handle, JT_METHOD_DATA *jt)\n \tunion acpi_object argv4 = {\n \t\t.buffer.type    = ACPI_TYPE_BUFFER,\n \t\t.buffer.length  = sizeof(caps),\n-\t\t.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL),\n \t}, *obj;\n \n \tjt->status = 0xffff;\n \n+\targv4.buffer.pointer = kmalloc(argv4.buffer.length, GFP_KERNEL);\n+\tif (!argv4.buffer.pointer)\n+\t\treturn;\n+\n \tobj = acpi_evaluate_dsm(handle, &JT_DSM_GUID, JT_DSM_REV, 0x1, &argv4);\n \tif (!obj)\n-\t\treturn;\n+\t\tgoto done;\n \n \tif (WARN_ON(obj->type != ACPI_TYPE_BUFFER) ||\n \t    WARN_ON(obj->buffer.length != 4))\n-\t\treturn;\n+\t\tgoto done;\n \n \tjt->status = 0;\n \tjt->jtCaps = *(u32 *)obj->buffer.pointer;\n \tjt->jtRevId = (jt->jtCaps & 0xfff00000) >> 20;\n \tjt->bSBIOSCaps = 0;\n \n+done:\n \tACPI_FREE(obj);\n \n \tkfree(argv4.buffer.pointer);\n@@ -1744,6 +1752,13 @@ r535_gsp_fini(struct nvkm_gsp *gsp, bool suspend)\n \t\t\tnvkm_gsp_sg_free(gsp->subdev.device, &gsp->sr.sgt);\n \t\t\treturn ret;\n \t\t}\n+\n+\t\t/*\n+\t\t * TODO: Debug the GSP firmware / RPC handling to find out why\n+\t\t * without this Turing (but none of the other architectures)\n+\t\t * ends up resetting all channels after resume.\n+\t\t */\n+\t\tmsleep(50);\n \t}\n \n \tret = r535_gsp_rpc_unloading_guest_driver(gsp, suspend);\ndiff --git a/drivers/gpu/drm/tegra/nvdec.c b/drivers/gpu/drm/tegra/nvdec.c\nindex 2d9a0a3f6c38..7a38664e890e 100644\n--- a/drivers/gpu/drm/tegra/nvdec.c\n+++ b/drivers/gpu/drm/tegra/nvdec.c\n@@ -261,10 +261,8 @@ static int nvdec_load_falcon_firmware(struct nvdec *nvdec)\n \n \tif (!client->group) {\n \t\tvirt = dma_alloc_coherent(nvdec->dev, size, &iova, GFP_KERNEL);\n-\n-\t\terr = dma_mapping_error(nvdec->dev, iova);\n-\t\tif (err < 0)\n-\t\t\treturn err;\n+\t\tif (!virt)\n+\t\t\treturn -ENOMEM;\n \t} else {\n \t\tvirt = tegra_drm_alloc(tegra, size, &iova);\n \t\tif (IS_ERR(virt))\ndiff --git a/include/drm/drm_file.h b/include/drm/drm_file.h\nindex 5c3b2aa3e69d..d344d41e6cfe 100644\n--- a/include/drm/drm_file.h\n+++ b/include/drm/drm_file.h\n@@ -300,6 +300,9 @@ struct drm_file {\n \t *\n \t * Mapping of mm object handles to object pointers. Used by the GEM\n \t * subsystem. Protected by @table_lock.\n+\t *\n+\t * Note that allocated entries might be NULL as a transient state when\n+\t * creating or deleting a handle.\n \t */\n \tstruct idr object_idr;\n \ndiff --git a/include/drm/drm_framebuffer.h b/include/drm/drm_framebuffer.h\nindex 668077009fce..38b24fc8978d 100644\n--- a/include/drm/drm_framebuffer.h\n+++ b/include/drm/drm_framebuffer.h\n@@ -23,6 +23,7 @@\n #ifndef __DRM_FRAMEBUFFER_H__\n #define __DRM_FRAMEBUFFER_H__\n \n+#include <linux/bits.h>\n #include <linux/ctype.h>\n #include <linux/list.h>\n #include <linux/sched.h>\n@@ -100,6 +101,8 @@ struct drm_framebuffer_funcs {\n \t\t     unsigned num_clips);\n };\n \n+#define DRM_FRAMEBUFFER_HAS_HANDLE_REF(_i)\tBIT(0u + (_i))\n+\n /**\n  * struct drm_framebuffer - frame buffer object\n  *\n@@ -188,6 +191,10 @@ struct drm_framebuffer {\n \t * DRM_MODE_FB_MODIFIERS.\n \t */\n \tint flags;\n+\t/**\n+\t * @internal_flags: Framebuffer flags like DRM_FRAMEBUFFER_HAS_HANDLE_REF.\n+\t */\n+\tunsigned int internal_flags;\n \t/**\n \t * @filp_head: Placed on &drm_file.fbs, protected by &drm_file.fbs_lock.\n \t */\ndiff --git a/rust/kernel/drm/device.rs b/rust/kernel/drm/device.rs\nindex 624d7a4c83ea..14c1aa402951 100644\n--- a/rust/kernel/drm/device.rs\n+++ b/rust/kernel/drm/device.rs\n@@ -66,7 +66,7 @@ impl<T: drm::Driver> Device<T> {\n         open: Some(drm::File::<T::File>::open_callback),\n         postclose: Some(drm::File::<T::File>::postclose_callback),\n         unload: None,\n-        release: None,\n+        release: Some(Self::release),\n         master_set: None,\n         master_drop: None,\n         debugfs_init: None,\n@@ -162,6 +162,16 @@ pub unsafe fn as_ref<'a>(ptr: *const bindings::drm_device) -> &'a Self {\n         // SAFETY: `ptr` is valid by the safety requirements of this function.\n         unsafe { &*ptr.cast() }\n     }\n+\n+    extern \"C\" fn release(ptr: *mut bindings::drm_device) {\n+        // SAFETY: `ptr` is a valid pointer to a `struct drm_device` and embedded in `Self`.\n+        let this = unsafe { Self::from_drm_device(ptr) };\n+\n+        // SAFETY:\n+        // - When `release` runs it is guaranteed that there is no further access to `this`.\n+        // - `this` is valid for dropping.\n+        unsafe { core::ptr::drop_in_place(this) };\n+    }\n }\n \n impl<T: drm::Driver> Deref for Device<T> {\ndiff --git a/rust/kernel/drm/driver.rs b/rust/kernel/drm/driver.rs\nindex acb638086131..af93d46d03d3 100644\n--- a/rust/kernel/drm/driver.rs\n+++ b/rust/kernel/drm/driver.rs\n@@ -10,7 +10,6 @@\n     drm,\n     error::{to_result, Result},\n     prelude::*,\n-    str::CStr,\n     types::ARef,\n };\n use macros::vtable;",
    "stats": {
      "insertions": 130,
      "deletions": 62,
      "files": 17
    }
  },
  {
    "sha": "711c80f7d8b163d3ecd463cd96f07230f488e750",
    "message": "net: appletalk: Fix device refcount leak in atrtr_create()\n\nWhen updating an existing route entry in atrtr_create(), the old device\nreference was not being released before assigning the new device,\nleading to a device refcount leak. Fix this by calling dev_put() to\nrelease the old device reference before holding the new one.\n\nFixes: c7f905f0f6d4 (\"[ATALK]: Add missing dev_hold() to atrtr_create().\")\nSigned-off-by: Kito Xu <veritas501@foxmail.com>\nLink: https://patch.msgid.link/tencent_E1A26771CDAB389A0396D1681A90A49E5D09@qq.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Kito Xu",
    "date": "2025-07-10T18:01:08-07:00",
    "files_changed": [
      "net/appletalk/ddp.c"
    ],
    "diff": "diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c\nindex 73ea7e67f05a..30242fe10341 100644\n--- a/net/appletalk/ddp.c\n+++ b/net/appletalk/ddp.c\n@@ -576,6 +576,7 @@ static int atrtr_create(struct rtentry *r, struct net_device *devhint)\n \n \t/* Fill in the routing entry */\n \trt->target  = ta->sat_addr;\n+\tdev_put(rt->dev); /* Release old device */\n \tdev_hold(devhint);\n \trt->dev     = devhint;\n \trt->flags   = r->rt_flags;",
    "stats": {
      "insertions": 1,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "7ac5cc2616257cf80d32a8814e44474f07efed62",
    "message": "Merge tag 'wireless-2025-07-10' of https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless\n\nJohannes Berg says:\n\n====================\nQuite a number of fixes still:\n\n - mt76 (hadn't sent any fixes so far)\n   - RCU\n   - scanning\n   - decapsulation offload\n   - interface combinations\n - rt2x00: build fix (bad function pointer prototype)\n - cfg80211: prevent A-MSDU flipping attacks in mesh\n - zd1211rw: prevent race ending with NULL ptr deref\n - cfg80211/mac80211: more S1G fixes\n - mwifiex: avoid WARN on certain RX frames\n - mac80211:\n   - avoid stack data leak in WARN cases\n   - fix non-transmitted BSSID search\n     (on certain multi-BSSID APs)\n   - always initialize key list so driver\n     iteration won't crash\n   - fix monitor interface in device restart\n   - fix __free() annotation usage\n\n* tag 'wireless-2025-07-10' of https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless: (26 commits)\n  wifi: mac80211: add the virtual monitor after reconfig complete\n  wifi: mac80211: always initialize sdata::key_list\n  wifi: mac80211: Fix uninitialized variable with __free() in ieee80211_ml_epcs()\n  wifi: mt76: mt792x: Limit the concurrent STA and SoftAP to operate on the same channel\n  wifi: mt76: mt7925: Fix null-ptr-deref in mt7925_thermal_init()\n  wifi: mt76: fix queue assignment for deauth packets\n  wifi: mt76: add a wrapper for wcid access with validation\n  wifi: mt76: mt7921: prevent decap offload config before STA initialization\n  wifi: mt76: mt7925: prevent NULL pointer dereference in mt7925_sta_set_decap_offload()\n  wifi: mt76: mt7925: fix incorrect scan probe IE handling for hw_scan\n  wifi: mt76: mt7925: fix invalid array index in ssid assignment during hw scan\n  wifi: mt76: mt7925: fix the wrong config for tx interrupt\n  wifi: mt76: Remove RCU section in mt7996_mac_sta_rc_work()\n  wifi: mt76: Move RCU section in mt7996_mcu_add_rate_ctrl()\n  wifi: mt76: Move RCU section in mt7996_mcu_add_rate_ctrl_fixed()\n  wifi: mt76: Move RCU section in mt7996_mcu_set_fixed_field()\n  wifi: mt76: Assume __mt76_connac_mcu_alloc_sta_req runs in atomic context\n  wifi: prevent A-MSDU attacks in mesh networks\n  wifi: rt2x00: fix remove callback type mismatch\n  wifi: mac80211: reject VHT opmode for unsupported channel widths\n  ...\n====================\n\nLink: https://patch.msgid.link/20250710122212.24272-3-johannes@sipsolutions.net\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-07-10T17:13:46-07:00",
    "files_changed": [
      "drivers/net/wireless/marvell/mwifiex/util.c",
      "drivers/net/wireless/mediatek/mt76/mt76.h",
      "drivers/net/wireless/mediatek/mt76/mt7603/dma.c",
      "drivers/net/wireless/mediatek/mt76/mt7603/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7615/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt76x02.h",
      "drivers/net/wireless/mediatek/mt76/mt76x02_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7915/mmio.c",
      "drivers/net/wireless/mediatek/mt76/mt7921/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7921/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/init.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7925/mcu.h",
      "drivers/net/wireless/mediatek/mt76/mt7925/regs.h",
      "drivers/net/wireless/mediatek/mt76/mt792x_core.c",
      "drivers/net/wireless/mediatek/mt76/mt792x_mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mac.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/main.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
      "drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h",
      "drivers/net/wireless/mediatek/mt76/tx.c",
      "drivers/net/wireless/mediatek/mt76/util.c",
      "drivers/net/wireless/ralink/rt2x00/rt2x00soc.c",
      "drivers/net/wireless/ralink/rt2x00/rt2x00soc.h",
      "drivers/net/wireless/zydas/zd1211rw/zd_mac.c",
      "include/linux/ieee80211.h",
      "net/mac80211/cfg.c",
      "net/mac80211/iface.c",
      "net/mac80211/mlme.c",
      "net/mac80211/parse.c",
      "net/mac80211/util.c",
      "net/wireless/nl80211.c",
      "net/wireless/util.c"
    ],
    "diff": "diff --git a/drivers/net/wireless/marvell/mwifiex/util.c b/drivers/net/wireless/marvell/mwifiex/util.c\nindex 4c5b1de0e936..6882e90e90b2 100644\n--- a/drivers/net/wireless/marvell/mwifiex/util.c\n+++ b/drivers/net/wireless/marvell/mwifiex/util.c\n@@ -459,7 +459,9 @@ mwifiex_process_mgmt_packet(struct mwifiex_private *priv,\n \t\t\t\t    \"auth: receive authentication from %pM\\n\",\n \t\t\t\t    ieee_hdr->addr3);\n \t\t} else {\n-\t\t\tif (!priv->wdev.connected)\n+\t\t\tif (!priv->wdev.connected ||\n+\t\t\t    !ether_addr_equal(ieee_hdr->addr3,\n+\t\t\t\t\t      priv->curr_bss_params.bss_descriptor.mac_address))\n \t\t\t\treturn 0;\n \n \t\t\tif (ieee80211_is_deauth(ieee_hdr->frame_control)) {\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76.h b/drivers/net/wireless/mediatek/mt76/mt76.h\nindex 5f8d81cda6cd..74b75035d361 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt76.h\n@@ -1224,6 +1224,16 @@ static inline int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q,\n #define mt76_dereference(p, dev) \\\n \trcu_dereference_protected(p, lockdep_is_held(&(dev)->mutex))\n \n+static inline struct mt76_wcid *\n+__mt76_wcid_ptr(struct mt76_dev *dev, u16 idx)\n+{\n+\tif (idx >= ARRAY_SIZE(dev->wcid))\n+\t\treturn NULL;\n+\treturn rcu_dereference(dev->wcid[idx]);\n+}\n+\n+#define mt76_wcid_ptr(dev, idx) __mt76_wcid_ptr(&(dev)->mt76, idx)\n+\n struct mt76_dev *mt76_alloc_device(struct device *pdev, unsigned int size,\n \t\t\t\t   const struct ieee80211_ops *ops,\n \t\t\t\t   const struct mt76_driver_ops *drv_ops);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\nindex 863e5770df51..e26cc78fff94 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7603/dma.c\n@@ -44,7 +44,7 @@ mt7603_rx_loopback_skb(struct mt7603_dev *dev, struct sk_buff *skb)\n \tif (idx >= MT7603_WTBL_STA - 1)\n \t\tgoto free;\n \n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\tgoto free;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\nindex 413973d05b43..6387f9e61060 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7603/mac.c\n@@ -487,10 +487,7 @@ mt7603_rx_get_wcid(struct mt7603_dev *dev, u8 idx, bool unicast)\n \tstruct mt7603_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT7603_WTBL_SIZE)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -1266,12 +1263,9 @@ void mt7603_mac_add_txs(struct mt7603_dev *dev, void *data)\n \tif (pid == MT_PACKET_ID_NO_ACK)\n \t\treturn;\n \n-\tif (wcidx >= MT7603_WTBL_SIZE)\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\nindex 3ca4fae7c4b0..f8d2cc94b742 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c\n@@ -90,10 +90,7 @@ static struct mt76_wcid *mt7615_rx_get_wcid(struct mt7615_dev *dev,\n \tstruct mt7615_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT7615_WTBL_SIZE)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -1504,7 +1501,7 @@ static void mt7615_mac_add_txs(struct mt7615_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\nindex e9ac8a7317a1..0db00efe88b0 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c\n@@ -1172,7 +1172,7 @@ void mt76_connac2_txwi_free(struct mt76_dev *dev, struct mt76_txwi_cache *t,\n \t\twcid_idx = wcid->idx;\n \t} else {\n \t\twcid_idx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n+\t\twcid = __mt76_wcid_ptr(dev, wcid_idx);\n \n \t\tif (wcid && wcid->sta) {\n \t\t\tsta = container_of((void *)wcid, struct ieee80211_sta,\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\nindex cb13d0a76878..16db0f2082d1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c\n@@ -287,7 +287,7 @@ __mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif_link *mvif\n \n \tmt76_connac_mcu_get_wlan_idx(dev, wcid, &hdr.wlan_idx_lo,\n \t\t\t\t     &hdr.wlan_idx_hi);\n-\tskb = mt76_mcu_msg_alloc(dev, NULL, len);\n+\tskb = __mt76_mcu_msg_alloc(dev, NULL, len, len, GFP_ATOMIC);\n \tif (!skb)\n \t\treturn ERR_PTR(-ENOMEM);\n \n@@ -1740,8 +1740,8 @@ int mt76_connac_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\tif (!sreq->ssids[i].ssid_len)\n \t\t\tcontinue;\n \n-\t\treq->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n-\t\tmemcpy(req->ssids[i].ssid, sreq->ssids[i].ssid,\n+\t\treq->ssids[n_ssids].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n+\t\tmemcpy(req->ssids[n_ssids].ssid, sreq->ssids[i].ssid,\n \t\t       sreq->ssids[i].ssid_len);\n \t\tn_ssids++;\n \t}\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76x02.h b/drivers/net/wireless/mediatek/mt76/mt76x02.h\nindex 4cd63bacd742..9d7ee09b6cc9 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76x02.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt76x02.h\n@@ -262,10 +262,7 @@ mt76x02_rx_get_sta(struct mt76_dev *dev, u8 idx)\n {\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= MT76x02_N_WCIDS)\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\treturn NULL;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\nindex d5db6ffd6d36..83488b2d6efb 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c\n@@ -564,9 +564,7 @@ void mt76x02_send_tx_status(struct mt76x02_dev *dev,\n \n \trcu_read_lock();\n \n-\tif (stat->wcid < MT76x02_N_WCIDS)\n-\t\twcid = rcu_dereference(dev->mt76.wcid[stat->wcid]);\n-\n+\twcid = mt76_wcid_ptr(dev, stat->wcid);\n \tif (wcid && wcid->sta) {\n \t\tvoid *priv;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\nindex 9400e4af2a04..6639976afcee 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mac.c\n@@ -56,10 +56,7 @@ static struct mt76_wcid *mt7915_rx_get_wcid(struct mt7915_dev *dev,\n \tstruct mt7915_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \n@@ -917,7 +914,7 @@ mt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -1013,12 +1010,9 @@ static void mt7915_mac_add_txs(struct mt7915_dev *dev, void *data)\n \tif (pid < MT_PACKET_ID_WED)\n \t\treturn;\n \n-\tif (wcidx >= mt7915_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\nindex 427542777abc..c6584d2b7509 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c\n@@ -3986,7 +3986,7 @@ int mt7915_mcu_wed_wa_tx_stats(struct mt7915_dev *dev, u16 wlan_idx)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \tif (wcid)\n \t\twcid->stats.tx_packets += le32_to_cpu(res->tx_packets);\n \telse\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c b/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\nindex 9c4d5cea0c42..4a82f8e4c118 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c\n@@ -587,12 +587,9 @@ static void mt7915_mmio_wed_update_rx_stats(struct mtk_wed_device *wed,\n \n \tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n \n-\tif (idx >= mt7915_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (wcid) {\n \t\twcid->stats.rx_bytes += le32_to_cpu(stats->rx_byte_cnt);\n \t\twcid->stats.rx_packets += le32_to_cpu(stats->rx_pkt_cnt);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\nindex 5dd57de59f27..f1f76506b0a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mac.c\n@@ -465,7 +465,7 @@ void mt7921_mac_add_txs(struct mt792x_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -516,7 +516,7 @@ static void mt7921_mac_tx_free(struct mt792x_dev *dev, void *data, int len)\n \n \t\t\tcount++;\n \t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -816,7 +816,7 @@ void mt7921_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n \tu16 idx;\n \n \tidx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\twcid = rcu_dereference(mdev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(mdev, idx);\n \tsta = wcid_to_sta(wcid);\n \n \tif (sta && likely(e->skb->protocol != cpu_to_be16(ETH_P_PAE)))\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7921/main.c b/drivers/net/wireless/mediatek/mt76/mt7921/main.c\nindex 1fffa43379b2..77f73ae1d7ec 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7921/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7921/main.c\n@@ -1180,6 +1180,9 @@ static void mt7921_sta_set_decap_offload(struct ieee80211_hw *hw,\n \tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n \tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n \n+\tif (!msta->deflink.wcid.sta)\n+\t\treturn;\n+\n \tmt792x_mutex_acquire(dev);\n \n \tif (enabled)\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/init.c b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\nindex 2a83ff59a968..4249bad83c93 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/init.c\n@@ -52,6 +52,8 @@ static int mt7925_thermal_init(struct mt792x_phy *phy)\n \n \tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7925_%s\",\n \t\t\t      wiphy_name(wiphy));\n+\tif (!name)\n+\t\treturn -ENOMEM;\n \n \thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,\n \t\t\t\t\t\t       mt7925_hwmon_groups);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mac.c b/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\nindex c871d2f9688b..75823c9fd3a1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mac.c\n@@ -1040,7 +1040,7 @@ void mt7925_mac_add_txs(struct mt792x_dev *dev, void *data)\n \n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -1122,7 +1122,7 @@ mt7925_mac_tx_free(struct mt792x_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tcontinue;\n@@ -1445,7 +1445,7 @@ void mt7925_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n \tu16 idx;\n \n \tidx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n-\twcid = rcu_dereference(mdev->wcid[idx]);\n+\twcid = __mt76_wcid_ptr(mdev, idx);\n \tsta = wcid_to_sta(wcid);\n \n \tif (sta && likely(e->skb->protocol != cpu_to_be16(ETH_P_PAE)))\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/main.c b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\nindex 94b0099dcd41..5b001548dffc 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/main.c\n@@ -1481,7 +1481,7 @@ mt7925_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n \n \tmt792x_mutex_acquire(dev);\n \n-\terr = mt7925_mcu_sched_scan_req(mphy, vif, req);\n+\terr = mt7925_mcu_sched_scan_req(mphy, vif, req, ies);\n \tif (err < 0)\n \t\tgoto out;\n \n@@ -1603,6 +1603,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \tunsigned long valid = mvif->valid_links;\n \tu8 i;\n \n+\tif (!msta->vif)\n+\t\treturn;\n+\n \tmt792x_mutex_acquire(dev);\n \n \tvalid = ieee80211_vif_is_mld(vif) ? mvif->valid_links : BIT(0);\n@@ -1617,6 +1620,9 @@ static void mt7925_sta_set_decap_offload(struct ieee80211_hw *hw,\n \t\telse\n \t\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &mlink->wcid.flags);\n \n+\t\tif (!mlink->wcid.sta)\n+\t\t\tcontinue;\n+\n \t\tmt7925_mcu_wtbl_update_hdr_trans(dev, vif, sta, i);\n \t}\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\nindex b8542be0d945..8ac6fbb736ab 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c\n@@ -164,6 +164,7 @@ mt7925_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\t\t       bool suspend, struct cfg80211_wowlan *wowlan)\n {\n \tstruct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;\n+\tstruct ieee80211_scan_ies ies = {};\n \tstruct mt76_dev *dev = phy->dev;\n \tstruct {\n \t\tstruct {\n@@ -194,7 +195,7 @@ mt7925_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\treq.wow_ctrl_tlv.trigger |= (UNI_WOW_DETECT_TYPE_DISCONNECT |\n \t\t\t\t\t     UNI_WOW_DETECT_TYPE_BCN_LOST);\n \tif (wowlan->nd_config) {\n-\t\tmt7925_mcu_sched_scan_req(phy, vif, wowlan->nd_config);\n+\t\tmt7925_mcu_sched_scan_req(phy, vif, wowlan->nd_config, &ies);\n \t\treq.wow_ctrl_tlv.trigger |= UNI_WOW_DETECT_TYPE_SCH_SCAN_HIT;\n \t\tmt7925_mcu_sched_scan_enable(phy, vif, suspend);\n \t}\n@@ -2818,6 +2819,54 @@ int mt7925_mcu_set_dbdc(struct mt76_phy *phy, bool enable)\n \treturn err;\n }\n \n+static void\n+mt7925_mcu_build_scan_ie_tlv(struct mt76_dev *mdev,\n+\t\t\t     struct sk_buff *skb,\n+\t\t\t     struct ieee80211_scan_ies *scan_ies)\n+{\n+\tu32 max_len = sizeof(struct scan_ie_tlv) + MT76_CONNAC_SCAN_IE_LEN;\n+\tstruct scan_ie_tlv *ie;\n+\tenum nl80211_band i;\n+\tstruct tlv *tlv;\n+\tconst u8 *ies;\n+\tu16 ies_len;\n+\n+\tfor (i = 0; i <= NL80211_BAND_6GHZ; i++) {\n+\t\tif (i == NL80211_BAND_60GHZ)\n+\t\t\tcontinue;\n+\n+\t\ties = scan_ies->ies[i];\n+\t\ties_len = scan_ies->len[i];\n+\n+\t\tif (!ies || !ies_len)\n+\t\t\tcontinue;\n+\n+\t\tif (ies_len > max_len)\n+\t\t\treturn;\n+\n+\t\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE,\n+\t\t\t\t\t      sizeof(*ie) + ies_len);\n+\t\tie = (struct scan_ie_tlv *)tlv;\n+\n+\t\tmemcpy(ie->ies, ies, ies_len);\n+\t\tie->ies_len = cpu_to_le16(ies_len);\n+\n+\t\tswitch (i) {\n+\t\tcase NL80211_BAND_2GHZ:\n+\t\t\tie->band = 1;\n+\t\t\tbreak;\n+\t\tcase NL80211_BAND_6GHZ:\n+\t\t\tie->band = 3;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tie->band = 2;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tmax_len -= (sizeof(*ie) + ies_len);\n+\t}\n+}\n+\n int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\t       struct ieee80211_scan_request *scan_req)\n {\n@@ -2843,7 +2892,8 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \n \tmax_len = sizeof(*hdr) + sizeof(*req) + sizeof(*ssid) +\n \t\t  sizeof(*bssid) * MT7925_RNR_SCAN_MAX_BSSIDS +\n-\t\t  sizeof(*chan_info) + sizeof(*misc) + sizeof(*ie);\n+\t\t  sizeof(*chan_info) + sizeof(*misc) + sizeof(*ie) +\n+\t\t  MT76_CONNAC_SCAN_IE_LEN;\n \n \tskb = mt76_mcu_msg_alloc(mdev, NULL, max_len);\n \tif (!skb)\n@@ -2869,8 +2919,8 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\tif (i > MT7925_RNR_SCAN_MAX_BSSIDS)\n \t\t\tbreak;\n \n-\t\tssid->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n-\t\tmemcpy(ssid->ssids[i].ssid, sreq->ssids[i].ssid,\n+\t\tssid->ssids[n_ssids].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n+\t\tmemcpy(ssid->ssids[n_ssids].ssid, sreq->ssids[i].ssid,\n \t\t       sreq->ssids[i].ssid_len);\n \t\tn_ssids++;\n \t}\n@@ -2925,13 +2975,6 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t}\n \tchan_info->channel_type = sreq->n_channels ? 4 : 0;\n \n-\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE, sizeof(*ie));\n-\tie = (struct scan_ie_tlv *)tlv;\n-\tif (sreq->ie_len > 0) {\n-\t\tmemcpy(ie->ies, sreq->ie, sreq->ie_len);\n-\t\tie->ies_len = cpu_to_le16(sreq->ie_len);\n-\t}\n-\n \treq->scan_func |= SCAN_FUNC_SPLIT_SCAN;\n \n \ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_MISC, sizeof(*misc));\n@@ -2942,6 +2985,9 @@ int mt7925_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n \t\treq->scan_func |= SCAN_FUNC_RANDOM_MAC;\n \t}\n \n+\t/* Append scan probe IEs as the last tlv */\n+\tmt7925_mcu_build_scan_ie_tlv(mdev, skb, &scan_req->ies);\n+\n \terr = mt76_mcu_skb_send_msg(mdev, skb, MCU_UNI_CMD(SCAN_REQ),\n \t\t\t\t    true);\n \tif (err < 0)\n@@ -2953,7 +2999,8 @@ EXPORT_SYMBOL_GPL(mt7925_mcu_hw_scan);\n \n int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif,\n-\t\t\t      struct cfg80211_sched_scan_request *sreq)\n+\t\t\t      struct cfg80211_sched_scan_request *sreq,\n+\t\t\t      struct ieee80211_scan_ies *ies)\n {\n \tstruct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;\n \tstruct ieee80211_channel **scan_list = sreq->channels;\n@@ -3041,12 +3088,8 @@ int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t}\n \tchan_info->channel_type = sreq->n_channels ? 4 : 0;\n \n-\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_SCAN_IE, sizeof(*ie));\n-\tie = (struct scan_ie_tlv *)tlv;\n-\tif (sreq->ie_len > 0) {\n-\t\tmemcpy(ie->ies, sreq->ie, sreq->ie_len);\n-\t\tie->ies_len = cpu_to_le16(sreq->ie_len);\n-\t}\n+\t/* Append scan probe IEs as the last tlv */\n+\tmt7925_mcu_build_scan_ie_tlv(mdev, skb, ies);\n \n \treturn mt76_mcu_skb_send_msg(mdev, skb, MCU_UNI_CMD(SCAN_REQ),\n \t\t\t\t     true);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\nindex ee6fb16e83c5..a40764d89a1f 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.h\n@@ -269,7 +269,7 @@ struct scan_ie_tlv {\n \t__le16 ies_len;\n \tu8 band;\n \tu8 pad;\n-\tu8 ies[MT76_CONNAC_SCAN_IE_LEN];\n+\tu8 ies[];\n };\n \n struct scan_misc_tlv {\n@@ -673,7 +673,8 @@ int mt7925_mcu_cancel_hw_scan(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif);\n int mt7925_mcu_sched_scan_req(struct mt76_phy *phy,\n \t\t\t      struct ieee80211_vif *vif,\n-\t\t\t      struct cfg80211_sched_scan_request *sreq);\n+\t\t\t      struct cfg80211_sched_scan_request *sreq,\n+\t\t\t      struct ieee80211_scan_ies *ies);\n int mt7925_mcu_sched_scan_enable(struct mt76_phy *phy,\n \t\t\t\t struct ieee80211_vif *vif,\n \t\t\t\t bool enable);\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7925/regs.h b/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\nindex 547489092c29..341987e47f67 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7925/regs.h\n@@ -58,7 +58,7 @@\n \n #define MT_INT_TX_DONE_MCU\t\t(MT_INT_TX_DONE_MCU_WM |\t\\\n \t\t\t\t\t MT_INT_TX_DONE_FWDL)\n-#define MT_INT_TX_DONE_ALL\t\t(MT_INT_TX_DONE_MCU_WM |\t\\\n+#define MT_INT_TX_DONE_ALL\t\t(MT_INT_TX_DONE_MCU |\t\\\n \t\t\t\t\t MT_INT_TX_DONE_BAND0 |\t\\\n \t\t\t\t\tGENMASK(18, 4))\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt792x_core.c b/drivers/net/wireless/mediatek/mt76/mt792x_core.c\nindex a50c1723ca29..05130ec1e5f7 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt792x_core.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt792x_core.c\n@@ -28,7 +28,7 @@ static const struct ieee80211_iface_combination if_comb[] = {\n \t},\n };\n \n-static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n+static const struct ieee80211_iface_limit if_limits_chanctx_mcc[] = {\n \t{\n \t\t.max = 2,\n \t\t.types = BIT(NL80211_IFTYPE_STATION) |\n@@ -36,8 +36,23 @@ static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n \t},\n \t{\n \t\t.max = 1,\n-\t\t.types = BIT(NL80211_IFTYPE_AP) |\n-\t\t\t BIT(NL80211_IFTYPE_P2P_GO)\n+\t\t.types = BIT(NL80211_IFTYPE_P2P_GO)\n+\t},\n+\t{\n+\t\t.max = 1,\n+\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE)\n+\t}\n+};\n+\n+static const struct ieee80211_iface_limit if_limits_chanctx_scc[] = {\n+\t{\n+\t\t.max = 2,\n+\t\t.types = BIT(NL80211_IFTYPE_STATION) |\n+\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT)\n+\t},\n+\t{\n+\t\t.max = 1,\n+\t\t.types = BIT(NL80211_IFTYPE_AP)\n \t},\n \t{\n \t\t.max = 1,\n@@ -47,11 +62,18 @@ static const struct ieee80211_iface_limit if_limits_chanctx[] = {\n \n static const struct ieee80211_iface_combination if_comb_chanctx[] = {\n \t{\n-\t\t.limits = if_limits_chanctx,\n-\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx),\n+\t\t.limits = if_limits_chanctx_mcc,\n+\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx_mcc),\n \t\t.max_interfaces = 3,\n \t\t.num_different_channels = 2,\n \t\t.beacon_int_infra_match = false,\n+\t},\n+\t{\n+\t\t.limits = if_limits_chanctx_scc,\n+\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx_scc),\n+\t\t.max_interfaces = 3,\n+\t\t.num_different_channels = 1,\n+\t\t.beacon_int_infra_match = false,\n \t}\n };\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt792x_mac.c b/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\nindex 05978d9c7b91..3f1d9ba49076 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt792x_mac.c\n@@ -142,10 +142,7 @@ struct mt76_wcid *mt792x_rx_get_wcid(struct mt792x_dev *dev, u16 idx,\n \tstruct mt792x_sta *sta;\n \tstruct mt76_wcid *wcid;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (unicast || !wcid)\n \t\treturn wcid;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\nindex 0dbd4662bc84..92148518f6a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mac.c\n@@ -61,10 +61,7 @@ static struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,\n \tstruct mt76_wcid *wcid;\n \tint i;\n \n-\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\treturn NULL;\n-\n-\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\twcid = mt76_wcid_ptr(dev, idx);\n \tif (!wcid)\n \t\treturn NULL;\n \n@@ -1249,7 +1246,7 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)\n \t\t\tu16 idx;\n \n \t\t\tidx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tsta = wcid_to_sta(wcid);\n \t\t\tif (!sta)\n \t\t\t\tgoto next;\n@@ -1471,12 +1468,9 @@ static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)\n \tif (pid < MT_PACKET_ID_NO_SKB)\n \t\treturn;\n \n-\tif (wcidx >= mt7996_wtbl_size(dev))\n-\t\treturn;\n-\n \trcu_read_lock();\n \n-\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n+\twcid = mt76_wcid_ptr(dev, wcidx);\n \tif (!wcid)\n \t\tgoto out;\n \n@@ -2353,20 +2347,12 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)\n void mt7996_mac_sta_rc_work(struct work_struct *work)\n {\n \tstruct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);\n-\tstruct ieee80211_bss_conf *link_conf;\n-\tstruct ieee80211_link_sta *link_sta;\n \tstruct mt7996_sta_link *msta_link;\n-\tstruct mt7996_vif_link *link;\n-\tstruct mt76_vif_link *mlink;\n-\tstruct ieee80211_sta *sta;\n \tstruct ieee80211_vif *vif;\n-\tstruct mt7996_sta *msta;\n \tstruct mt7996_vif *mvif;\n \tLIST_HEAD(list);\n \tu32 changed;\n-\tu8 link_id;\n \n-\trcu_read_lock();\n \tspin_lock_bh(&dev->mt76.sta_poll_lock);\n \tlist_splice_init(&dev->sta_rc_list, &list);\n \n@@ -2377,46 +2363,28 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)\n \n \t\tchanged = msta_link->changed;\n \t\tmsta_link->changed = 0;\n-\n-\t\tsta = wcid_to_sta(&msta_link->wcid);\n-\t\tlink_id = msta_link->wcid.link_id;\n-\t\tmsta = msta_link->sta;\n-\t\tmvif = msta->vif;\n-\t\tvif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);\n-\n-\t\tmlink = rcu_dereference(mvif->mt76.link[link_id]);\n-\t\tif (!mlink)\n-\t\t\tcontinue;\n-\n-\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n-\t\tif (!link_sta)\n-\t\t\tcontinue;\n-\n-\t\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n-\t\tif (!link_conf)\n-\t\t\tcontinue;\n+\t\tmvif = msta_link->sta->vif;\n+\t\tvif = container_of((void *)mvif, struct ieee80211_vif,\n+\t\t\t\t   drv_priv);\n \n \t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n \n-\t\tlink = (struct mt7996_vif_link *)mlink;\n-\n \t\tif (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |\n \t\t\t       IEEE80211_RC_NSS_CHANGED |\n \t\t\t       IEEE80211_RC_BW_CHANGED))\n-\t\t\tmt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t link_sta, link, msta_link,\n+\t\t\tmt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n+\t\t\t\t\t\t msta_link->wcid.link_id,\n \t\t\t\t\t\t true);\n \n \t\tif (changed & IEEE80211_RC_SMPS_CHANGED)\n-\t\t\tmt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t   msta_link, NULL,\n+\t\t\tmt7996_mcu_set_fixed_field(dev, msta_link->sta, NULL,\n+\t\t\t\t\t\t   msta_link->wcid.link_id,\n \t\t\t\t\t\t   RATE_PARAM_MMPS_UPDATE);\n \n \t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n \t}\n \n \tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n-\trcu_read_unlock();\n }\n \n void mt7996_mac_work(struct work_struct *work)\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/main.c b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\nindex 78ae9f5cb176..07dd75ce94a5 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/main.c\n@@ -1112,9 +1112,8 @@ mt7996_mac_sta_event(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t\tif (err)\n \t\t\t\treturn err;\n \n-\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, vif, link_conf,\n-\t\t\t\t\t\t       link_sta, link,\n-\t\t\t\t\t\t       msta_link, false);\n+\t\t\terr = mt7996_mcu_add_rate_ctrl(dev, msta_link->sta, vif,\n+\t\t\t\t\t\t       link_id, false);\n \t\t\tif (err)\n \t\t\t\treturn err;\n \ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\nindex f0adc0b4b8b6..994526c65bfc 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c\n@@ -555,7 +555,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\tswitch (le16_to_cpu(res->tag)) {\n \t\tcase UNI_ALL_STA_TXRX_RATE:\n \t\t\twlan_idx = le16_to_cpu(res->rate[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -565,7 +565,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\t\tbreak;\n \t\tcase UNI_ALL_STA_TXRX_ADM_STAT:\n \t\t\twlan_idx = le16_to_cpu(res->adm_stat[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -579,7 +579,7 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \t\t\tbreak;\n \t\tcase UNI_ALL_STA_TXRX_MSDU_COUNT:\n \t\t\twlan_idx = le16_to_cpu(res->msdu_cnt[i].wlan_idx);\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, wlan_idx);\n \n \t\t\tif (!wcid)\n \t\t\t\tbreak;\n@@ -676,10 +676,7 @@ mt7996_mcu_wed_rro_event(struct mt7996_dev *dev, struct sk_buff *skb)\n \n \t\t\te = (void *)skb->data;\n \t\t\tidx = le16_to_cpu(e->wlan_id);\n-\t\t\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n-\t\t\t\tbreak;\n-\n-\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n+\t\t\twcid = mt76_wcid_ptr(dev, idx);\n \t\t\tif (!wcid || !wcid->sta)\n \t\t\t\tbreak;\n \n@@ -1905,22 +1902,35 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t     MCU_WM_UNI_CMD(RA), true);\n }\n \n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field)\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field)\n {\n-\tstruct sta_phy_uni *phy = data;\n+\tstruct mt7996_vif *mvif = msta->vif;\n+\tstruct mt7996_sta_link *msta_link;\n \tstruct sta_rec_ra_fixed_uni *ra;\n+\tstruct sta_phy_uni *phy = data;\n+\tstruct mt76_vif_link *mlink;\n \tstruct sk_buff *skb;\n+\tint err = -ENODEV;\n \tstruct tlv *tlv;\n \n-\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n+\trcu_read_lock();\n+\n+\tmlink = rcu_dereference(mvif->mt76.link[link_id]);\n+\tif (!mlink)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, mlink,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\terr = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA_UPDATE, sizeof(*ra));\n \tra = (struct sta_rec_ra_fixed_uni *)tlv;\n@@ -1935,106 +1945,149 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n \t\tif (phy)\n \t\t\tra->phy = *phy;\n \t\tbreak;\n-\tcase RATE_PARAM_MMPS_UPDATE:\n+\tcase RATE_PARAM_MMPS_UPDATE: {\n+\t\tstruct ieee80211_sta *sta = wcid_to_sta(&msta_link->wcid);\n+\t\tstruct ieee80211_link_sta *link_sta;\n+\n+\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\t\tif (!link_sta) {\n+\t\t\tdev_kfree_skb(skb);\n+\t\t\tgoto error_unlock;\n+\t\t}\n+\n \t\tra->mmps_mode = mt7996_mcu_get_mmps_mode(link_sta->smps_mode);\n \t\tbreak;\n+\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tra->field = cpu_to_le32(field);\n \n+\trcu_read_unlock();\n+\n \treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn err;\n }\n \n static int\n-mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link)\n+mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       struct ieee80211_vif *vif, u8 link_id)\n {\n-\tstruct cfg80211_chan_def *chandef = &link->phy->mt76->chandef;\n-\tstruct cfg80211_bitrate_mask *mask = &link->bitrate_mask;\n-\tenum nl80211_band band = chandef->chan->band;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct cfg80211_bitrate_mask mask;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n \tstruct sta_phy_uni phy = {};\n-\tint ret, nrates = 0;\n+\tstruct ieee80211_sta *sta;\n+\tint ret, nrates = 0, idx;\n+\tenum nl80211_band band;\n+\tbool has_he;\n \n #define __sta_phy_bitrate_mask_check(_mcs, _gi, _ht, _he)\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\t\\\n-\t\tu8 i, gi = mask->control[band]._gi;\t\t\t\t\\\n+\t\tu8 i, gi = mask.control[band]._gi;\t\t\t\t\\\n \t\tgi = (_he) ? gi : gi == NL80211_TXRATE_FORCE_SGI;\t\t\\\n \t\tphy.sgi = gi;\t\t\t\t\t\t\t\\\n-\t\tphy.he_ltf = mask->control[band].he_ltf;\t\t\t\\\n-\t\tfor (i = 0; i < ARRAY_SIZE(mask->control[band]._mcs); i++) {\t\\\n-\t\t\tif (!mask->control[band]._mcs[i])\t\t\t\\\n+\t\tphy.he_ltf = mask.control[band].he_ltf;\t\t\t\t\\\n+\t\tfor (i = 0; i < ARRAY_SIZE(mask.control[band]._mcs); i++) {\t\\\n+\t\t\tif (!mask.control[band]._mcs[i])\t\t\t\\\n \t\t\t\tcontinue;\t\t\t\t\t\\\n-\t\t\tnrates += hweight16(mask->control[band]._mcs[i]);\t\\\n-\t\t\tphy.mcs = ffs(mask->control[band]._mcs[i]) - 1;\t\t\\\n+\t\t\tnrates += hweight16(mask.control[band]._mcs[i]);\t\\\n+\t\t\tphy.mcs = ffs(mask.control[band]._mcs[i]) - 1;\t\t\\\n \t\t\tif (_ht)\t\t\t\t\t\t\\\n \t\t\t\tphy.mcs += 8 * i;\t\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\t\\\n \t} while (0)\n \n-\tif (link_sta->he_cap.has_he) {\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tband = link->phy->mt76->chandef.chan->band;\n+\thas_he = link_sta->he_cap.has_he;\n+\tmask = link->bitrate_mask;\n+\tidx = msta_link->wcid.idx;\n+\n+\tif (has_he) {\n \t\t__sta_phy_bitrate_mask_check(he_mcs, he_gi, 0, 1);\n \t} else if (link_sta->vht_cap.vht_supported) {\n \t\t__sta_phy_bitrate_mask_check(vht_mcs, gi, 0, 0);\n \t} else if (link_sta->ht_cap.ht_supported) {\n \t\t__sta_phy_bitrate_mask_check(ht_mcs, gi, 1, 0);\n \t} else {\n-\t\tnrates = hweight32(mask->control[band].legacy);\n-\t\tphy.mcs = ffs(mask->control[band].legacy) - 1;\n+\t\tnrates = hweight32(mask.control[band].legacy);\n+\t\tphy.mcs = ffs(mask.control[band].legacy) - 1;\n \t}\n+\n+\trcu_read_unlock();\n+\n #undef __sta_phy_bitrate_mask_check\n \n \t/* fall back to auto rate control */\n-\tif (mask->control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n-\t    mask->control[band].he_gi == GENMASK(7, 0) &&\n-\t    mask->control[band].he_ltf == GENMASK(7, 0) &&\n+\tif (mask.control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n+\t    mask.control[band].he_gi == GENMASK(7, 0) &&\n+\t    mask.control[band].he_ltf == GENMASK(7, 0) &&\n \t    nrates != 1)\n \t\treturn 0;\n \n \t/* fixed single rate */\n \tif (nrates == 1) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_MCS);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \t/* fixed GI */\n-\tif (mask->control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n-\t    mask->control[band].he_gi != GENMASK(7, 0)) {\n+\tif (mask.control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n+\t    mask.control[band].he_gi != GENMASK(7, 0)) {\n \t\tu32 addr;\n \n \t\t/* firmware updates only TXCMD but doesn't take WTBL into\n \t\t * account, so driver should update here to reflect the\n \t\t * actual txrate hardware sends out.\n \t\t */\n-\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, msta_link->wcid.idx, 7);\n-\t\tif (link_sta->he_cap.has_he)\n+\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 7);\n+\t\tif (has_he)\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(31, 24), phy.sgi);\n \t\telse\n \t\t\tmt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);\n \n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_GI);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \t/* fixed HE_LTF */\n-\tif (mask->control[band].he_ltf != GENMASK(7, 0)) {\n-\t\tret = mt7996_mcu_set_fixed_field(dev, link_sta, link,\n-\t\t\t\t\t\t msta_link, &phy,\n+\tif (mask.control[band].he_ltf != GENMASK(7, 0)) {\n+\t\tret = mt7996_mcu_set_fixed_field(dev, msta, &phy, link_id,\n \t\t\t\t\t\t RATE_PARAM_FIXED_HE_LTF);\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n \n \treturn 0;\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn -ENODEV;\n }\n \n static void\n@@ -2145,21 +2198,44 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,\n \tmemset(ra->rx_rcpi, INIT_RCPI, sizeof(ra->rx_rcpi));\n }\n \n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed)\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed)\n {\n+\tstruct ieee80211_bss_conf *link_conf;\n+\tstruct ieee80211_link_sta *link_sta;\n+\tstruct mt7996_sta_link *msta_link;\n+\tstruct mt7996_vif_link *link;\n+\tstruct ieee80211_sta *sta;\n \tstruct sk_buff *skb;\n-\tint ret;\n+\tint ret = -ENODEV;\n+\n+\trcu_read_lock();\n+\n+\tlink = mt7996_vif_link(dev, vif, link_id);\n+\tif (!link)\n+\t\tgoto error_unlock;\n+\n+\tmsta_link = rcu_dereference(msta->link[link_id]);\n+\tif (!msta_link)\n+\t\tgoto error_unlock;\n+\n+\tsta = wcid_to_sta(&msta_link->wcid);\n+\tlink_sta = rcu_dereference(sta->link[link_id]);\n+\tif (!link_sta)\n+\t\tgoto error_unlock;\n+\n+\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n+\tif (!link_conf)\n+\t\tgoto error_unlock;\n \n \tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &link->mt76,\n \t\t\t\t\t      &msta_link->wcid,\n \t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n-\tif (IS_ERR(skb))\n-\t\treturn PTR_ERR(skb);\n+\tif (IS_ERR(skb)) {\n+\t\tret = PTR_ERR(skb);\n+\t\tgoto error_unlock;\n+\t}\n \n \t/* firmware rc algorithm refers to sta_rec_he for HE control.\n \t * once dev->rc_work changes the settings driver should also\n@@ -2173,12 +2249,19 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n \t */\n \tmt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, link_conf, link_sta, link);\n \n+\trcu_read_unlock();\n+\n \tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n \t\t\t\t    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n \tif (ret)\n \t\treturn ret;\n \n-\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, link_sta, link, msta_link);\n+\treturn mt7996_mcu_add_rate_ctrl_fixed(dev, msta, vif, link_id);\n+\n+error_unlock:\n+\trcu_read_unlock();\n+\n+\treturn ret;\n }\n \n static int\ndiff --git a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\nindex 1ad6bc046f7c..33ac16b64ef1 100644\n--- a/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n+++ b/drivers/net/wireless/mediatek/mt76/mt7996/mt7996.h\n@@ -620,23 +620,17 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,\n int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,\n \t\t\t    struct mt7996_vif_link *link,\n \t\t\t    struct ieee80211_he_obss_pd *he_obss_pd);\n-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,\n-\t\t\t     struct ieee80211_vif *vif,\n-\t\t\t     struct ieee80211_bss_conf *link_conf,\n-\t\t\t     struct ieee80211_link_sta *link_sta,\n-\t\t\t     struct mt7996_vif_link *link,\n-\t\t\t     struct mt7996_sta_link *msta_link, bool changed);\n+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t     struct ieee80211_vif *vif, u8 link_id,\n+\t\t\t     bool changed);\n int mt7996_set_channel(struct mt76_phy *mphy);\n int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);\n int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n \t\t      struct ieee80211_bss_conf *link_conf);\n int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n \t\t\t\t   void *data, u16 version);\n-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,\n-\t\t\t       struct ieee80211_link_sta *link_sta,\n-\t\t\t       struct mt7996_vif_link *link,\n-\t\t\t       struct mt7996_sta_link *msta_link,\n-\t\t\t       void *data, u32 field);\n+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,\n+\t\t\t       void *data, u8 link_id, u32 field);\n int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);\n int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len);\n int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num);\ndiff --git a/drivers/net/wireless/mediatek/mt76/tx.c b/drivers/net/wireless/mediatek/mt76/tx.c\nindex 513916469ca2..e6cf16706667 100644\n--- a/drivers/net/wireless/mediatek/mt76/tx.c\n+++ b/drivers/net/wireless/mediatek/mt76/tx.c\n@@ -64,7 +64,7 @@ mt76_tx_status_unlock(struct mt76_dev *dev, struct sk_buff_head *list)\n \t\tstruct mt76_tx_cb *cb = mt76_tx_skb_cb(skb);\n \t\tstruct mt76_wcid *wcid;\n \n-\t\twcid = rcu_dereference(dev->wcid[cb->wcid]);\n+\t\twcid = __mt76_wcid_ptr(dev, cb->wcid);\n \t\tif (wcid) {\n \t\t\tstatus.sta = wcid_to_sta(wcid);\n \t\t\tif (status.sta && (wcid->rate.flags || wcid->rate.legacy)) {\n@@ -251,9 +251,7 @@ void __mt76_tx_complete_skb(struct mt76_dev *dev, u16 wcid_idx, struct sk_buff *\n \n \trcu_read_lock();\n \n-\tif (wcid_idx < ARRAY_SIZE(dev->wcid))\n-\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n-\n+\twcid = __mt76_wcid_ptr(dev, wcid_idx);\n \tmt76_tx_check_non_aql(dev, wcid, skb);\n \n #ifdef CONFIG_NL80211_TESTMODE\n@@ -538,7 +536,7 @@ mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)\n \t\t\tbreak;\n \n \t\tmtxq = (struct mt76_txq *)txq->drv_priv;\n-\t\twcid = rcu_dereference(dev->wcid[mtxq->wcid]);\n+\t\twcid = __mt76_wcid_ptr(dev, mtxq->wcid);\n \t\tif (!wcid || test_bit(MT_WCID_FLAG_PS, &wcid->flags))\n \t\t\tcontinue;\n \n@@ -617,7 +615,8 @@ mt76_txq_schedule_pending_wcid(struct mt76_phy *phy, struct mt76_wcid *wcid,\n \t\tif ((dev->drv->drv_flags & MT_DRV_HW_MGMT_TXQ) &&\n \t\t    !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n \t\t    !ieee80211_is_data(hdr->frame_control) &&\n-\t\t    !ieee80211_is_bufferable_mmpdu(skb))\n+\t\t    (!ieee80211_is_bufferable_mmpdu(skb) ||\n+\t\t     ieee80211_is_deauth(hdr->frame_control)))\n \t\t\tqid = MT_TXQ_PSD;\n \n \t\tq = phy->q_tx[qid];\ndiff --git a/drivers/net/wireless/mediatek/mt76/util.c b/drivers/net/wireless/mediatek/mt76/util.c\nindex 95b3dc96e4c4..97249ebb4bc8 100644\n--- a/drivers/net/wireless/mediatek/mt76/util.c\n+++ b/drivers/net/wireless/mediatek/mt76/util.c\n@@ -83,7 +83,7 @@ int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx)\n \t\t\tif (!(mask & 1))\n \t\t\t\tcontinue;\n \n-\t\t\twcid = rcu_dereference(dev->wcid[j]);\n+\t\t\twcid = __mt76_wcid_ptr(dev, j);\n \t\t\tif (!wcid || wcid->phy_idx != phy_idx)\n \t\t\t\tcontinue;\n \ndiff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\nindex eface610178d..f7f3a2340c39 100644\n--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\n+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c\n@@ -108,7 +108,7 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)\n }\n EXPORT_SYMBOL_GPL(rt2x00soc_probe);\n \n-int rt2x00soc_remove(struct platform_device *pdev)\n+void rt2x00soc_remove(struct platform_device *pdev)\n {\n \tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n \tstruct rt2x00_dev *rt2x00dev = hw->priv;\n@@ -119,8 +119,6 @@ int rt2x00soc_remove(struct platform_device *pdev)\n \trt2x00lib_remove_dev(rt2x00dev);\n \trt2x00soc_free_reg(rt2x00dev);\n \tieee80211_free_hw(hw);\n-\n-\treturn 0;\n }\n EXPORT_SYMBOL_GPL(rt2x00soc_remove);\n \ndiff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\nindex 021fd06b3627..d6226b8a10e0 100644\n--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\n+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h\n@@ -17,7 +17,7 @@\n  * SoC driver handlers.\n  */\n int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops);\n-int rt2x00soc_remove(struct platform_device *pdev);\n+void rt2x00soc_remove(struct platform_device *pdev);\n #ifdef CONFIG_PM\n int rt2x00soc_suspend(struct platform_device *pdev, pm_message_t state);\n int rt2x00soc_resume(struct platform_device *pdev);\ndiff --git a/drivers/net/wireless/zydas/zd1211rw/zd_mac.c b/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\nindex 9653dbaac3c0..781510a3ec6d 100644\n--- a/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\n+++ b/drivers/net/wireless/zydas/zd1211rw/zd_mac.c\n@@ -583,7 +583,11 @@ void zd_mac_tx_to_dev(struct sk_buff *skb, int error)\n \n \t\tskb_queue_tail(q, skb);\n \t\twhile (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {\n-\t\t\tzd_mac_tx_status(hw, skb_dequeue(q),\n+\t\t\tskb = skb_dequeue(q);\n+\t\t\tif (!skb)\n+\t\t\t\tbreak;\n+\n+\t\t\tzd_mac_tx_status(hw, skb,\n \t\t\t\t\t mac->ack_pending ? mac->ack_signal : 0,\n \t\t\t\t\t NULL);\n \t\t\tmac->ack_pending = 0;\ndiff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h\nindex 22f39e5e2ff1..996be3c2cff0 100644\n--- a/include/linux/ieee80211.h\n+++ b/include/linux/ieee80211.h\n@@ -662,18 +662,6 @@ static inline bool ieee80211_s1g_has_cssid(__le16 fc)\n \t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_CSSID));\n }\n \n-/**\n- * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n- * @fc: frame control bytes in little-endian byteorder\n- * Return: whether or not the frame is an S1G short beacon,\n- *\ti.e. it is an S1G beacon with 'next TBTT' flag set\n- */\n-static inline bool ieee80211_is_s1g_short_beacon(__le16 fc)\n-{\n-\treturn ieee80211_is_s1g_beacon(fc) &&\n-\t\t(fc & cpu_to_le16(IEEE80211_S1G_BCN_NEXT_TBTT));\n-}\n-\n /**\n  * ieee80211_is_atim - check if IEEE80211_FTYPE_MGMT && IEEE80211_STYPE_ATIM\n  * @fc: frame control bytes in little-endian byteorder\n@@ -4901,6 +4889,39 @@ static inline bool ieee80211_is_ftm(struct sk_buff *skb)\n \treturn false;\n }\n \n+/**\n+ * ieee80211_is_s1g_short_beacon - check if frame is an S1G short beacon\n+ * @fc: frame control bytes in little-endian byteorder\n+ * @variable: pointer to the beacon frame elements\n+ * @variable_len: length of the frame elements\n+ * Return: whether or not the frame is an S1G short beacon. As per\n+ *\tIEEE80211-2024 11.1.3.10.1, The S1G beacon compatibility element shall\n+ *\talways be present as the first element in beacon frames generated at a\n+ *\tTBTT (Target Beacon Transmission Time), so any frame not containing\n+ *\tthis element must have been generated at a TSBTT (Target Short Beacon\n+ *\tTransmission Time) that is not a TBTT. Additionally, short beacons are\n+ *\tprohibited from containing the S1G beacon compatibility element as per\n+ *\tIEEE80211-2024 9.3.4.3 Table 9-76, so if we have an S1G beacon with\n+ *\teither no elements or the first element is not the beacon compatibility\n+ *\telement, we have a short beacon.\n+ */\n+static inline bool ieee80211_is_s1g_short_beacon(__le16 fc, const u8 *variable,\n+\t\t\t\t\t\t size_t variable_len)\n+{\n+\tif (!ieee80211_is_s1g_beacon(fc))\n+\t\treturn false;\n+\n+\t/*\n+\t * If the frame does not contain at least 1 element (this is perfectly\n+\t * valid in a short beacon) and is an S1G beacon, we have a short\n+\t * beacon.\n+\t */\n+\tif (variable_len < 2)\n+\t\treturn true;\n+\n+\treturn variable[0] != WLAN_EID_S1G_BCN_COMPAT;\n+}\n+\n struct element {\n \tu8 id;\n \tu8 datalen;\ndiff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c\nindex d9d88f2f2831..954795b0fe48 100644\n--- a/net/mac80211/cfg.c\n+++ b/net/mac80211/cfg.c\n@@ -1959,6 +1959,20 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,\n \tieee80211_sta_init_nss(link_sta);\n \n \tif (params->opmode_notif_used) {\n+\t\tenum nl80211_chan_width width = link->conf->chanreq.oper.width;\n+\n+\t\tswitch (width) {\n+\t\tcase NL80211_CHAN_WIDTH_20:\n+\t\tcase NL80211_CHAN_WIDTH_40:\n+\t\tcase NL80211_CHAN_WIDTH_80:\n+\t\tcase NL80211_CHAN_WIDTH_160:\n+\t\tcase NL80211_CHAN_WIDTH_80P80:\n+\t\tcase NL80211_CHAN_WIDTH_320: /* not VHT, allowed for HE/EHT */\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\n \t\t/* returned value is only needed for rc update, but the\n \t\t * rc isn't initialized here yet, so ignore it\n \t\t */\ndiff --git a/net/mac80211/iface.c b/net/mac80211/iface.c\nindex 7c27f3cd841c..c01634fdba78 100644\n--- a/net/mac80211/iface.c\n+++ b/net/mac80211/iface.c\n@@ -1150,6 +1150,8 @@ static void ieee80211_sdata_init(struct ieee80211_local *local,\n {\n \tsdata->local = local;\n \n+\tINIT_LIST_HEAD(&sdata->key_list);\n+\n \t/*\n \t * Initialize the default link, so we can use link_id 0 for non-MLD,\n \t * and that continues to work for non-MLD-aware drivers that use just\n@@ -2210,8 +2212,6 @@ int ieee80211_if_add(struct ieee80211_local *local, const char *name,\n \n \tieee80211_init_frag_cache(&sdata->frags);\n \n-\tINIT_LIST_HEAD(&sdata->key_list);\n-\n \twiphy_delayed_work_init(&sdata->dec_tailroom_needed_wk,\n \t\t\t\tieee80211_delayed_tailroom_dec);\n \ndiff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c\nindex 2d46d4af60d7..0ed68182f79b 100644\n--- a/net/mac80211/mlme.c\n+++ b/net/mac80211/mlme.c\n@@ -3934,6 +3934,9 @@ static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,\n \n \tlockdep_assert_wiphy(local->hw.wiphy);\n \n+\tif (frame_buf)\n+\t\tmemset(frame_buf, 0, IEEE80211_DEAUTH_FRAME_LEN);\n+\n \tif (WARN_ON(!ap_sta))\n \t\treturn;\n \n@@ -7195,6 +7198,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \tstruct ieee80211_bss_conf *bss_conf = link->conf;\n \tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n \tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n+\tstruct ieee80211_ext *ext = NULL;\n \tsize_t baselen;\n \tstruct ieee802_11_elems *elems;\n \tstruct ieee80211_local *local = sdata->local;\n@@ -7220,7 +7224,7 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t/* Process beacon from the current BSS */\n \tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n \tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n-\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n+\t\text = (void *)mgmt;\n \t\tvariable = ext->u.s1g_beacon.variable +\n \t\t\t   ieee80211_s1g_optional_len(ext->frame_control);\n \t}\n@@ -7407,7 +7411,9 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n \t}\n \n \tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n-\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n+\t    (ext && ieee80211_is_s1g_short_beacon(ext->frame_control,\n+\t\t\t\t\t\t  parse_params.start,\n+\t\t\t\t\t\t  parse_params.len)))\n \t\tgoto free;\n \tlink->u.mgd.beacon_crc = ncrc;\n \tlink->u.mgd.beacon_crc_valid = true;\n@@ -10699,8 +10705,8 @@ static void ieee80211_ml_epcs(struct ieee80211_sub_if_data *sdata,\n \t */\n \tfor_each_mle_subelement(sub, (const u8 *)elems->ml_epcs,\n \t\t\t\telems->ml_epcs_len) {\n+\t\tstruct ieee802_11_elems *link_elems __free(kfree) = NULL;\n \t\tstruct ieee80211_link_data *link;\n-\t\tstruct ieee802_11_elems *link_elems __free(kfree);\n \t\tu8 *pos = (void *)sub->data;\n \t\tu16 control;\n \t\tssize_t len;\ndiff --git a/net/mac80211/parse.c b/net/mac80211/parse.c\nindex 96584b39215e..c5e0f7f46004 100644\n--- a/net/mac80211/parse.c\n+++ b/net/mac80211/parse.c\n@@ -758,7 +758,6 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,\n {\n \tconst struct element *elem, *sub;\n \tsize_t profile_len = 0;\n-\tbool found = false;\n \n \tif (!bss || !bss->transmitted_bss)\n \t\treturn profile_len;\n@@ -809,15 +808,14 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,\n \t\t\t\t\t       index[2],\n \t\t\t\t\t       new_bssid);\n \t\t\tif (ether_addr_equal(new_bssid, bss->bssid)) {\n-\t\t\t\tfound = true;\n \t\t\t\telems->bssid_index_len = index[1];\n \t\t\t\telems->bssid_index = (void *)&index[2];\n-\t\t\t\tbreak;\n+\t\t\t\treturn profile_len;\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn found ? profile_len : 0;\n+\treturn 0;\n }\n \n static void\ndiff --git a/net/mac80211/util.c b/net/mac80211/util.c\nindex a125995ed252..e66da651678a 100644\n--- a/net/mac80211/util.c\n+++ b/net/mac80211/util.c\n@@ -2144,11 +2144,6 @@ int ieee80211_reconfig(struct ieee80211_local *local)\n \t\tcfg80211_sched_scan_stopped_locked(local->hw.wiphy, 0);\n \n  wake_up:\n-\n-\tif (local->virt_monitors > 0 &&\n-\t    local->virt_monitors == local->open_count)\n-\t\tieee80211_add_virtual_monitor(local);\n-\n \t/*\n \t * Clear the WLAN_STA_BLOCK_BA flag so new aggregation\n \t * sessions can be established after a resume.\n@@ -2202,6 +2197,10 @@ int ieee80211_reconfig(struct ieee80211_local *local)\n \t\t}\n \t}\n \n+\tif (local->virt_monitors > 0 &&\n+\t    local->virt_monitors == local->open_count)\n+\t\tieee80211_add_virtual_monitor(local);\n+\n \tif (!suspended)\n \t\treturn 0;\n \ndiff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c\nindex 85f139016da2..50202d170f3a 100644\n--- a/net/wireless/nl80211.c\n+++ b/net/wireless/nl80211.c\n@@ -229,6 +229,7 @@ static int validate_beacon_head(const struct nlattr *attr,\n \tunsigned int len = nla_len(attr);\n \tconst struct element *elem;\n \tconst struct ieee80211_mgmt *mgmt = (void *)data;\n+\tconst struct ieee80211_ext *ext;\n \tunsigned int fixedlen, hdrlen;\n \tbool s1g_bcn;\n \n@@ -237,8 +238,10 @@ static int validate_beacon_head(const struct nlattr *attr,\n \n \ts1g_bcn = ieee80211_is_s1g_beacon(mgmt->frame_control);\n \tif (s1g_bcn) {\n-\t\tfixedlen = offsetof(struct ieee80211_ext,\n-\t\t\t\t    u.s1g_beacon.variable);\n+\t\text = (struct ieee80211_ext *)mgmt;\n+\t\tfixedlen =\n+\t\t\toffsetof(struct ieee80211_ext, u.s1g_beacon.variable) +\n+\t\t\tieee80211_s1g_optional_len(ext->frame_control);\n \t\thdrlen = offsetof(struct ieee80211_ext, u.s1g_beacon);\n \t} else {\n \t\tfixedlen = offsetof(struct ieee80211_mgmt,\ndiff --git a/net/wireless/util.c b/net/wireless/util.c\nindex ed868c0f7ca8..1ad5a6bdfd75 100644\n--- a/net/wireless/util.c\n+++ b/net/wireless/util.c\n@@ -820,6 +820,52 @@ bool ieee80211_is_valid_amsdu(struct sk_buff *skb, u8 mesh_hdr)\n }\n EXPORT_SYMBOL(ieee80211_is_valid_amsdu);\n \n+\n+/*\n+ * Detects if an MSDU frame was maliciously converted into an A-MSDU\n+ * frame by an adversary. This is done by parsing the received frame\n+ * as if it were a regular MSDU, even though the A-MSDU flag is set.\n+ *\n+ * For non-mesh interfaces, detection involves checking whether the\n+ * payload, when interpreted as an MSDU, begins with a valid RFC1042\n+ * header. This is done by comparing the A-MSDU subheader's destination\n+ * address to the start of the RFC1042 header.\n+ *\n+ * For mesh interfaces, the MSDU includes a 6-byte Mesh Control field\n+ * and an optional variable-length Mesh Address Extension field before\n+ * the RFC1042 header. The position of the RFC1042 header must therefore\n+ * be calculated based on the mesh header length.\n+ *\n+ * Since this function intentionally parses an A-MSDU frame as an MSDU,\n+ * it only assumes that the A-MSDU subframe header is present, and\n+ * beyond this it performs its own bounds checks under the assumption\n+ * that the frame is instead parsed as a non-aggregated MSDU.\n+ */\n+static bool\n+is_amsdu_aggregation_attack(struct ethhdr *eth, struct sk_buff *skb,\n+\t\t\t    enum nl80211_iftype iftype)\n+{\n+\tint offset;\n+\n+\t/* Non-mesh case can be directly compared */\n+\tif (iftype != NL80211_IFTYPE_MESH_POINT)\n+\t\treturn ether_addr_equal(eth->h_dest, rfc1042_header);\n+\n+\toffset = __ieee80211_get_mesh_hdrlen(eth->h_dest[0]);\n+\tif (offset == 6) {\n+\t\t/* Mesh case with empty address extension field */\n+\t\treturn ether_addr_equal(eth->h_source, rfc1042_header);\n+\t} else if (offset + ETH_ALEN <= skb->len) {\n+\t\t/* Mesh case with non-empty address extension field */\n+\t\tu8 temp[ETH_ALEN];\n+\n+\t\tskb_copy_bits(skb, offset, temp, ETH_ALEN);\n+\t\treturn ether_addr_equal(temp, rfc1042_header);\n+\t}\n+\n+\treturn false;\n+}\n+\n void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n \t\t\t      const unsigned int extra_headroom,\n@@ -861,8 +907,10 @@ void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n \t\t/* the last MSDU has no padding */\n \t\tif (subframe_len > remaining)\n \t\t\tgoto purge;\n-\t\t/* mitigate A-MSDU aggregation injection attacks */\n-\t\tif (ether_addr_equal(hdr.eth.h_dest, rfc1042_header))\n+\t\t/* mitigate A-MSDU aggregation injection attacks, to be\n+\t\t * checked when processing first subframe (offset == 0).\n+\t\t */\n+\t\tif (offset == 0 && is_amsdu_aggregation_attack(&hdr.eth, skb, iftype))\n \t\t\tgoto purge;\n \n \t\toffset += sizeof(struct ethhdr);",
    "stats": {
      "insertions": 430,
      "deletions": 233,
      "files": 39
    }
  },
  {
    "sha": "18cdb3d982da8976b28d57691eb256ec5688fad2",
    "message": "netfilter: flowtable: account for Ethernet header in nf_flow_pppoe_proto()\n\nsyzbot found a potential access to uninit-value in nf_flow_pppoe_proto()\n\nBlamed commit forgot the Ethernet header.\n\nBUG: KMSAN: uninit-value in nf_flow_offload_inet_hook+0x7e4/0x940 net/netfilter/nf_flow_table_inet.c:27\n  nf_flow_offload_inet_hook+0x7e4/0x940 net/netfilter/nf_flow_table_inet.c:27\n  nf_hook_entry_hookfn include/linux/netfilter.h:157 [inline]\n  nf_hook_slow+0xe1/0x3d0 net/netfilter/core.c:623\n  nf_hook_ingress include/linux/netfilter_netdev.h:34 [inline]\n  nf_ingress net/core/dev.c:5742 [inline]\n  __netif_receive_skb_core+0x4aff/0x70c0 net/core/dev.c:5837\n  __netif_receive_skb_one_core net/core/dev.c:5975 [inline]\n  __netif_receive_skb+0xcc/0xac0 net/core/dev.c:6090\n  netif_receive_skb_internal net/core/dev.c:6176 [inline]\n  netif_receive_skb+0x57/0x630 net/core/dev.c:6235\n  tun_rx_batched+0x1df/0x980 drivers/net/tun.c:1485\n  tun_get_user+0x4ee0/0x6b40 drivers/net/tun.c:1938\n  tun_chr_write_iter+0x3e9/0x5c0 drivers/net/tun.c:1984\n  new_sync_write fs/read_write.c:593 [inline]\n  vfs_write+0xb4b/0x1580 fs/read_write.c:686\n  ksys_write fs/read_write.c:738 [inline]\n  __do_sys_write fs/read_write.c:749 [inline]\n\nReported-by: syzbot+bf6ed459397e307c3ad2@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/netdev/686bc073.a00a0220.c7b3.0086.GAE@google.com/T/#u\nFixes: 87b3593bed18 (\"netfilter: flowtable: validate pppoe header\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReviewed-by: Pablo Neira Ayuso <pablo@netfilter.org>\nLink: https://patch.msgid.link/20250707124517.614489-1-edumazet@google.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Eric Dumazet",
    "date": "2025-07-10T17:12:28-07:00",
    "files_changed": [
      "include/net/netfilter/nf_flow_table.h"
    ],
    "diff": "diff --git a/include/net/netfilter/nf_flow_table.h b/include/net/netfilter/nf_flow_table.h\nindex d711642e78b5..c003cd194fa2 100644\n--- a/include/net/netfilter/nf_flow_table.h\n+++ b/include/net/netfilter/nf_flow_table.h\n@@ -370,7 +370,7 @@ static inline __be16 __nf_flow_pppoe_proto(const struct sk_buff *skb)\n \n static inline bool nf_flow_pppoe_proto(struct sk_buff *skb, __be16 *inner_proto)\n {\n-\tif (!pskb_may_pull(skb, PPPOE_SES_HLEN))\n+\tif (!pskb_may_pull(skb, ETH_HLEN + PPPOE_SES_HLEN))\n \t\treturn false;\n \n \t*inner_proto = __nf_flow_pppoe_proto(skb);",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  },
  {
    "sha": "bc9ff192a6c940d9a26e21a0a82f2667067aaf5f",
    "message": "Merge tag 'net-6.16-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net\n\nPull networking fixes from Paolo Abeni:\n \"Including fixes from Bluetooth.\n\n  Current release - regressions:\n\n   - tcp: refine sk_rcvbuf increase for ooo packets\n\n   - bluetooth: fix attempting to send HCI_Disconnect to BIS handle\n\n   - rxrpc: fix over large frame size warning\n\n   - eth: bcmgenet: initialize u64 stats seq counter\n\n  Previous releases - regressions:\n\n   - tcp: correct signedness in skb remaining space calculation\n\n   - sched: abort __tc_modify_qdisc if parent class does not exist\n\n   - vsock: fix transport_{g2h,h2g} TOCTOU\n\n   - rxrpc: fix bug due to prealloc collision\n\n   - tipc: fix use-after-free in tipc_conn_close().\n\n   - bluetooth: fix not marking Broadcast Sink BIS as connected\n\n   - phy: qca808x: fix WoL issue by utilizing at8031_set_wol()\n\n   - eth: am65-cpsw-nuss: fix skb size by accounting for skb_shared_info\n\n  Previous releases - always broken:\n\n   - netlink: fix wraparounds of sk->sk_rmem_alloc.\n\n   - atm: fix infinite recursive call of clip_push().\n\n   - eth:\n      - stmmac: fix interrupt handling for level-triggered mode in DWC_XGMAC2\n      - rtsn: fix a null pointer dereference in rtsn_probe()\"\n\n* tag 'net-6.16-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net: (37 commits)\n  net/sched: sch_qfq: Fix null-deref in agg_dequeue\n  rxrpc: Fix oops due to non-existence of prealloc backlog struct\n  rxrpc: Fix bug due to prealloc collision\n  MAINTAINERS: remove myself as netronome maintainer\n  selftests/net: packetdrill: add tcp_ooo-before-and-after-accept.pkt\n  tcp: refine sk_rcvbuf increase for ooo packets\n  net/sched: Abort __tc_modify_qdisc if parent class does not exist\n  net: ethernet: ti: am65-cpsw-nuss: Fix skb size by accounting for skb_shared_info\n  net: thunderx: avoid direct MTU assignment after WRITE_ONCE()\n  selftests/tc-testing: Create test case for UAF scenario with DRR/NETEM/BLACKHOLE chain\n  atm: clip: Fix NULL pointer dereference in vcc_sendmsg()\n  atm: clip: Fix infinite recursive call of clip_push().\n  atm: clip: Fix memory leak of struct clip_vcc.\n  atm: clip: Fix potential null-ptr-deref in to_atmarpd().\n  net: phy: smsc: Fix link failure in forced mode with Auto-MDIX\n  net: phy: smsc: Force predictable MDI-X state on LAN87xx\n  net: phy: smsc: Fix Auto-MDIX configuration when disabled by strap\n  net: stmmac: Fix interrupt handling for level-triggered mode in DWC_XGMAC2\n  rxrpc: Fix over large frame size warning\n  net: airoha: Fix an error handling path in airoha_probe()\n  ...",
    "author": "Linus Torvalds",
    "date": "2025-07-10T09:18:53-07:00",
    "files_changed": [
      "drivers/net/ethernet/airoha/airoha_eth.c",
      "drivers/net/ethernet/broadcom/bnxt/bnxt.c",
      "drivers/net/ethernet/broadcom/genet/bcmgenet.c",
      "drivers/net/ethernet/cavium/thunder/nicvf_main.c",
      "drivers/net/ethernet/renesas/rtsn.c",
      "drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c",
      "drivers/net/ethernet/ti/am65-cpsw-nuss.c",
      "drivers/net/phy/qcom/at803x.c",
      "drivers/net/phy/qcom/qca808x.c",
      "drivers/net/phy/qcom/qcom-phy-lib.c",
      "drivers/net/phy/qcom/qcom.h",
      "drivers/net/phy/smsc.c",
      "include/net/af_vsock.h",
      "include/net/bluetooth/hci_core.h",
      "include/net/pkt_sched.h",
      "net/atm/clip.c",
      "net/bluetooth/hci_event.c",
      "net/bluetooth/hci_sync.c",
      "net/ipv4/tcp.c",
      "net/ipv4/tcp_input.c",
      "net/netlink/af_netlink.c",
      "net/rxrpc/ar-internal.h",
      "net/rxrpc/call_accept.c",
      "net/rxrpc/output.c",
      "net/sched/sch_api.c",
      "net/sched/sch_hfsc.c",
      "net/sched/sch_qfq.c",
      "net/tipc/topsrv.c",
      "net/vmw_vsock/af_vsock.c"
    ],
    "diff": "diff --git a/Documentation/devicetree/bindings/net/allwinner,sun8i-a83t-emac.yaml b/Documentation/devicetree/bindings/net/allwinner,sun8i-a83t-emac.yaml\nindex 7b6a2fde8175..19934d5c24e5 100644\n--- a/Documentation/devicetree/bindings/net/allwinner,sun8i-a83t-emac.yaml\n+++ b/Documentation/devicetree/bindings/net/allwinner,sun8i-a83t-emac.yaml\n@@ -23,7 +23,7 @@ properties:\n               - allwinner,sun20i-d1-emac\n               - allwinner,sun50i-h6-emac\n               - allwinner,sun50i-h616-emac0\n-              - allwinner,sun55i-a523-emac0\n+              - allwinner,sun55i-a523-gmac0\n           - const: allwinner,sun50i-a64-emac\n \n   reg:\ndiff --git a/MAINTAINERS b/MAINTAINERS\nindex eb7616d241b9..60eba51d8839 100644\n--- a/MAINTAINERS\n+++ b/MAINTAINERS\n@@ -17224,10 +17224,10 @@ F:\tdrivers/rtc/rtc-ntxec.c\n F:\tinclude/linux/mfd/ntxec.h\n \n NETRONOME ETHERNET DRIVERS\n-M:\tLouis Peens <louis.peens@corigine.com>\n R:\tJakub Kicinski <kuba@kernel.org>\n+R:\tSimon Horman <horms@kernel.org>\n L:\toss-drivers@corigine.com\n-S:\tMaintained\n+S:\tOdd Fixes\n F:\tdrivers/net/ethernet/netronome/\n \n NETWORK BLOCK DEVICE (NBD)\ndiff --git a/drivers/net/ethernet/airoha/airoha_eth.c b/drivers/net/ethernet/airoha/airoha_eth.c\nindex 06dea3a13e77..9057180051df 100644\n--- a/drivers/net/ethernet/airoha/airoha_eth.c\n+++ b/drivers/net/ethernet/airoha/airoha_eth.c\n@@ -2984,6 +2984,7 @@ static int airoha_probe(struct platform_device *pdev)\n error_napi_stop:\n \tfor (i = 0; i < ARRAY_SIZE(eth->qdma); i++)\n \t\tairoha_qdma_stop_napi(&eth->qdma[i]);\n+\tairoha_ppe_deinit(eth);\n error_hw_cleanup:\n \tfor (i = 0; i < ARRAY_SIZE(eth->qdma); i++)\n \t\tairoha_hw_cleanup(&eth->qdma[i]);\ndiff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c\nindex ae89a981e052..243cb13cb01c 100644\n--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n@@ -11607,11 +11607,9 @@ static void bnxt_free_irq(struct bnxt *bp)\n \n static int bnxt_request_irq(struct bnxt *bp)\n {\n+\tstruct cpu_rmap *rmap = NULL;\n \tint i, j, rc = 0;\n \tunsigned long flags = 0;\n-#ifdef CONFIG_RFS_ACCEL\n-\tstruct cpu_rmap *rmap;\n-#endif\n \n \trc = bnxt_setup_int_mode(bp);\n \tif (rc) {\n@@ -11632,15 +11630,15 @@ static int bnxt_request_irq(struct bnxt *bp)\n \t\tint map_idx = bnxt_cp_num_to_irq_num(bp, i);\n \t\tstruct bnxt_irq *irq = &bp->irq_tbl[map_idx];\n \n-#ifdef CONFIG_RFS_ACCEL\n-\t\tif (rmap && bp->bnapi[i]->rx_ring) {\n+\t\tif (IS_ENABLED(CONFIG_RFS_ACCEL) &&\n+\t\t    rmap && bp->bnapi[i]->rx_ring) {\n \t\t\trc = irq_cpu_rmap_add(rmap, irq->vector);\n \t\t\tif (rc)\n \t\t\t\tnetdev_warn(bp->dev, \"failed adding irq rmap for ring %d\\n\",\n \t\t\t\t\t    j);\n \t\t\tj++;\n \t\t}\n-#endif\n+\n \t\trc = request_irq(irq->vector, irq->handler, flags, irq->name,\n \t\t\t\t bp->bnapi[i]);\n \t\tif (rc)\ndiff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c\nindex fa0077bc67b7..97585c160de3 100644\n--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c\n+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c\n@@ -4092,6 +4092,12 @@ static int bcmgenet_probe(struct platform_device *pdev)\n \tfor (i = 0; i <= priv->hw_params->rx_queues; i++)\n \t\tpriv->rx_rings[i].rx_max_coalesced_frames = 1;\n \n+\t/* Initialize u64 stats seq counter for 32bit machines */\n+\tfor (i = 0; i <= priv->hw_params->rx_queues; i++)\n+\t\tu64_stats_init(&priv->rx_rings[i].stats64.syncp);\n+\tfor (i = 0; i <= priv->hw_params->tx_queues; i++)\n+\t\tu64_stats_init(&priv->tx_rings[i].stats64.syncp);\n+\n \t/* libphy will determine the link state */\n \tnetif_carrier_off(dev);\n \ndiff --git a/drivers/net/ethernet/cavium/thunder/nicvf_main.c b/drivers/net/ethernet/cavium/thunder/nicvf_main.c\nindex aebb9fef3f6e..1be2dc40a1a6 100644\n--- a/drivers/net/ethernet/cavium/thunder/nicvf_main.c\n+++ b/drivers/net/ethernet/cavium/thunder/nicvf_main.c\n@@ -1578,7 +1578,6 @@ int nicvf_open(struct net_device *netdev)\n static int nicvf_change_mtu(struct net_device *netdev, int new_mtu)\n {\n \tstruct nicvf *nic = netdev_priv(netdev);\n-\tint orig_mtu = netdev->mtu;\n \n \t/* For now just support only the usual MTU sized frames,\n \t * plus some headroom for VLAN, QinQ.\n@@ -1589,15 +1588,10 @@ static int nicvf_change_mtu(struct net_device *netdev, int new_mtu)\n \t\treturn -EINVAL;\n \t}\n \n-\tWRITE_ONCE(netdev->mtu, new_mtu);\n-\n-\tif (!netif_running(netdev))\n-\t\treturn 0;\n-\n-\tif (nicvf_update_hw_max_frs(nic, new_mtu)) {\n-\t\tnetdev->mtu = orig_mtu;\n+\tif (netif_running(netdev) && nicvf_update_hw_max_frs(nic, new_mtu))\n \t\treturn -EINVAL;\n-\t}\n+\n+\tWRITE_ONCE(netdev->mtu, new_mtu);\n \n \treturn 0;\n }\ndiff --git a/drivers/net/ethernet/renesas/rtsn.c b/drivers/net/ethernet/renesas/rtsn.c\nindex 6b3f7fca8d15..05c4b6c8c9c3 100644\n--- a/drivers/net/ethernet/renesas/rtsn.c\n+++ b/drivers/net/ethernet/renesas/rtsn.c\n@@ -1259,7 +1259,12 @@ static int rtsn_probe(struct platform_device *pdev)\n \tpriv = netdev_priv(ndev);\n \tpriv->pdev = pdev;\n \tpriv->ndev = ndev;\n+\n \tpriv->ptp_priv = rcar_gen4_ptp_alloc(pdev);\n+\tif (!priv->ptp_priv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto error_free;\n+\t}\n \n \tspin_lock_init(&priv->lock);\n \tplatform_set_drvdata(pdev, priv);\ndiff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c\nindex 7840bc403788..5dcc95bc0ad2 100644\n--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c\n+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c\n@@ -364,19 +364,17 @@ static int dwxgmac2_dma_interrupt(struct stmmac_priv *priv,\n \t}\n \n \t/* TX/RX NORMAL interrupts */\n-\tif (likely(intr_status & XGMAC_NIS)) {\n-\t\tif (likely(intr_status & XGMAC_RI)) {\n-\t\t\tu64_stats_update_begin(&stats->syncp);\n-\t\t\tu64_stats_inc(&stats->rx_normal_irq_n[chan]);\n-\t\t\tu64_stats_update_end(&stats->syncp);\n-\t\t\tret |= handle_rx;\n-\t\t}\n-\t\tif (likely(intr_status & (XGMAC_TI | XGMAC_TBU))) {\n-\t\t\tu64_stats_update_begin(&stats->syncp);\n-\t\t\tu64_stats_inc(&stats->tx_normal_irq_n[chan]);\n-\t\t\tu64_stats_update_end(&stats->syncp);\n-\t\t\tret |= handle_tx;\n-\t\t}\n+\tif (likely(intr_status & XGMAC_RI)) {\n+\t\tu64_stats_update_begin(&stats->syncp);\n+\t\tu64_stats_inc(&stats->rx_normal_irq_n[chan]);\n+\t\tu64_stats_update_end(&stats->syncp);\n+\t\tret |= handle_rx;\n+\t}\n+\tif (likely(intr_status & (XGMAC_TI | XGMAC_TBU))) {\n+\t\tu64_stats_update_begin(&stats->syncp);\n+\t\tu64_stats_inc(&stats->tx_normal_irq_n[chan]);\n+\t\tu64_stats_update_end(&stats->syncp);\n+\t\tret |= handle_tx;\n \t}\n \n \t/* Clear interrupts */\ndiff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.c b/drivers/net/ethernet/ti/am65-cpsw-nuss.c\nindex f20d1ff192ef..231ca141331f 100644\n--- a/drivers/net/ethernet/ti/am65-cpsw-nuss.c\n+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.c\n@@ -856,8 +856,6 @@ static struct sk_buff *am65_cpsw_build_skb(void *page_addr,\n {\n \tstruct sk_buff *skb;\n \n-\tlen += AM65_CPSW_HEADROOM;\n-\n \tskb = build_skb(page_addr, len);\n \tif (unlikely(!skb))\n \t\treturn NULL;\n@@ -1344,7 +1342,7 @@ static int am65_cpsw_nuss_rx_packets(struct am65_cpsw_rx_flow *flow,\n \t}\n \n \tskb = am65_cpsw_build_skb(page_addr, ndev,\n-\t\t\t\t  AM65_CPSW_MAX_PACKET_SIZE, headroom);\n+\t\t\t\t  PAGE_SIZE, headroom);\n \tif (unlikely(!skb)) {\n \t\tnew_page = page;\n \t\tgoto requeue;\ndiff --git a/drivers/net/phy/qcom/at803x.c b/drivers/net/phy/qcom/at803x.c\nindex 26350b962890..8f26e395e39f 100644\n--- a/drivers/net/phy/qcom/at803x.c\n+++ b/drivers/net/phy/qcom/at803x.c\n@@ -26,9 +26,6 @@\n \n #define AT803X_LED_CONTROL\t\t\t0x18\n \n-#define AT803X_PHY_MMD3_WOL_CTRL\t\t0x8012\n-#define AT803X_WOL_EN\t\t\t\tBIT(5)\n-\n #define AT803X_REG_CHIP_CONFIG\t\t\t0x1f\n #define AT803X_BT_BX_REG_SEL\t\t\t0x8000\n \n@@ -866,30 +863,6 @@ static int at8031_config_init(struct phy_device *phydev)\n \treturn at803x_config_init(phydev);\n }\n \n-static int at8031_set_wol(struct phy_device *phydev,\n-\t\t\t  struct ethtool_wolinfo *wol)\n-{\n-\tint ret;\n-\n-\t/* First setup MAC address and enable WOL interrupt */\n-\tret = at803x_set_wol(phydev, wol);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\tif (wol->wolopts & WAKE_MAGIC)\n-\t\t/* Enable WOL function for 1588 */\n-\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n-\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n-\t\t\t\t     0, AT803X_WOL_EN);\n-\telse\n-\t\t/* Disable WoL function for 1588 */\n-\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n-\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n-\t\t\t\t     AT803X_WOL_EN, 0);\n-\n-\treturn ret;\n-}\n-\n static int at8031_config_intr(struct phy_device *phydev)\n {\n \tstruct at803x_priv *priv = phydev->priv;\ndiff --git a/drivers/net/phy/qcom/qca808x.c b/drivers/net/phy/qcom/qca808x.c\nindex 71498c518f0f..6de16c0eaa08 100644\n--- a/drivers/net/phy/qcom/qca808x.c\n+++ b/drivers/net/phy/qcom/qca808x.c\n@@ -633,7 +633,7 @@ static struct phy_driver qca808x_driver[] = {\n \t.handle_interrupt\t= at803x_handle_interrupt,\n \t.get_tunable\t\t= at803x_get_tunable,\n \t.set_tunable\t\t= at803x_set_tunable,\n-\t.set_wol\t\t= at803x_set_wol,\n+\t.set_wol\t\t= at8031_set_wol,\n \t.get_wol\t\t= at803x_get_wol,\n \t.get_features\t\t= qca808x_get_features,\n \t.config_aneg\t\t= qca808x_config_aneg,\ndiff --git a/drivers/net/phy/qcom/qcom-phy-lib.c b/drivers/net/phy/qcom/qcom-phy-lib.c\nindex d28815ef56bb..af7d0d8e81be 100644\n--- a/drivers/net/phy/qcom/qcom-phy-lib.c\n+++ b/drivers/net/phy/qcom/qcom-phy-lib.c\n@@ -115,6 +115,31 @@ int at803x_set_wol(struct phy_device *phydev,\n }\n EXPORT_SYMBOL_GPL(at803x_set_wol);\n \n+int at8031_set_wol(struct phy_device *phydev,\n+\t\t   struct ethtool_wolinfo *wol)\n+{\n+\tint ret;\n+\n+\t/* First setup MAC address and enable WOL interrupt */\n+\tret = at803x_set_wol(phydev, wol);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\tif (wol->wolopts & WAKE_MAGIC)\n+\t\t/* Enable WOL function for 1588 */\n+\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n+\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n+\t\t\t\t     0, AT803X_WOL_EN);\n+\telse\n+\t\t/* Disable WoL function for 1588 */\n+\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n+\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n+\t\t\t\t     AT803X_WOL_EN, 0);\n+\n+\treturn ret;\n+}\n+EXPORT_SYMBOL_GPL(at8031_set_wol);\n+\n void at803x_get_wol(struct phy_device *phydev,\n \t\t    struct ethtool_wolinfo *wol)\n {\ndiff --git a/drivers/net/phy/qcom/qcom.h b/drivers/net/phy/qcom/qcom.h\nindex 4bb541728846..7f7151c8baca 100644\n--- a/drivers/net/phy/qcom/qcom.h\n+++ b/drivers/net/phy/qcom/qcom.h\n@@ -172,6 +172,9 @@\n #define AT803X_LOC_MAC_ADDR_16_31_OFFSET\t0x804B\n #define AT803X_LOC_MAC_ADDR_32_47_OFFSET\t0x804A\n \n+#define AT803X_PHY_MMD3_WOL_CTRL\t\t0x8012\n+#define AT803X_WOL_EN\t\t\t\tBIT(5)\n+\n #define AT803X_DEBUG_ADDR\t\t\t0x1D\n #define AT803X_DEBUG_DATA\t\t\t0x1E\n \n@@ -215,6 +218,8 @@ int at803x_debug_reg_mask(struct phy_device *phydev, u16 reg,\n int at803x_debug_reg_write(struct phy_device *phydev, u16 reg, u16 data);\n int at803x_set_wol(struct phy_device *phydev,\n \t\t   struct ethtool_wolinfo *wol);\n+int at8031_set_wol(struct phy_device *phydev,\n+\t\t   struct ethtool_wolinfo *wol);\n void at803x_get_wol(struct phy_device *phydev,\n \t\t    struct ethtool_wolinfo *wol);\n int at803x_ack_interrupt(struct phy_device *phydev);\ndiff --git a/drivers/net/phy/smsc.c b/drivers/net/phy/smsc.c\nindex 31463b9e5697..b6489da5cfcd 100644\n--- a/drivers/net/phy/smsc.c\n+++ b/drivers/net/phy/smsc.c\n@@ -155,10 +155,29 @@ static int smsc_phy_reset(struct phy_device *phydev)\n \n static int lan87xx_config_aneg(struct phy_device *phydev)\n {\n-\tint rc;\n+\tu8 mdix_ctrl;\n \tint val;\n+\tint rc;\n+\n+\t/* When auto-negotiation is disabled (forced mode), the PHY's\n+\t * Auto-MDIX will continue toggling the TX/RX pairs.\n+\t *\n+\t * To establish a stable link, we must select a fixed MDI mode.\n+\t * If the user has not specified a fixed MDI mode (i.e., mdix_ctrl is\n+\t * 'auto'), we default to ETH_TP_MDI. This choice of a ETH_TP_MDI mode\n+\t * mirrors the behavior the hardware would exhibit if the AUTOMDIX_EN\n+\t * strap were configured for a fixed MDI connection.\n+\t */\n+\tif (phydev->autoneg == AUTONEG_DISABLE) {\n+\t\tif (phydev->mdix_ctrl == ETH_TP_MDI_AUTO)\n+\t\t\tmdix_ctrl = ETH_TP_MDI;\n+\t\telse\n+\t\t\tmdix_ctrl = phydev->mdix_ctrl;\n+\t} else {\n+\t\tmdix_ctrl = phydev->mdix_ctrl;\n+\t}\n \n-\tswitch (phydev->mdix_ctrl) {\n+\tswitch (mdix_ctrl) {\n \tcase ETH_TP_MDI:\n \t\tval = SPECIAL_CTRL_STS_OVRRD_AMDIX_;\n \t\tbreak;\n@@ -167,7 +186,8 @@ static int lan87xx_config_aneg(struct phy_device *phydev)\n \t\t\tSPECIAL_CTRL_STS_AMDIX_STATE_;\n \t\tbreak;\n \tcase ETH_TP_MDI_AUTO:\n-\t\tval = SPECIAL_CTRL_STS_AMDIX_ENABLE_;\n+\t\tval = SPECIAL_CTRL_STS_OVRRD_AMDIX_ |\n+\t\t\tSPECIAL_CTRL_STS_AMDIX_ENABLE_;\n \t\tbreak;\n \tdefault:\n \t\treturn genphy_config_aneg(phydev);\n@@ -183,7 +203,7 @@ static int lan87xx_config_aneg(struct phy_device *phydev)\n \trc |= val;\n \tphy_write(phydev, SPECIAL_CTRL_STS, rc);\n \n-\tphydev->mdix = phydev->mdix_ctrl;\n+\tphydev->mdix = mdix_ctrl;\n \treturn genphy_config_aneg(phydev);\n }\n \n@@ -261,6 +281,33 @@ int lan87xx_read_status(struct phy_device *phydev)\n }\n EXPORT_SYMBOL_GPL(lan87xx_read_status);\n \n+static int lan87xx_phy_config_init(struct phy_device *phydev)\n+{\n+\tint rc;\n+\n+\t/* The LAN87xx PHY's initial MDI-X mode is determined by the AUTOMDIX_EN\n+\t * hardware strap, but the driver cannot read the strap's status. This\n+\t * creates an unpredictable initial state.\n+\t *\n+\t * To ensure consistent and reliable behavior across all boards,\n+\t * override the strap configuration on initialization and force the PHY\n+\t * into a known state with Auto-MDIX enabled, which is the expected\n+\t * default for modern hardware.\n+\t */\n+\trc = phy_modify(phydev, SPECIAL_CTRL_STS,\n+\t\t\tSPECIAL_CTRL_STS_OVRRD_AMDIX_ |\n+\t\t\tSPECIAL_CTRL_STS_AMDIX_ENABLE_ |\n+\t\t\tSPECIAL_CTRL_STS_AMDIX_STATE_,\n+\t\t\tSPECIAL_CTRL_STS_OVRRD_AMDIX_ |\n+\t\t\tSPECIAL_CTRL_STS_AMDIX_ENABLE_);\n+\tif (rc < 0)\n+\t\treturn rc;\n+\n+\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n+\n+\treturn smsc_phy_config_init(phydev);\n+}\n+\n static int lan874x_phy_config_init(struct phy_device *phydev)\n {\n \tu16 val;\n@@ -695,7 +742,7 @@ static struct phy_driver smsc_phy_driver[] = {\n \n \t/* basic functions */\n \t.read_status\t= lan87xx_read_status,\n-\t.config_init\t= smsc_phy_config_init,\n+\t.config_init\t= lan87xx_phy_config_init,\n \t.soft_reset\t= smsc_phy_reset,\n \t.config_aneg\t= lan87xx_config_aneg,\n \ndiff --git a/include/net/af_vsock.h b/include/net/af_vsock.h\nindex d56e6e135158..d40e978126e3 100644\n--- a/include/net/af_vsock.h\n+++ b/include/net/af_vsock.h\n@@ -243,8 +243,8 @@ int __vsock_dgram_recvmsg(struct socket *sock, struct msghdr *msg,\n int vsock_dgram_recvmsg(struct socket *sock, struct msghdr *msg,\n \t\t\tsize_t len, int flags);\n \n-#ifdef CONFIG_BPF_SYSCALL\n extern struct proto vsock_proto;\n+#ifdef CONFIG_BPF_SYSCALL\n int vsock_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore);\n void __init vsock_bpf_build_proto(void);\n #else\ndiff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h\nindex 9fc8f544e20e..0da011fc8146 100644\n--- a/include/net/bluetooth/hci_core.h\n+++ b/include/net/bluetooth/hci_core.h\n@@ -1350,8 +1350,7 @@ hci_conn_hash_lookup_big_state(struct hci_dev *hdev, __u8 handle,  __u16 state)\n \trcu_read_lock();\n \n \tlist_for_each_entry_rcu(c, &h->list, list) {\n-\t\tif (c->type != BIS_LINK || bacmp(&c->dst, BDADDR_ANY) ||\n-\t\t    c->state != state)\n+\t\tif (c->type != BIS_LINK || c->state != state)\n \t\t\tcontinue;\n \n \t\tif (handle == c->iso_qos.bcast.big) {\ndiff --git a/include/net/pkt_sched.h b/include/net/pkt_sched.h\nindex d7b7b6cd4aa1..8a75c73fc555 100644\n--- a/include/net/pkt_sched.h\n+++ b/include/net/pkt_sched.h\n@@ -114,7 +114,6 @@ struct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r,\n \t\t\t\t\tstruct netlink_ext_ack *extack);\n void qdisc_put_rtab(struct qdisc_rate_table *tab);\n void qdisc_put_stab(struct qdisc_size_table *tab);\n-void qdisc_warn_nonwc(const char *txt, struct Qdisc *qdisc);\n bool sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,\n \t\t     struct net_device *dev, struct netdev_queue *txq,\n \t\t     spinlock_t *root_lock, bool validate);\n@@ -290,4 +289,28 @@ static inline bool tc_qdisc_stats_dump(struct Qdisc *sch,\n \treturn true;\n }\n \n+static inline void qdisc_warn_nonwc(const char *txt, struct Qdisc *qdisc)\n+{\n+\tif (!(qdisc->flags & TCQ_F_WARN_NONWC)) {\n+\t\tpr_warn(\"%s: %s qdisc %X: is non-work-conserving?\\n\",\n+\t\t\ttxt, qdisc->ops->id, qdisc->handle >> 16);\n+\t\tqdisc->flags |= TCQ_F_WARN_NONWC;\n+\t}\n+}\n+\n+static inline unsigned int qdisc_peek_len(struct Qdisc *sch)\n+{\n+\tstruct sk_buff *skb;\n+\tunsigned int len;\n+\n+\tskb = sch->ops->peek(sch);\n+\tif (unlikely(skb == NULL)) {\n+\t\tqdisc_warn_nonwc(\"qdisc_peek_len\", sch);\n+\t\treturn 0;\n+\t}\n+\tlen = qdisc_pkt_len(skb);\n+\n+\treturn len;\n+}\n+\n #endif\ndiff --git a/net/atm/clip.c b/net/atm/clip.c\nindex b234dc3bcb0d..f7a5565e794e 100644\n--- a/net/atm/clip.c\n+++ b/net/atm/clip.c\n@@ -45,7 +45,8 @@\n #include <net/atmclip.h>\n \n static struct net_device *clip_devs;\n-static struct atm_vcc *atmarpd;\n+static struct atm_vcc __rcu *atmarpd;\n+static DEFINE_MUTEX(atmarpd_lock);\n static struct timer_list idle_timer;\n static const struct neigh_ops clip_neigh_ops;\n \n@@ -53,24 +54,35 @@ static int to_atmarpd(enum atmarp_ctrl_type type, int itf, __be32 ip)\n {\n \tstruct sock *sk;\n \tstruct atmarp_ctrl *ctrl;\n+\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n+\tint err = 0;\n \n \tpr_debug(\"(%d)\\n\", type);\n-\tif (!atmarpd)\n-\t\treturn -EUNATCH;\n+\n+\trcu_read_lock();\n+\tvcc = rcu_dereference(atmarpd);\n+\tif (!vcc) {\n+\t\terr = -EUNATCH;\n+\t\tgoto unlock;\n+\t}\n \tskb = alloc_skb(sizeof(struct atmarp_ctrl), GFP_ATOMIC);\n-\tif (!skb)\n-\t\treturn -ENOMEM;\n+\tif (!skb) {\n+\t\terr = -ENOMEM;\n+\t\tgoto unlock;\n+\t}\n \tctrl = skb_put(skb, sizeof(struct atmarp_ctrl));\n \tctrl->type = type;\n \tctrl->itf_num = itf;\n \tctrl->ip = ip;\n-\tatm_force_charge(atmarpd, skb->truesize);\n+\tatm_force_charge(vcc, skb->truesize);\n \n-\tsk = sk_atm(atmarpd);\n+\tsk = sk_atm(vcc);\n \tskb_queue_tail(&sk->sk_receive_queue, skb);\n \tsk->sk_data_ready(sk);\n-\treturn 0;\n+unlock:\n+\trcu_read_unlock();\n+\treturn err;\n }\n \n static void link_vcc(struct clip_vcc *clip_vcc, struct atmarp_entry *entry)\n@@ -417,6 +429,8 @@ static int clip_mkip(struct atm_vcc *vcc, int timeout)\n \n \tif (!vcc->push)\n \t\treturn -EBADFD;\n+\tif (vcc->user_back)\n+\t\treturn -EINVAL;\n \tclip_vcc = kmalloc(sizeof(struct clip_vcc), GFP_KERNEL);\n \tif (!clip_vcc)\n \t\treturn -ENOMEM;\n@@ -607,17 +621,27 @@ static void atmarpd_close(struct atm_vcc *vcc)\n {\n \tpr_debug(\"\\n\");\n \n-\trtnl_lock();\n-\tatmarpd = NULL;\n+\tmutex_lock(&atmarpd_lock);\n+\tRCU_INIT_POINTER(atmarpd, NULL);\n+\tmutex_unlock(&atmarpd_lock);\n+\n+\tsynchronize_rcu();\n \tskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\n-\trtnl_unlock();\n \n \tpr_debug(\"(done)\\n\");\n \tmodule_put(THIS_MODULE);\n }\n \n+static int atmarpd_send(struct atm_vcc *vcc, struct sk_buff *skb)\n+{\n+\tatm_return_tx(vcc, skb);\n+\tdev_kfree_skb_any(skb);\n+\treturn 0;\n+}\n+\n static const struct atmdev_ops atmarpd_dev_ops = {\n-\t.close = atmarpd_close\n+\t.close = atmarpd_close,\n+\t.send = atmarpd_send\n };\n \n \n@@ -631,15 +655,18 @@ static struct atm_dev atmarpd_dev = {\n \n static int atm_init_atmarp(struct atm_vcc *vcc)\n {\n-\trtnl_lock();\n+\tif (vcc->push == clip_push)\n+\t\treturn -EINVAL;\n+\n+\tmutex_lock(&atmarpd_lock);\n \tif (atmarpd) {\n-\t\trtnl_unlock();\n+\t\tmutex_unlock(&atmarpd_lock);\n \t\treturn -EADDRINUSE;\n \t}\n \n \tmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\n \n-\tatmarpd = vcc;\n+\trcu_assign_pointer(atmarpd, vcc);\n \tset_bit(ATM_VF_META, &vcc->flags);\n \tset_bit(ATM_VF_READY, &vcc->flags);\n \t    /* allow replies and avoid getting closed if signaling dies */\n@@ -648,13 +675,14 @@ static int atm_init_atmarp(struct atm_vcc *vcc)\n \tvcc->push = NULL;\n \tvcc->pop = NULL; /* crash */\n \tvcc->push_oam = NULL; /* crash */\n-\trtnl_unlock();\n+\tmutex_unlock(&atmarpd_lock);\n \treturn 0;\n }\n \n static int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n {\n \tstruct atm_vcc *vcc = ATM_SD(sock);\n+\tstruct sock *sk = sock->sk;\n \tint err = 0;\n \n \tswitch (cmd) {\n@@ -675,14 +703,18 @@ static int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n \t\terr = clip_create(arg);\n \t\tbreak;\n \tcase ATMARPD_CTRL:\n+\t\tlock_sock(sk);\n \t\terr = atm_init_atmarp(vcc);\n \t\tif (!err) {\n \t\t\tsock->state = SS_CONNECTED;\n \t\t\t__module_get(THIS_MODULE);\n \t\t}\n+\t\trelease_sock(sk);\n \t\tbreak;\n \tcase ATMARP_MKIP:\n+\t\tlock_sock(sk);\n \t\terr = clip_mkip(vcc, arg);\n+\t\trelease_sock(sk);\n \t\tbreak;\n \tcase ATMARP_SETENTRY:\n \t\terr = clip_setentry(vcc, (__force __be32)arg);\ndiff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c\nindex 4d5ace9d245d..992131f88a45 100644\n--- a/net/bluetooth/hci_event.c\n+++ b/net/bluetooth/hci_event.c\n@@ -6966,7 +6966,10 @@ static void hci_le_big_sync_established_evt(struct hci_dev *hdev, void *data,\n \t\tbis->iso_qos.bcast.in.sdu = le16_to_cpu(ev->max_pdu);\n \n \t\tif (!ev->status) {\n+\t\t\tbis->state = BT_CONNECTED;\n \t\t\tset_bit(HCI_CONN_BIG_SYNC, &bis->flags);\n+\t\t\thci_debugfs_create_conn(bis);\n+\t\t\thci_conn_add_sysfs(bis);\n \t\t\thci_iso_setup_path(bis);\n \t\t}\n \t}\ndiff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c\nindex 77b3691f3423..5f178db8d40d 100644\n--- a/net/bluetooth/hci_sync.c\n+++ b/net/bluetooth/hci_sync.c\n@@ -1345,7 +1345,7 @@ int hci_setup_ext_adv_instance_sync(struct hci_dev *hdev, u8 instance)\n \t * Command Disallowed error, so we must first disable the\n \t * instance if it is active.\n \t */\n-\tif (adv && !adv->pending) {\n+\tif (adv) {\n \t\terr = hci_disable_ext_adv_instance_sync(hdev, instance);\n \t\tif (err)\n \t\t\treturn err;\n@@ -5493,7 +5493,7 @@ static int hci_disconnect_sync(struct hci_dev *hdev, struct hci_conn *conn,\n {\n \tstruct hci_cp_disconnect cp;\n \n-\tif (test_bit(HCI_CONN_BIG_CREATED, &conn->flags)) {\n+\tif (conn->type == BIS_LINK) {\n \t\t/* This is a BIS connection, hci_conn_del will\n \t\t * do the necessary cleanup.\n \t\t */\ndiff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c\nindex f64f8276a73c..461a9ab540af 100644\n--- a/net/ipv4/tcp.c\n+++ b/net/ipv4/tcp.c\n@@ -1176,7 +1176,7 @@ int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)\n \t\tgoto do_error;\n \n \twhile (msg_data_left(msg)) {\n-\t\tssize_t copy = 0;\n+\t\tint copy = 0;\n \n \t\tskb = tcp_write_queue_tail(sk);\n \t\tif (skb)\ndiff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c\nindex 12c2e6fc85c6..68bc79eb9019 100644\n--- a/net/ipv4/tcp_input.c\n+++ b/net/ipv4/tcp_input.c\n@@ -5181,7 +5181,9 @@ static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n \t\tskb_condense(skb);\n \t\tskb_set_owner_r(skb, sk);\n \t}\n-\ttcp_rcvbuf_grow(sk);\n+\t/* do not grow rcvbuf for not-yet-accepted or orphaned sockets. */\n+\tif (sk->sk_socket)\n+\t\ttcp_rcvbuf_grow(sk);\n }\n \n static int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb,\ndiff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c\nindex e8972a857e51..79fbaf7333ce 100644\n--- a/net/netlink/af_netlink.c\n+++ b/net/netlink/af_netlink.c\n@@ -387,7 +387,6 @@ static void netlink_skb_set_owner_r(struct sk_buff *skb, struct sock *sk)\n \tWARN_ON(skb->sk != NULL);\n \tskb->sk = sk;\n \tskb->destructor = netlink_skb_destructor;\n-\tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n \tsk_mem_charge(sk, skb->truesize);\n }\n \n@@ -1212,41 +1211,48 @@ struct sk_buff *netlink_alloc_large_skb(unsigned int size, int broadcast)\n int netlink_attachskb(struct sock *sk, struct sk_buff *skb,\n \t\t      long *timeo, struct sock *ssk)\n {\n+\tDECLARE_WAITQUEUE(wait, current);\n \tstruct netlink_sock *nlk;\n+\tunsigned int rmem;\n \n \tnlk = nlk_sk(sk);\n+\trmem = atomic_add_return(skb->truesize, &sk->sk_rmem_alloc);\n \n-\tif ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n-\t     test_bit(NETLINK_S_CONGESTED, &nlk->state))) {\n-\t\tDECLARE_WAITQUEUE(wait, current);\n-\t\tif (!*timeo) {\n-\t\t\tif (!ssk || netlink_is_kernel(ssk))\n-\t\t\t\tnetlink_overrun(sk);\n-\t\t\tsock_put(sk);\n-\t\t\tkfree_skb(skb);\n-\t\t\treturn -EAGAIN;\n-\t\t}\n-\n-\t\t__set_current_state(TASK_INTERRUPTIBLE);\n-\t\tadd_wait_queue(&nlk->wait, &wait);\n+\tif ((rmem == skb->truesize || rmem < READ_ONCE(sk->sk_rcvbuf)) &&\n+\t    !test_bit(NETLINK_S_CONGESTED, &nlk->state)) {\n+\t\tnetlink_skb_set_owner_r(skb, sk);\n+\t\treturn 0;\n+\t}\n \n-\t\tif ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||\n-\t\t     test_bit(NETLINK_S_CONGESTED, &nlk->state)) &&\n-\t\t    !sock_flag(sk, SOCK_DEAD))\n-\t\t\t*timeo = schedule_timeout(*timeo);\n+\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n \n-\t\t__set_current_state(TASK_RUNNING);\n-\t\tremove_wait_queue(&nlk->wait, &wait);\n+\tif (!*timeo) {\n+\t\tif (!ssk || netlink_is_kernel(ssk))\n+\t\t\tnetlink_overrun(sk);\n \t\tsock_put(sk);\n+\t\tkfree_skb(skb);\n+\t\treturn -EAGAIN;\n+\t}\n \n-\t\tif (signal_pending(current)) {\n-\t\t\tkfree_skb(skb);\n-\t\t\treturn sock_intr_errno(*timeo);\n-\t\t}\n-\t\treturn 1;\n+\t__set_current_state(TASK_INTERRUPTIBLE);\n+\tadd_wait_queue(&nlk->wait, &wait);\n+\trmem = atomic_read(&sk->sk_rmem_alloc);\n+\n+\tif (((rmem && rmem + skb->truesize > READ_ONCE(sk->sk_rcvbuf)) ||\n+\t     test_bit(NETLINK_S_CONGESTED, &nlk->state)) &&\n+\t    !sock_flag(sk, SOCK_DEAD))\n+\t\t*timeo = schedule_timeout(*timeo);\n+\n+\t__set_current_state(TASK_RUNNING);\n+\tremove_wait_queue(&nlk->wait, &wait);\n+\tsock_put(sk);\n+\n+\tif (signal_pending(current)) {\n+\t\tkfree_skb(skb);\n+\t\treturn sock_intr_errno(*timeo);\n \t}\n-\tnetlink_skb_set_owner_r(skb, sk);\n-\treturn 0;\n+\n+\treturn 1;\n }\n \n static int __netlink_sendskb(struct sock *sk, struct sk_buff *skb)\n@@ -1307,6 +1313,7 @@ static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,\n \tret = -ECONNREFUSED;\n \tif (nlk->netlink_rcv != NULL) {\n \t\tret = skb->len;\n+\t\tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n \t\tnetlink_skb_set_owner_r(skb, sk);\n \t\tNETLINK_CB(skb).sk = ssk;\n \t\tnetlink_deliver_tap_kernel(sk, ssk, skb);\n@@ -1383,13 +1390,19 @@ EXPORT_SYMBOL_GPL(netlink_strict_get_check);\n static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)\n {\n \tstruct netlink_sock *nlk = nlk_sk(sk);\n+\tunsigned int rmem, rcvbuf;\n \n-\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n+\trmem = atomic_add_return(skb->truesize, &sk->sk_rmem_alloc);\n+\trcvbuf = READ_ONCE(sk->sk_rcvbuf);\n+\n+\tif ((rmem != skb->truesize || rmem <= rcvbuf) &&\n \t    !test_bit(NETLINK_S_CONGESTED, &nlk->state)) {\n \t\tnetlink_skb_set_owner_r(skb, sk);\n \t\t__netlink_sendskb(sk, skb);\n-\t\treturn atomic_read(&sk->sk_rmem_alloc) > (sk->sk_rcvbuf >> 1);\n+\t\treturn rmem > (rcvbuf >> 1);\n \t}\n+\n+\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n \treturn -1;\n }\n \n@@ -2249,6 +2262,7 @@ static int netlink_dump(struct sock *sk, bool lock_taken)\n \tstruct module *module;\n \tint err = -ENOBUFS;\n \tint alloc_min_size;\n+\tunsigned int rmem;\n \tint alloc_size;\n \n \tif (!lock_taken)\n@@ -2258,9 +2272,6 @@ static int netlink_dump(struct sock *sk, bool lock_taken)\n \t\tgoto errout_skb;\n \t}\n \n-\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n-\t\tgoto errout_skb;\n-\n \t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n \t * required, but it makes sense to _attempt_ a 32KiB allocation\n \t * to reduce number of system calls on dump operations, if user\n@@ -2283,6 +2294,12 @@ static int netlink_dump(struct sock *sk, bool lock_taken)\n \tif (!skb)\n \t\tgoto errout_skb;\n \n+\trmem = atomic_add_return(skb->truesize, &sk->sk_rmem_alloc);\n+\tif (rmem >= READ_ONCE(sk->sk_rcvbuf)) {\n+\t\tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n+\t\tgoto errout_skb;\n+\t}\n+\n \t/* Trim skb to allocated size. User is expected to provide buffer as\n \t * large as max(min_dump_alloc, 32KiB (max_recvmsg_len capped at\n \t * netlink_recvmsg())). dump will pack as many smaller messages as\ndiff --git a/net/rxrpc/ar-internal.h b/net/rxrpc/ar-internal.h\nindex 5bd3922c310d..376e33dce8c1 100644\n--- a/net/rxrpc/ar-internal.h\n+++ b/net/rxrpc/ar-internal.h\n@@ -361,12 +361,15 @@ struct rxrpc_local {\n \tstruct list_head\tnew_client_calls; /* Newly created client calls need connection */\n \tspinlock_t\t\tclient_call_lock; /* Lock for ->new_client_calls */\n \tstruct sockaddr_rxrpc\tsrx;\t\t/* local address */\n-\t/* Provide a kvec table sufficiently large to manage either a DATA\n-\t * packet with a maximum set of jumbo subpackets or a PING ACK padded\n-\t * out to 64K with zeropages for PMTUD.\n-\t */\n-\tstruct kvec\t\tkvec[1 + RXRPC_MAX_NR_JUMBO > 3 + 16 ?\n-\t\t\t\t     1 + RXRPC_MAX_NR_JUMBO : 3 + 16];\n+\tunion {\n+\t\t/* Provide a kvec table sufficiently large to manage either a\n+\t\t * DATA packet with a maximum set of jumbo subpackets or a PING\n+\t\t * ACK padded out to 64K with zeropages for PMTUD.\n+\t\t */\n+\t\tstruct kvec\t\tkvec[1 + RXRPC_MAX_NR_JUMBO > 3 + 16 ?\n+\t\t\t\t\t     1 + RXRPC_MAX_NR_JUMBO : 3 + 16];\n+\t\tstruct bio_vec\t\tbvec[3 + 16];\n+\t};\n };\n \n /*\ndiff --git a/net/rxrpc/call_accept.c b/net/rxrpc/call_accept.c\nindex a4b363b47cca..49fccee1a726 100644\n--- a/net/rxrpc/call_accept.c\n+++ b/net/rxrpc/call_accept.c\n@@ -149,6 +149,7 @@ static int rxrpc_service_prealloc_one(struct rxrpc_sock *rx,\n \n id_in_use:\n \twrite_unlock(&rx->call_lock);\n+\trxrpc_prefail_call(call, RXRPC_CALL_LOCAL_ERROR, -EBADSLT);\n \trxrpc_cleanup_call(call);\n \t_leave(\" = -EBADSLT\");\n \treturn -EBADSLT;\n@@ -254,6 +255,9 @@ static struct rxrpc_call *rxrpc_alloc_incoming_call(struct rxrpc_sock *rx,\n \tunsigned short call_tail, conn_tail, peer_tail;\n \tunsigned short call_count, conn_count;\n \n+\tif (!b)\n+\t\treturn NULL;\n+\n \t/* #calls >= #conns >= #peers must hold true. */\n \tcall_head = smp_load_acquire(&b->call_backlog_head);\n \tcall_tail = b->call_backlog_tail;\ndiff --git a/net/rxrpc/output.c b/net/rxrpc/output.c\nindex 0af19bcdc80a..ef7b3096c95e 100644\n--- a/net/rxrpc/output.c\n+++ b/net/rxrpc/output.c\n@@ -924,7 +924,7 @@ void rxrpc_send_response(struct rxrpc_connection *conn, struct sk_buff *response\n {\n \tstruct rxrpc_skb_priv *sp = rxrpc_skb(response);\n \tstruct scatterlist sg[16];\n-\tstruct bio_vec bvec[16];\n+\tstruct bio_vec *bvec = conn->local->bvec;\n \tstruct msghdr msg;\n \tsize_t len = sp->resp.len;\n \t__be32 wserial;\n@@ -938,6 +938,9 @@ void rxrpc_send_response(struct rxrpc_connection *conn, struct sk_buff *response\n \tif (ret < 0)\n \t\tgoto fail;\n \tnr_sg = ret;\n+\tret = -EIO;\n+\tif (WARN_ON_ONCE(nr_sg > ARRAY_SIZE(conn->local->bvec)))\n+\t\tgoto fail;\n \n \tfor (int i = 0; i < nr_sg; i++)\n \t\tbvec_set_page(&bvec[i], sg_page(&sg[i]), sg[i].length, sg[i].offset);\ndiff --git a/net/sched/sch_api.c b/net/sched/sch_api.c\nindex d8a33486c511..d7c767b861a4 100644\n--- a/net/sched/sch_api.c\n+++ b/net/sched/sch_api.c\n@@ -336,17 +336,22 @@ struct Qdisc *qdisc_lookup_rcu(struct net_device *dev, u32 handle)\n \treturn q;\n }\n \n-static struct Qdisc *qdisc_leaf(struct Qdisc *p, u32 classid)\n+static struct Qdisc *qdisc_leaf(struct Qdisc *p, u32 classid,\n+\t\t\t\tstruct netlink_ext_ack *extack)\n {\n \tunsigned long cl;\n \tconst struct Qdisc_class_ops *cops = p->ops->cl_ops;\n \n-\tif (cops == NULL)\n-\t\treturn NULL;\n+\tif (cops == NULL) {\n+\t\tNL_SET_ERR_MSG(extack, \"Parent qdisc is not classful\");\n+\t\treturn ERR_PTR(-EOPNOTSUPP);\n+\t}\n \tcl = cops->find(p, classid);\n \n-\tif (cl == 0)\n-\t\treturn NULL;\n+\tif (cl == 0) {\n+\t\tNL_SET_ERR_MSG(extack, \"Specified class not found\");\n+\t\treturn ERR_PTR(-ENOENT);\n+\t}\n \treturn cops->leaf(p, cl);\n }\n \n@@ -596,16 +601,6 @@ void __qdisc_calculate_pkt_len(struct sk_buff *skb,\n \tqdisc_skb_cb(skb)->pkt_len = pkt_len;\n }\n \n-void qdisc_warn_nonwc(const char *txt, struct Qdisc *qdisc)\n-{\n-\tif (!(qdisc->flags & TCQ_F_WARN_NONWC)) {\n-\t\tpr_warn(\"%s: %s qdisc %X: is non-work-conserving?\\n\",\n-\t\t\ttxt, qdisc->ops->id, qdisc->handle >> 16);\n-\t\tqdisc->flags |= TCQ_F_WARN_NONWC;\n-\t}\n-}\n-EXPORT_SYMBOL(qdisc_warn_nonwc);\n-\n static enum hrtimer_restart qdisc_watchdog(struct hrtimer *timer)\n {\n \tstruct qdisc_watchdog *wd = container_of(timer, struct qdisc_watchdog,\n@@ -1490,7 +1485,7 @@ static int __tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,\n \t\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find qdisc with specified classid\");\n \t\t\t\t\treturn -ENOENT;\n \t\t\t\t}\n-\t\t\t\tq = qdisc_leaf(p, clid);\n+\t\t\t\tq = qdisc_leaf(p, clid, extack);\n \t\t\t} else if (dev_ingress_queue(dev)) {\n \t\t\t\tq = rtnl_dereference(dev_ingress_queue(dev)->qdisc_sleeping);\n \t\t\t}\n@@ -1501,6 +1496,8 @@ static int __tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,\n \t\t\tNL_SET_ERR_MSG(extack, \"Cannot find specified qdisc on specified device\");\n \t\t\treturn -ENOENT;\n \t\t}\n+\t\tif (IS_ERR(q))\n+\t\t\treturn PTR_ERR(q);\n \n \t\tif (tcm->tcm_handle && q->handle != tcm->tcm_handle) {\n \t\t\tNL_SET_ERR_MSG(extack, \"Invalid handle\");\n@@ -1602,7 +1599,9 @@ static int __tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,\n \t\t\t\t\tNL_SET_ERR_MSG(extack, \"Failed to find specified qdisc\");\n \t\t\t\t\treturn -ENOENT;\n \t\t\t\t}\n-\t\t\t\tq = qdisc_leaf(p, clid);\n+\t\t\t\tq = qdisc_leaf(p, clid, extack);\n+\t\t\t\tif (IS_ERR(q))\n+\t\t\t\t\treturn PTR_ERR(q);\n \t\t\t} else if (dev_ingress_queue_create(dev)) {\n \t\t\t\tq = rtnl_dereference(dev_ingress_queue(dev)->qdisc_sleeping);\n \t\t\t}\ndiff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c\nindex 5a7745170e84..d8fd35da32a7 100644\n--- a/net/sched/sch_hfsc.c\n+++ b/net/sched/sch_hfsc.c\n@@ -835,22 +835,6 @@ update_vf(struct hfsc_class *cl, unsigned int len, u64 cur_time)\n \t}\n }\n \n-static unsigned int\n-qdisc_peek_len(struct Qdisc *sch)\n-{\n-\tstruct sk_buff *skb;\n-\tunsigned int len;\n-\n-\tskb = sch->ops->peek(sch);\n-\tif (unlikely(skb == NULL)) {\n-\t\tqdisc_warn_nonwc(\"qdisc_peek_len\", sch);\n-\t\treturn 0;\n-\t}\n-\tlen = qdisc_pkt_len(skb);\n-\n-\treturn len;\n-}\n-\n static void\n hfsc_adjust_levels(struct hfsc_class *cl)\n {\ndiff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c\nindex bf1282cb22eb..bcce36608871 100644\n--- a/net/sched/sch_qfq.c\n+++ b/net/sched/sch_qfq.c\n@@ -989,7 +989,7 @@ static struct sk_buff *agg_dequeue(struct qfq_aggregate *agg,\n \n \tif (cl->qdisc->q.qlen == 0) /* no more packets, remove from list */\n \t\tlist_del_init(&cl->alist);\n-\telse if (cl->deficit < qdisc_pkt_len(cl->qdisc->ops->peek(cl->qdisc))) {\n+\telse if (cl->deficit < qdisc_peek_len(cl->qdisc)) {\n \t\tcl->deficit += agg->lmax;\n \t\tlist_move_tail(&cl->alist, &agg->active);\n \t}\ndiff --git a/net/tipc/topsrv.c b/net/tipc/topsrv.c\nindex 8ee0c07d00e9..ffe577bf6b51 100644\n--- a/net/tipc/topsrv.c\n+++ b/net/tipc/topsrv.c\n@@ -704,8 +704,10 @@ static void tipc_topsrv_stop(struct net *net)\n \tfor (id = 0; srv->idr_in_use; id++) {\n \t\tcon = idr_find(&srv->conn_idr, id);\n \t\tif (con) {\n+\t\t\tconn_get(con);\n \t\t\tspin_unlock_bh(&srv->idr_lock);\n \t\t\ttipc_conn_close(con);\n+\t\t\tconn_put(con);\n \t\t\tspin_lock_bh(&srv->idr_lock);\n \t\t}\n \t}\ndiff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c\nindex 2e7a3034e965..1053662725f8 100644\n--- a/net/vmw_vsock/af_vsock.c\n+++ b/net/vmw_vsock/af_vsock.c\n@@ -407,6 +407,8 @@ EXPORT_SYMBOL_GPL(vsock_enqueue_accept);\n \n static bool vsock_use_local_transport(unsigned int remote_cid)\n {\n+\tlockdep_assert_held(&vsock_register_mutex);\n+\n \tif (!transport_local)\n \t\treturn false;\n \n@@ -464,6 +466,8 @@ int vsock_assign_transport(struct vsock_sock *vsk, struct vsock_sock *psk)\n \n \tremote_flags = vsk->remote_addr.svm_flags;\n \n+\tmutex_lock(&vsock_register_mutex);\n+\n \tswitch (sk->sk_type) {\n \tcase SOCK_DGRAM:\n \t\tnew_transport = transport_dgram;\n@@ -479,12 +483,15 @@ int vsock_assign_transport(struct vsock_sock *vsk, struct vsock_sock *psk)\n \t\t\tnew_transport = transport_h2g;\n \t\tbreak;\n \tdefault:\n-\t\treturn -ESOCKTNOSUPPORT;\n+\t\tret = -ESOCKTNOSUPPORT;\n+\t\tgoto err;\n \t}\n \n \tif (vsk->transport) {\n-\t\tif (vsk->transport == new_transport)\n-\t\t\treturn 0;\n+\t\tif (vsk->transport == new_transport) {\n+\t\t\tret = 0;\n+\t\t\tgoto err;\n+\t\t}\n \n \t\t/* transport->release() must be called with sock lock acquired.\n \t\t * This path can only be taken during vsock_connect(), where we\n@@ -508,8 +515,16 @@ int vsock_assign_transport(struct vsock_sock *vsk, struct vsock_sock *psk)\n \t/* We increase the module refcnt to prevent the transport unloading\n \t * while there are open sockets assigned to it.\n \t */\n-\tif (!new_transport || !try_module_get(new_transport->module))\n-\t\treturn -ENODEV;\n+\tif (!new_transport || !try_module_get(new_transport->module)) {\n+\t\tret = -ENODEV;\n+\t\tgoto err;\n+\t}\n+\n+\t/* It's safe to release the mutex after a successful try_module_get().\n+\t * Whichever transport `new_transport` points at, it won't go away until\n+\t * the last module_put() below or in vsock_deassign_transport().\n+\t */\n+\tmutex_unlock(&vsock_register_mutex);\n \n \tif (sk->sk_type == SOCK_SEQPACKET) {\n \t\tif (!new_transport->seqpacket_allow ||\n@@ -528,12 +543,31 @@ int vsock_assign_transport(struct vsock_sock *vsk, struct vsock_sock *psk)\n \tvsk->transport = new_transport;\n \n \treturn 0;\n+err:\n+\tmutex_unlock(&vsock_register_mutex);\n+\treturn ret;\n }\n EXPORT_SYMBOL_GPL(vsock_assign_transport);\n \n+/*\n+ * Provide safe access to static transport_{h2g,g2h,dgram,local} callbacks.\n+ * Otherwise we may race with module removal. Do not use on `vsk->transport`.\n+ */\n+static u32 vsock_registered_transport_cid(const struct vsock_transport **transport)\n+{\n+\tu32 cid = VMADDR_CID_ANY;\n+\n+\tmutex_lock(&vsock_register_mutex);\n+\tif (*transport)\n+\t\tcid = (*transport)->get_local_cid();\n+\tmutex_unlock(&vsock_register_mutex);\n+\n+\treturn cid;\n+}\n+\n bool vsock_find_cid(unsigned int cid)\n {\n-\tif (transport_g2h && cid == transport_g2h->get_local_cid())\n+\tif (cid == vsock_registered_transport_cid(&transport_g2h))\n \t\treturn true;\n \n \tif (transport_h2g && cid == VMADDR_CID_HOST)\n@@ -2536,18 +2570,19 @@ static long vsock_dev_do_ioctl(struct file *filp,\n \t\t\t       unsigned int cmd, void __user *ptr)\n {\n \tu32 __user *p = ptr;\n-\tu32 cid = VMADDR_CID_ANY;\n \tint retval = 0;\n+\tu32 cid;\n \n \tswitch (cmd) {\n \tcase IOCTL_VM_SOCKETS_GET_LOCAL_CID:\n \t\t/* To be compatible with the VMCI behavior, we prioritize the\n \t\t * guest CID instead of well-know host CID (VMADDR_CID_HOST).\n \t\t */\n-\t\tif (transport_g2h)\n-\t\t\tcid = transport_g2h->get_local_cid();\n-\t\telse if (transport_h2g)\n-\t\t\tcid = transport_h2g->get_local_cid();\n+\t\tcid = vsock_registered_transport_cid(&transport_g2h);\n+\t\tif (cid == VMADDR_CID_ANY)\n+\t\t\tcid = vsock_registered_transport_cid(&transport_h2g);\n+\t\tif (cid == VMADDR_CID_ANY)\n+\t\t\tcid = vsock_registered_transport_cid(&transport_local);\n \n \t\tif (put_user(cid, p) != 0)\n \t\t\tretval = -EFAULT;\ndiff --git a/tools/testing/selftests/net/packetdrill/tcp_ooo-before-and-after-accept.pkt b/tools/testing/selftests/net/packetdrill/tcp_ooo-before-and-after-accept.pkt\nnew file mode 100644\nindex 000000000000..09aabc775e80\n--- /dev/null\n+++ b/tools/testing/selftests/net/packetdrill/tcp_ooo-before-and-after-accept.pkt\n@@ -0,0 +1,53 @@\n+// SPDX-License-Identifier: GPL-2.0\n+\n+--mss=1000\n+\n+`./defaults.sh\n+sysctl -q net.ipv4.tcp_rmem=\"4096 131072 $((32*1024*1024))\"`\n+\n+// Test that a not-yet-accepted socket does not change\n+// its initial sk_rcvbuf (tcp_rmem[1]) when receiving ooo packets.\n+\n+   +0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n+   +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n+   +0 bind(3, ..., ...) = 0\n+   +0 listen(3, 1) = 0\n+\n+   +0 < S 0:0(0) win 65535 <mss 1000,nop,nop,sackOK,nop,wscale 7>\n+   +0 > S. 0:0(0) ack 1 <mss 1460,nop,nop,sackOK,nop,wscale 10>\n+  +.1 < . 1:1(0) ack 1 win 257\n+  +0  < . 2001:41001(39000) ack 1 win 257\n+  +0  > . 1:1(0) ack 1 <nop,nop,sack 2001:41001>\n+  +0  < . 41001:101001(60000) ack 1 win 257\n+  +0  > . 1:1(0) ack 1 <nop,nop,sack 2001:101001>\n+  +0  < . 1:1001(1000) ack 1 win 257\n+  +0  > . 1:1(0) ack 1001 <nop,nop,sack 2001:101001>\n+  +0  < . 1001:2001(1000) ack 1 win 257\n+  +0  > . 1:1(0) ack 101001\n+\n+  +0 accept(3, ..., ...) = 4\n+\n+  +0 %{ assert SK_MEMINFO_RCVBUF == 131072, SK_MEMINFO_RCVBUF }%\n+\n+  +0 close(4) = 0\n+  +0 close(3) = 0\n+\n+// Test that ooo packets for accepted sockets do increase sk_rcvbuf\n+   +0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n+   +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n+   +0 bind(3, ..., ...) = 0\n+   +0 listen(3, 1) = 0\n+\n+   +0 < S 0:0(0) win 65535 <mss 1000,nop,nop,sackOK,nop,wscale 7>\n+   +0 > S. 0:0(0) ack 1 <mss 1460,nop,nop,sackOK,nop,wscale 10>\n+  +.1 < . 1:1(0) ack 1 win 257\n+\n+   +0 accept(3, ..., ...) = 4\n+\n+  +0  < . 2001:41001(39000) ack 1 win 257\n+  +0  > . 1:1(0) ack 1 <nop,nop,sack 2001:41001>\n+  +0  < . 41001:101001(60000) ack 1 win 257\n+  +0  > . 1:1(0) ack 1 <nop,nop,sack 2001:101001>\n+\n+  +0 %{ assert SK_MEMINFO_RCVBUF > 131072, SK_MEMINFO_RCVBUF }%\n+\ndiff --git a/tools/testing/selftests/tc-testing/tc-tests/infra/qdiscs.json b/tools/testing/selftests/tc-testing/tc-tests/infra/qdiscs.json\nindex 9aa44d8176d9..5c6851e8d311 100644\n--- a/tools/testing/selftests/tc-testing/tc-tests/infra/qdiscs.json\n+++ b/tools/testing/selftests/tc-testing/tc-tests/infra/qdiscs.json\n@@ -635,5 +635,42 @@\n             \"$TC qdisc del dev $DUMMY handle 1:0 root\",\n             \"$IP addr del 10.10.10.10/24 dev $DUMMY || true\"\n         ]\n+    },\n+    {\n+        \"id\": \"d74b\",\n+        \"name\": \"Test use-after-free with DRR/NETEM/BLACKHOLE chain\",\n+        \"category\": [\n+            \"qdisc\",\n+            \"hfsc\",\n+            \"drr\",\n+            \"netem\",\n+            \"blackhole\"\n+        ],\n+        \"plugins\": {\n+            \"requires\": [\n+                \"nsPlugin\",\n+                \"scapyPlugin\"\n+            ]\n+        },\n+        \"setup\": [\n+            \"$IP link set dev $DUMMY up || true\",\n+            \"$IP addr add 10.10.11.10/24 dev $DUMMY || true\",\n+            \"$TC qdisc add dev $DUMMY root handle 1: drr\",\n+            \"$TC filter add dev $DUMMY parent 1: basic classid 1:1\",\n+            \"$TC class add dev $DUMMY parent 1: classid 1:1 drr\",\n+            \"$TC qdisc add dev $DUMMY parent 1:1 handle 2: hfsc def 1\",\n+            \"$TC class add dev $DUMMY parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0\",\n+            \"$TC qdisc add dev $DUMMY parent 2:1 handle 3: netem\",\n+            \"$TC qdisc add dev $DUMMY parent 3:1 handle 4: blackhole\",\n+            \"ping -c1 -W0.01 -I $DUMMY 10.10.11.11 || true\",\n+            \"$TC class del dev $DUMMY classid 1:1\"\n+        ],\n+        \"cmdUnderTest\": \"ping -c1 -W0.01 -I $DUMMY 10.10.11.11\",\n+        \"expExitCode\": \"1\",\n+        \"verifyCmd\": \"$TC -j class ls dev $DUMMY classid 1:1\",\n+        \"matchJSON\": [],\n+        \"teardown\": [\n+            \"$TC qdisc del dev $DUMMY root handle 1: drr\"\n+        ]\n     }\n ]",
    "stats": {
      "insertions": 421,
      "deletions": 175,
      "files": 33
    }
  }
]
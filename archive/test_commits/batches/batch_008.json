[
  {
    "sha": "70b9c0c11e55167b9552ef395bc00f4920299177",
    "message": "uapi: bitops: use UAPI-safe variant of BITS_PER_LONG again (2)\n\nBITS_PER_LONG does not exist in UAPI headers, so can't be used by the UAPI\n__GENMASK(). Instead __BITS_PER_LONG needs to be used.\n\nWhen __GENMASK() was introduced in commit 3c7a8e190bc5 (\"uapi: introduce uapi-friendly macros for GENMASK\"),\nthe code was fine. A broken revert in 1e7933a575ed (\"uapi: Revert \"bitops: avoid integer overflow in GENMASK(_ULL)\"\")\nintroduced the incorrect usage of BITS_PER_LONG.\nThat was fixed in commit 11fcf368506d (\"uapi: bitops: use UAPI-safe variant of BITS_PER_LONG again\").\nBut a broken sync of the kernel headers with the tools/ headers in\ncommit fc92099902fb (\"tools headers: Synchronize linux/bits.h with the kernel sources\")\nundid the fix.\n\nReapply the fix and while at it also fix the tools header.\n\nFixes: fc92099902fb (\"tools headers: Synchronize linux/bits.h with the kernel sources\")\nSigned-off-by: Thomas Weißschuh <thomas.weissschuh@linutronix.de>\nAcked-by: Yury Norov (NVIDIA) <yury.norov@gmail.com>\nSigned-off-by: Yury Norov (NVIDIA) <yury.norov@gmail.com>",
    "author": "Thomas Weißschuh",
    "date": "2025-07-08T10:23:13-04:00",
    "files_changed": [
      "include/uapi/linux/bits.h",
      "tools/include/uapi/linux/bits.h"
    ],
    "diff": "diff --git a/include/uapi/linux/bits.h b/include/uapi/linux/bits.h\nindex 682b406e1067..a04afef9efca 100644\n--- a/include/uapi/linux/bits.h\n+++ b/include/uapi/linux/bits.h\n@@ -4,9 +4,9 @@\n #ifndef _UAPI_LINUX_BITS_H\n #define _UAPI_LINUX_BITS_H\n \n-#define __GENMASK(h, l) (((~_UL(0)) << (l)) & (~_UL(0) >> (BITS_PER_LONG - 1 - (h))))\n+#define __GENMASK(h, l) (((~_UL(0)) << (l)) & (~_UL(0) >> (__BITS_PER_LONG - 1 - (h))))\n \n-#define __GENMASK_ULL(h, l) (((~_ULL(0)) << (l)) & (~_ULL(0) >> (BITS_PER_LONG_LONG - 1 - (h))))\n+#define __GENMASK_ULL(h, l) (((~_ULL(0)) << (l)) & (~_ULL(0) >> (__BITS_PER_LONG_LONG - 1 - (h))))\n \n #define __GENMASK_U128(h, l) \\\n \t((_BIT128((h)) << 1) - (_BIT128(l)))\ndiff --git a/tools/include/uapi/linux/bits.h b/tools/include/uapi/linux/bits.h\nindex 682b406e1067..a04afef9efca 100644\n--- a/tools/include/uapi/linux/bits.h\n+++ b/tools/include/uapi/linux/bits.h\n@@ -4,9 +4,9 @@\n #ifndef _UAPI_LINUX_BITS_H\n #define _UAPI_LINUX_BITS_H\n \n-#define __GENMASK(h, l) (((~_UL(0)) << (l)) & (~_UL(0) >> (BITS_PER_LONG - 1 - (h))))\n+#define __GENMASK(h, l) (((~_UL(0)) << (l)) & (~_UL(0) >> (__BITS_PER_LONG - 1 - (h))))\n \n-#define __GENMASK_ULL(h, l) (((~_ULL(0)) << (l)) & (~_ULL(0) >> (BITS_PER_LONG_LONG - 1 - (h))))\n+#define __GENMASK_ULL(h, l) (((~_ULL(0)) << (l)) & (~_ULL(0) >> (__BITS_PER_LONG_LONG - 1 - (h))))\n \n #define __GENMASK_U128(h, l) \\\n \t((_BIT128((h)) << 1) - (_BIT128(l)))",
    "stats": {
      "insertions": 4,
      "deletions": 4,
      "files": 2
    }
  },
  {
    "sha": "705a412a367f383430fa34bada387af2e52eb043",
    "message": "drm/xe/pf: Clear all LMTT pages on alloc\n\nOur LMEM buffer objects are not cleared by default on alloc\nand during VF provisioning we only setup LMTT PTEs for the\nactually provisioned LMEM range. But beyond that valid range\nwe might leave some stale data that could either point to some\nother VFs allocations or even to the PF pages.\n\nExplicitly clear all new LMTT page to avoid the risk that a\nmalicious VF would try to exploit that gap.\n\nWhile around add asserts to catch any undesired PTE overwrites\nand low-level debug traces to track LMTT PT life-cycle.\n\nFixes: b1d204058218 (\"drm/xe/pf: Introduce Local Memory Translation Table\")\nSigned-off-by: Michal Wajdeczko <michal.wajdeczko@intel.com>\nCc: Michał Winiarski <michal.winiarski@intel.com>\nCc: Lukasz Laguna <lukasz.laguna@intel.com>\nReviewed-by: Michał Winiarski <michal.winiarski@intel.com>\nReviewed-by: Piotr Piórkowski <piotr.piorkowski@intel.com>\nLink: https://lore.kernel.org/r/20250701220052.1612-1-michal.wajdeczko@intel.com\n(cherry picked from commit 3fae6918a3e27cce20ded2551f863fb05d4bef8d)\nSigned-off-by: Lucas De Marchi <lucas.demarchi@intel.com>",
    "author": "Michal Wajdeczko",
    "date": "2025-07-07T20:57:07-07:00",
    "files_changed": [
      "drivers/gpu/drm/xe/xe_lmtt.c"
    ],
    "diff": "diff --git a/drivers/gpu/drm/xe/xe_lmtt.c b/drivers/gpu/drm/xe/xe_lmtt.c\nindex 63db66df064b..023ed6a6b49d 100644\n--- a/drivers/gpu/drm/xe/xe_lmtt.c\n+++ b/drivers/gpu/drm/xe/xe_lmtt.c\n@@ -78,6 +78,9 @@ static struct xe_lmtt_pt *lmtt_pt_alloc(struct xe_lmtt *lmtt, unsigned int level\n \t}\n \n \tlmtt_assert(lmtt, xe_bo_is_vram(bo));\n+\tlmtt_debug(lmtt, \"level=%u addr=%#llx\\n\", level, (u64)xe_bo_main_addr(bo, XE_PAGE_SIZE));\n+\n+\txe_map_memset(lmtt_to_xe(lmtt), &bo->vmap, 0, 0, bo->size);\n \n \tpt->level = level;\n \tpt->bo = bo;\n@@ -91,6 +94,9 @@ static struct xe_lmtt_pt *lmtt_pt_alloc(struct xe_lmtt *lmtt, unsigned int level\n \n static void lmtt_pt_free(struct xe_lmtt_pt *pt)\n {\n+\tlmtt_debug(&pt->bo->tile->sriov.pf.lmtt, \"level=%u addr=%llx\\n\",\n+\t\t   pt->level, (u64)xe_bo_main_addr(pt->bo, XE_PAGE_SIZE));\n+\n \txe_bo_unpin_map_no_vm(pt->bo);\n \tkfree(pt);\n }\n@@ -226,9 +232,14 @@ static void lmtt_write_pte(struct xe_lmtt *lmtt, struct xe_lmtt_pt *pt,\n \n \tswitch (lmtt->ops->lmtt_pte_size(level)) {\n \tcase sizeof(u32):\n+\t\tlmtt_assert(lmtt, !overflows_type(pte, u32));\n+\t\tlmtt_assert(lmtt, !pte || !iosys_map_rd(&pt->bo->vmap, idx * sizeof(u32), u32));\n+\n \t\txe_map_wr(lmtt_to_xe(lmtt), &pt->bo->vmap, idx * sizeof(u32), u32, pte);\n \t\tbreak;\n \tcase sizeof(u64):\n+\t\tlmtt_assert(lmtt, !pte || !iosys_map_rd(&pt->bo->vmap, idx * sizeof(u64), u64));\n+\n \t\txe_map_wr(lmtt_to_xe(lmtt), &pt->bo->vmap, idx * sizeof(u64), u64, pte);\n \t\tbreak;\n \tdefault:",
    "stats": {
      "insertions": 11,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "667eeab4999e981c96b447a4df5f20bdf5c26f13",
    "message": "tipc: Fix use-after-free in tipc_conn_close().\n\nsyzbot reported a null-ptr-deref in tipc_conn_close() during netns\ndismantle. [0]\n\ntipc_topsrv_stop() iterates tipc_net(net)->topsrv->conn_idr and calls\ntipc_conn_close() for each tipc_conn.\n\nThe problem is that tipc_conn_close() is called after releasing the\nIDR lock.\n\nAt the same time, there might be tipc_conn_recv_work() running and it\ncould call tipc_conn_close() for the same tipc_conn and release its\nlast ->kref.\n\nOnce we release the IDR lock in tipc_topsrv_stop(), there is no\nguarantee that the tipc_conn is alive.\n\nLet's hold the ref before releasing the lock and put the ref after\ntipc_conn_close() in tipc_topsrv_stop().\n\n[0]:\nBUG: KASAN: use-after-free in tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165\nRead of size 8 at addr ffff888099305a08 by task kworker/u4:3/435\n\nCPU: 0 PID: 435 Comm: kworker/u4:3 Not tainted 4.19.204-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nWorkqueue: netns cleanup_net\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x1fc/0x2ef lib/dump_stack.c:118\n print_address_description.cold+0x54/0x219 mm/kasan/report.c:256\n kasan_report_error.cold+0x8a/0x1b9 mm/kasan/report.c:354\n kasan_report mm/kasan/report.c:412 [inline]\n __asan_report_load8_noabort+0x88/0x90 mm/kasan/report.c:433\n tipc_conn_close+0x122/0x140 net/tipc/topsrv.c:165\n tipc_topsrv_stop net/tipc/topsrv.c:701 [inline]\n tipc_topsrv_exit_net+0x27b/0x5c0 net/tipc/topsrv.c:722\n ops_exit_list+0xa5/0x150 net/core/net_namespace.c:153\n cleanup_net+0x3b4/0x8b0 net/core/net_namespace.c:553\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nAllocated by task 23:\n kmem_cache_alloc_trace+0x12f/0x380 mm/slab.c:3625\n kmalloc include/linux/slab.h:515 [inline]\n kzalloc include/linux/slab.h:709 [inline]\n tipc_conn_alloc+0x43/0x4f0 net/tipc/topsrv.c:192\n tipc_topsrv_accept+0x1b5/0x280 net/tipc/topsrv.c:470\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nFreed by task 23:\n __cache_free mm/slab.c:3503 [inline]\n kfree+0xcc/0x210 mm/slab.c:3822\n tipc_conn_kref_release net/tipc/topsrv.c:150 [inline]\n kref_put include/linux/kref.h:70 [inline]\n conn_put+0x2cd/0x3a0 net/tipc/topsrv.c:155\n process_one_work+0x864/0x1570 kernel/workqueue.c:2153\n worker_thread+0x64c/0x1130 kernel/workqueue.c:2296\n kthread+0x33f/0x460 kernel/kthread.c:259\n ret_from_fork+0x24/0x30 arch/x86/entry/entry_64.S:415\n\nThe buggy address belongs to the object at ffff888099305a00\n which belongs to the cache kmalloc-512 of size 512\nThe buggy address is located 8 bytes inside of\n 512-byte region [ffff888099305a00, ffff888099305c00)\nThe buggy address belongs to the page:\npage:ffffea000264c140 count:1 mapcount:0 mapping:ffff88813bff0940 index:0x0\nflags: 0xfff00000000100(slab)\nraw: 00fff00000000100 ffffea00028b6b88 ffffea0002cd2b08 ffff88813bff0940\nraw: 0000000000000000 ffff888099305000 0000000100000006 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888099305900: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888099305980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff888099305a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                      ^\n ffff888099305a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888099305b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nFixes: c5fa7b3cf3cb (\"tipc: introduce new TIPC server infrastructure\")\nReported-by: syzbot+d333febcf8f4bc5f6110@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=27169a847a70550d17be\nSigned-off-by: Kuniyuki Iwashima <kuniyu@google.com>\nReviewed-by: Tung Nguyen <tung.quang.nguyen@est.tech>\nLink: https://patch.msgid.link/20250702014350.692213-1-kuniyu@google.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Kuniyuki Iwashima",
    "date": "2025-07-07T18:38:24-07:00",
    "files_changed": [
      "net/tipc/topsrv.c"
    ],
    "diff": "diff --git a/net/tipc/topsrv.c b/net/tipc/topsrv.c\nindex 8ee0c07d00e9..ffe577bf6b51 100644\n--- a/net/tipc/topsrv.c\n+++ b/net/tipc/topsrv.c\n@@ -704,8 +704,10 @@ static void tipc_topsrv_stop(struct net *net)\n \tfor (id = 0; srv->idr_in_use; id++) {\n \t\tcon = idr_find(&srv->conn_idr, id);\n \t\tif (con) {\n+\t\t\tconn_get(con);\n \t\t\tspin_unlock_bh(&srv->idr_lock);\n \t\t\ttipc_conn_close(con);\n+\t\t\tconn_put(con);\n \t\t\tspin_lock_bh(&srv->idr_lock);\n \t\t}\n \t}",
    "stats": {
      "insertions": 2,
      "deletions": 0,
      "files": 1
    }
  },
  {
    "sha": "4e2bba30b16935d18e59d137f607f8e10b6fda87",
    "message": "Merge branch 'fix-qca808x-wol-issue'\n\nLuo Jie says:\n\n====================\nFix QCA808X WoL Issue\n\nRestore WoL (Wake-on-LAN) enablement via MMD3 register 0x8012 BIT5 for\nthe QCA808X PHY. This change resolves the issue where WoL functionality\nwas not working due to its unintended removal in a previous commit.\n\nRefactor at8031_set_wol() into a shared library to enable reuse of the\nWake-on-LAN (WoL) functionality by the AT8031, QCA807X and QCA808X PHY\ndrivers.\n====================\n\nLink: https://patch.msgid.link/20250704-qcom_phy_wol_support-v1-0-053342b1538d@quicinc.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Jakub Kicinski",
    "date": "2025-07-07T16:45:21-07:00",
    "files_changed": [
      "drivers/net/phy/qcom/at803x.c",
      "drivers/net/phy/qcom/qca808x.c",
      "drivers/net/phy/qcom/qcom-phy-lib.c",
      "drivers/net/phy/qcom/qcom.h"
    ],
    "diff": "diff --git a/drivers/net/phy/qcom/at803x.c b/drivers/net/phy/qcom/at803x.c\nindex 26350b962890..8f26e395e39f 100644\n--- a/drivers/net/phy/qcom/at803x.c\n+++ b/drivers/net/phy/qcom/at803x.c\n@@ -26,9 +26,6 @@\n \n #define AT803X_LED_CONTROL\t\t\t0x18\n \n-#define AT803X_PHY_MMD3_WOL_CTRL\t\t0x8012\n-#define AT803X_WOL_EN\t\t\t\tBIT(5)\n-\n #define AT803X_REG_CHIP_CONFIG\t\t\t0x1f\n #define AT803X_BT_BX_REG_SEL\t\t\t0x8000\n \n@@ -866,30 +863,6 @@ static int at8031_config_init(struct phy_device *phydev)\n \treturn at803x_config_init(phydev);\n }\n \n-static int at8031_set_wol(struct phy_device *phydev,\n-\t\t\t  struct ethtool_wolinfo *wol)\n-{\n-\tint ret;\n-\n-\t/* First setup MAC address and enable WOL interrupt */\n-\tret = at803x_set_wol(phydev, wol);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\tif (wol->wolopts & WAKE_MAGIC)\n-\t\t/* Enable WOL function for 1588 */\n-\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n-\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n-\t\t\t\t     0, AT803X_WOL_EN);\n-\telse\n-\t\t/* Disable WoL function for 1588 */\n-\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n-\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n-\t\t\t\t     AT803X_WOL_EN, 0);\n-\n-\treturn ret;\n-}\n-\n static int at8031_config_intr(struct phy_device *phydev)\n {\n \tstruct at803x_priv *priv = phydev->priv;\ndiff --git a/drivers/net/phy/qcom/qca808x.c b/drivers/net/phy/qcom/qca808x.c\nindex 71498c518f0f..6de16c0eaa08 100644\n--- a/drivers/net/phy/qcom/qca808x.c\n+++ b/drivers/net/phy/qcom/qca808x.c\n@@ -633,7 +633,7 @@ static struct phy_driver qca808x_driver[] = {\n \t.handle_interrupt\t= at803x_handle_interrupt,\n \t.get_tunable\t\t= at803x_get_tunable,\n \t.set_tunable\t\t= at803x_set_tunable,\n-\t.set_wol\t\t= at803x_set_wol,\n+\t.set_wol\t\t= at8031_set_wol,\n \t.get_wol\t\t= at803x_get_wol,\n \t.get_features\t\t= qca808x_get_features,\n \t.config_aneg\t\t= qca808x_config_aneg,\ndiff --git a/drivers/net/phy/qcom/qcom-phy-lib.c b/drivers/net/phy/qcom/qcom-phy-lib.c\nindex d28815ef56bb..af7d0d8e81be 100644\n--- a/drivers/net/phy/qcom/qcom-phy-lib.c\n+++ b/drivers/net/phy/qcom/qcom-phy-lib.c\n@@ -115,6 +115,31 @@ int at803x_set_wol(struct phy_device *phydev,\n }\n EXPORT_SYMBOL_GPL(at803x_set_wol);\n \n+int at8031_set_wol(struct phy_device *phydev,\n+\t\t   struct ethtool_wolinfo *wol)\n+{\n+\tint ret;\n+\n+\t/* First setup MAC address and enable WOL interrupt */\n+\tret = at803x_set_wol(phydev, wol);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\tif (wol->wolopts & WAKE_MAGIC)\n+\t\t/* Enable WOL function for 1588 */\n+\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n+\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n+\t\t\t\t     0, AT803X_WOL_EN);\n+\telse\n+\t\t/* Disable WoL function for 1588 */\n+\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n+\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n+\t\t\t\t     AT803X_WOL_EN, 0);\n+\n+\treturn ret;\n+}\n+EXPORT_SYMBOL_GPL(at8031_set_wol);\n+\n void at803x_get_wol(struct phy_device *phydev,\n \t\t    struct ethtool_wolinfo *wol)\n {\ndiff --git a/drivers/net/phy/qcom/qcom.h b/drivers/net/phy/qcom/qcom.h\nindex 4bb541728846..7f7151c8baca 100644\n--- a/drivers/net/phy/qcom/qcom.h\n+++ b/drivers/net/phy/qcom/qcom.h\n@@ -172,6 +172,9 @@\n #define AT803X_LOC_MAC_ADDR_16_31_OFFSET\t0x804B\n #define AT803X_LOC_MAC_ADDR_32_47_OFFSET\t0x804A\n \n+#define AT803X_PHY_MMD3_WOL_CTRL\t\t0x8012\n+#define AT803X_WOL_EN\t\t\t\tBIT(5)\n+\n #define AT803X_DEBUG_ADDR\t\t\t0x1D\n #define AT803X_DEBUG_DATA\t\t\t0x1E\n \n@@ -215,6 +218,8 @@ int at803x_debug_reg_mask(struct phy_device *phydev, u16 reg,\n int at803x_debug_reg_write(struct phy_device *phydev, u16 reg, u16 data);\n int at803x_set_wol(struct phy_device *phydev,\n \t\t   struct ethtool_wolinfo *wol);\n+int at8031_set_wol(struct phy_device *phydev,\n+\t\t   struct ethtool_wolinfo *wol);\n void at803x_get_wol(struct phy_device *phydev,\n \t\t    struct ethtool_wolinfo *wol);\n int at803x_ack_interrupt(struct phy_device *phydev);",
    "stats": {
      "insertions": 31,
      "deletions": 28,
      "files": 4
    }
  },
  {
    "sha": "4ab9ada765b7acb5cd02fe27632ec2586b7868ee",
    "message": "net: phy: qcom: qca808x: Fix WoL issue by utilizing at8031_set_wol()\n\nThe previous commit unintentionally removed the code responsible for\nenabling WoL via MMD3 register 0x8012 BIT5. As a result, Wake-on-LAN\n(WoL) support for the QCA808X PHY is no longer functional.\n\nThe WoL (Wake-on-LAN) feature for the QCA808X PHY is enabled via MMD3\nregister 0x8012, BIT5. This implementation is aligned with the approach\nused in at8031_set_wol().\n\nFixes: e58f30246c35 (\"net: phy: at803x: fix the wol setting functions\")\nSigned-off-by: Luo Jie <quic_luoj@quicinc.com>\nReviewed-by: Maxime Chevallier <maxime.chevallier@bootlin.com>\nLink: https://patch.msgid.link/20250704-qcom_phy_wol_support-v1-2-053342b1538d@quicinc.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
    "author": "Luo Jie",
    "date": "2025-07-07T16:43:47-07:00",
    "files_changed": [
      "drivers/net/phy/qcom/qca808x.c"
    ],
    "diff": "diff --git a/drivers/net/phy/qcom/qca808x.c b/drivers/net/phy/qcom/qca808x.c\nindex 71498c518f0f..6de16c0eaa08 100644\n--- a/drivers/net/phy/qcom/qca808x.c\n+++ b/drivers/net/phy/qcom/qca808x.c\n@@ -633,7 +633,7 @@ static struct phy_driver qca808x_driver[] = {\n \t.handle_interrupt\t= at803x_handle_interrupt,\n \t.get_tunable\t\t= at803x_get_tunable,\n \t.set_tunable\t\t= at803x_set_tunable,\n-\t.set_wol\t\t= at803x_set_wol,\n+\t.set_wol\t\t= at8031_set_wol,\n \t.get_wol\t\t= at803x_get_wol,\n \t.get_features\t\t= qca808x_get_features,\n \t.config_aneg\t\t= qca808x_config_aneg,",
    "stats": {
      "insertions": 1,
      "deletions": 1,
      "files": 1
    }
  }
]